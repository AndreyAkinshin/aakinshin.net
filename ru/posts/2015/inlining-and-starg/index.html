<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><title>История про инлайнинг под JIT-x86 и starg | Andrey Akinshin</title><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://googlechromelabs.github.io/dark-mode-toggle/src/dark-mode-toggle.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.e78467baec0179d7ccd2ef995e0c94f25b4a63a3191a93c3547e22bdf590ef5d.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.a9ad336a30411929ac042537ef03ddbe3b2b28af5aa50655711f870419408467.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-XXXXX-Y','auto');ga('send','pageview');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li><li class=nav-item></li><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a></li></ul></nav></div></div><div class=container><main id=main><h1>История про инлайнинг под JIT-x86 и starg</h1><p>Порой можно узнать много интересного во время чтения исходников .NET. Взглянем на конструктор типа <code>Decimal</code> из .NET Reference Source (<a href=http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158>mscorlib/system/decimal.cs,158</a>):</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=c1>// Constructs a Decimal from an integer value.
</span><span class=c1>//
</span><span class=c1></span><span class=k>public</span> <span class=n>Decimal</span><span class=p>(</span><span class=kt>int</span> <span class=k>value</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>//  JIT today can&#39;t inline methods that contains &#34;starg&#34; opcode.
</span><span class=c1></span>    <span class=c1>//  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &#34;starg&#34;.
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>value_copy</span> <span class=p>=</span> <span class=k>value</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>value_copy</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>flags</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
        <span class=n>flags</span> <span class=p>=</span> <span class=n>SignMask</span><span class=p>;</span>
        <span class=n>value_copy</span> <span class=p>=</span> <span class=p>-</span><span class=n>value_copy</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>lo</span> <span class=p>=</span> <span class=n>value_copy</span><span class=p>;</span>
    <span class=n>mid</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=n>hi</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>В комментарии сказано, что если метод содержит IL-опкод <a href=https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx>starg</a>, то он не может быть заинлайнен под x86. Любопытно, не правда ли?</p><h3 id=исходники-jit>Исходники JIT</h3><p>Давайте разберёмся в ситуации. Заглянем в исходники JIT из CoreCLR. Фрагмент файла <a href=https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252>flowgraph.cpp</a></p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=c1>// NetCF had some strict restrictions on inlining.  Specifically they
</span><span class=c1>// would only inline methods that fit a specific pattern of loading
</span><span class=c1>// arguments inorder, starting with zero, with no skipping, but not
</span><span class=c1>// needing to load all of them.  Then a &#39;body&#39; section that could do
</span><span class=c1>// anything besides control flow.  And a final ending ret opcode.
</span><span class=c1>// Lastly they did not allow starg or ldarga.
</span><span class=c1>// These simplifications allowed them to skip past the ldargs, when
</span><span class=c1>// inlining, and just use the caller&#39;s EE stack as the callee&#39;s EE
</span><span class=c1>// stack, after optionally popping a few &#39;arguments&#39; from the end.
</span><span class=c1>//
</span><span class=c1>// stateNetCFQuirks is a simple state machine to track that state
</span><span class=c1>// and allow us to match those restrictions.
</span><span class=c1>// State -1 means we&#39;re not tracking (no quirks mode)
</span><span class=c1>// State 0 though 0x0000FFFF tracks what the *next* ldarg should be
</span><span class=c1>//    to match the pattern
</span><span class=c1>// State 0x00010000 and above means we are in the &#39;body&#39; section and
</span><span class=c1>//    thus no more ldarg&#39;s are allowed.
</span></code></pre></div><p>Комментарий гласит, что если метод содержит IL-команду <code>starg</code> или <code>ldarga</code>, то инлайнинг не выполнится. Почитаем код и убедимся, что это действительно так. Вскоре после комментария происходит выбор опкода:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=k>switch</span> <span class=p>(</span><span class=n>opcode</span><span class=p>)</span>

<span class=c1>// ...
</span><span class=c1></span>
    <span class=k>case</span> <span class=nl>CEE_STARG</span><span class=p>:</span>
    <span class=k>case</span> <span class=nl>CEE_STARG_S</span><span class=p>:</span>     <span class=k>goto</span> <span class=n>ARG_WRITE</span><span class=p>;</span>

    <span class=k>case</span> <span class=nl>CEE_LDARGA</span><span class=p>:</span>
    <span class=k>case</span> <span class=nl>CEE_LDARGA_S</span><span class=p>:</span>
    <span class=k>case</span> <span class=nl>CEE_LDLOCA</span><span class=p>:</span>
    <span class=k>case</span> <span class=nl>CEE_LDLOCA_S</span><span class=p>:</span>    <span class=k>goto</span> <span class=n>ADDR_TAKEN</span><span class=p>;</span>
</code></pre></div><p>Случай с командой <code>starg</code> попроще, взглянем на него более внимательно:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=nl>ARG_WRITE</span><span class=p>:</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>compIsForInlining</span><span class=p>())</span>
            <span class=p>{</span>

<span class=cp>#ifdef DEBUG
</span><span class=cp></span>                <span class=k>if</span> <span class=p>(</span><span class=n>verbose</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\n\n</span><span class=s>Inline expansion aborted due to opcode at offset [%02u] which writes to an argument</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span>
                           <span class=n>codeAddr</span><span class=o>-</span><span class=n>codeBegp</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
                <span class=p>}</span>
<span class=cp>#endif
</span><span class=cp></span>
                <span class=cm>/* The inliner keeps the args as trees and clones them.  Storing the arguments breaks that
</span><span class=cm>                 * simplification.  To allow this, flag the argument as written to and spill it before
</span><span class=cm>                 * inlining.  That way the STARG in the inlinee is trivial. */</span>
                <span class=n>inlineFailReason</span> <span class=o>=</span> <span class=s>&#34;Inlinee writes to an argument.&#34;</span><span class=p>;</span>
                <span class=k>goto</span> <span class=n>InlineNever</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>else</span>
            <span class=p>{</span>
                <span class=n>noway_assert</span><span class=p>(</span><span class=n>sz</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BYTE</span><span class=p>)</span> <span class=o>||</span> <span class=n>sz</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>WORD</span><span class=p>));</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>codeAddr</span> <span class=o>&gt;</span> <span class=n>codeEndp</span> <span class=o>-</span> <span class=n>sz</span><span class=p>)</span>
                <span class=k>goto</span> <span class=n>TOO_FAR</span><span class=p>;</span>
                <span class=n>varNum</span> <span class=o>=</span> <span class=p>(</span><span class=n>sz</span> <span class=o>==</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BYTE</span><span class=p>))</span> <span class=o>?</span> <span class=n>getU1LittleEndian</span><span class=p>(</span><span class=n>codeAddr</span><span class=p>)</span>
                                              <span class=o>:</span> <span class=n>getU2LittleEndian</span><span class=p>(</span><span class=n>codeAddr</span><span class=p>);</span>
                <span class=n>varNum</span> <span class=o>=</span> <span class=n>compMapILargNum</span><span class=p>(</span><span class=n>varNum</span><span class=p>);</span> <span class=c1>// account for possible hidden param
</span><span class=c1></span>
                <span class=c1>// This check is only intended to prevent an AV.  Bad varNum values will later
</span><span class=c1></span>                <span class=c1>// be handled properly by the verifier.
</span><span class=c1></span>                <span class=k>if</span> <span class=p>(</span><span class=n>varNum</span> <span class=o>&lt;</span> <span class=n>lvaTableCnt</span><span class=p>)</span>
                    <span class=n>lvaTable</span><span class=p>[</span><span class=n>varNum</span><span class=p>].</span><span class=n>lvArgWrite</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
            <span class=p>}</span>
            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
</code></pre></div><p>Действительно, всё выглядит так, что для опкода <code>starg</code> в конечном итоге выполнится <code>goto InlineNever</code>. В <code>DEBUG</code>-режиме мы также получим сообщение, что процесс инлайнинга был прерван.</p><p>Эта «фича» используется в других местах JIT-а. Взглянем на фрагмент файла <a href=https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp>importer.cpp</a>:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=cm>/******************************************************************************
</span><span class=cm> Is this the original &#34;this&#34; argument to the call being inlined?
</span><span class=cm> 
</span><span class=cm> Note that we do not inline methods with &#34;starg 0&#34;, and so we do not need to
</span><span class=cm> worry about it.
</span><span class=cm>*/</span>
</code></pre></div><h3 id=смотрим-на-decimal>Смотрим на Decimal</h3><p>Вернёмся к нашему конструктору класса <code>Decimal</code>, убедимся, что копирование параметра <code>value</code> в локальную переменную действительно помогает. Вооружимся <a href=http://ilspy.net/>ILSpy</a> и взглянем на IL-код нашего конструктора:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>// Methods
.method public hidebysig specialname rtspecialname 
  instance void .ctor (
    int32 &#39;value&#39;
  ) cil managed 
{
  .custom instance void __DynamicallyInvokableAttribute::.ctor() = (
    01 00 00 00
  )
  // Method begins at RVA 0x222e8
  // Code size 51 (0x33)
  .maxstack 2
  .locals init (
    [0] int32
  )

  IL_0000: ldarg.1
  IL_0001: stloc.0
  IL_0002: ldloc.0
  IL_0003: ldc.i4.0
  IL_0004: blt.s IL_000f

  IL_0006: ldarg.0
  IL_0007: ldc.i4.0
  IL_0008: stfld int32 System.Decimal::&#39;flags&#39;
  IL_000d: br.s IL_001d

  IL_000f: ldarg.0
  IL_0010: ldc.i4 -2147483648
  IL_0015: stfld int32 System.Decimal::&#39;flags&#39;
  IL_001a: ldloc.0
  IL_001b: neg
  IL_001c: stloc.0

  IL_001d: ldarg.0
  IL_001e: ldloc.0
  IL_001f: stfld int32 System.Decimal::lo
  IL_0024: ldarg.0
  IL_0025: ldc.i4.0
  IL_0026: stfld int32 System.Decimal::mid
  IL_002b: ldarg.0
  IL_002c: ldc.i4.0
  IL_002d: stfld int32 System.Decimal::hi
  IL_0032: ret
} // end of method Decimal::.ctor
</code></pre></div><p>А что было бы, если бы мы не скопировали <code>value</code> в локальную переменную? Давайте проверим. Напишем простой код:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>class</span> <span class=nc>MyDecimal</span>
<span class=p>{</span>
  <span class=k>private</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>SignMask</span>  <span class=p>=</span> <span class=k>unchecked</span><span class=p>((</span><span class=kt>int</span><span class=p>)</span><span class=m>0</span><span class=n>x80000000</span><span class=p>);</span>
  <span class=k>private</span> <span class=kt>int</span> <span class=n>flags</span><span class=p>,</span> <span class=n>hi</span><span class=p>,</span> <span class=n>lo</span><span class=p>,</span> <span class=n>mid</span><span class=p>;</span>

  <span class=k>public</span> <span class=n>MyDecimal</span><span class=p>(</span><span class=kt>int</span> <span class=k>value</span><span class=p>)</span>
  <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=k>value</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>flags</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
        <span class=n>flags</span> <span class=p>=</span> <span class=n>SignMask</span><span class=p>;</span>
        <span class=k>value</span> <span class=p>=</span> <span class=p>-</span><span class=k>value</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>lo</span> <span class=p>=</span> <span class=k>value</span><span class=p>;</span>
    <span class=n>mid</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=n>hi</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
<span class=k>class</span> <span class=nc>Program</span>
<span class=p>{</span>
  <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>
  <span class=p>{</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Скомпилируем его:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>&gt;csc Program.cs /optimize
Microsoft (R) Visual C# Compiler version 4.0.30319.33440
for Microsoft (R) .NET Framework 4.5
Copyright (C) Microsoft Corporation. All rights reserved.
</code></pre></div><p>И взглянем на IL:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>.class private auto ansi beforefieldinit MyDecimal
  extends [mscorlib]System.Object
{
  // Fields
  .field private static literal int32 SignMask = int32(-2147483648)
  .field private int32 &#39;flags&#39;
  .field private int32 hi
  .field private int32 lo
  .field private int32 mid

  // Methods
  .method public hidebysig specialname rtspecialname 
    instance void .ctor (
      int32 &#39;value&#39;
    ) cil managed 
  {
    // Method begins at RVA 0x2050
    // Code size 56 (0x38)
    .maxstack 8

    IL_0000: ldarg.0
    IL_0001: call instance void [mscorlib]System.Object::.ctor()
    IL_0006: ldarg.1
    IL_0007: ldc.i4.0
    IL_0008: blt.s IL_0013

    IL_000a: ldarg.0
    IL_000b: ldc.i4.0
    IL_000c: stfld int32 MyDecimal::&#39;flags&#39;
    IL_0011: br.s IL_0022

    IL_0013: ldarg.0
    IL_0014: ldc.i4 -2147483648
    IL_0019: stfld int32 MyDecimal::&#39;flags&#39;
    IL_001e: ldarg.1
    IL_001f: neg
    IL_0020: starg.s &#39;value&#39;

    IL_0022: ldarg.0
    IL_0023: ldarg.1
    IL_0024: stfld int32 MyDecimal::lo
    IL_0029: ldarg.0
    IL_002a: ldc.i4.0
    IL_002b: stfld int32 MyDecimal::mid
    IL_0030: ldarg.0
    IL_0031: ldc.i4.0
    IL_0032: stfld int32 MyDecimal::hi
    IL_0037: ret
  } // end of method MyDecimal::.ctor

} // end of class MyDecimal
</code></pre></div><p>Как мы видим, в строчке <code>IL_0020</code> действительно вызывается команда <code>starg.a</code>. Подобный приём используется также в конструкторе, который принимает аргумент типа <code>long</code>:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=c1>// Constructs a Decimal from a long value.
</span><span class=c1>//
</span><span class=c1></span><span class=k>public</span> <span class=n>Decimal</span><span class=p>(</span><span class=kt>long</span> <span class=k>value</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>//  JIT today can&#39;t inline methods that contains &#34;starg&#34; opcode.
</span><span class=c1></span>    <span class=c1>//  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &#34;starg&#34;.
</span><span class=c1></span>    <span class=kt>long</span> <span class=n>value_copy</span> <span class=p>=</span> <span class=k>value</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>value_copy</span> <span class=p>&gt;=</span> <span class=m>0</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>flags</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span>
        <span class=n>flags</span> <span class=p>=</span> <span class=n>SignMask</span><span class=p>;</span>
        <span class=n>value_copy</span> <span class=p>=</span> <span class=p>-</span><span class=n>value_copy</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>lo</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>value_copy</span><span class=p>;</span>
    <span class=n>mid</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)(</span><span class=n>value_copy</span> <span class=p>&gt;&gt;</span> <span class=m>32</span><span class=p>);</span>
    <span class=n>hi</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h3 id=проверяем-возможности-jit>Проверяем возможности JIT</h3><p>Для полноты исследования осталось убедиться, что JIT действительно себя ведёт именно так. Напишем простой код для проверки:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>using</span> <span class=nn>System</span><span class=p>;</span>
<span class=k>using</span> <span class=nn>System.Runtime.CompilerServices</span><span class=p>;</span>

<span class=k>class</span> <span class=nc>Program</span>
<span class=p>{</span>
    <span class=k>static</span> <span class=k>void</span> <span class=n>Main</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=kt>var</span> <span class=k>value</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
        <span class=k>value</span> <span class=p>+=</span> <span class=n>SimpleMethod</span><span class=p>(</span><span class=m>0</span><span class=n>x11</span><span class=p>);</span>
        <span class=k>value</span> <span class=p>+=</span> <span class=n>MethodWithStarg</span><span class=p>(</span><span class=m>0</span><span class=n>x12</span><span class=p>);</span>
        <span class=k>value</span> <span class=p>+=</span> <span class=n>MethodWithStargAggressive</span><span class=p>(</span><span class=m>0</span><span class=n>x13</span><span class=p>);</span>
        <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=k>value</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>static</span> <span class=kt>int</span> <span class=n>SimpleMethod</span><span class=p>(</span><span class=kt>int</span> <span class=k>value</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=k>value</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>static</span> <span class=kt>int</span> <span class=n>MethodWithStarg</span><span class=p>(</span><span class=kt>int</span> <span class=k>value</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=k>value</span> <span class=p>&lt;</span> <span class=m>0</span><span class=p>)</span>
            <span class=k>value</span> <span class=p>=</span> <span class=p>-</span><span class=k>value</span><span class=p>;</span>
        <span class=k>return</span> <span class=k>value</span><span class=p>;</span>
    <span class=p>}</span>
<span class=na>
</span><span class=na>    [MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
    <span class=k>static</span> <span class=kt>int</span> <span class=n>MethodWithStargAggressive</span><span class=p>(</span><span class=kt>int</span> <span class=k>value</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=k>value</span> <span class=p>&lt;</span> <span class=m>0</span><span class=p>)</span>
            <span class=k>value</span> <span class=p>=</span> <span class=p>-</span><span class=k>value</span><span class=p>;</span>
        <span class=k>return</span> <span class=k>value</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Метод <code>SimpleMethod</code> очень маленький и будет заинлайнен. Метод <code>MethodWithStarg</code> имеет следующее IL-представление:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=p>.</span><span class=n>method</span> <span class=k>private</span> <span class=n>hidebysig</span> <span class=k>static</span> 
  <span class=n>int32</span> <span class=n>MethodWithStarg</span> <span class=p>(</span>
    <span class=n>int32</span> <span class=err>&#39;</span><span class=k>value</span><span class=err>&#39;</span>
  <span class=p>)</span> <span class=n>cil</span> <span class=n>managed</span> 
<span class=p>{</span>
  <span class=c1>// Method begins at RVA 0x2086
</span><span class=c1></span>  <span class=c1>// Code size 10 (0xa)
</span><span class=c1></span>  <span class=p>.</span><span class=n>maxstack</span> <span class=m>8</span>

  <span class=n>IL_0000</span><span class=p>:</span> <span class=n>ldarg</span><span class=p>.</span><span class=m>0</span>
  <span class=n>IL_0001</span><span class=p>:</span> <span class=n>ldc</span><span class=p>.</span><span class=n>i4</span><span class=p>.</span><span class=m>0</span>
  <span class=n>IL_0002</span><span class=p>:</span> <span class=n>bge</span><span class=p>.</span><span class=n>s</span> <span class=n>IL_0008</span>

  <span class=n>IL_0004</span><span class=p>:</span> <span class=n>ldarg</span><span class=p>.</span><span class=m>0</span>
  <span class=n>IL_0005</span><span class=p>:</span> <span class=n>neg</span>
  <span class=n>IL_0006</span><span class=p>:</span> <span class=n>starg</span><span class=p>.</span><span class=n>s</span> <span class=err>&#39;</span><span class=k>value</span><span class=err>&#39;</span>

  <span class=n>IL_0008</span><span class=p>:</span> <span class=n>ldarg</span><span class=p>.</span><span class=m>0</span>
  <span class=n>IL_0009</span><span class=p>:</span> <span class=n>ret</span>
<span class=p>}</span> <span class=c1>// end of method Program::MethodWithStarg
</span></code></pre></div><p>Данный код в строчке <code>IL_0006</code> содержит интересующую нас команду <code>starg.s</code>. Метод <code>MethodWithStargAggressive</code> имеет аналогичный код с той лишь разнице, что для него указан атрибут <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code>. Взглянем на ассемблерный код под x86:</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>008</span><span class=nf>A0050</span>  <span class=no>push</span>        <span class=no>ebp</span>  
<span class=mi>008</span><span class=no>A0051</span>  <span class=no>mov</span>         <span class=no>ebp</span><span class=p>,</span><span class=no>esp</span>  
<span class=mi>008</span><span class=no>A0053</span>  <span class=no>push</span>        <span class=no>esi</span>  
<span class=mi>008</span><span class=no>A0054</span>  <span class=no>mov</span>         <span class=no>ecx</span><span class=p>,</span><span class=mi>12</span><span class=no>h</span>  
<span class=mi>008</span><span class=no>A0059</span>  <span class=no>call</span>        <span class=no>dword</span> <span class=no>ptr</span> <span class=no>ds</span><span class=p>:[</span><span class=mi>7237</span><span class=no>BCh</span><span class=p>]</span>  <span class=err>//</span> <span class=no>MethodWithStarg</span>
<span class=err>008</span><span class=nf>A005F</span>  <span class=no>add</span>         <span class=no>eax</span><span class=p>,</span><span class=mi>11</span><span class=no>h</span>  
<span class=mi>008</span><span class=no>A0062</span>  <span class=no>mov</span>         <span class=no>esi</span><span class=p>,</span><span class=no>eax</span>  
<span class=mi>008</span><span class=no>A0064</span>  <span class=no>mov</span>         <span class=no>ecx</span><span class=p>,</span><span class=mi>13</span><span class=no>h</span>  
<span class=mi>008</span><span class=no>A0069</span>  <span class=no>call</span>        <span class=no>dword</span> <span class=no>ptr</span> <span class=no>ds</span><span class=p>:[</span><span class=mi>7237</span><span class=no>C8h</span><span class=p>]</span>  <span class=err>//</span> <span class=no>MethodWithStargAggressive</span>
<span class=err>008</span><span class=nf>A006F</span>  <span class=no>add</span>         <span class=no>esi</span><span class=p>,</span><span class=no>eax</span>  
</code></pre></div><p>Эксперимент прошёл успешно. Метод <code>SimpleMethod</code> был заинлайнен, как и предполагалось. Метод <code>MethodWithStarg</code> не был заинлайнен, т. к. содержит IL-команду <code>starg.s</code>. Даже атрибут <code>[MethodImpl(MethodImplOptions.AggressiveInlining)]</code> не поспособствовал тому, чтобы инлайнинг был выполнен.</p><p>А теперь взглянем на ассемблерный код под x64:</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>00007</span><span class=nf>FFCC8720094</span>  <span class=no>mov</span>         <span class=no>ecx</span><span class=p>,</span><span class=mi>36</span><span class=no>h</span>
</code></pre></div><p>Как мы видим, JIT успешно выполнил инлайнинг всех методов и заранее предподсчитал результат.</p><h3 id=выводы>Выводы</h3><p>Для возможности инлайнинга методов необходимо выполнение ряда условий. JIT-x86 не может заинлайнить метод, в теле которого присутствуют IL-команды <code>starg</code> или <code>ldarga</code>, при этом даже <code>MethodImplOptions.AggressiveInlining</code> не в силах на это повлиять. Если вам критично, чтобы JIT мог выполнять инлайнинг, то порой придётся делать костыли, подобные тем, которые мы можем наблюдать в конструкторах класса <code>Decimal</code>.</p><h3 id=ссылки>Ссылки</h3><ul><li><a href=http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158>.NET Reference Source: Constructs a Decimal from an integer value</a></li><li><a href=https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252>CoreCLR, JIT sources: flowgraph.cpp (Feb 26, 2015)</a></li><li><a href=https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp>CoreCLR, JIT sources: importer.cpp (Feb 26, 2015)</a></li><li><a href=https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx>MSDN: starg</a></li><li><a href=https://msdn.microsoft.com/library/system.reflection.emit.opcodes.ldarga.aspx>MSDN: ldarga</a></li><li><a href=http://stackoverflow.com/questions/26369163/net-local-variable-optimization>Stackoverflow: .NET local variable optimization</a></li></ul></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2020 Andrey Akinshin | <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.ea4f51ac7f59c8e13f4df787df946eb1a447174ce2f1fc5349483de93a607ecb.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script></body></html>