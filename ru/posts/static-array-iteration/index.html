<!doctype html><html lang=ru class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Андрей Акиньшин"><link href=/img/favicon.ico rel=icon type=image/x-icon><title>Об итерировании статичных массивов в .NET | Андрей Акиньшин</title><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://googlechromelabs.github.io/dark-mode-toggle/src/dark-mode-toggle.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.e78467baec0179d7ccd2ef995e0c94f25b4a63a3191a93c3547e22bdf590ef5d.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.a9ad336a30411929ac042537ef03ddbe3b2b28af5aa50655711f870419408467.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/ru/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41419012-5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41419012-5');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/ru/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/ru/posts/>Посты</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/ru/about/>Об авторе</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/ru/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li><li class=nav-item></li><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://aakinshin.net/ru/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class=blog-post><h2 class=blog-post-title id=post-title>Об итерировании статичных массивов в .NET</h2><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2013-08-29>29 августа 2013</time>
&nbsp;&nbsp;
<a href=https://aakinshin.net/ru/tags/dotnet/ class="badge badge-info">.NET</a>
<a href=https://aakinshin.net/ru/tags/cs/ class="badge badge-info">C#</a>
<a href=https://aakinshin.net/ru/tags/benchmarking/ class="badge badge-info">Benchmarking</a>
<a href=https://aakinshin.net/ru/tags/static/ class="badge badge-info">Static</a>
<a href=https://aakinshin.net/ru/tags/il/ class="badge badge-info">IL</a>
<a href=https://aakinshin.net/ru/tags/arrays/ class="badge badge-info">Arrays</a></span><br><br><h2 id=часть-1>Часть 1</h2><p>Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.</p><p>В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.</p><p>В примере будем решать простую задачу: подсчёт суммы элементов массива. В первом случае мы будем использовать обычное боле класса, а во втором — статическое. Для замеров времени будем использовать <a href=https://github.com/AndreyAkinshin/BenchmarkDotNet>BenchmarkDotNet</a> (исходный код примера: <a href=https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/ArrayIterationProgram.cs>ArrayIterationProgram.cs</a>, тестировать следует в <strong>Release mode without debugging</strong>):</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>private</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>N</span> <span class=p>=</span> <span class=m>1000</span><span class=p>,</span> <span class=n>IterationCount</span> <span class=p>=</span> <span class=m>1000000</span><span class=p>;</span>

<span class=k>private</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>nonStaticField</span><span class=p>;</span>
<span class=k>private</span> <span class=k>static</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>staticField</span><span class=p>;</span>

<span class=k>public</span> <span class=k>void</span> <span class=n>Run</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>nonStaticField</span> <span class=p>=</span> <span class=n>staticField</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>

    <span class=kt>var</span> <span class=n>competition</span> <span class=p>=</span> <span class=k>new</span> <span class=n>BenchmarkCompetition</span><span class=p>();</span>
    <span class=n>competition</span><span class=p>.</span><span class=n>AddTask</span><span class=p>(</span><span class=s>&#34;Non-static&#34;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=n>NonStaticRun</span><span class=p>());</span>
    <span class=n>competition</span><span class=p>.</span><span class=n>AddTask</span><span class=p>(</span><span class=s>&#34;Static&#34;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=n>StaticRun</span><span class=p>());</span>
    <span class=n>competition</span><span class=p>.</span><span class=n>Run</span><span class=p>();</span>
<span class=p>}</span>

<span class=k>private</span> <span class=kt>int</span> <span class=n>NonStaticRun</span><span class=p>()</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>iteration</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>iteration</span> <span class=p>&lt;</span> <span class=n>IterationCount</span><span class=p>;</span> <span class=n>iteration</span><span class=p>++)</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
            <span class=n>sum</span> <span class=p>+=</span> <span class=n>nonStaticField</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>private</span> <span class=kt>int</span> <span class=n>StaticRun</span><span class=p>()</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>iteration</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>iteration</span> <span class=p>&lt;</span> <span class=n>IterationCount</span><span class=p>;</span> <span class=n>iteration</span><span class=p>++)</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
            <span class=n>sum</span> <span class=p>+=</span> <span class=n>staticField</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>На своей машине я получил следующие результаты:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>Non-static : 346ms
Static     : 535ms
</code></pre></div><p>Если мы взглянем на IL-код целевых методов, то увидим, что они различаются только в одном месте, при обращении к полю:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>Non-static:
L_000b: ldarg.0 
L_000c: ldfld int32[] Benchmarks.StaticFieldBenchmark::nonStaticField
Static:
L_000b: ldsfld int32[] Benchmarks.StaticFieldBenchmark::staticField
</code></pre></div><p>Заметим, что физически оба поля ссылаются на одну и ту же область памяти. Мы можем ускорить работу со статическим полем, если перед многократным обращением к полю сохраним его в локальную переменную:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>private</span> <span class=kt>int</span> <span class=n>StaticRun</span><span class=p>()</span>
<span class=p>{</span>
    <span class=kt>var</span> <span class=n>localField</span> <span class=p>=</span> <span class=n>staticField</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>iteration</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>iteration</span> <span class=p>&lt;</span> <span class=n>IterationCount</span><span class=p>;</span> <span class=n>iteration</span><span class=p>++)</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
            <span class=n>sum</span> <span class=p>+=</span> <span class=n>localField</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>В итоге <code>StaticRun</code> будет работать столько же, сколько и <code>NonStaticRun</code>.</p><p>Объяснение такого поведения можно прочитать во второй части статьи.</p><h2 id=часть-2>Часть 2</h2><p>В первой части я встретился с весьма интересной ситуацией. Были измерены скорости работы двух методов, в первом из которых считалась сумма элементов массива, ссылка на который хранилась в обычном поле объекта, а во втором — массива, ссылка на который хранилась в статичном поле. Результаты меня удивили: массивы были одинаковые, но второй метод работал ощутимо дольше. Сперва я подумал, что дело в организации скорости доступа к статичным полям, но более детальный анализ ситуации и разговоры с коллегами помогли мне понять, что истинная причина такого поведения намного интересней: для массивов, длина которых кратна 4, JIT использует различные оптимизации в случае обычных и статичных массивов. Давайте разберёмся с ситуацией более детально.</p><p>Напомню методы, поведение которых мы будем изучать:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>private</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>N</span> <span class=p>=</span> <span class=m>1000</span><span class=p>,</span> <span class=n>IterationCount</span> <span class=p>=</span> <span class=m>1000000</span><span class=p>;</span>
<span class=k>private</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>nonStaticField</span><span class=p>;</span>
<span class=k>private</span> <span class=k>static</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>staticField</span><span class=p>;</span>

<span class=k>public</span> <span class=k>void</span> <span class=n>Run</span><span class=p>()</span>
<span class=p>{</span>
    <span class=n>nonStaticField</span> <span class=p>=</span> <span class=n>staticField</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
    <span class=n>NonStaticRun</span><span class=p>();</span>
    <span class=n>StaticRun</span><span class=p>();</span>
<span class=p>}</span>

<span class=k>private</span> <span class=kt>int</span> <span class=n>NonStaticRun</span><span class=p>()</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>iteration</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>iteration</span> <span class=p>&lt;</span> <span class=n>IterationCount</span><span class=p>;</span> <span class=n>iteration</span><span class=p>++)</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
            <span class=n>sum</span> <span class=p>+=</span> <span class=n>nonStaticField</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>private</span> <span class=kt>int</span> <span class=n>StaticRun</span><span class=p>()</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>iteration</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>iteration</span> <span class=p>&lt;</span> <span class=n>IterationCount</span><span class=p>;</span> <span class=n>iteration</span><span class=p>++)</span>
        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
            <span class=n>sum</span> <span class=p>+=</span> <span class=n>staticField</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Для начала поменяем Platform target на x86 и запустим <a href=https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/ArrayIterationProgram.cs>бенчмарк</a>. Получим следующие результаты:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>Non-static : 708ms
Static     : 709ms
</code></pre></div><p>Интересный вывод: на x86 результаты тестов одинаковы. Чтобы лучше разобраться в проблеме взглянем на нативный код, который получается после JIT-оптимизаций (изучается версия в Release mode without debugging). Конфигурация моей машины, на которой я проводил тестирование: Intel Core i7-3632QM CPU 2.20GHz.</p><p><strong>NonStaticRun-x86.asm</strong></p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>00</span> <span class=nf>push</span> <span class=no>ebp</span> 
<span class=mi>01</span> <span class=no>mov</span>  <span class=no>ebp</span><span class=p>,</span><span class=no>esp</span> 
<span class=mi>03</span> <span class=no>push</span> <span class=no>edi</span> 
<span class=mi>04</span> <span class=no>push</span> <span class=no>esi</span> 
<span class=mi>05</span> <span class=no>push</span> <span class=no>ebx</span> 
<span class=mi>06</span> <span class=no>xor</span>  <span class=no>edi</span><span class=p>,</span><span class=no>edi</span>                     <span class=c>; sum = 0
</span><span class=c></span><span class=mi>08</span> <span class=no>xor</span>  <span class=no>ebx</span><span class=p>,</span><span class=no>ebx</span>                     <span class=c>; iteration
</span><span class=c></span><span class=mi>0</span><span class=no>a</span> <span class=no>xor</span>  <span class=no>edx</span><span class=p>,</span><span class=no>edx</span>                     <span class=c>; i = 0
</span><span class=c></span><span class=mi>0</span><span class=no>c</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ecx</span><span class=err>+</span><span class=mi>4</span><span class=p>]</span>       <span class=c>; eax = &amp;nonStaticField
</span><span class=c></span><span class=mi>0</span><span class=no>f</span> <span class=no>mov</span>  <span class=no>esi</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=err>+</span><span class=mi>4</span><span class=p>]</span>       <span class=c>; esi = nonStaticField.Length
</span><span class=c></span><span class=mi>12</span> <span class=no>cmp</span>  <span class=no>edx</span><span class=p>,</span><span class=no>esi</span>                     <span class=c>; if i &gt;= nonStaticField.Length then
</span><span class=c></span><span class=mi>14</span> <span class=no>jae</span>  <span class=mi>00000033</span>                    <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>16</span> <span class=no>add</span>  <span class=no>edi</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=err>+</span><span class=no>edx</span><span class=p>*</span><span class=mi>4</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span> <span class=c>; sum += nonStaticField[i];
</span><span class=c></span><span class=mi>1</span><span class=no>a</span> <span class=no>inc</span>  <span class=no>edx</span>                         <span class=c>; i++
</span><span class=c></span><span class=mi>1</span><span class=no>b</span> <span class=no>cmp</span>  <span class=no>edx</span><span class=p>,</span><span class=mi>3</span><span class=no>E8h</span>                    <span class=c>; if i &lt; 1000 then
</span><span class=c></span><span class=mi>21</span> <span class=no>jl</span>   <span class=mi>00000012</span>                    <span class=c>; loop by i
</span><span class=c></span><span class=mi>23</span> <span class=no>inc</span>  <span class=no>ebx</span>                         <span class=c>; iteration++
</span><span class=c></span><span class=mi>24</span> <span class=no>cmp</span>  <span class=no>ebx</span><span class=p>,</span><span class=mi>0</span><span class=no>F4240h</span>                 <span class=c>; if iteration &lt; 1000000 then
</span><span class=c></span><span class=mi>2</span><span class=no>a</span> <span class=no>jl</span>   <span class=mi>0000000</span><span class=no>A</span>                    <span class=c>; loop by iteration
</span><span class=c></span><span class=mi>2</span><span class=no>c</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>edi</span>                     <span class=c>; eax = sum (Result)
</span><span class=c></span><span class=mi>2</span><span class=no>e</span> <span class=no>pop</span>  <span class=no>ebx</span> 
<span class=mi>2</span><span class=no>f</span> <span class=no>pop</span>  <span class=no>esi</span> 
<span class=mi>30</span> <span class=no>pop</span>  <span class=no>edi</span> 
<span class=mi>31</span> <span class=no>pop</span>  <span class=no>ebp</span> 
<span class=mi>32</span> <span class=no>ret</span> 
<span class=mi>33</span> <span class=no>call</span> <span class=mi>63495</span><span class=no>C4D</span>                    <span class=c>; IndexOutOfRangeException
</span><span class=c></span><span class=mi>38</span> <span class=no>int</span>  <span class=mi>3</span> 
</code></pre></div><p><strong>StaticRun-x86.asm</strong></p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>00</span> <span class=nf>push</span> <span class=no>ebp</span> 
<span class=mi>01</span> <span class=no>mov</span>  <span class=no>ebp</span><span class=p>,</span><span class=no>esp</span> 
<span class=mi>03</span> <span class=no>push</span> <span class=no>edi</span> 
<span class=mi>04</span> <span class=no>push</span> <span class=no>esi</span> 
<span class=mi>05</span> <span class=no>push</span> <span class=no>ebx</span> 
<span class=mi>06</span> <span class=no>xor</span>  <span class=no>edi</span><span class=p>,</span><span class=no>edi</span>                      <span class=c>; sum = 0
</span><span class=c></span><span class=mi>08</span> <span class=no>xor</span>  <span class=no>ebx</span><span class=p>,</span><span class=no>ebx</span>                      <span class=c>; iteration = 0
</span><span class=c></span><span class=mi>0</span><span class=no>a</span> <span class=no>xor</span>  <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>                      <span class=c>; i = 0
</span><span class=c></span><span class=mi>0</span><span class=no>c</span> <span class=no>mov</span>  <span class=no>edx</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=no>ds</span><span class=p>:[</span><span class=mi>03943380</span><span class=no>h</span><span class=p>]</span> <span class=c>; edx = &amp;staticField
</span><span class=c></span><span class=mi>12</span> <span class=no>mov</span>  <span class=no>esi</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=mi>4</span><span class=p>]</span>        <span class=c>; esi = staticField.Length 
</span><span class=c></span><span class=mi>15</span> <span class=no>cmp</span>  <span class=no>eax</span><span class=p>,</span><span class=no>esi</span>                      <span class=c>; if i &gt;= staticField.Length then
</span><span class=c></span><span class=mi>17</span> <span class=no>jae</span>  <span class=mi>00000035</span>                     <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>19</span> <span class=no>add</span>  <span class=no>edi</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>edx</span><span class=err>+</span><span class=no>eax</span><span class=p>*</span><span class=mi>4</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span>  <span class=c>; sum += staticField[i];
</span><span class=c></span><span class=mi>1</span><span class=no>d</span> <span class=no>inc</span>  <span class=no>eax</span>                          <span class=c>; i++
</span><span class=c></span><span class=mi>1</span><span class=no>e</span> <span class=no>cmp</span>  <span class=no>eax</span><span class=p>,</span><span class=mi>3</span><span class=no>E8h</span>                     <span class=c>; if i &lt; 1000 then
</span><span class=c></span><span class=mi>23</span> <span class=no>jl</span>   <span class=mi>00000015</span>                     <span class=c>; loop by i
</span><span class=c></span><span class=mi>25</span> <span class=no>inc</span>  <span class=no>ebx</span>                          <span class=c>; iteration++
</span><span class=c></span><span class=mi>26</span> <span class=no>cmp</span>  <span class=no>ebx</span><span class=p>,</span><span class=mi>0</span><span class=no>F4240h</span>                  <span class=c>; if iteration &lt; 1000000 then
</span><span class=c></span><span class=mi>2</span><span class=no>c</span> <span class=no>jl</span>   <span class=mi>0000000</span><span class=no>A</span>                     <span class=c>; loop by iteration
</span><span class=c></span><span class=mi>2</span><span class=no>e</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>edi</span>                      <span class=c>; eax = sum (Result)
</span><span class=c></span><span class=mi>30</span> <span class=no>pop</span>  <span class=no>ebx</span> 
<span class=mi>31</span> <span class=no>pop</span>  <span class=no>esi</span> 
<span class=mi>32</span> <span class=no>pop</span>  <span class=no>edi</span> 
<span class=mi>33</span> <span class=no>pop</span>  <span class=no>ebp</span> 
<span class=mi>34</span> <span class=no>ret</span> 
<span class=mi>35</span> <span class=no>call</span> <span class=mi>639</span><span class=no>E52D5</span>                     <span class=c>; IndexOutOfRangeException
</span><span class=c></span><span class=mi>3</span><span class=no>a</span> <span class=no>int</span>  <span class=mi>3</span> 
</code></pre></div><p>Из этого кода становится понятно, что разнице во времени взяться неоткуда: методы отличаются только в одной строчке, в которой берётся адрес интересующего нас массива. В обоих случаях используется команда <code>move</code> , просто её аргументы разнятся, это не должно сказаться на производительности.</p><p>Теперь поменяем платформу на x64 и запустим бенчмарк:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>Non-static : 347ms
Static     : 533ms
</code></pre></div><p>Любопытно: в обоих случаях быстродействие значительно возросло, но только в случае статичного поля оптимизация вышла «слабее». В чём же дело? Обратимся опять к машинному коду:</p><p><strong>NonStaticRun-x64.asm</strong></p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>00</span> <span class=nf>sub</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span>
<span class=err>04</span> <span class=nf>mov</span>  <span class=no>r8</span><span class=p>,</span><span class=no>rcx</span>
<span class=err>07</span> <span class=nf>xor</span>  <span class=no>ecx</span><span class=p>,</span><span class=no>ecx</span>
<span class=err>09</span> <span class=nf>mov</span>  <span class=no>edx</span><span class=p>,</span><span class=no>ecx</span>                      <span class=c>; sum = 0
</span><span class=c></span><span class=mi>0</span><span class=no>b</span> <span class=no>nop</span>  <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=p>]</span>
<span class=err>10</span> <span class=nf>xor</span>  <span class=no>r10d</span><span class=p>,</span><span class=no>r10d</span>                    <span class=c>; i = 0
</span><span class=c></span><span class=mi>13</span> <span class=no>mov</span>  <span class=no>r9</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r8</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span>          <span class=c>; r9 = &amp;nonStaticField
</span><span class=c></span><span class=mi>17</span> <span class=no>mov</span>  <span class=no>rax</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span>         <span class=c>; rax = nonStaticField.Length
</span><span class=c></span><span class=mi>1</span><span class=no>b</span> <span class=no>mov</span>  <span class=no>r11d</span><span class=p>,</span><span class=mi>3</span><span class=no>E4h</span>                    <span class=c>; r11 = 996
</span><span class=c></span><span class=mi>21</span> <span class=no>cmp</span>  <span class=no>r11</span><span class=p>,</span><span class=no>rax</span>                      <span class=c>; if r11 &gt;= nonStaticField.Length then
</span><span class=c></span><span class=mi>24</span> <span class=no>jae</span>  <span class=mi>000000000000008</span><span class=no>A</span>             <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>26</span> <span class=no>mov</span>  <span class=no>r11d</span><span class=p>,</span><span class=mi>3</span><span class=no>E5h</span>                    <span class=c>; r11 = 997
</span><span class=c></span><span class=mi>2</span><span class=no>c</span> <span class=no>cmp</span>  <span class=no>r11</span><span class=p>,</span><span class=no>rax</span>                      <span class=c>; if r11 &gt;= nonStaticField.Length then
</span><span class=c></span><span class=mi>2</span><span class=no>f</span> <span class=no>jae</span>  <span class=mi>000000000000008</span><span class=no>A</span>             <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>31</span> <span class=no>mov</span>  <span class=no>r11d</span><span class=p>,</span><span class=mi>3</span><span class=no>E6h</span>                    <span class=c>; r11 = 998
</span><span class=c></span><span class=mi>37</span> <span class=no>cmp</span>  <span class=no>r11</span><span class=p>,</span><span class=no>rax</span>                      <span class=c>; if r11 &gt;= nonStaticField.Length then
</span><span class=c></span><span class=mi>3</span><span class=no>a</span> <span class=no>jae</span>  <span class=mi>000000000000008</span><span class=no>A</span>             <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>3</span><span class=no>c</span> <span class=no>mov</span>  <span class=no>r11d</span><span class=p>,</span><span class=mi>3</span><span class=no>E7h</span>                    <span class=c>; r11 = 999
</span><span class=c></span><span class=mi>42</span> <span class=no>cmp</span>  <span class=no>r11</span><span class=p>,</span><span class=no>rax</span>                      <span class=c>; if r11 &gt;= nonStaticField.Length then
</span><span class=c></span><span class=mi>45</span> <span class=no>jae</span>  <span class=mi>000000000000008</span><span class=no>A</span>             <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>47</span> <span class=no>nop</span>  <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=err>+</span><span class=mi>00000000</span><span class=no>h</span><span class=p>]</span>
<span class=err>50</span> <span class=nf>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>r10</span><span class=err>+</span><span class=mi>10</span><span class=no>h</span><span class=p>]</span>   <span class=c>; eax = nonStaticField[i]
</span><span class=c></span><span class=mi>55</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                      <span class=c>; sum += eax
</span><span class=c></span><span class=mi>57</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>r10</span><span class=err>+</span><span class=mi>14</span><span class=no>h</span><span class=p>]</span>   <span class=c>; eax = nonStaticField[i+1]
</span><span class=c></span><span class=mi>5</span><span class=no>c</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                      <span class=c>; sum += eax
</span><span class=c></span><span class=mi>5</span><span class=no>e</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>r10</span><span class=err>+</span><span class=mi>18</span><span class=no>h</span><span class=p>]</span>   <span class=c>; eax = nonStaticField[i+2]
</span><span class=c></span><span class=mi>63</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                      <span class=c>; sum += eax
</span><span class=c></span><span class=mi>65</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>r10</span><span class=err>+</span><span class=mi>1</span><span class=no>Ch</span><span class=p>]</span>   <span class=c>; eax = nonStaticField[i+3]
</span><span class=c></span><span class=mi>6</span><span class=no>a</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                      <span class=c>; sum += eax
</span><span class=c></span><span class=mi>6</span><span class=no>c</span> <span class=no>add</span>  <span class=no>r10</span><span class=p>,</span><span class=mi>10</span><span class=no>h</span>                      <span class=c>; i += 4
</span><span class=c></span><span class=mi>70</span> <span class=no>cmp</span>  <span class=no>r10</span><span class=p>,</span><span class=mi>0</span><span class=no>FA0h</span>                    <span class=c>; if i &lt; 1000 then
</span><span class=c></span><span class=mi>77</span> <span class=no>jl</span>   <span class=mi>0000000000000050</span>             <span class=c>; loop by i
</span><span class=c></span><span class=mi>79</span> <span class=no>inc</span>  <span class=no>ecx</span>                          <span class=c>; iteration++
</span><span class=c></span><span class=mi>7</span><span class=no>b</span> <span class=no>cmp</span>  <span class=no>ecx</span><span class=p>,</span><span class=mi>0</span><span class=no>F4240h</span>                  <span class=c>; if iteration &lt; 1000000  then
</span><span class=c></span><span class=mi>81</span> <span class=no>jl</span>   <span class=mi>0000000000000010</span>             <span class=c>; loop by iteration
</span><span class=c></span><span class=mi>83</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>edx</span>                      <span class=c>; eax = sum (Result)
</span><span class=c></span><span class=mi>85</span> <span class=no>add</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span>
<span class=err>89</span> <span class=nf>ret</span>   
<span class=mi>8</span><span class=no>a</span> <span class=no>call</span> <span class=mi>000000005</span><span class=no>FA4AE14</span>             <span class=c>; IndexOutOfRangeException
</span><span class=c></span><span class=mi>8</span><span class=no>f</span> <span class=no>nop</span> 
</code></pre></div><p>Этот пример намного интересней! Вспомним, что в x86 нам доступно только 8 регистров по 32 бита (EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, R8D), а в x64 доступно 16 регистров по 64 бита (RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI, R8 — R15). Увеличение количества регистров позволило произвести JIT-оптимизацию «размотка цикла» (см.
<a href=http://en.wikipedia.org/wiki/Loop_unwinding>Loop unwinding</a>). При этом важную роль играет то обстоятельство, что количество итераций в каждом из циклов кратно четвёрке. Мы ещё вернёмся к этому моменту, а пока взглянем на static-версию.</p><p><strong>StaticRun-x64.asm</strong></p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>00</span> <span class=nf>sub</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span> 
<span class=mi>04</span> <span class=no>xor</span>  <span class=no>ecx</span><span class=p>,</span><span class=no>ecx</span>                       <span class=c>; iteration = 0
</span><span class=c></span><span class=mi>06</span> <span class=no>mov</span>  <span class=no>edx</span><span class=p>,</span><span class=no>ecx</span>                       <span class=c>; sum = 0
</span><span class=c></span><span class=mi>08</span> <span class=no>nop</span>  <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=err>+</span><span class=mi>00000000</span><span class=no>h</span><span class=p>]</span> 
<span class=mi>10</span> <span class=no>xor</span>  <span class=no>r8d</span><span class=p>,</span><span class=no>r8d</span>                       <span class=c>; i = 0
</span><span class=c></span><span class=mi>13</span> <span class=no>mov</span>  <span class=no>r9</span><span class=p>,</span><span class=mi>12</span><span class=no>D756F0h</span>                  <span class=c>; r9 = staticField
</span><span class=c></span><span class=mi>1</span><span class=no>d</span> <span class=no>mov</span>  <span class=no>r9</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=p>]</span>             <span class=c>; r9 = &amp;staticField
</span><span class=c></span><span class=mi>20</span> <span class=no>mov</span>  <span class=no>r10</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span>          <span class=c>; r10 = staticField.Length
</span><span class=c></span><span class=mi>24</span> <span class=no>cmp</span>  <span class=no>r8</span><span class=p>,</span><span class=no>r10</span>                        <span class=c>; if r8 &gt;= staticField.Length then
</span><span class=c></span><span class=mi>27</span> <span class=no>jae</span>  <span class=mi>0000000000000080</span>              <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>29</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>r8</span><span class=p>*</span><span class=mi>4</span><span class=err>+</span><span class=mi>10</span><span class=no>h</span><span class=p>]</span>   <span class=c>; eax = staticField[i]
</span><span class=c></span><span class=mi>2</span><span class=no>e</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                       <span class=c>; sum += eax
</span><span class=c></span><span class=mi>30</span> <span class=no>lea</span>  <span class=no>rax</span><span class=p>,[</span><span class=no>r8</span><span class=err>+</span><span class=mi>1</span><span class=p>]</span>                    <span class=c>; rax = i+1
</span><span class=c></span><span class=mi>34</span> <span class=no>cmp</span>  <span class=no>rax</span><span class=p>,</span><span class=no>r10</span>                       <span class=c>; if rax &gt;= staticField.Length then
</span><span class=c></span><span class=mi>37</span> <span class=no>jae</span>  <span class=mi>0000000000000080</span>              <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>39</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>rax</span><span class=p>*</span><span class=mi>4</span><span class=err>+</span><span class=mi>10</span><span class=no>h</span><span class=p>]</span>  <span class=c>; eax = staticField[i+1]
</span><span class=c></span><span class=mi>3</span><span class=no>e</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                       <span class=c>; sum += eax
</span><span class=c></span><span class=mi>40</span> <span class=no>lea</span>  <span class=no>rax</span><span class=p>,[</span><span class=no>r8</span><span class=err>+</span><span class=mi>2</span><span class=p>]</span>                    <span class=c>; rax = i+2
</span><span class=c></span><span class=mi>44</span> <span class=no>cmp</span>  <span class=no>rax</span><span class=p>,</span><span class=no>r10</span>                       <span class=c>; if rax &gt;= staticField.Length then
</span><span class=c></span><span class=mi>47</span> <span class=no>jae</span>  <span class=mi>0000000000000080</span>              <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>49</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>rax</span><span class=p>*</span><span class=mi>4</span><span class=err>+</span><span class=mi>10</span><span class=no>h</span><span class=p>]</span>  <span class=c>; eax = staticField[i+2]
</span><span class=c></span><span class=mi>4</span><span class=no>e</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                       <span class=c>; sum += eax
</span><span class=c></span><span class=mi>50</span> <span class=no>lea</span>  <span class=no>rax</span><span class=p>,[</span><span class=no>r8</span><span class=err>+</span><span class=mi>3</span><span class=p>]</span>                    <span class=c>; rax = i+3
</span><span class=c></span><span class=mi>54</span> <span class=no>cmp</span>  <span class=no>rax</span><span class=p>,</span><span class=no>r10</span>                       <span class=c>; if rax &gt;= staticField.Length then
</span><span class=c></span><span class=mi>57</span> <span class=no>jae</span>  <span class=mi>0000000000000080</span>              <span class=c>; throw IndexOutOfRangeException
</span><span class=c></span><span class=mi>59</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>rax</span><span class=p>*</span><span class=mi>4</span><span class=err>+</span><span class=mi>10</span><span class=no>h</span><span class=p>]</span>  <span class=c>; eax = staticField[i+3]
</span><span class=c></span><span class=mi>5</span><span class=no>e</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span>                       <span class=c>; sum += eax
</span><span class=c></span><span class=mi>60</span> <span class=no>add</span>  <span class=no>r8</span><span class=p>,</span><span class=mi>4</span>                          <span class=c>; i += 4
</span><span class=c></span><span class=mi>64</span> <span class=no>cmp</span>  <span class=no>r8</span><span class=p>,</span><span class=mi>3</span><span class=no>E8h</span>                       <span class=c>; if i &lt; 1000 then
</span><span class=c></span><span class=mi>6</span><span class=no>b</span> <span class=no>jl</span>   <span class=mi>0000000000000013</span>              <span class=c>; loop by i
</span><span class=c></span><span class=mi>6</span><span class=no>d</span> <span class=no>inc</span>  <span class=no>ecx</span>                           <span class=c>; iteration++
</span><span class=c></span><span class=mi>6</span><span class=no>f</span> <span class=no>cmp</span>  <span class=no>ecx</span><span class=p>,</span><span class=mi>0</span><span class=no>F4240h</span>                   <span class=c>; if iteration &lt; 1000000 then
</span><span class=c></span><span class=mi>75</span> <span class=no>jl</span>   <span class=mi>0000000000000010</span>              <span class=c>; loop by iteration
</span><span class=c></span><span class=mi>77</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>edx</span>                       <span class=c>; eax = sum (result)
</span><span class=c></span><span class=mi>79</span> <span class=no>add</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span> 
<span class=mi>7</span><span class=no>d</span> <span class=no>ret</span>     
<span class=mi>7</span><span class=no>e</span> <span class=no>xchg</span> <span class=no>ax</span><span class=p>,</span><span class=no>ax</span> 
<span class=mi>80</span> <span class=no>call</span> <span class=mi>000000005</span><span class=no>FA49F64</span>              <span class=c>; IndexOutOfRangeException
</span><span class=c></span><span class=mi>85</span> <span class=no>nop</span>   
</code></pre></div><p>Из примера видно, что для статичного массива оптимизация размотки цикла прошла несколько иначе. Причём, если в методе <code>StaticRun</code> сохранить ссылку на статический массив в локальную переменную и итерировать по ней, то машинный код будет аналогичен примеру NonStaticRun-x64.asm, а производительность обоих методов станет одинаковой. В текущей версии static-версия «проседает» по скорости из-за следующих обстоятельств:</p><ul><li>Вместо того, чтобы явно хранить смещения элементов, хранится индекс, который в момент вычисления адреса умножается на 4 для получения смещения.</li><li>Вычисление адресов элементов [i+1], [i+2], [i+3] происходит в регистрах вместо того, чтобы использовать константные смещения в 4h, 8h, bh, относительно элемента [i].</li></ul><p>Теперь попробуем изменить длину массива, чтобы она больше не делилась на 4: N = 1001. Результаты бенчмарка:</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=nf>Non-static</span> <span class=p>:</span> <span class=mi>550</span><span class=no>ms</span>
<span class=nf>Static</span>     <span class=p>:</span> <span class=mi>719</span><span class=no>ms</span>
</code></pre></div><p>Static-версия по скорости «вернулась» к результату без оптимизации, который мы видели в x86-версии. В NonStatic-версии результат интереснее: текущая версия работает медленнее, чем для N=1000, но быстрее, чем для x86. Опять обратимся к машинному коду, чтобы разобраться:</p><p><strong>NonStaticRun-x64-1001.asm</strong></p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>00</span> <span class=nf>sub</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span> 
<span class=mi>04</span> <span class=no>mov</span>  <span class=no>r9</span><span class=p>,</span><span class=no>rcx</span> 
<span class=mi>07</span> <span class=no>xor</span>  <span class=no>ecx</span><span class=p>,</span><span class=no>ecx</span> 
<span class=mi>09</span> <span class=no>mov</span>  <span class=no>edx</span><span class=p>,</span><span class=no>ecx</span> 
<span class=mi>0</span><span class=no>b</span> <span class=no>nop</span>  <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=p>]</span> 
<span class=mi>10</span> <span class=no>xor</span>  <span class=no>r8d</span><span class=p>,</span><span class=no>r8d</span> 
<span class=mi>13</span> <span class=no>mov</span>  <span class=no>r10</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span> 
<span class=mi>17</span> <span class=no>mov</span>  <span class=no>rax</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r10</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span> 
<span class=mi>1</span><span class=no>b</span> <span class=no>mov</span>  <span class=no>r11d</span><span class=p>,</span><span class=mi>3</span><span class=no>E8h</span> 
<span class=mi>21</span> <span class=no>cmp</span>  <span class=no>r11</span><span class=p>,</span><span class=no>rax</span> 
<span class=mi>24</span> <span class=no>jae</span>  <span class=mi>0000000000000055</span> 
<span class=mi>26</span> <span class=no>nop</span>  <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=err>+</span><span class=mi>00000000</span><span class=no>h</span><span class=p>]</span> 
<span class=mi>30</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r10</span><span class=err>+</span><span class=no>r8</span><span class=err>+</span><span class=mi>10</span><span class=no>h</span><span class=p>]</span> 
<span class=mi>35</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span> 
<span class=mi>37</span> <span class=no>add</span>  <span class=no>r8</span><span class=p>,</span><span class=mi>4</span> 
<span class=mi>3</span><span class=no>b</span> <span class=no>cmp</span>  <span class=no>r8</span><span class=p>,</span><span class=mi>0</span><span class=no>FA4h</span> 
<span class=mi>42</span> <span class=no>jl</span>   <span class=mi>0000000000000030</span> 
<span class=mi>44</span> <span class=no>inc</span>  <span class=no>ecx</span> 
<span class=mi>46</span> <span class=no>cmp</span>  <span class=no>ecx</span><span class=p>,</span><span class=mi>0</span><span class=no>F4240h</span> 
<span class=mi>4</span><span class=no>c</span> <span class=no>jl</span>   <span class=mi>0000000000000010</span> 
<span class=mi>4</span><span class=no>e</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>edx</span> 
<span class=mi>50</span> <span class=no>add</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span> 
<span class=mi>54</span> <span class=no>ret</span>    
<span class=mi>55</span> <span class=no>call</span> <span class=mi>000000005</span><span class=no>FA5AE14</span> 
<span class=mi>5</span><span class=no>a</span> <span class=no>nop</span>    
</code></pre></div><p><strong>StaticRun-x64-1001.asm</strong></p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=err>00</span> <span class=nf>sub</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span> 
<span class=mi>04</span> <span class=no>xor</span>  <span class=no>ecx</span><span class=p>,</span><span class=no>ecx</span> 
<span class=mi>06</span> <span class=no>mov</span>  <span class=no>edx</span><span class=p>,</span><span class=no>ecx</span> 
<span class=mi>08</span> <span class=no>nop</span>  <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=err>+</span><span class=mi>00000000</span><span class=no>h</span><span class=p>]</span> 
<span class=mi>10</span> <span class=no>xor</span>  <span class=no>r8d</span><span class=p>,</span><span class=no>r8d</span> 
<span class=mi>13</span> <span class=no>mov</span>  <span class=no>r9</span><span class=p>,</span><span class=mi>12</span><span class=no>B556F0h</span> 
<span class=mi>1</span><span class=no>d</span> <span class=no>mov</span>  <span class=no>r9</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=p>]</span> 
<span class=mi>20</span> <span class=no>mov</span>  <span class=no>rax</span><span class=p>,</span><span class=no>qword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span> 
<span class=mi>24</span> <span class=no>cmp</span>  <span class=no>r8</span><span class=p>,</span><span class=no>rax</span> 
<span class=mi>27</span> <span class=no>jae</span>  <span class=mi>0000000000000050</span> 
<span class=mi>29</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>r9</span><span class=err>+</span><span class=no>r8</span><span class=p>*</span><span class=mi>4</span><span class=err>+</span><span class=mi>10</span><span class=no>h</span><span class=p>]</span> 
<span class=mi>2</span><span class=no>e</span> <span class=no>add</span>  <span class=no>edx</span><span class=p>,</span><span class=no>eax</span> 
<span class=mi>30</span> <span class=no>inc</span>  <span class=no>r8</span> 
<span class=mi>33</span> <span class=no>cmp</span>  <span class=no>r8</span><span class=p>,</span><span class=mi>3</span><span class=no>E9h</span> 
<span class=mi>3</span><span class=no>a</span> <span class=no>jl</span>   <span class=mi>0000000000000013</span> 
<span class=mi>3</span><span class=no>c</span> <span class=no>inc</span>  <span class=no>ecx</span> 
<span class=mi>3</span><span class=no>e</span> <span class=no>cmp</span>  <span class=no>ecx</span><span class=p>,</span><span class=mi>0</span><span class=no>F4240h</span> 
<span class=mi>44</span> <span class=no>jl</span>   <span class=mi>0000000000000010</span> 
<span class=mi>46</span> <span class=no>mov</span>  <span class=no>eax</span><span class=p>,</span><span class=no>edx</span> 
<span class=mi>48</span> <span class=no>add</span>  <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span> 
<span class=mi>4</span><span class=no>c</span> <span class=no>ret</span>   
<span class=mi>4</span><span class=no>d</span> <span class=no>nop</span>  <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=p>]</span> 
<span class=mi>50</span> <span class=no>call</span> <span class=mi>000000005</span><span class=no>FA69FA4</span> 
<span class=mi>55</span> <span class=no>nop</span>
</code></pre></div><p>Из примеров можно заметить, что в методах NonStaticRun-x86, StaticRun-x86, StaticRun-x64-1001 для вычисления очередного элемента массива используется формула:
<code>BaseAddress + i * 4 + 10h</code>, а в методе NonStaticRun: <code>BaseAddress + offset + 10h</code>, где <code>offset = i * 4</code> — уже готовое смещение. Этим и объясняется разница в скорости.</p><p>Данную тему можно изучать ещё очень долго: пробовать менять конфигурацию сборки, пробовать различные длины массивов и т.п. Но я ограничусь формулировкой основного вывода.</p><h3 id=выводы>Выводы</h3><p>Скорость итерирования может значительно зависеть от следующих обстоятельств:</p><ul><li>Тип ссылки на массив: статичное поле или обычное поле/локальная переменная</li><li>Используемая архитектура процессора</li><li>Делимость количества элементов на степени двойки</li><li>Версия CLR</li><li>Фаза луны</li></ul><p>Всем хороших бенчмарков =)</p><br><br><div class=mx-auto>Поделиться:<div class=faicon><a href="https://twitter.com/intent/tweet?text=%d0%9e%d0%b1%20%d0%b8%d1%82%d0%b5%d1%80%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b8%20%d1%81%d1%82%d0%b0%d1%82%d0%b8%d1%87%d0%bd%d1%8b%d1%85%20%d0%bc%d0%b0%d1%81%d1%81%d0%b8%d0%b2%d0%be%d0%b2%20%d0%b2%20.NET&url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fstatic-array-iteration%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x" title=Twitter></i></a></div><div class=faicon><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fstatic-array-iteration%2f&title=%d0%9e%d0%b1%20%d0%b8%d1%82%d0%b5%d1%80%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b8%20%d1%81%d1%82%d0%b0%d1%82%d0%b8%d1%87%d0%bd%d1%8b%d1%85%20%d0%bc%d0%b0%d1%81%d1%81%d0%b8%d0%b2%d0%be%d0%b2%20%d0%b2%20.NET" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=faicon><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fru%2fposts%2fstatic-array-iteration%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=faicon><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fru%2fposts%2fstatic-array-iteration%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=faicon><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fstatic-array-iteration%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=faicon><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fstatic-array-iteration%2f&title=%d0%9e%d0%b1%20%d0%b8%d1%82%d0%b5%d1%80%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b8%20%d1%81%d1%82%d0%b0%d1%82%d0%b8%d1%87%d0%bd%d1%8b%d1%85%20%d0%bc%d0%b0%d1%81%d1%81%d0%b8%d0%b2%d0%be%d0%b2%20%d0%b2%20.NET" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2020 Андрей Акиньшин | <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.ea4f51ac7f59c8e13f4df787df946eb1a447174ce2f1fc5349483de93a607ecb.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script></body></html>