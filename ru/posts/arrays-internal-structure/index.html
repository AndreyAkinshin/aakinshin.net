<!doctype html><html lang=ru><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.123.8"><meta name=author content='Андрей Акиньшин'><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content='.NET,C#,Arrays'><title>Внутреннее устройство массивов в .NET | Андрей Акиньшин</title>
<meta name=description content="Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблер..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.beef8b4fb043af14c2883e35de1b55e76fb412aa04a92889080ed30141cda7b6.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/ru/posts/index.xml title="RSS Feed"></head><body class="flex flex-col min-h-screen"><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-2 xs:px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/ru/about/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div></div><button id=theme-toggle type=button title="Alt+Click to match OS color theme" class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6 flex-grow"><div class=main-post><h1 class=blog-post-title id=post-title>Внутреннее устройство массивов в .NET</h1><div class="flex flex-wrap justify-start items-center"><div class="flex flex-wrap gap-y-1"><span class=label><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#calendar"/></svg>
<time datetime=2013-10-11>11 октября 2013</time>
</span><a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET
</a><a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#
</a><a class=label-link href=https://aakinshin.net/ru/tags/arrays/>Arrays</a></div></div><br><div class=main-content><p>Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблерный код при обращении к их элементам. Я рассмотрю три вида массивов: single (<code>T[]</code>), rectangular (<code>T[,]</code>), jagged (<code>T[][]</code>). Также будет затронута тема массивов с ненулевой нижней границей (<code>T[*]</code>) и нюансов работы с ними.</p><p>При рассмотрении низкоуровневых данных (например, дампов памяти) следует понимать, что адреса различных объектов будут меняться от одного запуска программы к запуску. В примерах нас больше будет интересовать относительное размещение объектов. В качестве целевой архитектуры взята
<code>x86</code>
. Для удобства восприятия многие данные переведены из родной шестнадцатеричной формы в десятичную (за исключением адресов, они начинаются с префикса
<code>0x</code>
). Данная статья не претендует на фундаментальное описание внутреннего представления массивов, скорее это просто краткий обзор организации различных массивов на низком уровне. В качестве реализации платформы рассматривается стандартная MS.NET, Mono обсуждать не будем.</p><h3 id=single-array>Single array</h3><p>Такие массивы часто называются также <em>SZ-массивами</em> (single-dimensional, zero-based) или <em>векторами</em>. Создадим обычный <code>int[]</code>-массив (каждый элемент занимает 4 байта) длинной 5 элементов, который заполним числами от 0 до 4:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span><span class=p>[]</span> <span class=n>a</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>5</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>5</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=n>i</span><span class=p>;</span>
</span></span></code></pre></div><p>В памяти он будет представлен следующим образом:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>0x03022424           0  // SyncBlockIndex
</span></span><span class=line><span class=cl>0x03022428  0x61B9C448  // *MethodTable
</span></span><span class=line><span class=cl>0x0302242C           5  // a.Length
</span></span><span class=line><span class=cl>0x03022430           0  // a[0]
</span></span><span class=line><span class=cl>0x03022434           1  // a[1]
</span></span><span class=line><span class=cl>0x03022438           2  // a[2]
</span></span><span class=line><span class=cl>0x0302243C           3  // a[3]
</span></span><span class=line><span class=cl>0x03022440           4  // a[4]
</span></span></code></pre></div><p>Воспользуемся расширением отладчика <a href=http://msdn.microsoft.com/ru-ru/library/bb190764.aspx>SOS</a> и через Immediate Window посмотрим чуть больше информации о нашем массиве:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>.load sos.dll
</span></span><span class=line><span class=cl>!DumpArray 0x03022428
</span></span><span class=line><span class=cl>Name:        System.Int32[]
</span></span><span class=line><span class=cl>MethodTable: 61b9c448
</span></span><span class=line><span class=cl>EEClass:     6180c0d0
</span></span><span class=line><span class=cl>Size:        32(0x20) bytes
</span></span><span class=line><span class=cl>Array:       Rank 1, Number of elements 5, Type Int32
</span></span><span class=line><span class=cl>Element Methodtable: 61b9c480
</span></span><span class=line><span class=cl>[0] 03022430
</span></span><span class=line><span class=cl>[1] 03022434
</span></span><span class=line><span class=cl>[2] 03022438
</span></span><span class=line><span class=cl>[3] 0302243c
</span></span><span class=line><span class=cl>[4] 03022440
</span></span></code></pre></div><p>Тут всё достаточно просто. Переменная <code>a</code> указывает на адрес <code>0x03022428</code>, по которому хранится указатель на таблицу методов соответствующего типа (в данном случае
<code>System.Int32[]</code>), которая занимает 4 байта (для <code>x64</code> — 8 байт). Перед ней находится SyncBlockIndex (отсчитывается от 1, 0 означает пустое значение; размер под
<code>x86</code> — 4 байта, под <code>x64</code> — 8 байт). После <code>*MethodTable</code> идёт сначала размер массива, а затем по порядку все его элементы.</p><p>Для операций с SZ-массивами предусмотрены следующие IL-команды:</p><ul><li><code>newarr &lt;etype></code> : создание нового массива с элементами типа etype</li><li><code>ldelem &lt;typeTok></code>: добавить значение элемента по заданному индексу в стек</li><li><code>ldelema &lt;class></code>: добавить адрес элемента по заданному индексу в стек</li><li><code>ldlen</code>: добавить длину массива в стек</li><li><code>stelem &lt;typeTok></code>: заменить значение элемента по заданному индексу значением из стека</li></ul><p>Обращение к элементу на уровне ассемблера имеет примерно следующий вид: <code>[ebx+ecx*4+8]</code>. Здесь <code>ebx</code> обозначает базовый адрес массива, <code>ecx</code> — индекс элемента (он умножается на 4, т.к. Int32 занимает в памяти 4 байта), <code>8</code> — смещение для нулевого элемента (пропускаем MethodTable и количество элементов массива, т.е. два значения по 4 байта).</p><h3 id=rectangular-array>Rectangular array</h3><p>Создадим двумерный массив</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span><span class=p>[,]</span> <span class=n>a</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>2</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>j</span> <span class=p>&lt;</span> <span class=m>3</span><span class=p>;</span> <span class=n>j</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>]</span> <span class=p>=</span> <span class=n>i</span> <span class=p>*</span> <span class=m>3</span> <span class=p>+</span> <span class=n>j</span><span class=p>;</span>
</span></span></code></pre></div><p>и по аналогии взглянем на дамп памяти:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=m>0x03022444</span>           <span class=m>0</span>  <span class=c1>// SyncBlockIndex</span>
</span></span><span class=line><span class=cl><span class=m>0x03022448</span>  <span class=m>0x61B5E938</span>  <span class=c1>// *MethodTable</span>
</span></span><span class=line><span class=cl><span class=m>0x0302244C</span>           <span class=m>6</span>  <span class=c1>// a.Length</span>
</span></span><span class=line><span class=cl><span class=m>0x03022450</span>           <span class=m>2</span>  <span class=c1>// a.GetLength(0)</span>
</span></span><span class=line><span class=cl><span class=m>0x03022454</span>           <span class=m>3</span>  <span class=c1>// a.GetLength(1)</span>
</span></span><span class=line><span class=cl><span class=m>0x03022458</span>           <span class=m>0</span>  <span class=c1>// a.GetLowerBound(0)</span>
</span></span><span class=line><span class=cl><span class=m>0x0302245C</span>           <span class=m>0</span>  <span class=c1>// a.GetLowerBound(1)</span>
</span></span><span class=line><span class=cl><span class=m>0x03022460</span>           <span class=m>0</span>  <span class=c1>// a[0, 0]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022464</span>           <span class=m>1</span>  <span class=c1>// a[0, 1]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022468</span>           <span class=m>2</span>  <span class=c1>// a[0, 2]</span>
</span></span><span class=line><span class=cl><span class=m>0x0302246C</span>           <span class=m>3</span>  <span class=c1>// a[1, 0]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022470</span>           <span class=m>4</span>  <span class=c1>// a[1, 1]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022474</span>           <span class=m>5</span>  <span class=c1>// a[1, 2]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>!DumpArray 0x03022448
</span></span><span class=line><span class=cl>Name:        System.Int32[,]
</span></span><span class=line><span class=cl>MethodTable: 61b5e938
</span></span><span class=line><span class=cl>EEClass:     617fd0c4
</span></span><span class=line><span class=cl>Size:        52(0x34) bytes
</span></span><span class=line><span class=cl>Array:       Rank 2, Number of elements 6, Type Int32
</span></span><span class=line><span class=cl>Element Methodtable: 61b9c480
</span></span><span class=line><span class=cl>[0][0] 03022460
</span></span><span class=line><span class=cl>[0][1] 03022464
</span></span><span class=line><span class=cl>[0][2] 03022468
</span></span><span class=line><span class=cl>[1][0] 0302246c
</span></span><span class=line><span class=cl>[1][1] 03022470
</span></span><span class=line><span class=cl>[1][2] 03022474
</span></span></code></pre></div><p>Структура немного усложнилась. Сперва (как и в первом случае), идут <code>SyncBlockIndex</code> и <code>*MethodTable</code> (<code>a</code> указывает именно на *MethodTable, т.е. на <code>0x03022448</code>). Далее точно также идёт длина массива, т.е. общее количество элементов, которые в нём содержатся. А после этого идут отличительные данные для rectangular-массива: длины по каждому измерению и нижние границы (их мы подробнее обсудим чуть позже, по умолчанию они равны нулю). Количество измерений массива (<a href=http://msdn.microsoft.com/en-us/library/system.array.rank.aspx>a.Rank</a>) можно узнать из типа (<code>System.Int32[,]</code>). Далее идут непосредственно сами элементы.</p><p>Для работы с элементами rectangular-массива на IL-уровне нет специальных команд, приходится вызывать методы <code>Get</code> и <code>Set</code>. На уровне ассемблера для двумерного массива мы будем иметь инструкцию вида <code>[ebx+ecx*4+18h]</code>. <code>ebx</code> — базовый адрес массива, <code>ecx</code> — номер элемента (который высчитывается на основе индексов i, j), <code>18h</code>
— смещение (больше, чем в <code>single</code>-версии, т.к. теперь нам нужно пропустить больше служебных значений: <code>18h=24=6*4</code> — <code>TypeHandle</code>, <code>a.Length</code>, <code>a.GetLength(0)</code>, <code>a.GetLength(1)</code>, <code>a.GetLowerBound(0)</code>, <code>a.GetLowerBound(1))</code>.</p><h3 id=jagged-array>Jagged array</h3><p>Создадим двумерный изломанный массив</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span><span class=p>[][]</span> <span class=n>a</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>2</span><span class=p>][];</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>2</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>j</span> <span class=p>&lt;</span> <span class=m>3</span><span class=p>;</span> <span class=n>j</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=p>=</span> <span class=n>i</span> <span class=p>*</span> <span class=m>3</span> <span class=p>+</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>и по аналогии взглянем на дамп памяти:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=m>0x03022478</span>           <span class=m>0</span>  <span class=c1>// SyncBlockIndex (a)</span>
</span></span><span class=line><span class=cl><span class=m>0x0302247C</span>  <span class=m>0x61B8D5BC</span>  <span class=c1>// *MethodTable (a)</span>
</span></span><span class=line><span class=cl><span class=m>0x03022480</span>           <span class=m>2</span>  <span class=c1>// a.Length</span>
</span></span><span class=line><span class=cl><span class=m>0x03022484</span>  <span class=m>0x617A4C8A</span>  <span class=c1>// *TypeDesc (int[])</span>
</span></span><span class=line><span class=cl><span class=m>0x03022488</span>  <span class=m>0x03022494</span>  <span class=c1>// a[0]</span>
</span></span><span class=line><span class=cl><span class=m>0x0302248C</span>  <span class=m>0x030224AC</span>  <span class=c1>// a[1]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022490</span>           <span class=m>0</span>  <span class=c1>// SyncBlockIndex (a[0])</span>
</span></span><span class=line><span class=cl><span class=m>0x03022494</span>  <span class=m>0x61B9C448</span>  <span class=c1>// *MethodTable (a[0])</span>
</span></span><span class=line><span class=cl><span class=m>0x03022498</span>           <span class=m>3</span>  <span class=c1>// a[0].Length</span>
</span></span><span class=line><span class=cl><span class=m>0x0302249C</span>           <span class=m>0</span>  <span class=c1>// a[0][0]</span>
</span></span><span class=line><span class=cl><span class=m>0x030224A0</span>           <span class=m>1</span>  <span class=c1>// a[0][1]</span>
</span></span><span class=line><span class=cl><span class=m>0x030224A4</span>           <span class=m>2</span>  <span class=c1>// a[0][2]</span>
</span></span><span class=line><span class=cl><span class=m>0x030224A8</span>           <span class=m>0</span>  <span class=c1>// SyncBlockIndex (a[1])</span>
</span></span><span class=line><span class=cl><span class=m>0x030224AC</span>  <span class=m>0x61B9C448</span>  <span class=c1>// *MethodTable (a[1])</span>
</span></span><span class=line><span class=cl><span class=m>0x030224B0</span>           <span class=m>3</span>  <span class=c1>// a[1].Length</span>
</span></span><span class=line><span class=cl><span class=m>0x030224B4</span>           <span class=m>3</span>  <span class=c1>// a[1][0]</span>
</span></span><span class=line><span class=cl><span class=m>0x030224B8</span>           <span class=m>4</span>  <span class=c1>// a[1][1]</span>
</span></span><span class=line><span class=cl><span class=m>0x030224BC</span>           <span class=m>5</span>  <span class=c1>// a[1][2]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>!DumpArray 0x0302247C
</span></span><span class=line><span class=cl>Name:        System.Int32[]
</span></span><span class=line><span class=cl>MethodTable: 61b8d5bc
</span></span><span class=line><span class=cl>EEClass:     618ab450
</span></span><span class=line><span class=cl>Size:        24(0x18) bytes
</span></span><span class=line><span class=cl>Array:       Rank 1, Number of elements 2, Type SZARRAY
</span></span><span class=line><span class=cl>Element Methodtable: 617a4c8a
</span></span><span class=line><span class=cl>[0] 03022494
</span></span><span class=line><span class=cl>[1] 030224ac
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>!DumpObj 0x0302247C
</span></span><span class=line><span class=cl>Name:        System.Int32[][]
</span></span><span class=line><span class=cl>MethodTable: 61b8d5bc
</span></span><span class=line><span class=cl>EEClass:     618ab450
</span></span><span class=line><span class=cl>Size:        24(0x18) bytes
</span></span><span class=line><span class=cl>Array:       Rank 1, Number of elements 2, Type SZARRAY
</span></span><span class=line><span class=cl>Fields:
</span></span><span class=line><span class=cl>None
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>!DumpArray 0x03022494
</span></span><span class=line><span class=cl>Name:        System.Int32[]
</span></span><span class=line><span class=cl>MethodTable: 61b9c448
</span></span><span class=line><span class=cl>EEClass:     6180c0d0
</span></span><span class=line><span class=cl>Size:        24(0x18) bytes
</span></span><span class=line><span class=cl>Array:       Rank 1, Number of elements 3, Type Int32
</span></span><span class=line><span class=cl>Element Methodtable: 61b9c480
</span></span><span class=line><span class=cl>[0] 0302249c
</span></span><span class=line><span class=cl>[1] 030224a0
</span></span><span class=line><span class=cl>[2] 030224a4
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>!DumpArray 0x030224AC
</span></span><span class=line><span class=cl>Name:        System.Int32[]
</span></span><span class=line><span class=cl>MethodTable: 61b9c448
</span></span><span class=line><span class=cl>EEClass:     6180c0d0
</span></span><span class=line><span class=cl>Size:        24(0x18) bytes
</span></span><span class=line><span class=cl>Array:       Rank 1, Number of elements 3, Type Int32
</span></span><span class=line><span class=cl>Element Methodtable: 61b9c480
</span></span><span class=line><span class=cl>[0] 030224b4
</span></span><span class=line><span class=cl>[1] 030224b8
</span></span><span class=line><span class=cl>[2] 030224bc
</span></span></code></pre></div><p>По сути <code>int[][]</code> представляет собой массив массивов. Т.е. это одномерный массив, элементами которого являются ссылки на другие массивы. Команда <code>DumpArray</code>
не может нормально восстановить тип объекта, для этой цели необходимо пользоваться командой <code>DumpObj</code>.</p><p>Методы по работе с jagged-массивом на IL и ASM уровнях аналогичны single-массиву с той лишь разницей, что теперь нам необходимо перейти к нужному элементу одномерного массива не один раз, а несколько (в зависимости от количества размерностей). По адресу <code>0x03022484</code> находится указатель на TypeDesc для <code>int[]</code> (<a href=http://aakinshin.blogspot.ru/2013/09/dotnet-typehandle.html>тут</a> можно почитать подробнее).</p><h3 id=non-zero-based-single-array>Non-zero based single array</h3><p>Явно объявить одномерный массив с ненулевой нижней границей нельзя, для этого нам понадобится метод <a href=http://msdn.microsoft.com/en-us/library/system.array.createinstance.aspx>Array.CreateInstance</a>, в который передаётся тип элементов, массив длин и массив нижних границ. Создадим элемент из 5-ти элементов с нижней границей 2:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=n>Array</span> <span class=n>a</span> <span class=p>=</span> <span class=n>Array</span><span class=p>.</span><span class=n>CreateInstance</span><span class=p>(</span><span class=k>typeof</span><span class=p>(</span><span class=kt>int</span><span class=p>),</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=m>5</span> <span class=p>},</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=m>2</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>2</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>7</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>.</span><span class=n>SetValue</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>);</span>
</span></span></code></pre></div><p>Взглянем на соответствующий дамп памяти:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=m>0x030224FC</span>           <span class=m>0</span>  <span class=c1>// SyncBlockIndex</span>
</span></span><span class=line><span class=cl><span class=m>0x03022500</span>  <span class=m>1639311728</span>  <span class=c1>// *MethodTable</span>
</span></span><span class=line><span class=cl><span class=m>0x03022504</span>           <span class=m>5</span>  <span class=c1>// a.Length</span>
</span></span><span class=line><span class=cl><span class=m>0x03022508</span>           <span class=m>5</span>  <span class=c1>// a.GetLength(0)</span>
</span></span><span class=line><span class=cl><span class=m>0x0302250C</span>           <span class=m>2</span>  <span class=c1>// a.GetLowerBound(0)</span>
</span></span><span class=line><span class=cl><span class=m>0x03022510</span>           <span class=m>2</span>  <span class=c1>// a[2]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022514</span>           <span class=m>3</span>  <span class=c1>// a[3]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022518</span>           <span class=m>4</span>  <span class=c1>// a[4]</span>
</span></span><span class=line><span class=cl><span class=m>0x0302251C</span>           <span class=m>5</span>  <span class=c1>// a[5]</span>
</span></span><span class=line><span class=cl><span class=m>0x03022520</span>           <span class=m>6</span>  <span class=c1>// a[6]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>!DumpArray 0x03022500
</span></span><span class=line><span class=cl>Name:        System.Int32[]
</span></span><span class=line><span class=cl>MethodTable: 61b5e970
</span></span><span class=line><span class=cl>EEClass:     617fd110
</span></span><span class=line><span class=cl>Size:        40(0x28) bytes
</span></span><span class=line><span class=cl>Array:       Rank 1, Number of elements 5, Type Int32
</span></span><span class=line><span class=cl>Element Methodtable: 61b9c480
</span></span><span class=line><span class=cl>[0] 03022508
</span></span><span class=line><span class=cl>[1] 0302250c
</span></span><span class=line><span class=cl>[2] 03022510
</span></span><span class=line><span class=cl>[3] 03022514
</span></span><span class=line><span class=cl>[4] 03022518
</span></span><span class=line><span class=cl>[5] 0302251c
</span></span><span class=line><span class=cl>[6] 03022520
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>!DumpObj 0x03022500
</span></span><span class=line><span class=cl>Name:        System.Int32[*]
</span></span><span class=line><span class=cl>MethodTable: 61b5e970
</span></span><span class=line><span class=cl>EEClass:     617fd110
</span></span><span class=line><span class=cl>Size:        40(0x28) bytes
</span></span><span class=line><span class=cl>Array:       Rank 1, Number of elements 5, Type Int32
</span></span><span class=line><span class=cl>Fields:
</span></span><span class=line><span class=cl>None
</span></span></code></pre></div><p>Тип данного объекта: <code>System.Int32[*]</code>. Знак <code>*</code> означает, что CLR знает о ненулевой нижней границе. Синтаксис C# не позволяет явно объявить переменную такого типа, также запрещается явное обращение к его элементам посредствам стандартного синтаксиса, поэтому приходится пользоваться методами <a href=http://msdn.microsoft.com/en-us/library/system.array.getvalue.aspx>GetValue</a> и <a href=http://msdn.microsoft.com/en-us/library/system.array.setvalue.aspx>SetValue</a>.</p><p>Обратите внимание, что команда <code>DumpArray</code> не умеет корректно отображать тип одномерного массива с ненулевой нижней границей. Правильный тип можно получить, используя команду <code>DumpObj</code>.</p><p>Что касается структуры массива в памяти, то она полностью аналогична структуре rectangular-массива. Для доступа к элементам массива специальных IL-команд не предусмотрено, приходится вновь явно вызывать методы.</p><h3 id=non-zero-based-rectangular-array>Non-zero based rectangular array</h3><p>А теперь создадим двумерный массив 2 на 3 с нижними границами 4 и 5. Поможет нам в этом уже знакомый метод <code>Array.CreateInstance</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=n>Array</span> <span class=n>a</span> <span class=p>=</span> <span class=n>Array</span><span class=p>.</span><span class=n>CreateInstance</span><span class=p>(</span><span class=k>typeof</span><span class=p>(</span><span class=kt>int</span><span class=p>),</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span> <span class=p>},</span> <span class=k>new</span><span class=p>[]</span> <span class=p>{</span> <span class=m>4</span><span class=p>,</span> <span class=m>5</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>4</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>6</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=p>=</span> <span class=m>5</span><span class=p>;</span> <span class=n>j</span> <span class=p>&lt;</span> <span class=m>8</span><span class=p>;</span> <span class=n>j</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=p>.</span><span class=n>SetValue</span><span class=p>(</span><span class=n>i</span> <span class=p>*</span> <span class=m>3</span> <span class=p>+</span> <span class=n>j</span> <span class=p>-</span> <span class=m>17</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span></code></pre></div><p>Дамп памяти:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=m>0x03022588</span>           <span class=m>0</span>  <span class=c1>// SyncBlockIndex</span>
</span></span><span class=line><span class=cl><span class=m>0x0302258C</span>  <span class=m>1639311672</span>  <span class=c1>// *MethodTable</span>
</span></span><span class=line><span class=cl><span class=m>0x03022590</span>           <span class=m>6</span>  <span class=c1>// a.Length</span>
</span></span><span class=line><span class=cl><span class=m>0x03022594</span>           <span class=m>2</span>  <span class=c1>// a.GetLength(0)</span>
</span></span><span class=line><span class=cl><span class=m>0x03022598</span>           <span class=m>3</span>  <span class=c1>// a.GetLength(1)</span>
</span></span><span class=line><span class=cl><span class=m>0x0302259C</span>           <span class=m>4</span>  <span class=c1>// a.GetLowerBound(0)</span>
</span></span><span class=line><span class=cl><span class=m>0x030225A0</span>           <span class=m>5</span>  <span class=c1>// a.GetLowerBound(1)</span>
</span></span><span class=line><span class=cl><span class=m>0x030225A4</span>           <span class=m>0</span>  <span class=c1>// a[4, 5]</span>
</span></span><span class=line><span class=cl><span class=m>0x030225A8</span>           <span class=m>1</span>  <span class=c1>// a[4, 6]</span>
</span></span><span class=line><span class=cl><span class=m>0x030225AC</span>           <span class=m>2</span>  <span class=c1>// a[4, 7]</span>
</span></span><span class=line><span class=cl><span class=m>0x030225B0</span>           <span class=m>3</span>  <span class=c1>// a[5, 5]</span>
</span></span><span class=line><span class=cl><span class=m>0x030225B4</span>           <span class=m>4</span>  <span class=c1>// a[5, 6]</span>
</span></span><span class=line><span class=cl><span class=m>0x030225B8</span>           <span class=m>5</span>  <span class=c1>// a[5, 7]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>!DumpArray 0x0302258C
</span></span><span class=line><span class=cl>Name:        System.Int32[,]
</span></span><span class=line><span class=cl>MethodTable: 61b5e938
</span></span><span class=line><span class=cl>EEClass:     617fd0c4
</span></span><span class=line><span class=cl>Size:        52(0x34) bytes
</span></span><span class=line><span class=cl>Array:       Rank 2, Number of elements 6, Type Int32
</span></span><span class=line><span class=cl>Element Methodtable: 61b9c480
</span></span><span class=line><span class=cl>[4][5] 030225a4
</span></span><span class=line><span class=cl>[4][6] 030225a8
</span></span><span class=line><span class=cl>[4][7] 030225ac
</span></span><span class=line><span class=cl>[5][5] 030225b0
</span></span><span class=line><span class=cl>[5][6] 030225b4
</span></span><span class=line><span class=cl>[5][7] 030225b8
</span></span></code></pre></div><p>Заметим, что для rectangular-массивов с ненулевой нижней границей команда <code>DumpArray</code> прекрасно работает. Несложно понять, что структура хранения и организации rectangular-массива не зависит от нижней границы: представление в памяти всегда будет одинаковое, тип всегда будет <code>System.Int32[,]</code>, IL и ASM инструкции будут аналогичны.</p><h3 id=выводы>Выводы</h3><p>Общее устройство массива выглядит следующим образом:</p><ul><li><code>SyncBlockIndex</code> (по отрицательному смещению)</li><li><code>*MethodTable</code> (по нулевому смещению)</li><li>Общая длина массива</li><li><code>*TypeDesc</code> для элементов массива (только для массивов из элементов ссылочного типа; <code>int[][]</code> является частным случаем, т.к. это массив из <code>int[]</code>)</li><li>Длины по каждому измерению массива (только для одномерных массивов с заданной нижней границей и многомерных массивов)</li><li>Нижние индексы по каждому измерению массива (только для одномерных массивов с заданной нижней границей и многомерных массивов)</li><li>Элементы массива</li></ul></div></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}));function toggleTheme(e){e?(document.documentElement.classList.add("dark"),themeToggleLightIcon.classList.remove("hidden"),themeToggleDarkIcon.classList.add("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")}),imagesLight.forEach(e=>{e.classList.add("hidden")})):(document.documentElement.classList.remove("dark"),themeToggleDarkIcon.classList.remove("hidden"),themeToggleLightIcon.classList.add("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}),imagesDark.forEach(e=>{e.classList.add("hidden")}))}themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),event.altKey?(localStorage.removeItem("color-theme"),toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches)):localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{if(localStorage.getItem("color-theme")===null){const t=e.matches?"dark":"light";toggleTheme(t==="dark")}})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2024 <span class=whitespace-nowrap>Андрей Акиньшин</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/ru/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"],ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+=" has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></body></html>