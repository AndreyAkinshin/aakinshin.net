<!doctype html><html lang=ru class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Андрей Акиньшин"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content=".NET,Endianness,ASM,Mono,C#"><title>Endianness в .NET | Андрей Акиньшин</title><meta name=description content="Рассмотрим простую задачку: что выведет следующий код?
[StructLayout(LayoutKind.Explicit)] struct UInt16Wrapper { [FieldOffset(0)] public UInt16 Value; [Fi..."><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.882998740b9c4c24677576b997bde5a487246e2e3bd72128a0e922eaa59db029.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.e78467baec0179d7ccd2ef995e0c94f25b4a63a3191a93c3547e22bdf590ef5d.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.fe41ce51781393cea2f6a8fd3567674242dd6203d0a0b62f852fb257e992a236.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/ru/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41419012-5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41419012-5');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/ru/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-posts href=https://aakinshin.net/ru/posts/>Посты</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/ru/about/>Об авторе</a></li><li class=nav-item><a class=nav-link id=nav-link-pdnb href=https://aakinshin.net/ru/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class=blog-post><h1 class=blog-post-title id=post-title>Endianness в .NET</h1><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2014-10-29>29 октября 2014</time>
&nbsp;&nbsp;
<i class="fas fa-tag"></i>&nbsp;
<a href=https://aakinshin.net/ru/tags/dotnet/ class="badge badge-info">.NET</a>
<a href=https://aakinshin.net/ru/tags/endianness/ class="badge badge-info">Endianness</a>
<a href=https://aakinshin.net/ru/tags/asm/ class="badge badge-info">ASM</a>
<a href=https://aakinshin.net/ru/tags/mono/ class="badge badge-info">Mono</a>
<a href=https://aakinshin.net/ru/tags/cs/ class="badge badge-info">C#</a></span><br><br><table class=table-ok><tr><td valign=top><div class=separator style=clear:both;text-align:center><img src=/img/posts/dotnet/endianness/front.png alt="Endian funny image" style="margin:0 2em 1em 0"></div></td><td valign=top><p>Рассмотрим простую задачку: что выведет следующий код?</p><pre class="prettyprint lang-cs">
[StructLayout(LayoutKind.Explicit)]
struct UInt16Wrapper
{
  [FieldOffset(0)]
  public UInt16 Value;
  [FieldOffset(0)]
  public Byte Byte1;
  [FieldOffset(1)]
  public Byte Byte2;
}
void Main()
{
  var uint16 = new UInt16Wrapper();
  uint16.Value = 1 + 2 * 256;
  Console.WriteLine(uint16.Byte1);
  Console.WriteLine(uint16.Byte2);
}
</pre></td></tr></table><p>Полагаю, что внимательный читатель должен обратить внимание на название поста и дать правильный ответ: «зависит». Сегодня мы немного поговорим о том, как в .NET обстоят дела с порядком байтов.</p><h3 id=небольшой-обзор>Небольшой обзор</h3><p>Про то, что такое endianness и зачем он нужен, я писать не буду — на эту тему и так хватает материала (<a href=http://en.wikipedia.org/wiki/Endianness>Endianness</a>), <a href=http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures#Endianness>Comparison of instruction set architectures</a>, <a href=http://habrahabr.ru/post/233245/>Разбираемся с прямым и обратным порядком байтов</a>). Ответ на задачку можно легко найти в <a href=http://www.ecma-international.org/publications/standards/Ecma-335.htm>ECMA-335</a>, «I.12.6.3 Byte ordering»:</p><blockquote><p>For data types larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms. The PE file format (see §I.12.2) allows the file to be marked to indicate that it depends on a particular type ordering.</p></blockquote><p>Ну, казалось бы, всё просто: зависит от конкретной архитектуры. Только вот архитектур у нас много. Например, Mono <a href=http://www.mono-project.com/docs/about-mono/supported-platforms/>поддерживает</a> в числе прочего <a href=http://en.wikipedia.org/wiki/X86>x86</a>, <a href=http://en.wikipedia.org/wiki/X86-64>x64</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Little-endian>Little-endian</a>); <a href=http://en.wikipedia.org/wiki/IBM_ESA/390>s390</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Big-endian>Big-endian</a>); <a href=http://en.wikipedia.org/wiki/PowerPC>PowerPC</a>, <a href=http://en.wikipedia.org/wiki/SPARC>SPARC</a>, <a href=http://en.wikipedia.org/wiki/ARM_architecture>ARM</a>, <a href=http://en.wikipedia.org/wiki/Itanium>IA64</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Bi-endian_hardware>Bi-endian</a>, т.е. есть возможность переключаться между Little/Big-endian). Общая мораль такова: лучше не закладываться на какой-то конкретный порядок байт. Конечно, скорее всего вы пишете под x86 или x64 и можете представлять себе всю память как Little-endian, но нужно держать в уме, что это может быть и не так (особенно актуально в свете распространённости ARM для мобильных устройств).</p><h3 id=погружаемся-внутрь>Погружаемся внутрь</h3><p>Данный раздел предназначен для тех, кто любит залезать внутрь своих программ. Если вы не из таких, то можете просто перейти к следующему разделу. А с теми, кому всё-таки интересно, вернёмся к рассмотрению нашего примера и взглянем на IL-код метода Main:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>.class nested private explicit ansi sealed beforefieldinit UInt16Wrapper
  extends [mscorlib]System.ValueType
{
  // Fields
  .field [0] public uint16 Value
  .field [0] public uint8 Byte1
  .field [1] public uint8 Byte2
} // end of class UInt16Wrapper

.method private hidebysig 
  instance void Run () cil managed 
{
  // Method begins at RVA 0x205c
  // Code size 45 (0x2d)
  .maxstack 2
  .locals init (
    [0] valuetype Program/UInt16Wrapper uint16
  )

  IL_0000: ldloca.s uint16
  IL_0002: initobj Program/UInt16Wrapper
  IL_0008: ldloca.s uint16
  IL_000a: ldc.i4 513
  IL_000f: stfld uint16 Program/UInt16Wrapper::Value
  IL_0014: ldloca.s uint16
  IL_0016: ldfld uint8 Program/UInt16Wrapper::Byte1
  IL_001b: call void [mscorlib]System.Console::WriteLine(int32)
  IL_0020: ldloca.s uint16
  IL_0022: ldfld uint8 Program/UInt16Wrapper::Byte2
  IL_0027: call void [mscorlib]System.Console::WriteLine(int32)
  IL_002c: ret
} // end of method Program::Run
</code></pre></div><p>Тут всё достаточно просто: в нашей структуре имеется три поля: одно двухбайтовое (<code>uint16</code>) и два однобайтовых (<code>uint8</code>). Двухбайтовое поле <code>Value</code> имеет смещение 0 байт. Первое однобайтовое поле <code>Byte1</code> также имеет смещение 0 байт, т.е. указывает в точности туда же, куда и <code>Value</code> (другими словами, на байт <code>Value</code> с младшим адресом). Второе однобайтовое поле <code>Byte2</code> имеет смещение 1 байт, т.е. указывает на байт <code>Value</code> со старшим адресом. В примере значение <code>Value</code> равно <code>1+2*256</code>. На моём компьютере архитектура x64, что означает Little-endian. Для простоты примера соберём программу под x86 (с точно таким же Little-endian) А значит в <code>Byte1</code> будет хранится <code>1</code>, а в <code>Byte2</code> — <code>2</code>. На консоли мы увидим:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>1
2
</code></pre></div><p>Ради интереса взглянем на asm-код. Под Windows получим следующее:</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm>        <span class=err>{</span>
            <span class=nf>var</span> <span class=no>uint16</span> <span class=err>=</span> <span class=no>new</span> <span class=no>UInt16Wrapper</span><span class=p>()</span><span class=c>;
</span><span class=c></span><span class=mi>00</span><span class=no>DE29A1</span>  <span class=no>mov</span>         <span class=no>ebp</span><span class=p>,</span><span class=no>esp</span>  
<span class=mi>00</span><span class=no>DE29A3</span>  <span class=no>sub</span>         <span class=no>esp</span><span class=p>,</span><span class=mi>8</span>  
<span class=mi>00</span><span class=no>DE29A6</span>  <span class=no>xor</span>         <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>  
<span class=mi>00</span><span class=no>DE29A8</span>  <span class=no>mov</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>],</span><span class=no>eax</span>  
<span class=mi>00</span><span class=no>DE29AB</span>  <span class=no>mov</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-4</span><span class=p>],</span><span class=no>ecx</span>  
<span class=mi>00</span><span class=no>DE29AE</span>  <span class=no>cmp</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=no>ds</span><span class=p>:[</span><span class=mi>4</span><span class=no>B51058h</span><span class=p>],</span><span class=mi>0</span>  
<span class=mi>00</span><span class=no>DE29B5</span>  <span class=no>je</span>          <span class=mi>00</span><span class=no>DE29BC</span>  
<span class=mi>00</span><span class=no>DE29B7</span>  <span class=no>call</span>        <span class=mi>73</span><span class=no>DFC310</span>  
<span class=mi>00</span><span class=no>DE29BC</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>ebp-8</span><span class=p>]</span>  
<span class=mi>00</span><span class=no>DE29BF</span>  <span class=no>mov</span>         <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=p>],</span><span class=mi>0</span>  
            <span class=no>uint16.Value</span> <span class=err>=</span> <span class=mi>1</span> <span class=err>+</span> <span class=mi>2</span> <span class=p>*</span> <span class=mi>256</span><span class=c>;
</span><span class=c></span><span class=mi>00</span><span class=no>DE29C4</span>  <span class=no>mov</span>         <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>],</span><span class=mi>201</span><span class=no>h</span>  
            <span class=no>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte1</span><span class=p>)</span><span class=c>;
</span><span class=c></span><span class=mi>00</span><span class=no>DE29CA</span>  <span class=no>movzx</span>       <span class=no>ecx</span><span class=p>,</span><span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>]</span>  
<span class=mi>00</span><span class=no>DE29CE</span>  <span class=no>call</span>        <span class=mi>7325</span><span class=no>A920</span>  
            <span class=no>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte2</span><span class=p>)</span><span class=c>;
</span><span class=c></span><span class=mi>00</span><span class=no>DE29D3</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>ebp-8</span><span class=p>]</span>  
<span class=mi>00</span><span class=no>DE29D6</span>  <span class=no>movzx</span>       <span class=no>ecx</span><span class=p>,</span><span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=err>+</span><span class=mi>1</span><span class=p>]</span>  
<span class=mi>00</span><span class=no>DE29DA</span>  <span class=no>call</span>        <span class=mi>7325</span><span class=no>A920</span>  
        <span class=err>}</span>
<span class=err>00</span><span class=nf>DE29DF</span>  <span class=no>nop</span>  
<span class=mi>00</span><span class=no>DE29E0</span>  <span class=no>mov</span>         <span class=no>esp</span><span class=p>,</span><span class=no>ebp</span>  
<span class=mi>00</span><span class=no>DE29E2</span>  <span class=no>pop</span>         <span class=no>ebp</span>  
<span class=mi>00</span><span class=no>DE29E3</span>  <span class=no>ret</span>  
</code></pre></div><p>Значение нашего поля в шестнадцатеричном представлении имеет вид <code>201h</code>, а найти его мы можем по адресу <code>byte ptr [ebp-8]</code>. В первом случае (<code>00DE29CA</code>) мы просто загружаем значение по данному адресу в <code>ecx</code>, а во втором (<code>00DE29D3</code>) — сначала загружаем адрес в <code>eax</code>, а затем получаем значение из <code>byte ptr [eax+1]</code>. Для полноты эксперимента глянем также код под Linux. Я взял Ubuntu 14.04 и собрал следующую версию mono:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>$ mono --version
Mono JIT compiler version 3.10.0
        TLS:           __thread
        SIGSEGV:       altstack
        Notifications: epoll
        Architecture:  amd64
        Disabled:      none
        Misc:          softdebug 
        LLVM:          supported, not enabled.
        GC:            sgen
</code></pre></div><p>Имеем код (x64-версия):</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=nl>gram_Main:</span>
<span class=err>//{</span>
   <span class=err>0:</span>   <span class=err>48</span> <span class=err>83</span> <span class=nf>ec</span> <span class=mi>08</span>             <span class=no>sub</span>    <span class=no>$0x8</span><span class=p>,</span><span class=nv>%rsp</span>
<span class=err>//</span> <span class=nf>var</span> <span class=no>int16</span> <span class=err>=</span> <span class=no>new</span> <span class=no>Int16Wrapper</span><span class=p>()</span><span class=c>;
</span><span class=c></span>   <span class=mi>4</span><span class=p>:</span>   <span class=mi>66</span> <span class=no>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>00</span> <span class=mi>00</span>       <span class=no>movw</span>   <span class=no>$0x0</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
   <span class=nl>a:</span>   <span class=err>66</span> <span class=nf>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>00</span> <span class=mi>00</span>       <span class=no>movw</span>   <span class=no>$0x0</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
<span class=err>//</span> <span class=nf>int16.Value</span> <span class=err>=</span> <span class=mi>1</span> <span class=err>+</span> <span class=mi>2</span> <span class=p>*</span> <span class=mi>256</span><span class=c>;
</span><span class=c></span>  <span class=mi>10</span><span class=p>:</span>   <span class=mi>66</span> <span class=no>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>01</span> <span class=mi>02</span>       <span class=no>movw</span>   <span class=no>$0x201</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
<span class=err>//</span> <span class=nf>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte1</span><span class=p>)</span><span class=c>;
</span><span class=c></span>  <span class=mi>16</span><span class=p>:</span>   <span class=mi>0</span><span class=no>f</span> <span class=no>b6</span> <span class=mi>3</span><span class=no>c</span> <span class=mi>24</span>             <span class=no>movzbl</span> <span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%edi</span>
  <span class=err>1</span><span class=nl>a:</span>   <span class=err>49</span> <span class=nf>bb</span> <span class=mi>7</span><span class=no>e</span> <span class=no>dc</span> <span class=mi>0</span><span class=no>f</span> <span class=mi>40</span> <span class=mi>00</span>    <span class=no>movabs</span> <span class=no>$0x400fdc7e</span><span class=p>,</span><span class=nv>%r11</span>
  <span class=err>21:</span>   <span class=err>00</span> <span class=err>00</span> <span class=err>00</span> 
  <span class=err>24:</span>   <span class=err>41</span> <span class=nf>ff</span> <span class=no>d3</span>                <span class=no>callq</span>  <span class=p>*</span><span class=nv>%r11</span>
<span class=err>//</span> <span class=nf>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte2</span><span class=p>)</span><span class=c>;
</span><span class=c></span>  <span class=mi>27</span><span class=p>:</span>   <span class=mi>0</span><span class=no>f</span> <span class=no>b6</span> <span class=mi>7</span><span class=no>c</span> <span class=mi>24</span> <span class=mi>01</span>          <span class=no>movzbl</span> <span class=mi>0x1</span><span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%edi</span>
  <span class=err>2</span><span class=nl>c:</span>   <span class=err>49</span> <span class=nf>bb</span> <span class=mi>7</span><span class=no>e</span> <span class=no>dc</span> <span class=mi>0</span><span class=no>f</span> <span class=mi>40</span> <span class=mi>00</span>    <span class=no>movabs</span> <span class=no>$0x400fdc7e</span><span class=p>,</span><span class=nv>%r11</span>
  <span class=err>33:</span>   <span class=err>00</span> <span class=err>00</span> <span class=err>00</span> 
  <span class=err>36:</span>   <span class=err>41</span> <span class=nf>ff</span> <span class=no>d3</span>                <span class=no>callq</span>  <span class=p>*</span><span class=nv>%r11</span>
<span class=err>//</span> <span class=err>}</span>
  <span class=err>39:</span>   <span class=err>48</span> <span class=err>83</span> <span class=nf>c4</span> <span class=mi>08</span>             <span class=no>add</span>    <span class=no>$0x8</span><span class=p>,</span><span class=nv>%rsp</span>
  <span class=err>3</span><span class=nl>d:</span>   <span class=nf>c3</span>                      <span class=no>retq</span> 
</code></pre></div><p>Логика аналогична: по адресу <code>(%rsp)</code> загружаем целевое значение <code>$0x201</code>. Получаем <code>Byte1</code> по адресу <code>(%rsp)</code> и <code>Byte2</code> по адресу <code>0x1(%rsp)</code>.</p><h3 id=а-как-узнать-порядок-байт>А как узнать порядок байт?</h3><p>Если для вас критично то, в каком порядке байты идут в памяти, то неплохо было бы научиться узнавать: с какой архитектурой процессора мы имеем дело. Рассмотрим пару способов.</p><p><strong>Простой способ.</strong> Благо, разработчики .NET позаботились о программистах и сделали специальное поле <a href=http://msdn.microsoft.com/library/system.bitconverter.islittleendian.aspx>BitConverter.IsLittleEndian</a>. Пользоваться им очень просто:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>IsLittleEndian</span> <span class=p>?</span> <span class=s>&#34;LittleEndian&#34;</span> <span class=p>:</span> <span class=s>&#34;BigEndian&#34;</span><span class=p>);</span>
</code></pre></div><p>Класс <a href=http://msdn.microsoft.com/en-us/library/system.bitconverter.aspx>BitConverter</a> удобно использовать для работы с отдельными байтами «большой» переменной. И этот способ намного предпочтительней, чем ручная работа с байтами. Вот хороший фрагмент из примера в официальной документации:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=kt>int</span> <span class=k>value</span> <span class=p>=</span> <span class=m>12345678</span><span class=p>;</span>
<span class=kt>byte</span><span class=p>[]</span> <span class=n>bytes</span> <span class=p>=</span> <span class=n>BitConverter</span><span class=p>.</span><span class=n>GetBytes</span><span class=p>(</span><span class=k>value</span><span class=p>);</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=n>bytes</span><span class=p>));</span>
<span class=k>if</span> <span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>IsLittleEndian</span><span class=p>)</span>
   <span class=n>Array</span><span class=p>.</span><span class=n>Reverse</span><span class=p>(</span><span class=n>bytes</span><span class=p>);</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=n>bytes</span><span class=p>));</span>
<span class=c1>// The example displays the following output on a little-endian system: 
</span><span class=c1>//       4E-61-BC-00
</span><span class=c1>//       00-BC-61-4E
</span></code></pre></div><p><strong>Способ для тех, кто лёгких способов не ищет.</strong> Следующий пример приведён сугубо в академических целях, в реальных проектах так писать не стоит. Допустим, мы не доверяем значению <code>BitConverter.IsLittleEndian</code> и хотим сами проверить порядок байт, в котором хранятся наши переменные. Нам в этом поможет <code>unsafe</code>-code. Просто создадим уже знакомое нам значение <code>0x201</code>, получим его адрес и возьмём байт по этому адресу. Получится следующий код:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>public</span> <span class=kt>bool</span> <span class=n>IsLittleEndian</span><span class=p>()</span>
<span class=p>{</span>
  <span class=n>UInt16</span> <span class=k>value</span> <span class=p>=</span> <span class=m>0</span><span class=n>x201</span><span class=p>;</span>
  <span class=k>unsafe</span>
  <span class=p>{</span>
    <span class=n>UInt16</span><span class=p>*</span> <span class=n>valueAddress</span> <span class=p>=</span> <span class=p>&amp;</span><span class=k>value</span><span class=p>;</span>
    <span class=n>Byte</span><span class=p>*</span> <span class=n>firstByteAddress</span> <span class=p>=</span> <span class=p>(</span><span class=n>Byte</span><span class=p>*)</span><span class=n>valueAddress</span><span class=p>;</span>
    <span class=n>Byte</span> <span class=n>firstByte</span> <span class=p>=</span> <span class=p>*</span><span class=n>firstByteAddress</span><span class=p>;</span>
    <span class=k>return</span> <span class=n>firstByte</span> <span class=p>==</span> <span class=m>1</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h3 id=binaryreaderbinarywriter>BinaryReader/BinaryWriter</h3><p>Ок, с хранением чисел в памяти разобрались. А что, если нам нужно читать/писать числа в бинарном виде? .NET предлагает нам для этого классы <a href=https://msdn.microsoft.com/library/system.io.binaryreader.aspx>BinaryReader</a> и <a href=http://msdn.microsoft.com/library/system.io.binarywriter.aspx>BinaryWriter</a>. Но тут нужно быть аккуратным и помнить, что согласно документации эти классы <em>всегда</em> работают с данными в Little-endian формате. Если по какой-то причине вы хотите поработать с данными в формате с заданным порядком байт, то придётся либо ручками реверсировать каждое число для Big-endian, либо использовать какую-нибудь внешнюю библиотеку (например, класс EndianBitConverter из <a href=http://www.yoda.arachsys.com/csharp/miscutil/>MiscUtil</a> от Джона Скита).</p><h3 id=выводы>Выводы</h3><p>Всегда нужно помнить, что в разных местах для хранения чисел может использоваться разный порядок байт. А если вам доводится работать с памятью в бинарном виде, хранить числа в бинарном виде, передавать их по сети в бинарном виде или ещё что-нибудь делать с числами в бинарном виде, то к нюансу с порядком байт следует отнестись очень внимательно.</p><br><br><div class=row><div class="mx-auto share-block"><div class=share-title>Поделиться:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f&title=Endianness%20%d0%b2%20.NET" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=Endianness%20%d0%b2%20.NET&url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x"></i></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=share-button><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=share-button><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f&title=Endianness%20%d0%b2%20.NET" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2020 Андрей Акиньшин
|
<a href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a><a href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a><a href=https://aakinshin.net/ru/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.082780cb948cc57eabbc0d80172a7a5347d5572b599938b4c9876dfd7978b424.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script></body></html>