<!doctype html><html lang=ru><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.123.3"><meta name=author content='Андрей Акиньшин'><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content='.NET,Endianness,ASM,Mono,C#'><title>Endianness в .NET | Андрей Акиньшин</title>
<meta name=description content="Рассмотрим простую задачку: что выведет следующий код?
[StructLayout(LayoutKind.Explicit)] struct UInt16Wrapper { [FieldOffset(0)] public UInt16 Value; [FieldOffset(0)] public Byte Byte1; [FieldOffset(1)] public Byte Byte2; } void Main() { var uint16 = new ..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.507552e362c73186c7b6d8d093247a479099e01f527bcc3432990c78c2e426d8.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/ru/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-2 xs:px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/ru/about/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/ru/posts/>Посты</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/ru/about/>Об авторе</a></div></div><button id=theme-toggle type=button title="Alt+Click to match OS color theme" class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><div class=main-post><h1 class=blog-post-title id=post-title>Endianness В .NET</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai text-accent-l dark:text-front-d"><title>Date</title><use xlink:href="/img/fa/all.svg#calendar-days"/></svg>
<time datetime=2014-10-29>29 октября 2014</time><svg class="fai ml-3 text-accent-l dark:text-front-d"><title>Tags</title><use xlink:href="/img/fa/all.svg#tag"/></svg><div class="flex flex-wrap gap-y-1"><a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/endianness/>Endianness</a>
<a class=label-link href=https://aakinshin.net/ru/tags/asm/>ASM</a>
<a class=label-link href=https://aakinshin.net/ru/tags/mono/>Mono</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#</a></div></div><br><div class=main-content><table class=table-ok><tr><td valign=top><div class=separator style=clear:both;text-align:center><img src=/img/posts/dotnet/endianness/front.png alt="Endian funny image" style="margin:0 2em 1em 0"></div></td><td valign=top><p>Рассмотрим простую задачку: что выведет следующий код?</p><pre class="prettyprint lang-cs">
[StructLayout(LayoutKind.Explicit)]
struct UInt16Wrapper
{
  [FieldOffset(0)]
  public UInt16 Value;
  [FieldOffset(0)]
  public Byte Byte1;
  [FieldOffset(1)]
  public Byte Byte2;
}
void Main()
{
  var uint16 = new UInt16Wrapper();
  uint16.Value = 1 + 2 * 256;
  Console.WriteLine(uint16.Byte1);
  Console.WriteLine(uint16.Byte2);
}
</pre></td></tr></table><p>Полагаю, что внимательный читатель должен обратить внимание на название поста и дать правильный ответ: «зависит». Сегодня мы немного поговорим о том, как в .NET обстоят дела с порядком байтов.</p><h3 id=небольшой-обзор>Небольшой обзор</h3><p>Про то, что такое endianness и зачем он нужен, я писать не буду — на эту тему и так хватает материала (<a href=http://en.wikipedia.org/wiki/Endianness>Endianness</a>), <a href=http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures#Endianness>Comparison of instruction set architectures</a>, <a href=http://habrahabr.ru/post/233245/>Разбираемся с прямым и обратным порядком байтов</a>). Ответ на задачку можно легко найти в <a href=http://www.ecma-international.org/publications/standards/Ecma-335.htm>ECMA-335</a>, «I.12.6.3 Byte ordering»:</p><blockquote><p>For data types larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms. The PE file format (see §I.12.2) allows the file to be marked to indicate that it depends on a particular type ordering.</p></blockquote><p>Ну, казалось бы, всё просто: зависит от конкретной архитектуры. Только вот архитектур у нас много. Например, Mono <a href=http://www.mono-project.com/docs/about-mono/supported-platforms/>поддерживает</a> в числе прочего <a href=http://en.wikipedia.org/wiki/X86>x86</a>, <a href=http://en.wikipedia.org/wiki/X86-64>x64</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Little-endian>Little-endian</a>); <a href=http://en.wikipedia.org/wiki/IBM_ESA/390>s390</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Big-endian>Big-endian</a>); <a href=http://en.wikipedia.org/wiki/PowerPC>PowerPC</a>, <a href=http://en.wikipedia.org/wiki/SPARC>SPARC</a>, <a href=http://en.wikipedia.org/wiki/ARM_architecture>ARM</a>, <a href=http://en.wikipedia.org/wiki/Itanium>IA64</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Bi-endian_hardware>Bi-endian</a>, т.е. есть возможность переключаться между Little/Big-endian). Общая мораль такова: лучше не закладываться на какой-то конкретный порядок байт. Конечно, скорее всего вы пишете под x86 или x64 и можете представлять себе всю память как Little-endian, но нужно держать в уме, что это может быть и не так (особенно актуально в свете распространённости ARM для мобильных устройств).</p><h3 id=погружаемся-внутрь>Погружаемся внутрь</h3><p>Данный раздел предназначен для тех, кто любит залезать внутрь своих программ. Если вы не из таких, то можете просто перейти к следующему разделу. А с теми, кому всё-таки интересно, вернёмся к рассмотрению нашего примера и взглянем на IL-код метода Main:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>.class nested private explicit ansi sealed beforefieldinit UInt16Wrapper
</span></span><span class=line><span class=cl>  extends [mscorlib]System.ValueType
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  // Fields
</span></span><span class=line><span class=cl>  .field [0] public uint16 Value
</span></span><span class=line><span class=cl>  .field [0] public uint8 Byte1
</span></span><span class=line><span class=cl>  .field [1] public uint8 Byte2
</span></span><span class=line><span class=cl>} // end of class UInt16Wrapper
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.method private hidebysig 
</span></span><span class=line><span class=cl>  instance void Run () cil managed 
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  // Method begins at RVA 0x205c
</span></span><span class=line><span class=cl>  // Code size 45 (0x2d)
</span></span><span class=line><span class=cl>  .maxstack 2
</span></span><span class=line><span class=cl>  .locals init (
</span></span><span class=line><span class=cl>    [0] valuetype Program/UInt16Wrapper uint16
</span></span><span class=line><span class=cl>  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  IL_0000: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_0002: initobj Program/UInt16Wrapper
</span></span><span class=line><span class=cl>  IL_0008: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_000a: ldc.i4 513
</span></span><span class=line><span class=cl>  IL_000f: stfld uint16 Program/UInt16Wrapper::Value
</span></span><span class=line><span class=cl>  IL_0014: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_0016: ldfld uint8 Program/UInt16Wrapper::Byte1
</span></span><span class=line><span class=cl>  IL_001b: call void [mscorlib]System.Console::WriteLine(int32)
</span></span><span class=line><span class=cl>  IL_0020: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_0022: ldfld uint8 Program/UInt16Wrapper::Byte2
</span></span><span class=line><span class=cl>  IL_0027: call void [mscorlib]System.Console::WriteLine(int32)
</span></span><span class=line><span class=cl>  IL_002c: ret
</span></span><span class=line><span class=cl>} // end of method Program::Run
</span></span></code></pre></div><p>Тут всё достаточно просто: в нашей структуре имеется три поля: одно двухбайтовое (<code>uint16</code>) и два однобайтовых (<code>uint8</code>). Двухбайтовое поле <code>Value</code> имеет смещение 0 байт. Первое однобайтовое поле <code>Byte1</code> также имеет смещение 0 байт, т.е. указывает в точности туда же, куда и <code>Value</code> (другими словами, на байт <code>Value</code> с младшим адресом). Второе однобайтовое поле <code>Byte2</code> имеет смещение 1 байт, т.е. указывает на байт <code>Value</code> со старшим адресом. В примере значение <code>Value</code> равно <code>1+2*256</code>. На моём компьютере архитектура x64, что означает Little-endian. Для простоты примера соберём программу под x86 (с точно таким же Little-endian) А значит в <code>Byte1</code> будет хранится <code>1</code>, а в <code>Byte2</code> — <code>2</code>. На консоли мы увидим:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>1
</span></span><span class=line><span class=cl>2
</span></span></code></pre></div><p>Ради интереса взглянем на asm-код. Под Windows получим следующее:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>        <span class=err>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>var</span> <span class=no>uint16</span> <span class=err>=</span> <span class=no>new</span> <span class=no>UInt16Wrapper</span><span class=p>()</span><span class=c1>;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>DE29A1</span>  <span class=no>mov</span>         <span class=no>ebp</span><span class=p>,</span><span class=no>esp</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29A3</span>  <span class=no>sub</span>         <span class=no>esp</span><span class=p>,</span><span class=mi>8</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29A6</span>  <span class=no>xor</span>         <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29A8</span>  <span class=no>mov</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>],</span><span class=no>eax</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29AB</span>  <span class=no>mov</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-4</span><span class=p>],</span><span class=no>ecx</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29AE</span>  <span class=no>cmp</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=no>ds</span><span class=p>:[</span><span class=mi>4</span><span class=no>B51058h</span><span class=p>],</span><span class=mi>0</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29B5</span>  <span class=no>je</span>          <span class=mi>00</span><span class=no>DE29BC</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29B7</span>  <span class=no>call</span>        <span class=mi>73</span><span class=no>DFC310</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29BC</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>ebp-8</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29BF</span>  <span class=no>mov</span>         <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=p>],</span><span class=mi>0</span>  
</span></span><span class=line><span class=cl>            <span class=no>uint16.Value</span> <span class=err>=</span> <span class=mi>1</span> <span class=err>+</span> <span class=mi>2</span> <span class=p>*</span> <span class=mi>256</span><span class=c1>;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>DE29C4</span>  <span class=no>mov</span>         <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>],</span><span class=mi>201</span><span class=no>h</span>  
</span></span><span class=line><span class=cl>            <span class=no>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte1</span><span class=p>)</span><span class=c1>;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>DE29CA</span>  <span class=no>movzx</span>       <span class=no>ecx</span><span class=p>,</span><span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29CE</span>  <span class=no>call</span>        <span class=mi>7325</span><span class=no>A920</span>  
</span></span><span class=line><span class=cl>            <span class=no>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte2</span><span class=p>)</span><span class=c1>;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>DE29D3</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>ebp-8</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29D6</span>  <span class=no>movzx</span>       <span class=no>ecx</span><span class=p>,</span><span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=err>+</span><span class=mi>1</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29DA</span>  <span class=no>call</span>        <span class=mi>7325</span><span class=no>A920</span>  
</span></span><span class=line><span class=cl>        <span class=err>}</span>
</span></span><span class=line><span class=cl><span class=err>00</span><span class=nf>DE29DF</span>  <span class=no>nop</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29E0</span>  <span class=no>mov</span>         <span class=no>esp</span><span class=p>,</span><span class=no>ebp</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29E2</span>  <span class=no>pop</span>         <span class=no>ebp</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29E3</span>  <span class=no>ret</span>  
</span></span></code></pre></div><p>Значение нашего поля в шестнадцатеричном представлении имеет вид <code>201h</code>, а найти его мы можем по адресу <code>byte ptr [ebp-8]</code>. В первом случае (<code>00DE29CA</code>) мы просто загружаем значение по данному адресу в <code>ecx</code>, а во втором (<code>00DE29D3</code>) — сначала загружаем адрес в <code>eax</code>, а затем получаем значение из <code>byte ptr [eax+1]</code>. Для полноты эксперимента глянем также код под Linux. Я взял Ubuntu 14.04 и собрал следующую версию mono:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>$ mono --version
</span></span><span class=line><span class=cl>Mono JIT compiler version 3.10.0
</span></span><span class=line><span class=cl>        TLS:           __thread
</span></span><span class=line><span class=cl>        SIGSEGV:       altstack
</span></span><span class=line><span class=cl>        Notifications: epoll
</span></span><span class=line><span class=cl>        Architecture:  amd64
</span></span><span class=line><span class=cl>        Disabled:      none
</span></span><span class=line><span class=cl>        Misc:          softdebug 
</span></span><span class=line><span class=cl>        LLVM:          supported, not enabled.
</span></span><span class=line><span class=cl>        GC:            sgen
</span></span></code></pre></div><p>Имеем код (x64-версия):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>gram_Main:</span>
</span></span><span class=line><span class=cl><span class=c1>//{
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=err>0:</span>   <span class=err>48</span> <span class=err>83</span> <span class=nf>ec</span> <span class=mi>08</span>             <span class=no>sub</span>    <span class=no>$0x8</span><span class=p>,</span><span class=nv>%rsp</span>
</span></span><span class=line><span class=cl><span class=c1>// var int16 = new Int16Wrapper();
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=err>4:</span>   <span class=err>66</span> <span class=nf>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>00</span> <span class=mi>00</span>       <span class=no>movw</span>   <span class=no>$0x0</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nl>a:</span>   <span class=err>66</span> <span class=nf>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>00</span> <span class=mi>00</span>       <span class=no>movw</span>   <span class=no>$0x0</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// int16.Value = 1 + 2 * 256;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=err>10:</span>   <span class=err>66</span> <span class=nf>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>01</span> <span class=mi>02</span>       <span class=no>movw</span>   <span class=no>$0x201</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// Console.WriteLine(uint16.Byte1);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=err>16:</span>   <span class=err>0</span><span class=nf>f</span> <span class=no>b6</span> <span class=mi>3</span><span class=no>c</span> <span class=mi>24</span>             <span class=no>movzbl</span> <span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%edi</span>
</span></span><span class=line><span class=cl>  <span class=err>1</span><span class=nl>a:</span>   <span class=err>49</span> <span class=nf>bb</span> <span class=mi>7</span><span class=no>e</span> <span class=no>dc</span> <span class=mi>0</span><span class=no>f</span> <span class=mi>40</span> <span class=mi>00</span>    <span class=no>movabs</span> <span class=no>$0x400fdc7e</span><span class=p>,</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl>  <span class=err>21:</span>   <span class=err>00</span> <span class=err>00</span> <span class=err>00</span> 
</span></span><span class=line><span class=cl>  <span class=err>24:</span>   <span class=err>41</span> <span class=nf>ff</span> <span class=no>d3</span>                <span class=no>callq</span>  <span class=p>*</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl><span class=c1>// Console.WriteLine(uint16.Byte2);
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=err>27:</span>   <span class=err>0</span><span class=nf>f</span> <span class=no>b6</span> <span class=mi>7</span><span class=no>c</span> <span class=mi>24</span> <span class=mi>01</span>          <span class=no>movzbl</span> <span class=mi>0x1</span><span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%edi</span>
</span></span><span class=line><span class=cl>  <span class=err>2</span><span class=nl>c:</span>   <span class=err>49</span> <span class=nf>bb</span> <span class=mi>7</span><span class=no>e</span> <span class=no>dc</span> <span class=mi>0</span><span class=no>f</span> <span class=mi>40</span> <span class=mi>00</span>    <span class=no>movabs</span> <span class=no>$0x400fdc7e</span><span class=p>,</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl>  <span class=err>33:</span>   <span class=err>00</span> <span class=err>00</span> <span class=err>00</span> 
</span></span><span class=line><span class=cl>  <span class=err>36:</span>   <span class=err>41</span> <span class=nf>ff</span> <span class=no>d3</span>                <span class=no>callq</span>  <span class=p>*</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl><span class=c1>// }
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=err>39:</span>   <span class=err>48</span> <span class=err>83</span> <span class=nf>c4</span> <span class=mi>08</span>             <span class=no>add</span>    <span class=no>$0x8</span><span class=p>,</span><span class=nv>%rsp</span>
</span></span><span class=line><span class=cl>  <span class=err>3</span><span class=nl>d:</span>   <span class=nf>c3</span>                      <span class=no>retq</span> 
</span></span></code></pre></div><p>Логика аналогична: по адресу <code>(%rsp)</code> загружаем целевое значение <code>$0x201</code>. Получаем <code>Byte1</code> по адресу <code>(%rsp)</code> и <code>Byte2</code> по адресу <code>0x1(%rsp)</code>.</p><h3 id=а-как-узнать-порядок-байт>А как узнать порядок байт?</h3><p>Если для вас критично то, в каком порядке байты идут в памяти, то неплохо было бы научиться узнавать: с какой архитектурой процессора мы имеем дело. Рассмотрим пару способов.</p><p><strong>Простой способ.</strong> Благо, разработчики .NET позаботились о программистах и сделали специальное поле <a href=http://msdn.microsoft.com/library/system.bitconverter.islittleendian.aspx>BitConverter.IsLittleEndian</a>. Пользоваться им очень просто:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>IsLittleEndian</span> <span class=p>?</span> <span class=s>&#34;LittleEndian&#34;</span> <span class=p>:</span> <span class=s>&#34;BigEndian&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Класс <a href=http://msdn.microsoft.com/en-us/library/system.bitconverter.aspx>BitConverter</a> удобно использовать для работы с отдельными байтами «большой» переменной. И этот способ намного предпочтительней, чем ручная работа с байтами. Вот хороший фрагмент из примера в официальной документации:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span> <span class=k>value</span> <span class=p>=</span> <span class=m>12345678</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>byte</span><span class=p>[]</span> <span class=n>bytes</span> <span class=p>=</span> <span class=n>BitConverter</span><span class=p>.</span><span class=n>GetBytes</span><span class=p>(</span><span class=k>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=n>bytes</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>IsLittleEndian</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=n>Array</span><span class=p>.</span><span class=n>Reverse</span><span class=p>(</span><span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=n>bytes</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// The example displays the following output on a little-endian system: </span>
</span></span><span class=line><span class=cl><span class=c1>//       4E-61-BC-00</span>
</span></span><span class=line><span class=cl><span class=c1>//       00-BC-61-4E</span>
</span></span></code></pre></div><p><strong>Способ для тех, кто лёгких способов не ищет.</strong> Следующий пример приведён сугубо в академических целях, в реальных проектах так писать не стоит. Допустим, мы не доверяем значению <code>BitConverter.IsLittleEndian</code> и хотим сами проверить порядок байт, в котором хранятся наши переменные. Нам в этом поможет <code>unsafe</code>-code. Просто создадим уже знакомое нам значение <code>0x201</code>, получим его адрес и возьмём байт по этому адресу. Получится следующий код:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kd>public</span> <span class=kt>bool</span> <span class=n>IsLittleEndian</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>UInt16</span> <span class=k>value</span> <span class=p>=</span> <span class=m>0x201</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kd>unsafe</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>UInt16</span><span class=p>*</span> <span class=n>valueAddress</span> <span class=p>=</span> <span class=p>&amp;</span><span class=k>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Byte</span><span class=p>*</span> <span class=n>firstByteAddress</span> <span class=p>=</span> <span class=p>(</span><span class=n>Byte</span><span class=p>*)</span><span class=n>valueAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Byte</span> <span class=n>firstByte</span> <span class=p>=</span> <span class=p>*</span><span class=n>firstByteAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>firstByte</span> <span class=p>==</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=binaryreaderbinarywriter>BinaryReader/BinaryWriter</h3><p>Ок, с хранением чисел в памяти разобрались. А что, если нам нужно читать/писать числа в бинарном виде? .NET предлагает нам для этого классы <a href=https://msdn.microsoft.com/library/system.io.binaryreader.aspx>BinaryReader</a> и <a href=http://msdn.microsoft.com/library/system.io.binarywriter.aspx>BinaryWriter</a>. Но тут нужно быть аккуратным и помнить, что согласно документации эти классы <em>всегда</em> работают с данными в Little-endian формате. Если по какой-то причине вы хотите поработать с данными в формате с заданным порядком байт, то придётся либо ручками реверсировать каждое число для Big-endian, либо использовать какую-нибудь внешнюю библиотеку (например, класс EndianBitConverter из <a href=http://www.yoda.arachsys.com/csharp/miscutil/>MiscUtil</a> от Джона Скита).</p><h3 id=выводы>Выводы</h3><p>Всегда нужно помнить, что в разных местах для хранения чисел может использоваться разный порядок байт. А если вам доводится работать с памятью в бинарном виде, хранить числа в бинарном виде, передавать их по сети в бинарном виде или ещё что-нибудь делать с числами в бинарном виде, то к нюансу с порядком байт следует отнестись очень внимательно.</p></div><br><br></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}));function toggleTheme(e){e?(document.documentElement.classList.add("dark"),themeToggleLightIcon.classList.remove("hidden"),themeToggleDarkIcon.classList.add("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")}),imagesLight.forEach(e=>{e.classList.add("hidden")})):(document.documentElement.classList.remove("dark"),themeToggleDarkIcon.classList.remove("hidden"),themeToggleLightIcon.classList.add("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}),imagesDark.forEach(e=>{e.classList.add("hidden")}))}themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),event.altKey?(localStorage.removeItem("color-theme"),toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches)):localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{if(localStorage.getItem("color-theme")===null){const t=e.matches?"dark":"light";toggleTheme(t==="dark")}})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2024 <span class=whitespace-nowrap>Андрей Акиньшин</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/ru/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer></body></html>