<!doctype html><html lang=ru class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.103.0-DEV"><meta name=author content="Андрей Акиньшин"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content=".NET,Endianness,ASM,Mono,C#"><title>Endianness в .NET | Андрей Акиньшин</title><meta name=description content="Рассмотрим простую задачку: что выведет следующий код?
[StructLayout(LayoutKind.Explicit)] struct UInt16Wrapper { [FieldOffset(0)] public UInt16 Value; [Fi..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><link href=https://aakinshin.net/sass/bootstrap-light.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=https://aakinshin.net/sass/bootstrap-dark.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.d7f6578e23ad3f0c33c589f9bcb34f995b45121f1f3ce888869c86b26826c845.js></script>
<script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.9e68d431432744c07a43381a8a833ffe0921cc0e006d84ad97f0b0d43c5cd82d.mjs></script>
<link href=https://aakinshin.net/css/main.min.4521fdf961aba8dee11ce56edc3cfa07845a0629c82e528856f1558c230aea2f.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/ru/posts/index.xml title="RSS Feed"></head><body class="d-flex flex-column min-vh-100"><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-sm navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/ru/about/><svg class="fai"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></li><li class=nav-item><a class=nav-link id=nav-link-posts href=https://aakinshin.net/ru/posts/>Посты</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/ru/about/>Об авторе</a></li></ul><ul class="navbar-nav ms-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class="blog-post table-sm"><h1 class=blog-post-title id=post-title>Endianness в .NET</h1><span class=blog-post-meta><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2014-10-29>29 октября 2014</time>
&nbsp;&nbsp;<svg class="fai"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a href=https://aakinshin.net/ru/tags/dotnet/ class="badge badge-info">.NET</a>
<a href=https://aakinshin.net/ru/tags/endianness/ class="badge badge-info">Endianness</a>
<a href=https://aakinshin.net/ru/tags/asm/ class="badge badge-info">ASM</a>
<a href=https://aakinshin.net/ru/tags/mono/ class="badge badge-info">Mono</a>
<a href=https://aakinshin.net/ru/tags/cs/ class="badge badge-info">C#</a></span><br><br><table class=table-ok><tr><td valign=top><div class=separator style=clear:both;text-align:center><img src=/img/posts/dotnet/endianness/front.png alt="Endian funny image" style="margin:0 2em 1em 0"></div></td><td valign=top><p>Рассмотрим простую задачку: что выведет следующий код?</p><pre class="prettyprint lang-cs">
[StructLayout(LayoutKind.Explicit)]
struct UInt16Wrapper
{
  [FieldOffset(0)]
  public UInt16 Value;
  [FieldOffset(0)]
  public Byte Byte1;
  [FieldOffset(1)]
  public Byte Byte2;
}
void Main()
{
  var uint16 = new UInt16Wrapper();
  uint16.Value = 1 + 2 * 256;
  Console.WriteLine(uint16.Byte1);
  Console.WriteLine(uint16.Byte2);
}
</pre></td></tr></table><p>Полагаю, что внимательный читатель должен обратить внимание на название поста и дать правильный ответ: «зависит». Сегодня мы немного поговорим о том, как в .NET обстоят дела с порядком байтов.</p><h3 id=небольшой-обзор>Небольшой обзор</h3><p>Про то, что такое endianness и зачем он нужен, я писать не буду — на эту тему и так хватает материала (<a href=http://en.wikipedia.org/wiki/Endianness>Endianness</a>), <a href=http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures#Endianness>Comparison of instruction set architectures</a>, <a href=http://habrahabr.ru/post/233245/>Разбираемся с прямым и обратным порядком байтов</a>). Ответ на задачку можно легко найти в <a href=http://www.ecma-international.org/publications/standards/Ecma-335.htm>ECMA-335</a>, «I.12.6.3 Byte ordering»:</p><blockquote><p>For data types larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms. The PE file format (see §I.12.2) allows the file to be marked to indicate that it depends on a particular type ordering.</p></blockquote><p>Ну, казалось бы, всё просто: зависит от конкретной архитектуры. Только вот архитектур у нас много. Например, Mono <a href=http://www.mono-project.com/docs/about-mono/supported-platforms/>поддерживает</a> в числе прочего <a href=http://en.wikipedia.org/wiki/X86>x86</a>, <a href=http://en.wikipedia.org/wiki/X86-64>x64</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Little-endian>Little-endian</a>); <a href=http://en.wikipedia.org/wiki/IBM_ESA/390>s390</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Big-endian>Big-endian</a>); <a href=http://en.wikipedia.org/wiki/PowerPC>PowerPC</a>, <a href=http://en.wikipedia.org/wiki/SPARC>SPARC</a>, <a href=http://en.wikipedia.org/wiki/ARM_architecture>ARM</a>, <a href=http://en.wikipedia.org/wiki/Itanium>IA64</a> (<a href=http://en.wikipedia.org/wiki/Endianness#Bi-endian_hardware>Bi-endian</a>, т.е. есть возможность переключаться между Little/Big-endian). Общая мораль такова: лучше не закладываться на какой-то конкретный порядок байт. Конечно, скорее всего вы пишете под x86 или x64 и можете представлять себе всю память как Little-endian, но нужно держать в уме, что это может быть и не так (особенно актуально в свете распространённости ARM для мобильных устройств).</p><h3 id=погружаемся-внутрь>Погружаемся внутрь</h3><p>Данный раздел предназначен для тех, кто любит залезать внутрь своих программ. Если вы не из таких, то можете просто перейти к следующему разделу. А с теми, кому всё-таки интересно, вернёмся к рассмотрению нашего примера и взглянем на IL-код метода Main:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>.class nested private explicit ansi sealed beforefieldinit UInt16Wrapper
</span></span><span class=line><span class=cl>  extends [mscorlib]System.ValueType
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  // Fields
</span></span><span class=line><span class=cl>  .field [0] public uint16 Value
</span></span><span class=line><span class=cl>  .field [0] public uint8 Byte1
</span></span><span class=line><span class=cl>  .field [1] public uint8 Byte2
</span></span><span class=line><span class=cl>} // end of class UInt16Wrapper
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>.method private hidebysig 
</span></span><span class=line><span class=cl>  instance void Run () cil managed 
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  // Method begins at RVA 0x205c
</span></span><span class=line><span class=cl>  // Code size 45 (0x2d)
</span></span><span class=line><span class=cl>  .maxstack 2
</span></span><span class=line><span class=cl>  .locals init (
</span></span><span class=line><span class=cl>    [0] valuetype Program/UInt16Wrapper uint16
</span></span><span class=line><span class=cl>  )
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  IL_0000: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_0002: initobj Program/UInt16Wrapper
</span></span><span class=line><span class=cl>  IL_0008: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_000a: ldc.i4 513
</span></span><span class=line><span class=cl>  IL_000f: stfld uint16 Program/UInt16Wrapper::Value
</span></span><span class=line><span class=cl>  IL_0014: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_0016: ldfld uint8 Program/UInt16Wrapper::Byte1
</span></span><span class=line><span class=cl>  IL_001b: call void [mscorlib]System.Console::WriteLine(int32)
</span></span><span class=line><span class=cl>  IL_0020: ldloca.s uint16
</span></span><span class=line><span class=cl>  IL_0022: ldfld uint8 Program/UInt16Wrapper::Byte2
</span></span><span class=line><span class=cl>  IL_0027: call void [mscorlib]System.Console::WriteLine(int32)
</span></span><span class=line><span class=cl>  IL_002c: ret
</span></span><span class=line><span class=cl>} // end of method Program::Run
</span></span></code></pre></div><p>Тут всё достаточно просто: в нашей структуре имеется три поля: одно двухбайтовое (<code>uint16</code>) и два однобайтовых (<code>uint8</code>). Двухбайтовое поле <code>Value</code> имеет смещение 0 байт. Первое однобайтовое поле <code>Byte1</code> также имеет смещение 0 байт, т.е. указывает в точности туда же, куда и <code>Value</code> (другими словами, на байт <code>Value</code> с младшим адресом). Второе однобайтовое поле <code>Byte2</code> имеет смещение 1 байт, т.е. указывает на байт <code>Value</code> со старшим адресом. В примере значение <code>Value</code> равно <code>1+2*256</code>. На моём компьютере архитектура x64, что означает Little-endian. Для простоты примера соберём программу под x86 (с точно таким же Little-endian) А значит в <code>Byte1</code> будет хранится <code>1</code>, а в <code>Byte2</code> — <code>2</code>. На консоли мы увидим:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>1
</span></span><span class=line><span class=cl>2
</span></span></code></pre></div><p>Ради интереса взглянем на asm-код. Под Windows получим следующее:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>        <span class=err>{</span>
</span></span><span class=line><span class=cl>            <span class=nf>var</span> <span class=no>uint16</span> <span class=err>=</span> <span class=no>new</span> <span class=no>UInt16Wrapper</span><span class=p>()</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=mi>00</span><span class=no>DE29A1</span>  <span class=no>mov</span>         <span class=no>ebp</span><span class=p>,</span><span class=no>esp</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29A3</span>  <span class=no>sub</span>         <span class=no>esp</span><span class=p>,</span><span class=mi>8</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29A6</span>  <span class=no>xor</span>         <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29A8</span>  <span class=no>mov</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>],</span><span class=no>eax</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29AB</span>  <span class=no>mov</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-4</span><span class=p>],</span><span class=no>ecx</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29AE</span>  <span class=no>cmp</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=no>ds</span><span class=p>:[</span><span class=mi>4</span><span class=no>B51058h</span><span class=p>],</span><span class=mi>0</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29B5</span>  <span class=no>je</span>          <span class=mi>00</span><span class=no>DE29BC</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29B7</span>  <span class=no>call</span>        <span class=mi>73</span><span class=no>DFC310</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29BC</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>ebp-8</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29BF</span>  <span class=no>mov</span>         <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=p>],</span><span class=mi>0</span>  
</span></span><span class=line><span class=cl>            <span class=no>uint16.Value</span> <span class=err>=</span> <span class=mi>1</span> <span class=err>+</span> <span class=mi>2</span> <span class=p>*</span> <span class=mi>256</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=mi>00</span><span class=no>DE29C4</span>  <span class=no>mov</span>         <span class=no>word</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>],</span><span class=mi>201</span><span class=no>h</span>  
</span></span><span class=line><span class=cl>            <span class=no>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte1</span><span class=p>)</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=mi>00</span><span class=no>DE29CA</span>  <span class=no>movzx</span>       <span class=no>ecx</span><span class=p>,</span><span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>ebp-8</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29CE</span>  <span class=no>call</span>        <span class=mi>7325</span><span class=no>A920</span>  
</span></span><span class=line><span class=cl>            <span class=no>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte2</span><span class=p>)</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=mi>00</span><span class=no>DE29D3</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>ebp-8</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29D6</span>  <span class=no>movzx</span>       <span class=no>ecx</span><span class=p>,</span><span class=no>byte</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>eax</span><span class=err>+</span><span class=mi>1</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29DA</span>  <span class=no>call</span>        <span class=mi>7325</span><span class=no>A920</span>  
</span></span><span class=line><span class=cl>        <span class=err>}</span>
</span></span><span class=line><span class=cl><span class=err>00</span><span class=nf>DE29DF</span>  <span class=no>nop</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29E0</span>  <span class=no>mov</span>         <span class=no>esp</span><span class=p>,</span><span class=no>ebp</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29E2</span>  <span class=no>pop</span>         <span class=no>ebp</span>  
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>DE29E3</span>  <span class=no>ret</span>  
</span></span></code></pre></div><p>Значение нашего поля в шестнадцатеричном представлении имеет вид <code>201h</code>, а найти его мы можем по адресу <code>byte ptr [ebp-8]</code>. В первом случае (<code>00DE29CA</code>) мы просто загружаем значение по данному адресу в <code>ecx</code>, а во втором (<code>00DE29D3</code>) — сначала загружаем адрес в <code>eax</code>, а затем получаем значение из <code>byte ptr [eax+1]</code>. Для полноты эксперимента глянем также код под Linux. Я взял Ubuntu 14.04 и собрал следующую версию mono:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>$ mono --version
</span></span><span class=line><span class=cl>Mono JIT compiler version 3.10.0
</span></span><span class=line><span class=cl>        TLS:           __thread
</span></span><span class=line><span class=cl>        SIGSEGV:       altstack
</span></span><span class=line><span class=cl>        Notifications: epoll
</span></span><span class=line><span class=cl>        Architecture:  amd64
</span></span><span class=line><span class=cl>        Disabled:      none
</span></span><span class=line><span class=cl>        Misc:          softdebug 
</span></span><span class=line><span class=cl>        LLVM:          supported, not enabled.
</span></span><span class=line><span class=cl>        GC:            sgen
</span></span></code></pre></div><p>Имеем код (x64-версия):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nl>gram_Main:</span>
</span></span><span class=line><span class=cl><span class=err>//{</span>
</span></span><span class=line><span class=cl>   <span class=err>0:</span>   <span class=err>48</span> <span class=err>83</span> <span class=nf>ec</span> <span class=mi>08</span>             <span class=no>sub</span>    <span class=no>$0x8</span><span class=p>,</span><span class=nv>%rsp</span>
</span></span><span class=line><span class=cl><span class=err>//</span> <span class=nf>var</span> <span class=no>int16</span> <span class=err>=</span> <span class=no>new</span> <span class=no>Int16Wrapper</span><span class=p>()</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span>   <span class=mi>4</span><span class=p>:</span>   <span class=mi>66</span> <span class=no>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>00</span> <span class=mi>00</span>       <span class=no>movw</span>   <span class=no>$0x0</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=nl>a:</span>   <span class=err>66</span> <span class=nf>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>00</span> <span class=mi>00</span>       <span class=no>movw</span>   <span class=no>$0x0</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>//</span> <span class=nf>int16.Value</span> <span class=err>=</span> <span class=mi>1</span> <span class=err>+</span> <span class=mi>2</span> <span class=p>*</span> <span class=mi>256</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=mi>10</span><span class=p>:</span>   <span class=mi>66</span> <span class=no>c7</span> <span class=mi>04</span> <span class=mi>24</span> <span class=mi>01</span> <span class=mi>02</span>       <span class=no>movw</span>   <span class=no>$0x201</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=err>//</span> <span class=nf>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte1</span><span class=p>)</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=mi>16</span><span class=p>:</span>   <span class=mi>0</span><span class=no>f</span> <span class=no>b6</span> <span class=mi>3</span><span class=no>c</span> <span class=mi>24</span>             <span class=no>movzbl</span> <span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%edi</span>
</span></span><span class=line><span class=cl>  <span class=err>1</span><span class=nl>a:</span>   <span class=err>49</span> <span class=nf>bb</span> <span class=mi>7</span><span class=no>e</span> <span class=no>dc</span> <span class=mi>0</span><span class=no>f</span> <span class=mi>40</span> <span class=mi>00</span>    <span class=no>movabs</span> <span class=no>$0x400fdc7e</span><span class=p>,</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl>  <span class=err>21:</span>   <span class=err>00</span> <span class=err>00</span> <span class=err>00</span> 
</span></span><span class=line><span class=cl>  <span class=err>24:</span>   <span class=err>41</span> <span class=nf>ff</span> <span class=no>d3</span>                <span class=no>callq</span>  <span class=p>*</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl><span class=err>//</span> <span class=nf>Console.WriteLine</span><span class=p>(</span><span class=no>uint16.Byte2</span><span class=p>)</span><span class=c>;
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=mi>27</span><span class=p>:</span>   <span class=mi>0</span><span class=no>f</span> <span class=no>b6</span> <span class=mi>7</span><span class=no>c</span> <span class=mi>24</span> <span class=mi>01</span>          <span class=no>movzbl</span> <span class=mi>0x1</span><span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%edi</span>
</span></span><span class=line><span class=cl>  <span class=err>2</span><span class=nl>c:</span>   <span class=err>49</span> <span class=nf>bb</span> <span class=mi>7</span><span class=no>e</span> <span class=no>dc</span> <span class=mi>0</span><span class=no>f</span> <span class=mi>40</span> <span class=mi>00</span>    <span class=no>movabs</span> <span class=no>$0x400fdc7e</span><span class=p>,</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl>  <span class=err>33:</span>   <span class=err>00</span> <span class=err>00</span> <span class=err>00</span> 
</span></span><span class=line><span class=cl>  <span class=err>36:</span>   <span class=err>41</span> <span class=nf>ff</span> <span class=no>d3</span>                <span class=no>callq</span>  <span class=p>*</span><span class=nv>%r11</span>
</span></span><span class=line><span class=cl><span class=err>//</span> <span class=err>}</span>
</span></span><span class=line><span class=cl>  <span class=err>39:</span>   <span class=err>48</span> <span class=err>83</span> <span class=nf>c4</span> <span class=mi>08</span>             <span class=no>add</span>    <span class=no>$0x8</span><span class=p>,</span><span class=nv>%rsp</span>
</span></span><span class=line><span class=cl>  <span class=err>3</span><span class=nl>d:</span>   <span class=nf>c3</span>                      <span class=no>retq</span> 
</span></span></code></pre></div><p>Логика аналогична: по адресу <code>(%rsp)</code> загружаем целевое значение <code>$0x201</code>. Получаем <code>Byte1</code> по адресу <code>(%rsp)</code> и <code>Byte2</code> по адресу <code>0x1(%rsp)</code>.</p><h3 id=а-как-узнать-порядок-байт>А как узнать порядок байт?</h3><p>Если для вас критично то, в каком порядке байты идут в памяти, то неплохо было бы научиться узнавать: с какой архитектурой процессора мы имеем дело. Рассмотрим пару способов.</p><p><strong>Простой способ.</strong> Благо, разработчики .NET позаботились о программистах и сделали специальное поле <a href=http://msdn.microsoft.com/library/system.bitconverter.islittleendian.aspx>BitConverter.IsLittleEndian</a>. Пользоваться им очень просто:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>IsLittleEndian</span> <span class=p>?</span> <span class=s>&#34;LittleEndian&#34;</span> <span class=p>:</span> <span class=s>&#34;BigEndian&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Класс <a href=http://msdn.microsoft.com/en-us/library/system.bitconverter.aspx>BitConverter</a> удобно использовать для работы с отдельными байтами «большой» переменной. И этот способ намного предпочтительней, чем ручная работа с байтами. Вот хороший фрагмент из примера в официальной документации:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span> <span class=k>value</span> <span class=p>=</span> <span class=m>12345678</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>byte</span><span class=p>[]</span> <span class=n>bytes</span> <span class=p>=</span> <span class=n>BitConverter</span><span class=p>.</span><span class=n>GetBytes</span><span class=p>(</span><span class=k>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=n>bytes</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>IsLittleEndian</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=n>Array</span><span class=p>.</span><span class=n>Reverse</span><span class=p>(</span><span class=n>bytes</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>BitConverter</span><span class=p>.</span><span class=n>ToString</span><span class=p>(</span><span class=n>bytes</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=c1>// The example displays the following output on a little-endian system: </span>
</span></span><span class=line><span class=cl><span class=c1>//       4E-61-BC-00</span>
</span></span><span class=line><span class=cl><span class=c1>//       00-BC-61-4E</span>
</span></span></code></pre></div><p><strong>Способ для тех, кто лёгких способов не ищет.</strong> Следующий пример приведён сугубо в академических целях, в реальных проектах так писать не стоит. Допустим, мы не доверяем значению <code>BitConverter.IsLittleEndian</code> и хотим сами проверить порядок байт, в котором хранятся наши переменные. Нам в этом поможет <code>unsafe</code>-code. Просто создадим уже знакомое нам значение <code>0x201</code>, получим его адрес и возьмём байт по этому адресу. Получится следующий код:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>public</span> <span class=kt>bool</span> <span class=n>IsLittleEndian</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>UInt16</span> <span class=k>value</span> <span class=p>=</span> <span class=m>0x201</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>unsafe</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>UInt16</span><span class=p>*</span> <span class=n>valueAddress</span> <span class=p>=</span> <span class=p>&amp;</span><span class=k>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Byte</span><span class=p>*</span> <span class=n>firstByteAddress</span> <span class=p>=</span> <span class=p>(</span><span class=n>Byte</span><span class=p>*)</span><span class=n>valueAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Byte</span> <span class=n>firstByte</span> <span class=p>=</span> <span class=p>*</span><span class=n>firstByteAddress</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>firstByte</span> <span class=p>==</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=binaryreaderbinarywriter>BinaryReader/BinaryWriter</h3><p>Ок, с хранением чисел в памяти разобрались. А что, если нам нужно читать/писать числа в бинарном виде? .NET предлагает нам для этого классы <a href=https://msdn.microsoft.com/library/system.io.binaryreader.aspx>BinaryReader</a> и <a href=http://msdn.microsoft.com/library/system.io.binarywriter.aspx>BinaryWriter</a>. Но тут нужно быть аккуратным и помнить, что согласно документации эти классы <em>всегда</em> работают с данными в Little-endian формате. Если по какой-то причине вы хотите поработать с данными в формате с заданным порядком байт, то придётся либо ручками реверсировать каждое число для Big-endian, либо использовать какую-нибудь внешнюю библиотеку (например, класс EndianBitConverter из <a href=http://www.yoda.arachsys.com/csharp/miscutil/>MiscUtil</a> от Джона Скита).</p><h3 id=выводы>Выводы</h3><p>Всегда нужно помнить, что в разных местах для хранения чисел может использоваться разный порядок байт. А если вам доводится работать с памятью в бинарном виде, хранить числа в бинарном виде, передавать их по сети в бинарном виде или ещё что-нибудь делать с числами в бинарном виде, то к нюансу с порядком байт следует отнестись очень внимательно.</p><br><br><div class=row><div class="justify-content-center share-block"><div class=share-title>Поделиться:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f&title=Endianness%20%d0%b2%20.NET" target=_blank title="Share on Reddit"><svg class="fai"><use xlink:href="/img/fa/all.svg#reddit"/></svg></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=Endianness%20%d0%b2%20.NET&url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><svg class="fai"><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f" target=_blank title="Share on HackerNews"><svg class="fai"><use xlink:href="/img/fa/all.svg#hacker-news"/></svg></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fru%2fposts%2fendianness%2f&title=Endianness%20%d0%b2%20.NET" target=_blank title="Add to Pocket"><svg class="fai"><use xlink:href="/img/fa/all.svg#get-pocket"/></svg></a></div></div></div></div><hr></div></div></main></div><footer class="blog-footer mt-auto"><div class=container><p>&copy; 2013&mdash;2022 Андрей Акиньшин
|
<a href=https://github.com/AndreyAkinshin><svg class="fai"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a><a href=https://twitter.com/andrey_akinshin><svg class="fai"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a><a href=https://aakinshin.net/ru/posts/index.xml><svg class="fai"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js integrity="sha512-zPB79j2C+3sFS9zcA3vg/z6bVKzJVEyu9pY5w89akQRys76zpAT2t6S3wZKla3QQ14O5l/Yt0RUQ/DHXx82Y5g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://aakinshin.net/js/theme-after.min.29520a8e1176193da7ea4e6cb56cf9b3e634b867c9979234d8dafb5ab61dd494.js></script></body></html>