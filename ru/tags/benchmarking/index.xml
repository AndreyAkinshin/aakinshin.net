<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Benchmarking on Андрей Акиньшин</title><link>https://aakinshin.net/ru/tags/benchmarking/</link><description>Recent content in Benchmarking on Андрей Акиньшин</description><generator>Hugo -- gohugo.io</generator><language>ru</language><lastBuildDate>Sat, 31 Aug 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/ru/tags/benchmarking/index.xml" rel="self" type="application/rss+xml"/><item><title>Сравнение производительности массивов в .NET</title><link>https://aakinshin.net/ru/posts/arrays-access-performance/</link><pubDate>Sat, 31 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/arrays-access-performance/</guid><description>&lt;h2 id="часть-1">Часть 1&lt;/h2>
&lt;p>Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд &lt;code>newarr&lt;/code>, &lt;code>ldelem&lt;/code>, &lt;code>ldelema&lt;/code>, &lt;code>ldlen&lt;/code>, &lt;code>stelem&lt;/code>). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N&lt;em>M для обращения к элементу [i,j] будем писать [i&lt;/em>M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
&lt;a href="https://github.com/AndreyAkinshin/BenchmarkDotNet">BenchmarkDotNet&lt;/a>. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
&lt;a href="https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs">MultidimensionalArrayProgram.cs&lt;/a>, тестировать следует в &lt;strong>Release mode without debugging&lt;/strong>). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.&lt;/p></description></item><item><title>Об итерировании статичных массивов в .NET</title><link>https://aakinshin.net/ru/posts/static-array-iteration/</link><pubDate>Thu, 29 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/static-array-iteration/</guid><description>&lt;h2 id="часть-1">Часть 1&lt;/h2>
&lt;p>Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.&lt;/p>
&lt;p>В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.&lt;/p></description></item><item><title>Недокументированные ключевые слова C# или превращаем объект в тыкву</title><link>https://aakinshin.net/ru/posts/undocumented-keywords-in-cs/</link><pubDate>Mon, 26 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/undocumented-keywords-in-cs/</guid><description>&lt;p>Стандартный компилятор C# поддерживает 4 недокументированных ключевых слова: &lt;code>__makeref&lt;/code>, &lt;code>__reftype&lt;/code>, &lt;code>__refvalue&lt;/code>, &lt;code>__arglist&lt;/code>. Эти слова даже успешно распознаются в Visual Studio (хотя, ReSharper на них ругается). Они не даром исключены из стандарта — их использование может повлечь серьёзные проблемы с безопасностью. Поэтому не нужно их использовать везде подряд, но в отдельных исключительных случаях они могут пригодиться. В этом посте я обсужу предназначение недокументированных команд, рассмотрю вопросы их производительности и научусь превращать объект в тыкву.&lt;/p></description></item></channel></rss>