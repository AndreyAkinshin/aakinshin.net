<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ASM on Андрей Акиньшин</title><link>https://aakinshin.net/ru/tags/asm/</link><description>Recent content in ASM on Андрей Акиньшин</description><generator>Hugo -- gohugo.io</generator><language>ru</language><lastBuildDate>Wed, 29 Oct 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/ru/tags/asm/index.xml" rel="self" type="application/rss+xml"/><item><title>Endianness в .NET</title><link>https://aakinshin.net/ru/posts/endianness/</link><pubDate>Wed, 29 Oct 2014 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/endianness/</guid><description>&lt;table class="table-ok">
 &lt;tr>
 &lt;td valign="top">
 &lt;div class="separator" style="clear: both; text-align: center;">
 &lt;img src="https://aakinshin.net/img/posts/dotnet/endianness/front.png" alt="Endian funny image" style="margin: 0 2em 1em 0;" />
 &lt;/div>
 &lt;/td>
 &lt;td valign="top">
 &lt;p>Рассмотрим простую задачку: что выведет следующий код?&lt;/p>
&lt;pre class="prettyprint lang-cs">
[StructLayout(LayoutKind.Explicit)]
struct UInt16Wrapper
{
 [FieldOffset(0)]
 public UInt16 Value;
 [FieldOffset(0)]
 public Byte Byte1;
 [FieldOffset(1)]
 public Byte Byte2;
}
void Main()
{
 var uint16 = new UInt16Wrapper();
 uint16.Value = 1 + 2 * 256;
 Console.WriteLine(uint16.Byte1);
 Console.WriteLine(uint16.Byte2);
}
&lt;/pre>
 &lt;/td>
 &lt;/tr>
&lt;/table>
&lt;p>Полагаю, что внимательный читатель должен обратить внимание на название поста и дать правильный ответ: «зависит». Сегодня мы немного поговорим о том, как в .NET обстоят дела с порядком байтов.&lt;/p></description></item><item><title>Сравнение производительности массивов в .NET</title><link>https://aakinshin.net/ru/posts/arrays-access-performance/</link><pubDate>Sat, 31 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/arrays-access-performance/</guid><description>&lt;h2 id="часть-1">Часть 1&lt;/h2>
&lt;p>Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд &lt;code>newarr&lt;/code>, &lt;code>ldelem&lt;/code>, &lt;code>ldelema&lt;/code>, &lt;code>ldlen&lt;/code>, &lt;code>stelem&lt;/code>). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N&lt;em>M для обращения к элементу [i,j] будем писать [i&lt;/em>M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
&lt;a href="https://github.com/AndreyAkinshin/BenchmarkDotNet">BenchmarkDotNet&lt;/a>. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
&lt;a href="https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs">MultidimensionalArrayProgram.cs&lt;/a>, тестировать следует в &lt;strong>Release mode without debugging&lt;/strong>). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.&lt;/p></description></item></channel></rss>