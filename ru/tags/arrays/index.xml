<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Arrays on Андрей Акиньшин</title><link>https://aakinshin.net/ru/tags/arrays/</link><description>Recent content in Arrays on Андрей Акиньшин</description><generator>Hugo -- gohugo.io</generator><language>ru</language><lastBuildDate>Fri, 11 Oct 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/ru/tags/arrays/index.xml" rel="self" type="application/rss+xml"/><item><title>Внутреннее устройство массивов в .NET</title><link>https://aakinshin.net/ru/posts/arrays-internal-structure/</link><pubDate>Fri, 11 Oct 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/arrays-internal-structure/</guid><description>&lt;p>Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблерный код при обращении к их элементам. Я рассмотрю три вида массивов: single (&lt;code>T[]&lt;/code>), rectangular (&lt;code>T[,]&lt;/code>), jagged (&lt;code>T[][]&lt;/code>). Также будет затронута тема массивов с ненулевой нижней границей (&lt;code>T[*]&lt;/code>) и нюансов работы с ними.&lt;/p></description></item><item><title>Сравнение производительности массивов в .NET</title><link>https://aakinshin.net/ru/posts/arrays-access-performance/</link><pubDate>Sat, 31 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/arrays-access-performance/</guid><description>&lt;h2 id="часть-1">Часть 1&lt;/h2>
&lt;p>Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд &lt;code>newarr&lt;/code>, &lt;code>ldelem&lt;/code>, &lt;code>ldelema&lt;/code>, &lt;code>ldlen&lt;/code>, &lt;code>stelem&lt;/code>). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N&lt;em>M для обращения к элементу [i,j] будем писать [i&lt;/em>M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
&lt;a href="https://github.com/AndreyAkinshin/BenchmarkDotNet">BenchmarkDotNet&lt;/a>. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
&lt;a href="https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs">MultidimensionalArrayProgram.cs&lt;/a>, тестировать следует в &lt;strong>Release mode without debugging&lt;/strong>). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.&lt;/p></description></item><item><title>Об итерировании статичных массивов в .NET</title><link>https://aakinshin.net/ru/posts/static-array-iteration/</link><pubDate>Thu, 29 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/ru/posts/static-array-iteration/</guid><description>&lt;h2 id="часть-1">Часть 1&lt;/h2>
&lt;p>Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.&lt;/p>
&lt;p>В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.&lt;/p></description></item></channel></rss>