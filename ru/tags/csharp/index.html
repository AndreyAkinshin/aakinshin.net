<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <meta name="description" content="Andrey Akinshin">
    <meta name="author" content="Andrey Akinshin">
    <link href="/img/favicon.ico" rel="icon" type="image/x-icon"/>
    <meta name="keywords" content=''>

    <title>Andrey Akinshin</title>

    <!-- Bootstrap CSS -->
    <link href="/css/lumen-bootstrap.min.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/slate-bootstrap.min.css" rel="stylesheet" type="text/css" media="all" disabled>

    <!-- Highlight.js -->
    <link href="/css/github-highlight.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/darcula-highlight.css" rel="stylesheet" type="text/css" media="all" disabled>

    <!-- FontAwesome -->
    <link href="/css/fontawesome-all.min.css" rel="stylesheet" type="text/css" media="all">

    <!-- Custom styles -->
    <link href="/css/about.css" rel="stylesheet" type="text/css" media="all">
    <link href="/css/blog.css" rel="stylesheet" type="text/css" media="all">

    <!-- Load theme -->
    <script src="/js/load-theme.js"></script>

    <!-- Feeds -->
    <link href="/ru/rss.xml" type="application/rss+xml" rel="alternate" title="Blog RSS Feed" />
    <link href="/ru/atom.xml" type="application/atom+xml" rel="alternate" title="Blog ATOM Feed" />

    <!-- Google analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-41419012-5', 'auto');
      ga('send', 'pageview');
    </script>
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function (d, w, c) {
            (w[c] = w[c] || []).push(function() {
                try {
                    w.yaCounter28700916 = new Ya.Metrika({
                        id:28700916,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true,
                        webvisor:true,
                        trackHash:true
                    });
                } catch(e) { }
            });

            var n = d.getElementsByTagName("script")[0],
                s = d.createElement("script"),
                f = function () { n.parentNode.insertBefore(s, n); };
            s.type = "text/javascript";
            s.async = true;
            s.src = "https://mc.yandex.ru/metrika/watch.js";

            if (w.opera == "[object Opera]") {
                d.addEventListener("DOMContentLoaded", f, false);
            } else { f(); }
        })(document, window, "yandex_metrika_callbacks");
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/28700916" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->

    <!-- jQuery -->
    <script src="/js/jquery-3.2.1.slim.min.js"></script>
  </head>

  <body>
    <div class="bg-primary">
      <div class="container bg-primary">
        <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
          <ul class="navbar-nav mr-auto">
            <li class="nav-item">
              <a class="nav-link" id="nav-link-blog" href="/ru/posts/">Блог</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" id="nav-link-blog-content" href="/ru/content/">Содержание</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" id="nav-link-about" href="/ru/about/">Об авторе</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" id="nav-link-about" href="/prodotnetbenchmarking/">Pro .NET Benchmarking</a>
            </li>
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" data-toggle="dropdown" href="#" role="button" aria-haspopup="true" aria-expanded="false">Ru</a>
              <div class="dropdown-menu">
                  <a class="dropdown-item" href='/tags/csharp/'>En</a>
              </div>
            </li>
            <li class="nav-item" id="theme-switcher-to-dark"><a class="nav-link" href="#" onclick="setTheme('slate', 'darcula');"><i class="fas fa-moon" title="Переключиться на тёмную тему" style="color:white"></i></a></li>
            <li class="nav-item" id="theme-switcher-to-light"><a class="nav-link" href="#" onclick="setTheme('lumen', 'github');"><i class="far fa-moon" title="Переключиться на светлую тему" style="color:white"></i></a></li>
          </ul>
          <ul class="navbar-nav ml-auto">
            <li class="nav-item"><a class="nav-link" href="https://github.com/AndreyAkinshin"><i class="fab fa-github" title="GitHub" style="color:white"></i></a></li>
            <li class="nav-item"><a class="nav-link" href="https://twitter.com/andrey_akinshin"><i class="fab fa-twitter" title="Twitter" style="color:white"></i></a></li>
            <li class="nav-item"><a class="nav-link" href="/ru/rss.xml"><i class="fas fa-rss" title="RSS" style="color:white"></i></a></li>
          </ul>
        </nav>
      </div>
    </div>

    <div class="container">
      <div class="blog-main">

<h1 id="csharp">Посты про C#</h1>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/legacyjitx86-and-first-method-call/'>LegacyJIT-x86 и первый вызов метода</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 04 апреля 2016.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/jit"><span class="badge badge-pill badge-info">JIT</span></a>
                <a href="/ru/tags/benchmarks"><span class="badge badge-pill badge-info">Benchmarks</span></a>
        </span><br /><br />
        <p>Сегодня я расскажу вам об одном из моих любимых бенчмарков (данный метод не возвращает ничего полезного, он нам нужен только в качестве примера):</p>
<pre><code class="language-cs">[Benchmark]
public string Sum()
{
    double a = 1, b = 1;
    var sw = new Stopwatch();
    for (int i = 0; i &lt; 10001; i++)
        a = a + b;
    return string.Format(&quot;{0}{1}&quot;, a, sw.ElapsedMilliseconds);
}
</code></pre>
<p>Интересный факт: если вы вызовете <code>Stopwatch.GetTimestamp()</code> перед первым вызовом метода <code>Sum</code>, то это увеличит скорость работы метода в несколько раз (фокус работает только для LegacyJIT-x86).</p>
</p>
        <a href='/ru/posts/legacyjitx86-and-first-method-call/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/projecttypeguids/'>Visual Studio и ProjectTypeGuids.cs</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 27 февраля 2016.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/visualstudio"><span class="badge badge-pill badge-info">VisualStudio</span></a>
                <a href="/ru/tags/hate"><span class="badge badge-pill badge-info">Hate</span></a>
        </span><br /><br />
        <p>Это история о том, как я несколько часов пытался открыть проект в Visual Studio. Как-то раз я решил немножко поработать: стянул себе последние коммиты из репозитория, открыл Visual Studio и собрался программировать. Увы, один из моих проектов не открылся, а в окошке Output я увидел странное сообщение:</p>
<pre><code>error  : The operation could not be completed.
</code></pre>
<p>В Solution Explorer, рядом с названием проекта была надпись <em>&quot;load failed&quot;</em>, а вместо файлов было написано следующее: <em>&quot;The project requires user input. Reload the project for more information.&quot;</em> Хмм, ну ок, я попробовал перегрузить проект. Увы, не помогло, я получил ещё два уже знакомых сообщения об ошибке:</p>
<pre><code>error  : The operation could not be completed.
error  : The operation could not be completed.
</code></pre>
</p>
        <a href='/ru/posts/projecttypeguids/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/blittable/'>Blittable-типы</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 26 ноября 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
        </span><br /><br />
        <p>Вопрос дня: что выведет нижеприведённый код?</p>
<pre><code class="language-cs">[StructLayout(LayoutKind.Explicit)]
public struct UInt128
{
    [FieldOffset(0)]
    public ulong Value1;
    [FieldOffset(8)]
    public ulong Value2;
}
[StructLayout(LayoutKind.Sequential)]
public struct MyStruct
{
    public UInt128 UInt128;
    public char Char;
}
class Program
{
    public static unsafe void Main()
    {
        var myStruct = new MyStruct();
        var baseAddress = (int)&amp;myStruct;
        var uInt128Adress = (int)&amp;myStruct.UInt128;
        Console.WriteLine(uInt128Adress - baseAddress);
        Console.WriteLine(Marshal.OffsetOf(typeof(MyStruct), &quot;UInt128&quot;));
    }
}
</code></pre>
<p>Если вы подумали, что в консоли напечатается два нуля (или просто два одинаковых значения), то вам нужно узнать больше про внутреннее устройство структур в .NET. Ниже представлены результаты выполнения кода в зависимости от рантайма:</p>
<table>
<tr><th></th><th>MS.NET-x86</th><th>MS.NET-x64</th><th>Mono</th></tr>
<tr><td>uInt128Adress - baseAddress                  </td><td>4</td><td>8</td><td>0</td></tr>
<tr><td>Marshal.OffsetOf(typeof(MyStruct), "UInt128")</td><td>0</td><td>0</td><td>0</td></tr>
</table>
<p>Чтобы разобраться с ситуацией, нам необходимо узнать больше про blittable-типы.</p>
        <a href='/ru/posts/blittable/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/ryujit-rc-and-constant-folding/'>RyuJIT RC и свёртка констант</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 12 мая 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/jit"><span class="badge badge-pill badge-info">JIT</span></a>
                <a href="/ru/tags/ryujit"><span class="badge badge-pill badge-info">RyuJIT</span></a>
                <a href="/ru/tags/constantfolding"><span class="badge badge-pill badge-info">ConstantFolding</span></a>
        </span><br /><br />
        <p><strong>Update:</strong> Нижеприведённый материал справедлив для релизной версии RyuJIT (часть .NET Framework 4.6).</p>
<p>Задачка дня: какой из методов быстрее?</p>
<pre><code class="language-cs">public double Sqrt13()
{
    return Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
           Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
           Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13);
}
public double Sqrt14()
{
    return Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
           Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
           Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13) + Math.Sqrt(14);
}
</code></pre>
<p>Я померил скорость работы с помощью <a href="https://github.com/AndreyAkinshin/BenchmarkDotNet">BenchmarkDotNet</a> для RyuJIT RC (часть .NET Framework 4.6 RC) получил следующие результаты:</p>
<pre><code>// BenchmarkDotNet=v0.7.4.0
// OS=Microsoft Windows NT 6.2.9200.0
// Processor=Intel(R) Core(TM) i7-4702MQ CPU ＠ 2.20GHz, ProcessorCount=8
// CLR=MS.NET 4.0.30319.0, Arch=64-bit  [RyuJIT]
Common:  Type=Math_DoubleSqrtAvx  Mode=Throughput  Platform=X64  Jit=RyuJit  .NET=Current  

 Method |  AvrTime |    StdDev |         op/s |
------- |--------- |---------- |------------- |
 Sqrt13 | 55.40 ns |  0.571 ns |  18050993.06 |
 Sqrt14 |  1.43 ns | 0.0224 ns | 697125029.18 |
</code></pre>
<p>Как же так? Добавление в выражение одно дополнительного <code>Math.Sqrt</code> ускорило метод в 40 раз! Давайте разберёмся.</p>
        <a href='/ru/posts/ryujit-rc-and-constant-folding/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/unrolling-of-small-loops-in-different-jit-versions/'>Размотка маленьких циклов в разных версиях JIT</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 02 марта 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/jit"><span class="badge badge-pill badge-info">JIT</span></a>
                <a href="/ru/tags/bugs"><span class="badge badge-pill badge-info">Bugs</span></a>
                <a href="/ru/tags/loopunrolling"><span class="badge badge-pill badge-info">LoopUnrolling</span></a>
        </span><br /><br />
        <p>Вопрос дня: что выведет нижеприведённый код?</p>
<pre><code class="language-cs">struct Point
{
    public int X;
    public int Y;
}
static void Print(Point p)
{
    Console.WriteLine(p.X + &quot; &quot; + p.Y);
}
static void Main()
{
    var p = new Point();
    for (p.X = 0; p.X &lt; 2; p.X++)
        Print(p);
}
</code></pre>
<p>Правильный ответ: зависит. В JIT-x86 под CLR2 был баг, который портил эту замечательную программу. А проблема кроется в оптимизации, которая назвается раскрутка маленького цикла. Тема интересная, давайте обсудим её подробно.</p>
</p>
        <a href='/ru/posts/unrolling-of-small-loops-in-different-jit-versions/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/ryujit-ctp5-and-loop-unrolling/'>RyuJIT CTP5 и размотка циклов</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 01 марта 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/jit"><span class="badge badge-pill badge-info">JIT</span></a>
                <a href="/ru/tags/ryujit"><span class="badge badge-pill badge-info">RyuJIT</span></a>
                <a href="/ru/tags/loopunrolling"><span class="badge badge-pill badge-info">LoopUnrolling</span></a>
        </span><br /><br />
        <p>Уже скоро нам будет доступен RyuJIT, JIT-компилятор следующего поколения для .NET-приложений. Microsoft любит рассказывать нам о преимуществах использования SIMD и сокращением времени JIT-компиляции. Но что можно сказать о базовых оптимизациях кода, за которые обычно отвечает компилятор? Сегодня мы поговорим о такой оптимизации как размотка (раскрутка) цикла. Если кратко, то это оптимизации кода вида</p>
<pre><code class="language-cs">for (int i = 0; i &lt; 1024; i++)
    Foo(i);
</code></pre>
<p>превращается в</p>
<pre><code class="language-cs">for (int i = 0; i &lt; 1024; i += 4)
{
    Foo(i);
    Foo(i + 1);
    Foo(i + 2);
    Foo(i + 3);
}
</code></pre>
<p>Подобный подход может заметно увеличить производительность вашего кода. Итак, как же обстоят дела с раскруткой цикла в .NET?</p>
</p>
        <a href='/ru/posts/ryujit-ctp5-and-loop-unrolling/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/jit-version-determining-in-runtime/'>Определение версии JIT в рантайме</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 28 февраля 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/jit"><span class="badge badge-pill badge-info">JIT</span></a>
        </span><br /><br />
        <p>Иногда мне в моих маленьких C#-экспериментах нужно определять версию используемого JIT-компилятора. Понятно, что её можно определить заранее исходя из окружения. Но порой мне хочется знать её в рантайме, чтобы выполнять специфичный код для текущего JIT-компилятора. Строго говоря, я хочу получать значение из следующего перечисления:</p>
<pre><code class="language-cs">public enum JitVersion
{
    Mono, MsX86, MsX64, RyuJit
}
</code></pre>
<p>Я могу легко определить, что работаю под Mono, по наличию класса <code>Mono.Runtime</code>. Если это не так, то можно считать, что мы работаем с JIT от Microsoft. JIT-x86 легко узнать с помощью <code>IntPtr.Size == 4</code>. А вот чтобы отличить старый JIT-x64 от нового RyuJIT необходимо немного призадуматься. Далее я покажу, как это можно сделать с помощью бага JIT-x64, который я описывал в <a href="http://aakinshin.net/ru/blog/dotnet/subexpression-elimination-bug-in-jit-x64/">предыдущем посте</a>.</p>
</p>
        <a href='/ru/posts/jit-version-determining-in-runtime/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/subexpression-elimination-bug-in-jit-x64/'>История про баг в JIT-x64</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 27 февраля 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/jit"><span class="badge badge-pill badge-info">JIT</span></a>
                <a href="/ru/tags/bugs"><span class="badge badge-pill badge-info">Bugs</span></a>
        </span><br /><br />
        <p>Можете ли вы сказать, что выведет следующий код для <code>step=1</code>?</p>
<pre><code class="language-cs">public void Foo(int step)
{
    for (int i = 0; i &lt; step; i++)
    {
        bar = i + 10;
        for (int j = 0; j &lt; 2 * step; j += step)
            Console.WriteLine(j + 10);
    }
}
</code></pre>
<p>Если вы назвали конкретные числа, то ошиблись. Правильный ответ: зависит. Заголовок подсказывает нам, что под x64 программа может вести себя не так, как мы от неё ожидаем.</p>
        <a href='/ru/posts/subexpression-elimination-bug-in-jit-x64/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/inlining-and-starg/'>История про инлайнинг под JIT-x86 и starg</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 26 февраля 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/inlining"><span class="badge badge-pill badge-info">Inlining</span></a>
        </span><br /><br />
        <p>Порой можно узнать много интересного во время чтения исходников .NET. Взглянем на конструктор типа <code>Decimal</code> из .NET Reference Source (<a href="http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158">mscorlib/system/decimal.cs,158</a>):</p>
<pre><code class="language-cs">// Constructs a Decimal from an integer value.
//
public Decimal(int value) {
    //  JIT today can't inline methods that contains &quot;starg&quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &quot;starg&quot;.
    int value_copy = value;
    if (value_copy &gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = value_copy;
    mid = 0;
    hi = 0;
}
</code></pre>
<p>В комментарии сказано, что если метод содержит IL-опкод <a href="https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx">starg</a>, то он не может быть заинлайнен под x86. Любопытно, не правда ли?</p>
        <a href='/ru/posts/inlining-and-starg/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/static-field-in-generic-type/'>Статические поля в generic-классах</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 21 января 2015.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/generic"><span class="badge badge-pill badge-info">Generic</span></a>
                <a href="/ru/tags/static"><span class="badge badge-pill badge-info">Static</span></a>
        </span><br /><br />
        <p>Сегодня мы кратко поговорим о статических полях в generic-классах. Тема простая, но у некоторых разработчиков она вызывает трудности. Итак, задачка: что выведет следующий код?</p>
<pre><code class="language-cs">class Foo&lt;T&gt;
{
  public static int Bar;
}
void Main()
{
  Foo&lt;int&gt;.Bar++;
  Console.WriteLine(Foo&lt;double&gt;.Bar);
}
</code></pre>
</p>
        <a href='/ru/posts/static-field-in-generic-type/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/list-version-side-effect/'>Сайд-эффект внутренней реализации List</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 19 ноября 2014.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/list"><span class="badge badge-pill badge-info">List</span></a>
                <a href="/ru/tags/bugs"><span class="badge badge-pill badge-info">Bugs</span></a>
        </span><br /><br />
        <p>Если вы делаете <code>foreach</code> по некоторому <a href="http://msdn.microsoft.com/library/6sh2ey19.aspx">List</a>-у, то менять итерируемый лист внутри цикла крайне не рекомендуется, ведь это верный способ получить <a href="http://msdn.microsoft.com/library/system.invalidoperationexception.aspx">InvalidOperationException</a>. А теперь загадка: как думаете, что случится со следующим кодом:</p>
<pre><code class="language-cs">var list = new List&lt;int&gt; { 0, 1, 2 };
foreach(var x in list)
{
  if (x == 0)
  {
    for (int i = int.MinValue; i &lt; int.MaxValue; i++)
      list[0] = 0;
    list.Add(3);
  }
  Console.WriteLine(x);
}
</code></pre>
</p>
        <a href='/ru/posts/list-version-side-effect/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/uri-escaping/'>Об экранировании URI в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 13 ноября 2014.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/mono"><span class="badge badge-pill badge-info">Mono</span></a>
                <a href="/ru/tags/uri"><span class="badge badge-pill badge-info">URI</span></a>
                <a href="/ru/tags/escaping"><span class="badge badge-pill badge-info">Escaping</span></a>
        </span><br /><br />
        <h2 id="section">Часть 1</h2>
<p>Загадка на сегодня: что выведет код?</p>
<pre><code class="language-cs">var uri = new Uri(&quot;http://localhost/%2F1&quot;);
Console.WriteLine(uri.OriginalString);
Console.WriteLine(uri.AbsoluteUri);
</code></pre>
<p>Правильный ответ: зависит. Давайте немножко поразбираемся.
        <a href='/ru/posts/uri-escaping/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/cheatsheet-nullable/'>Nullable-арифметика</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 11 ноября 2014.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/nullable"><span class="badge badge-pill badge-info">Nullable</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/cheatsheet"><span class="badge badge-pill badge-info">CheatSheet</span></a>
        </span><br /><br />
        <p>Что будет, если <code>null</code> поделить на ноль? А сколько будет <code>null | true</code>? А <code>null &amp; true</code>? А <code>((string)null + null)</code>?</p>
<p>Практика подсказывает, что C#-разработчики зачастую не особо задумываются о том, как будут оцениваться выражения, если один из операндов равен <code>null</code>. Поэтому я решил составить небольшую шпаргалку на эту тему.</p>
        <a href='/ru/posts/cheatsheet-nullable/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/endianness/'>Endianness в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 29 октября 2014.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/endianness"><span class="badge badge-pill badge-info">Endianness</span></a>
                <a href="/ru/tags/asm"><span class="badge badge-pill badge-info">ASM</span></a>
                <a href="/ru/tags/mono"><span class="badge badge-pill badge-info">Mono</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
        </span><br /><br />
        <table class="table-ok">
    <tr>
        <td valign="top">
            <div class="separator" style="clear: both; text-align: center;">
                <img src="/img/posts/dotnet/endianness/front.png" alt="Endian funny image" style="margin: 0 2em 1em 0;" />
            </div>
        </td>
        <td valign="top">
            <p>Рассмотрим простую задачку: что выведет следующий код?</p>
<pre class="prettyprint lang-cs">
[StructLayout(LayoutKind.Explicit)]
struct UInt16Wrapper
{
  [FieldOffset(0)]
  public UInt16 Value;
  [FieldOffset(0)]
  public Byte Byte1;
  [FieldOffset(1)]
  public Byte Byte2;
}
void Main()
{
  var uint16 = new UInt16Wrapper();
  uint16.Value = 1 + 2 * 256;
  Console.WriteLine(uint16.Byte1);
  Console.WriteLine(uint16.Byte2);
}
</pre>
        </td>
    </tr>
</table>
<p>Полагаю, что внимательный читатель должен обратить внимание на название поста и дать правильный ответ: «зависит». Сегодня мы немного поговорим о том, как в .NET обстоят дела с порядком байтов.
        <a href='/ru/posts/endianness/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/ms-mcp/'>Получение MCP: личный опыт</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 24 июля 2014.
          <b>Tags:</b>
                <a href="/ru/tags/exams"><span class="badge badge-pill badge-info">Exams</span></a>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/microsoft"><span class="badge badge-pill badge-info">Microsoft</span></a>
                <a href="/ru/tags/mcp"><span class="badge badge-pill badge-info">MCP</span></a>
        </span><br /><br />
        <p>Не так давно мне на работе перепал ваучер на бесплатную сдачу экзамена от Microsoft. «А почему бы и нет?» — подумал я. План был выполнен успешно, в связи с чем мне хотелось бы поделиться личным опытом. Возможно, эта история пригодится тем, кто только собирается начать получать сертификации от Microsoft.</p>
<p class="center">
  <img src="/img/posts/dotnet/ms-mcp/mvp-roadmap.png" />
</p>
</p>
        <a href='/ru/posts/ms-mcp/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/findelementsinhostcoordinates/'>Странное поведение FindElementsInHostCoordinates в WinRT</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 29 апреля 2014.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/silverlight"><span class="badge badge-pill badge-info">Silverlight</span></a>
                <a href="/ru/tags/winrt"><span class="badge badge-pill badge-info">WinRT</span></a>
        </span><br /><br />
        <p>Есть в Silverlight отличный метод: <a href="http://msdn.microsoft.com/en-us/library/system.windows.media.visualtreehelper.findelementsinhostcoordinates(v=vs.95).aspx">VisualTreeHelper.FindElementsInHostCoordinates</a> — позволяет выполнять <code>HitTest</code>, т.е. для некоторой точки или прямоугольника искать все объекты визуального поддерева, которые с этими точкой или прямоугольником пересекаются. Внешне точно такой же метод <a href="http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates.aspx">VisualTreeHelper.FindElementsInHostCoordinates</a> можно встретить в WinRT. И вроде выглядит-то он точно также, но есть нюанс: работает этот чудо-метод в разных версиях платформы по-разному. Давайте разберёмся.</p>
        <a href='/ru/posts/findelementsinhostcoordinates/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/system-drawing-color-equals/'>Про System.Drawing.Color и оператор ==</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 21 февраля 2014.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/colors"><span class="badge badge-pill badge-info">Colors</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/equals"><span class="badge badge-pill badge-info">Equals</span></a>
        </span><br /><br />
        <p>Для многих стандартных структур в .NET-е переопределён оператор <code>==</code>, который позволяет легко сравнивать ваши объекты. К сожалению, далеко не все задумываются о том, что на самом деле сравнивается при работе с этим замечательным оператором. В этой короткой заметке мы посмотрим логику сравнения объектов на примере <code>System.Drawing.Color</code>. Как вы думаете, что выведет следующий код:</p>
<pre><code class="language-cs">var redName = Color.Red;
var redArgb = Color.FromArgb(255, 255, 0, 0);
Console.WriteLine(redName == redArgb);
</code></pre>
</p>
        <a href='/ru/posts/system-drawing-color-equals/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/cache-conscious-binary-search/'>Cache-Conscious Binary Search</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 20 ноября 2013.
          <b>Tags:</b>
                <a href="/ru/tags/algorithms"><span class="badge badge-pill badge-info">Algorithms</span></a>
                <a href="/ru/tags/cacheconscious"><span class="badge badge-pill badge-info">CacheConscious</span></a>
                <a href="/ru/tags/binarysearch"><span class="badge badge-pill badge-info">BinarySearch</span></a>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/cache"><span class="badge badge-pill badge-info">Cache</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
        </span><br /><br />
        <p>
	Рассмотрим простую задачу: есть некоторый достаточно большой неизменный набор чисел, к нему осуществляется множество запросов на наличие некоторого числа в этом наборе, необходимо максимально быстро эти запросы обрабатывать. Одно из классических решений заключается в формировании отсортированного массива и обработке запросов через бинарный поиск. Но можно ли добиться более высокой производительности, чем в классической реализации? В этой статье мне хотелось бы рассказать про Cache-Conscious Binary Search. В данном алгоритме предлагается переупорядочить элементы массива таким образом, чтобы использование кэша процессора происходило максимально эффективно.
</p>
</p>
        <a href='/ru/posts/cache-conscious-binary-search/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/jon-skeet-quiz/'>Jon Skeet&#39;s Quiz</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 03 ноября 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
        </span><br /><br />
        <p>Однажды Джона Скита попросили сформулировать три интересных вопроса на знание C#. Он спросил следующее (<a href="http://www.dotnetcurry.com/magazine/jon-skeet-quiz.aspx">оригинал вопросника</a>,	<a href="http://timyrguev.blogspot.ru/2013/10/blog-post.html">перевод статьи</a>):</p>
<ul>
<li><strong>Q1.</strong> <em>Вызов какого конструктора можно использовать, чтобы следующий код вывел True (хотя бы в реализации Microsoft.NET)?</em></li>
</ul>
<pre><code class="language-cs">object x = new /* fill in code here */;
object y = new /* fill in code here */;
Console.WriteLine(x == y);
</code></pre>
<p><em>Учтите, что это просто вызов конструктора, вы не можете поменять тип переменных.</em></p>
<ul>
<li><strong>Q2.</strong> <em>Как сделать так, чтобы следующий код вызывал три различных перегрузки метода?</em></li>
</ul>
<pre><code class="language-cs">void Foo()
{
    EvilMethod&lt;string&gt;();
    EvilMethod&lt;int&gt;();
    EvilMethod&lt;int?&gt;();
}
</code></pre>
<ul>
<li><strong>Q3.</strong> <em>Как заставить следующий код выбросить исключение во второй строчке с помощью локальной переменной (без хитрого изменения её значения)?</em></li>
</ul>
<pre><code class="language-cs">string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
</code></pre>
<p>Вопросы показались мне интересными, поэтому я решил обсудить их решения.</p>
        <a href='/ru/posts/jon-skeet-quiz/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/arrays-internal-structure/'>Внутреннее устройство массивов в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 11 октября 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/arrays"><span class="badge badge-pill badge-info">Arrays</span></a>
        </span><br /><br />
        <p>Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблерный код при обращении к их элементам. Я рассмотрю три вида массивов: single (<code>T[]</code>), rectangular (<code>T[,]</code>), jagged (<code>T[][]</code>). Также будет затронута тема массивов с ненулевой нижней границей (<code>T[*]</code>) и нюансов работы с ними.</p>
        <a href='/ru/posts/arrays-internal-structure/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/cheatsheet-rounding/'>Учимся округлять в C#</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 18 сентября 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/rounding"><span class="badge badge-pill badge-info">Rounding</span></a>
                <a href="/ru/tags/cheatsheet"><span class="badge badge-pill badge-info">CheatSheet</span></a>
        </span><br /><br />
        <p>А знаете ли вы, что <code>Math.Round(1.5) == Math.Round(2.5) == 2</code>? Можете ли сходу сказать, сколько будет <code>-7%3</code> и <code>7%-3</code>? Помните ли, чем отличаются
<code>Math.Round</code>, <code>Math.Floor</code>, <code>Math.Ceiling</code>, <code>Math.Truncate</code>? А как происходит округление при использовании <code>string.Format</code>? Давайте немного погрузимся в мир округлений и разберёмся с нюансами, которые не для всех могут быть очевидными.</p>
        <a href='/ru/posts/cheatsheet-rounding/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/arrays-access-performance/'>Сравнение производительности массивов в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 31 августа 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/benchmarking"><span class="badge badge-pill badge-info">Benchmarking</span></a>
                <a href="/ru/tags/asm"><span class="badge badge-pill badge-info">ASM</span></a>
                <a href="/ru/tags/jit"><span class="badge badge-pill badge-info">JIT</span></a>
                <a href="/ru/tags/arrays"><span class="badge badge-pill badge-info">Arrays</span></a>
        </span><br /><br />
        <h2 id="section">Часть 1</h2>
<p>Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд <code>newarr</code>, <code>ldelem</code>, <code>ldelema</code>, <code>ldlen</code>, <code>stelem</code>). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N<em>M для обращения к элементу [i,j] будем писать [i</em>M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
<a href="https://github.com/AndreyAkinshin/BenchmarkDotNet">BenchmarkDotNet</a>. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
<a href="https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs">MultidimensionalArrayProgram.cs</a>, тестировать следует в <strong>Release mode without debugging</strong>). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.
        <a href='/ru/posts/arrays-access-performance/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/static-array-iteration/'>Об итерировании статичных массивов в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 29 августа 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/benchmarking"><span class="badge badge-pill badge-info">Benchmarking</span></a>
                <a href="/ru/tags/static"><span class="badge badge-pill badge-info">Static</span></a>
                <a href="/ru/tags/il"><span class="badge badge-pill badge-info">IL</span></a>
                <a href="/ru/tags/arrays"><span class="badge badge-pill badge-info">Arrays</span></a>
        </span><br /><br />
        <h2 id="section">Часть 1</h2>
<p>Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.</p>
<p>В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.
        <a href='/ru/posts/static-array-iteration/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/undocumented-keywords-in-cs/'>Недокументированные ключевые слова C# или превращаем объект в тыкву</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 26 августа 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/il"><span class="badge badge-pill badge-info">IL</span></a>
                <a href="/ru/tags/benchmarking"><span class="badge badge-pill badge-info">Benchmarking</span></a>
        </span><br /><br />
        <p>Стандартный компилятор C# поддерживает 4 недокументированных ключевых слова: <code>__makeref</code>, <code>__reftype</code>, <code>__refvalue</code>, <code>__arglist</code>. Эти слова даже успешно распознаются в Visual Studio (хотя, ReSharper на них ругается). Они не даром исключены из стандарта — их использование может повлечь серьёзные проблемы с безопасностью. Поэтому не нужно их использовать везде подряд, но в отдельных исключительных случаях они могут пригодиться. В этом посте я обсужу предназначение недокументированных команд, рассмотрю вопросы их производительности и научусь превращать объект в тыкву.</p>
        <a href='/ru/posts/undocumented-keywords-in-cs/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/closures/'>Неочевидности в использовании C#-замыканий</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 07 августа 2013.
          <b>Tags:</b>
                <a href="/ru/tags/lambda"><span class="badge badge-pill badge-info">Lambda</span></a>
                <a href="/ru/tags/closures"><span class="badge badge-pill badge-info">Closures</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
        </span><br /><br />
        <p>Язык C# даёт нам возможность пользоваться замыканиями — мощным механизмом, который позволяет анонимным методам и лямбдам захватывать свободные переменные в своём лексическом контексте. И в .NET-мире многие программисты очень любят использовать замыкания, но немногие понимают, как они действительно работают. Начнём с простого примера:</p>
<pre><code>public void Run()
{
  int e = 1;
  Foo(x =&gt; x + e);
}
</code></pre>
<p>Ничего сложного тут не происходит: мы просто «захватили» локальную переменную <code>e</code> в лямбду, которая передаётся в некоторый метод <code>Foo</code>. Посмотрим, во что компилятор развернёт такую конструкцию:</p>
<pre><code>public void Run()
{
  DisplayClass c = new DisplayClass();
  c.e = 1;  
  Foo(c.Action);
}
private sealed class DisplayClass
{
  public int e;
  public int Action(int x)
  {
    return x + e;
  }
}
</code></pre>
</p>
        <a href='/ru/posts/closures/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/fastcoloredtextbox/'>FastColoredTextBox — божественный RichTextBox для .NET</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 17 июля 2013.
          <b>Tags:</b>
                <a href="/ru/tags/wpf"><span class="badge badge-pill badge-info">WPF</span></a>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/gui"><span class="badge badge-pill badge-info">GUI</span></a>
                <a href="/ru/tags/controls"><span class="badge badge-pill badge-info">Controls</span></a>
        </span><br /><br />
        <p>Появилась у меня недавно задачка сделать в WPF-приложении красивый редактор форматированного текста с определённой логикой обработки. И решил я использовать для этой задачи стандартный <a href="http://msdn.microsoft.com/ru-ru/library/system.windows.controls.richtextbox.aspx">RichTextBox</a>. Увы, практика показала, что этот контрол <a href="https://www.google.ru/search?q=wpf+richtextbox+performance">ужасно медленный</a>. Можно было, конечно, написать свою реализацию, но это занятие долгое, а функционал нужно было прикрутить побыстрее. Первая мысль была <a href="http://msdn.microsoft.com/en-us/library/ms751761.aspx">захостить</a> стандартный <a href="http://msdn.microsoft.com/ru-ru/library/system.windows.forms.richtextbox.aspx">RichTextBox</a> из WinForms. Он работает достаточно быстро, но его функционала мне не хватило. И тогда я пустился в поиск сторонних контролов. Каким же счастливым я стал, когда наткнулся на FastColoredTextBox! Изучение контрола лучше всего начать со <a href="http://www.codeproject.com/Articles/161871/Fast-Colored-TextBox-for-syntax-highlighting">статьи</a> на CodeProject. Увы, NuGet-пакет автор <a href="https://github.com/PavelTorgashov/FastColoredTextBox/issues/10">по каким-то причинам</a> делать не хочет, но зато есть <a href="https://github.com/PavelTorgashov/FastColoredTextBox">исходники</a> на GitHub. Итак, небольшой обзор.</p>
<p class="center">
  <img src="/img/posts/dotnet/fastcoloredtextbox/screen1.png" />
</p>
</p>
        <a href='/ru/posts/fastcoloredtextbox/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/mutable-structures-as-property/'>Использование изменяемых структур в свойствах классов</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 06 июня 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/properties"><span class="badge badge-pill badge-info">Properties</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/structures"><span class="badge badge-pill badge-info">Structures</span></a>
        </span><br /><br />
        <div style="text-align: right;"><i>Названия всех классов вымышленные,<br />все совпадения абсолютно случайны.</i></div>
<p>Занимался я как-то раз улучшением кода проекта. И наткнулся вот на такие строчки:</p>
<pre><code class="language-cs">public class Image
{
  public Rectangle Bounds;
}
</code></pre>
<p><em>«Ай-яй-яй! Публичное поле в классе, как же нехорошо-то! Нужно срочно превратить его в свойство!»</em> — подумал я. И превратил:</p>
<pre><code class="language-cs">public class Image
{
  public Rectangle Bounds { get; set; }
}
</code></pre>
<p>Сделал я такое невинное изменение и сразу пошёл дальше рефакторить — ведь ещё такое количество кода нуждалось в улучшении! Ну а в конце решил я запустить на всякий случай Unit-тесты. Какого же было моё удивление, когда половина тестов упала. <em>«Да как же так! Ведь я особо-то ничего и не менял!»</em> Ну, поехали разбираться.
        <a href='/ru/posts/mutable-structures-as-property/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/dotnet-fonts/'>Занимательное о шрифтах в .NET</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 03 июня 2013.
          <b>Tags:</b>
                <a href="/ru/tags/fonts"><span class="badge badge-pill badge-info">fonts</span></a>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
        </span><br /><br />
        <p>Сегодня мы поговорим о замечательном классе <a href="http://msdn.microsoft.com/en-us/library/system.drawing.font(v=vs.90).aspx">Font</a>. Иногда при работе с шрифтами возникают некоторые вопросы, которые не настолько очевидны, как хотелось бы. Рассмотрим несколько из них.</p>
<hr />
<p><strong>Q:</strong> Как опознать моноширинный шрифт?</p>
<p><strong>A:</strong> Это не такой простой вопрос. Если немного погуглить, то можно найти следующий совет: описываем у себя в проекте класс <a href="http://www.pinvoke.net/default.aspx/Structures/LOGFONT.html">LOGFONT</a> и используем метод <a href="http://msdn.microsoft.com/en-us/library/9a240xh2.aspx">ToLogFont</a> для конвертации шрифта в соответствующий объект. После этого (согласно легенде) в поле <a href="http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.shell.interop.uidlglogfont.lfpitchandfamily(v=vs.80).aspx">lfPitchAndFamily</a> первый бит должен определять моноширинность шрифта. Так вот, это враньё, в современном мире поле <a href="http://social.msdn.microsoft.com/Forums/en-US/netfxbcl/thread/1bc0166b-8a68-4067-a44b-e11ff7d55720">всегда будет равно нулю</a>. Когда-то где-то этот способ работал, но сейчас не работает. В реальности приходится использовать не очень красивое, но весьма эффективное решение типа такого:</p>
<pre><code>// graphics — заранее созданный экземпляр класса Graphics
public static bool IsMonospace(Font font)
{
    return Math.Abs(graphics.MeasureString(&quot;iii&quot;, font).Width - 
                    graphics.MeasureString(&quot;WWW&quot;, font).Width) &lt; 1e-3;
}
</code></pre>
</p>
        <a href='/ru/posts/dotnet-fonts/'>Читать дальше</a><br /><br />
        <hr />
    </div>
    <div class="blog-post">
        <h2 class="blog-post-title"><a href='/ru/posts/wrap-cs-in-com/'>Заворачиваем C#-класс в COM</a></h2>
        <span class="blog-post-meta">
          <b>Date:</b> 03 июня 2013.
          <b>Tags:</b>
                <a href="/ru/tags/dotnet"><span class="badge badge-pill badge-info">.NET</span></a>
                <a href="/ru/tags/csharp"><span class="badge badge-pill badge-info">C#</span></a>
                <a href="/ru/tags/com"><span class="badge badge-pill badge-info">COM</span></a>
        </span><br /><br />
        <p>Пусть у нас имеется C#-класс, который делает что-нибудь полезное, например:</p>
<pre><code class="language-cs">public class Calculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
</code></pre>
<p>Давайте создадим для этого класса <a href="http://ru.wikipedia.org/wiki/Component_Object_Model">COM</a>-интерфейс, чтобы его функциональность можно было использовать в других местах. В конце посмотрим на использование этого класса в среде Delphi.</p>
        <a href='/ru/posts/wrap-cs-in-com/'>Читать дальше</a><br /><br />
        <hr />
    </div>
</div>
    </div>

    <footer class="blog-footer">
      <div class="container">
        <p>&copy; 2013–2019 Андрей Акиньшин</p>
      </div>
    </footer>

    <!-- jQuery first (header), then popper, then Bootstrap JS. -->
    <script src="/js/popper.min.js"></script>
    <script src="/js/bootstrap.min.js"></script>
    <!-- Other scripts -->
    <script src="/js/highlight.pack.js"></script>
    <script src="/js/anchor.min.js"></script>
    <script src="/js/custom.js"></script>
  </body>
</html>
