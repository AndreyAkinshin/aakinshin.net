<!doctype html><html lang=ru><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.103.0-DEV"><meta name=author content="Андрей Акиньшин"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content><title>Блог Андрея Акиньшина (Страница 4)</title><meta name=description content="Блог Андрея Акиньшина"><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.12451002fa559e9b285d778b5c1851d6cca5f2e101af4458ff4ed03cbc60f484.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/ru/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/ru/about/><svg class="fai w-6 h-6"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/ru/posts/>Посты</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/ru/about/>Об авторе</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/>EN</a></div></div><button id=theme-toggle type=button class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><script>window.location.replace("/ru/about")</script><div class="my-5 px-5 py-2 rounded border border-orange-700 text-orange-700 hover:bg-orange-200 dark:hover:bg-orange-900"><a style=font-size:150% class="text-orange-700 dark:text-orange-700" href=https://aakinshin.net/>Последние посты доступны только в английской версии блога</a></div><div class=main-content><div><h2><a href=/ru/posts/arrays-internal-structure/>Внутреннее устройство массивов в .NET</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-10-11>11 октября 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#</a>
<a class=label-link href=https://aakinshin.net/ru/tags/arrays/>Arrays</a></div><br><p>Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблерный код при обращении к их элементам. Я рассмотрю три вида массивов: single (<code>T[]</code>), rectangular (<code>T[,]</code>), jagged (<code>T[][]</code>). Также будет затронута тема массивов с ненулевой нижней границей (<code>T[*]</code>) и нюансов работы с ними.</p><br><a href=/ru/posts/arrays-internal-structure/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/cheatsheet-rounding/>Учимся округлять в C#</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-09-18>18 сентября 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#</a>
<a class=label-link href=https://aakinshin.net/ru/tags/rounding/>Rounding</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cheatsheet/>CheatSheet</a></div><br><p>А знаете ли вы, что <code>Math.Round(1.5) == Math.Round(2.5) == 2</code>? Можете ли сходу сказать, сколько будет <code>-7%3</code> и <code>7%-3</code>? Помните ли, чем отличаются
<code>Math.Round</code>, <code>Math.Floor</code>, <code>Math.Ceiling</code>, <code>Math.Truncate</code>? А как происходит округление при использовании <code>string.Format</code>? Давайте немного погрузимся в мир округлений и разберёмся с нюансами, которые не для всех могут быть очевидными.</p><br><a href=/ru/posts/cheatsheet-rounding/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/typehandle/>Вся правда о TypeHandle в .NET</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-09-14>14 сентября 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/clr/>CLR</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cli/>CLI</a>
<a class=label-link href=https://aakinshin.net/ru/tags/typehandle/>TypeHandle</a>
<a class=label-link href=https://aakinshin.net/ru/tags/methodtable/>MethodTable</a>
<a class=label-link href=https://aakinshin.net/ru/tags/typedesc/>TypeDesc</a></div><br><p>В разных умных книжках и статьях про .NET я часто наталкивался на упоминания про TypeHandle. Чаще всего пишут, что у каждого .NET-объекта в заголовке находится некоторый TypeHandle, который представляет собой ссылку на тип. Ещё пишут, что TypeHandle — это всегда указатель на таблицу методов типа. А в некоторых местах мне доводилось встречать информацию о том, что TypeHandle указывает на некий TypeDesc. В общем, я устал от неразберихи: давайте вместе разберёмся что к чему. А для этого нам придётся немного подизассемблировать, поизучать дампы памяти и залезть в исходники CLI.</p><br><a href=/ru/posts/typehandle/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/arrays-access-performance/>Сравнение производительности массивов в .NET</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-08-31>31 августа 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#</a>
<a class=label-link href=https://aakinshin.net/ru/tags/benchmarking/>Benchmarking</a>
<a class=label-link href=https://aakinshin.net/ru/tags/asm/>ASM</a>
<a class=label-link href=https://aakinshin.net/ru/tags/jit/>JIT</a>
<a class=label-link href=https://aakinshin.net/ru/tags/arrays/>Arrays</a></div><br><h2 id=часть-1>Часть 1</h2><p>Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд <code>newarr</code>, <code>ldelem</code>, <code>ldelema</code>, <code>ldlen</code>, <code>stelem</code>). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N<em>M для обращения к элементу [i,j] будем писать [i</em>M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
<a href=https://github.com/AndreyAkinshin/BenchmarkDotNet>BenchmarkDotNet</a>. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
<a href=https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs>MultidimensionalArrayProgram.cs</a>, тестировать следует в <strong>Release mode without debugging</strong>). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.</p><br><a href=/ru/posts/arrays-access-performance/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/static-array-iteration/>Об итерировании статичных массивов в .NET</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-08-29>29 августа 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#</a>
<a class=label-link href=https://aakinshin.net/ru/tags/benchmarking/>Benchmarking</a>
<a class=label-link href=https://aakinshin.net/ru/tags/static/>Static</a>
<a class=label-link href=https://aakinshin.net/ru/tags/il/>IL</a>
<a class=label-link href=https://aakinshin.net/ru/tags/arrays/>Arrays</a></div><br><h2 id=часть-1>Часть 1</h2><p>Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.</p><p>В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.</p><br><a href=/ru/posts/static-array-iteration/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/comments/>Комментировать или не комментировать?</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-08-28>28 августа 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/perfectcode/>PerfectCode</a></div><br><p><em>По-настоящему хороший комментарий — тот, без которого вам удалось обойтись. © Дядюшка Боб</em></p><p class=center><img src=/img/posts/dev/refactoring/front.png height=250px></p><p>В последнее время меня стали очень утомлять оживлённые дебаты о том, нужно ли комментировать код. Как правило, по одну сторону баррикад — самоуверенные джуниоры, имеющие непререкаемую позицию вида <em>«А как же его не комментировать, ведь без комментариев непонятно будет!»</em>. По другую — умудрённые опытом сеньоры. Они понимают, что если возможно обойтись без комментариев, то <em>«Лучше бы, чёрт возьми, так и сделать!»</em>. Наверное, у многих жажда комментировать идёт со студенческой скамьи, когда товарищи преподаватели заставляли комментировать каждую строчку,
<em>«чтобы студент лучше разобрался»</em>. В реальном проекте не должно быть кучи комментариев, которые только и делают, что засоряют код. Впрочем, я не агитирую вообще не писать комментарии, но если вам удалось написать такой код, который не требует пояснений, то расценивайте это как свою маленькую победу. Сразу хотелось бы сослаться на несколько очень умных книжек, на основе которых формировалась моя позиция. Я люблю и уважаю авторов этих работ, полностью разделяя их мнение.</p><ul><li><a href=http://www.ozon.ru/context/detail/id/5508646/>С. Макконнелл, «Совершенный код. Мастер-класс»</a></li><li><a href=http://www.ozon.ru/context/detail/id/20216991/>Р. Мартин, «Чистый код. Создание, анализ и рефакторинг»</a></li><li><a href=http://www.ozon.ru/context/detail/id/8466390/>Д. Босуэлл, Т. Фаучер, «Читаемый код, или Программирование как искусство»</a></li></ul><br><a href=/ru/posts/comments/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/perfect-code-and-real-projects/>Совершенный код и реальные проекты</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-08-28>28 августа 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/perfectcode/>PerfectCode</a></div><br><p>У меня есть проблема — я перфекционист. Я люблю совершенный код. Ведь это не только правильный подход к написанию программ, но и настоящее искусство. От чтения хорошего листинга я получаю не меньше удовольствия, чем от чтения хорошей книги. Проектировать архитектуру большого проекта ничуть не легче, чем проектировать архитектуру большого здания, а в случае хорошей работы — результат не менее прекрасен. Порой меня завораживает то, как изящно переплелись паттерны проектирования в создании совершенной программной системы. Меня восхищает внимание к деталям, когда абсолютно каждый метод настолько прост и понятен, что претендует на место классического примера совершенного кода.</p><p class=center><img src=/img/posts/dev/perfect-code-and-real-projects/front.png height=200px></p><p>Но, увы, всё это великолепие разбивается о суровую действительность и реальные проекты. Если мы говорим о продакшн-проекте, то пользователей не волнует, насколько красив ваш код и насколько хороша архитектура, их волнует, чтобы проект хорошо работал. Но я всё равно считаю, что в любом случае нужно стремиться писать правильно, просто при этом фанатизма быть не должно. После чтения различных холиваров на тему правильных подходов к написанию кода мне в глаза бросилась одна тенденция: каждый пытается применить означенные подходы не в целом к программированию, а только к своему опыту разработки, к своим проектам. Многие не осознают, что хорошие практики — это не абсолютные правила, которые должны строго соблюдаться в 100% сценариев, это лишь советы о том, как следовало бы поступать в большинстве ситуаций. На каждую хорошую практику всегда можно придумать несколько дюжин примеров, в которых она работать не будет. Но это вовсе не означает, что хорошая практика не такая уж и хорошая, просто её применили не к месту.</p><br><a href=/ru/posts/perfect-code-and-real-projects/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/undocumented-keywords-in-cs/>Недокументированные ключевые слова C# или превращаем объект в тыкву</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-08-26>26 августа 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#</a>
<a class=label-link href=https://aakinshin.net/ru/tags/il/>IL</a>
<a class=label-link href=https://aakinshin.net/ru/tags/benchmarking/>Benchmarking</a></div><br><p>Стандартный компилятор C# поддерживает 4 недокументированных ключевых слова: <code>__makeref</code>, <code>__reftype</code>, <code>__refvalue</code>, <code>__arglist</code>. Эти слова даже успешно распознаются в Visual Studio (хотя, ReSharper на них ругается). Они не даром исключены из стандарта — их использование может повлечь серьёзные проблемы с безопасностью. Поэтому не нужно их использовать везде подряд, но в отдельных исключительных случаях они могут пригодиться. В этом посте я обсужу предназначение недокументированных команд, рассмотрю вопросы их производительности и научусь превращать объект в тыкву.</p><br><a href=/ru/posts/undocumented-keywords-in-cs/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/gc-native/>Неожиданное место для сборки мусора в .NET</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-08-08>8 августа 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/ru/tags/gc/>GC</a>
<a class=label-link href=https://aakinshin.net/ru/tags/opencv/>OpenCV</a></div><br><p>Платформа .NET обеспечивает нас высокоинтеллектуальным сборщиком мусора, который избавляет от рутины ручного управления памятью. И в 95% случаев можно действительно забыть про память и связанные с ней нюансы. Но вот оставшиеся 5% обладают своей спецификой, связанной с неуправляемыми ресурсами, слишком большими объектами и т.д. И тут лучше бы хорошо разбираться в том, как производится сборка мусора. В противном случае вас могут ждать очень неприятные сюрпризы.</p><p>Как вы думаете, может ли GC собрать объект до того, как выполнится последний из его методов? Оказывается, может. Правда, для этого необходимо запустить приложение в Release mode и отдельно от студии (without debugging). В этом случае JIT-компилятор сделает определённые оптимизации, в результате которых такая ситуация возможна. Разумеется, делает он это только тогда, когда в оставшемся теле метода нет ссылок на сам объект или его поля. Казалось бы, достаточно невинная оптимизация. Но она может привести к проблемам, если мы имеем дело с неуправляемыми ресурсами: сборка объекта может произойти <em>до того</em>, как закончится операция над неуправляемым объектом, что вполне вероятно повлечёт падение приложения.</p><br><a href=/ru/posts/gc-native/>Читать дальше</a><br><br><hr></div><div><h2><a href=/ru/posts/closures/>Неочевидности в использовании C#-замыканий</a></h2><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2013-08-07>7 августа 2013</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/ru/tags/lambda/>Lambda</a>
<a class=label-link href=https://aakinshin.net/ru/tags/closures/>Closures</a>
<a class=label-link href=https://aakinshin.net/ru/tags/cs/>C#</a>
<a class=label-link href=https://aakinshin.net/ru/tags/dotnet/>.NET</a></div><br><p>Язык C# даёт нам возможность пользоваться замыканиями — мощным механизмом, который позволяет анонимным методам и лямбдам захватывать свободные переменные в своём лексическом контексте. И в .NET-мире многие программисты очень любят использовать замыкания, но немногие понимают, как они действительно работают. Начнём с простого примера:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>public</span> <span class=k>void</span> <span class=n>Run</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>e</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>Foo</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>x</span> <span class=p>+</span> <span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Ничего сложного тут не происходит: мы просто «захватили» локальную переменную <code>e</code> в лямбду, которая передаётся в некоторый метод <code>Foo</code>. Посмотрим, во что компилятор развернёт такую конструкцию:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>public</span> <span class=k>void</span> <span class=n>Run</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>DisplayClass</span> <span class=n>c</span> <span class=p>=</span> <span class=k>new</span> <span class=n>DisplayClass</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>c</span><span class=p>.</span><span class=n>e</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>  <span class=n>Foo</span><span class=p>(</span><span class=n>c</span><span class=p>.</span><span class=n>Action</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>sealed</span> <span class=k>class</span> <span class=nc>DisplayClass</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=kt>int</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span> <span class=kt>int</span> <span class=n>Action</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=p>+</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><br><a href=/ru/posts/closures/>Читать дальше</a><br><br><hr></div></div><div class=paginator><ul class="pagination pagination-default"><li class=page-item><a href=/ru/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/ru/page/3/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/ru/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/ru/page/3/ aria-label="Page 3" class=page-link role=button>3</a></li><li class="page-item active"><a aria-current=page aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/ru/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/ru/page/6/ aria-label="Page 6" class=page-link role=button>6</a></li><li class=page-item><a href=/ru/page/5/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/ru/page/6/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")})),themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2022 <span class=whitespace-nowrap>Андрей Акиньшин</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/ru/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js integrity="sha512-zPB79j2C+3sFS9zcA3vg/z6bVKzJVEyu9pY5w89akQRys76zpAT2t6S3wZKla3QQ14O5l/Yt0RUQ/DHXx82Y5g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>anchors.options={placement:"left",icon:"§"},anchors.add("h1"),anchors.add("h2"),anchors.add("h3")</script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"],ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></body></html>