<?xml version="1.0" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
    <title>Блог Андрея Акиньшина</title>
    <link>http://aakinshin.net/</link>
    <atom:link href="http://aakinshin.net/ru/rss.xml" rel="self" type="application/rss+xml" />
    <description></description>
    <language>ru-ru</language>
    <pubDate>Wed, 10 Jul 2019 09:33:45 GMT</pubDate>
    <lastBuildDate>Wed, 10 Jul 2019 09:33:45 GMT</lastBuildDate>

        <item>
            <title>A story about slow NuGet package browsing</title>
            <link>http://aakinshin.net/posts/nuget-package-browsing/</link> 
            <pubDate>Tue, 08 May 2018 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/nuget-package-browsing/</guid>
            <description>&lt;p&gt;In &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt;, we have integration tests which interact with &lt;a href=&quot;https://api.nuget.org/&quot;&gt;api.nuget.org&lt;/a&gt;.
Also, we have an internal service which monitors the performance of these tests.
Two days ago, I noticed that some of these tests sometimes are running for too long.
For example, &lt;code&gt;nuget_NuGetTest_shouldUpgradeVersionForDotNetCore&lt;/code&gt; usually takes around &lt;code&gt;10 sec&lt;/code&gt;.
However, in some cases, it takes around &lt;code&gt;110 sec&lt;/code&gt;, &lt;code&gt;210 sec&lt;/code&gt;, or &lt;code&gt;310 sec&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/nuget-package-browsing/perf-chart.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/nuget-package-browsing/perf-chart.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It looks very suspicious and increases the whole test suite duration.
Also, our dashboard with performance degradations contains only such tests
and some real degradations (which are introduced by the changes in our codebase) can go unnoticed.
So, my colleagues and I decided to investigate it.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;First of all, we decided to look at the logs:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Information   GET https://api-v2v3search-0.nuget.org/query?q=&amp;amp;skip=0&amp;amp;take=10&amp;amp;prerelease=false&amp;amp;semVerLevel=2.0.0
Information An error was encountered when fetching
  &#39;GET https://api-v2v3search-0.nuget.org/query?q=&amp;amp;skip=0&amp;amp;take=10&amp;amp;prerelease=false&amp;amp;semVerLevel=2.0.0&#39;. The request will now be retried.
The HTTP request to &#39;GET https://api-v2v3search-0.nuget.org/query?q=&amp;amp;skip=0&amp;amp;take=10&amp;amp;prerelease=false&amp;amp;semVerLevel=2.0.0&#39;
  has timed out after 100000ms.
Information   GET https://api-v2v3search-0.nuget.org/query?q=&amp;amp;skip=0&amp;amp;take=10&amp;amp;prerelease=false&amp;amp;semVerLevel=2.0.0
Information   OK https://api-v2v3search-0.nuget.org/query?q=&amp;amp;skip=0&amp;amp;take=10&amp;amp;prerelease=false&amp;amp;semVerLevel=2.0.0 1090ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this test, we are trying to get TOP 10 NuGet packages from nuget.org.
The code calls &lt;a href=&quot;https://github.com/NuGet/NuGet.Client&quot;&gt;NuGet.Client API&lt;/a&gt;
which &lt;a href=&quot;https://github.com/NuGet/NuGet.Client/blob/release-4.5.0-rtm/src/NuGet.Core/NuGet.Protocol/Resources/RawSearchResourceV3.cs#L40&quot;&gt;constructs&lt;/a&gt;
the &lt;code&gt;https://api-v2v3search-0.nuget.org/query?q=&amp;amp;skip=0&amp;amp;take=10&amp;amp;prerelease=false&amp;amp;semVerLevel=2.0.0&lt;/code&gt; url
and send a HTTP request.
The server doesn&#39;t respond in &lt;code&gt;100&#39;000ms&lt;/code&gt;, NuGet terminates this request by timeout
and &lt;a href=&quot;https://github.com/NuGet/NuGet.Client/blob/release-4.5.0-rtm/src/NuGet.Core/NuGet.Protocol/HttpSource/HttpRetryHandler.cs#L38&quot;&gt;retries&lt;/a&gt; it.&lt;/p&gt;
&lt;p&gt;We decided to write a simple small repro based on &lt;code&gt;HttpClient&lt;/code&gt; which reproduces the issue:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 100; i++)
{
    using (var client = new HttpClient { Timeout = TimeSpan.FromSeconds(10000) })
    {
        Console.Write(&amp;quot;Request #&amp;quot; + (i + 1).ToString(&amp;quot;000&amp;quot;) + &amp;quot;: &amp;quot;);
        var sw = Stopwatch.StartNew();
        try
        {
            var r = await client.GetAsync(
                &amp;quot;https://api-v2v3search-0.nuget.org:443/query?q=&amp;amp;skip=0&amp;amp;take=10&amp;amp;prerelease=false&amp;amp;semVerLevel=2.0.0&amp;quot;);
            Console.Write(&amp;quot;OK&amp;quot;);
        }
        catch (Exception e)
        {
            Console.Write(&amp;quot;FAIL                 .&amp;quot;);
            Console.WriteLine(e);
        }
        sw.Stop();
        Console.WriteLine($&amp;quot; Time: {sw.Elapsed.TotalSeconds:0.000} sec&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Surprisingly, with &lt;code&gt;Timeout = TimeSpan.FromSeconds(10000)&lt;/code&gt; almost all of the request are successful.
On Windows, it produces the following distribution:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/nuget-package-browsing/stat.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/nuget-package-browsing/stat.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It&#39;s very important to create a new instance of &lt;code&gt;HttpClient&lt;/code&gt; for the each iteration: otherwise, the connection will be reused, and we will not get such a picture.&lt;/p&gt;
&lt;p&gt;In the picture, we have a multimodal distribution with following levels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~1sec&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; sends a request;&lt;/li&gt;
&lt;li&gt;request is finished without any problems;&lt;/li&gt;
&lt;li&gt;we get the list of packages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~125sec&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; sends a request;&lt;/li&gt;
&lt;li&gt;the server terminates the request after 2 minutes;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; retries the request;&lt;/li&gt;
&lt;li&gt;we get the list of packages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~250sec&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; sends a request;&lt;/li&gt;
&lt;li&gt;the server terminates the request after 2 minutes;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; retries the request;&lt;/li&gt;
&lt;li&gt;the server terminates the second request after 2 minutes;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; retries the request again;&lt;/li&gt;
&lt;li&gt;we get the list of packages&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~375sec&lt;/code&gt;:
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; sends a request;&lt;/li&gt;
&lt;li&gt;the server terminates the request after 2 minutes;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; retries the request;&lt;/li&gt;
&lt;li&gt;the server terminates the second request after 2 minutes;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HttpClient&lt;/code&gt; retries the request again;&lt;/li&gt;
&lt;li&gt;the server terminates the third request after 2 minutes;&lt;/li&gt;
&lt;li&gt;we &lt;strong&gt;don&#39;t&lt;/strong&gt; get the list of packages (we get &lt;code&gt;System.Net.Http.WinHttpException: The connection with the server was terminated abnormally&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A remark: on my machine, the first attempt uses &lt;code&gt;TLSv1.2&lt;/code&gt;, the second attempt uses &lt;code&gt;TLSv1.1&lt;/code&gt;, the third attempt uses &lt;code&gt;TLSv1&lt;/code&gt;.
A screenshot from &lt;a href=&quot;https://www.wireshark.org/&quot;&gt;Wireshark&lt;/a&gt; for the &lt;code&gt;~250sec&lt;/code&gt; case:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/nuget-package-browsing/wireshark.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/nuget-package-browsing/wireshark.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;We tried it on our local machines and double checked it on an Azure VM:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/nuget-package-browsing/azure.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/nuget-package-browsing/azure.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;This problem affects (sometimes) different IDEs with NuGet Package Manager: it may take up to several minutes before it displays the search results.
That&#39;s how it looks in Visual Studio:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/nuget-package-browsing/vs.gif&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/nuget-package-browsing/vs.gif&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;That&#39;s how it looks in Visual Studio for Mac:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/nuget-package-browsing/vs-for-mac.gif&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/nuget-package-browsing/vs-for-mac.gif&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It&#39;s hard to reproduce this issue in &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt; because we are &lt;a href=&quot;https://aakinshin.net/blog/post/rider-nuget-search/&quot;&gt;using a persistent local cache of search results&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/nuget-package-browsing/rider.gif&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/nuget-package-browsing/rider.gif&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Currently, the problem is reproduced on &lt;code&gt;api-v2v3search-0.nuget.org&lt;/code&gt; (&lt;code&gt;52.162.253.198&lt;/code&gt;) and &lt;code&gt;api-v2v3search-1.nuget.org&lt;/code&gt; (&lt;code&gt;13.84.46.37&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Since it&#39;s a server-side problem and we can&#39;t fix it locally, we created an issue on GitHub: &lt;a href=&quot;https://github.com/NuGet/Home/issues/6921&quot;&gt;NuGet/Home#6921&lt;/a&gt; (moved to &lt;a href=&quot;https://github.com/NuGet/NuGetGallery/issues/5899&quot;&gt;NuGet/NuGetGallery#5899&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update.&lt;/strong&gt;
A remark about the code snippet.
In the first version of the repro, I used a single &lt;code&gt;HttpClient&lt;/code&gt; instance for all requests.
In this case, the first request fails in ~30% cases,
other requests are successful because the connection is already established.
From the practical point of view, it means that user can get hanged NuGet Package Manager in VS only once after startup.
However, in this case, it&#39;s hard to investigate the problem because it&#39;s very unstable.
Thus, the code snippet creates a new HttpClient instance each time on purpose.
So, it&#39;s very easy to reproduce the problem.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 2018-05-11.&lt;/strong&gt;
The issue is &lt;a href=&quot;https://github.com/NuGet/NuGetGallery/issues/5899#issuecomment-388222254&quot;&gt;fixed&lt;/a&gt;.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Cross-runtime .NET disassembly with BenchmarkDotNet</title>
            <link>http://aakinshin.net/posts/dotnet-crossruntime-disasm/</link> 
            <pubDate>Tue, 10 Apr 2018 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/dotnet-crossruntime-disasm/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; is a cool tool for benchmarking.
It has a lot of useful features that help you with performance investigations.
However, you can use these features even if you are not actually going to benchmark something.
One of these features is &lt;code&gt;DisassemblyDiagnoser&lt;/code&gt;.
It shows you a disassembly listing of your code for all required runtimes.
In this post, I will show you how to get disassembly listing for .NET Framework, .NET Core, and Mono with one click!
You can do it with a very small code snippet like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DryCoreJob, DryMonoJob, DryClrJob(Platform.X86)]
[DisassemblyDiagnoser]
public class IntroDisasm
{
    [Benchmark]
    public double Sum()
    {
        double res = 0;
        for (int i = 0; i &amp;lt; 64; i++)
            res += i;
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;That&#39;s all!
&lt;code&gt;[CoreJob]&lt;/code&gt;, &lt;code&gt;[MonoJob]&lt;/code&gt;, &lt;code&gt;[ClrJob]&lt;/code&gt; mean that we are going to run it on .NET Core, Mono, and .NET Framework.
&lt;code&gt;[Dry]&lt;/code&gt; means that we are going to run only single &amp;quot;dry&amp;quot; iteration for each runtime without actual measurements.
&lt;code&gt;[DisassemblyDiagnoser]&lt;/code&gt; means that we want to get assembly listings in the &lt;code&gt;BenchmarkDotNet.Artifacts&lt;/code&gt; folder.&lt;/p&gt;
&lt;p&gt;Some important remarks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;This benchmark requires .NET Framework, so it works only on Windows.&lt;/li&gt;
&lt;li&gt;We use &lt;code&gt;Platform.X86&lt;/code&gt; for &lt;code&gt;[ClrJob]&lt;/code&gt; because we want to see a difference in assembly listing.
The modern versions of .NET Framework and .NET Core use the same JIT engine on &lt;code&gt;x64&lt;/code&gt;.
So let&#39;s compare &lt;code&gt;LegacyJIT-x86&lt;/code&gt; from .NET Framework and &lt;code&gt;RyuJIT-x64&lt;/code&gt; from .NET Core.&lt;/li&gt;
&lt;li&gt;To get assembly listings for Mono on Windows, you need &lt;code&gt;as&lt;/code&gt; and &lt;code&gt;x86_64-w64-mingw32-objdump.exe&lt;/code&gt; tools.
You can read more about it in the &lt;a href=&quot;http://benchmarkdotnet.org/Configs/Diagnosers.htm#disassembly-diagnoser-for-mono-on-windows&quot;&gt;documentation&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The source code (the benchmark + the csproj file) is available here: &lt;a href=&quot;https://gist.github.com/AndreyAkinshin/62d2f4c3e67acde844f569fbf5846570&quot;&gt;https://gist.github.com/AndreyAkinshin/62d2f4c3e67acde844f569fbf5846570&lt;/a&gt;
You can try it on your machine with the help of the following script:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;git clone https://gist.github.com/62d2f4c3e67acde844f569fbf5846570.git DisasmDemo
cd DisasmDemo
dotnet run -f netcoreapp2.0 -c Release
start BenchmarkDotNet.Artifacts\results\IntroDisasm-disassembly-report.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a result, you will see an html page which contains disassembly listings for all runtimes:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/dotnet-crossruntime-disasm/disasm.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/dotnet-crossruntime-disasm/disasm.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The raw code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; .NET Framework 4.7 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.2633.0

07404098 DisasmDemo.IntroDisasm.Sum()
0740409c d9ee            fldz
0740409e 33c0            xor     eax,eax
074040a0 8945fc          mov     dword ptr [ebp-4],eax
074040a3 db45fc          fild    dword ptr [ebp-4]
074040a6 dec1            faddp   st(1),st
074040a8 40              inc     eax
074040a9 83f840          cmp     eax,40h
074040ac 7cf2            jl      074040a0
074040ae 8be5            mov     esp,ebp
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; .NET Core 2.0.6 (CoreCLR 4.6.26212.01, CoreFX 4.6.26212.01), 64bit RyuJIT

00007fff 196433b0 DisasmDemo.IntroDisasm.Sum()
00007fff 196433b3 c4e17957c0      vxorpd  xmm0,xmm0,xmm0
00007fff 196433b8 33c0            xor     eax,eax
00007fff 196433ba c4e17057c9      vxorps  xmm1,xmm1,xmm1
00007fff 196433bf c4e1732ac8      vcvtsi2sd xmm1,xmm1,eax
00007fff 196433c4 c4e17b58c1      vaddsd  xmm0,xmm0,xmm1
00007fff 196433c9 ffc0            inc     eax
00007fff 196433cb 83f840          cmp     eax,40h
00007fff 196433ce 7cea            jl      00007fff 196433ba
00007fff 196433d0 c3              ret
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Mono 5.4.0 (Visual Studio), 64bit

 Sum
sub    $0x18,%rsp
mov    %rsi,(%rsp)
xorpd  %xmm0,%xmm0
movsd  %xmm0,0x8(%rsp)
xor    %esi,%esi
jmp    2e 
xchg   %ax,%ax
movsd  0x8(%rsp),%xmm0
cvtsi2sd %esi,%xmm1
addsd  %xmm1,%xmm0
movsd  %xmm0,0x8(%rsp)
inc    %esi
cmp    $0x40,%esi
jl     18 
movsd  0x8(%rsp),%xmm0
mov    (%rsp),%rsi
add    $0x18,%rsp
retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, BenchmarkDotNet uses different diasasm style for each runtime.
Well, &lt;code&gt;DisassemblyDiagnoser&lt;/code&gt; is a recent feature, it works, but we did not have enough time to polish it.
However, BenchmarkDotNet is &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/wiki/ChangeLog&quot;&gt;rapidly evolving&lt;/a&gt;,
each version contains many improvements and bug fixes.
If you want to help with the disasm support, &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet#contributions-are-welcome&quot;&gt;contributions are welcome&lt;/a&gt;!&lt;/p&gt;</description>
        </item>
        <item>
            <title>BenchmarkDotNet v0.10.14</title>
            <link>http://aakinshin.net/posts/bdn-v0_10_14/</link> 
            <pubDate>Mon, 09 Apr 2018 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/bdn-v0_10_14/</guid>
            <description>&lt;p&gt;BenchmarkDotNet v0.10.14 has been released! This release includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Per-method parameterization&lt;/strong&gt; (&lt;a href=&quot;http://benchmarkdotnet.org/Advanced/Arguments.htm&quot;&gt;Read more&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Console histograms and multimodal disribution detection&lt;/strong&gt; (&lt;a href=&quot;/blog/post/dotnet-crossruntime-disasm/&quot;&gt;Read more&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Many improvements for Mono disassembly support on Windows&lt;/strong&gt; (A blog post is coming soon)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Many bugfixes&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.14&quot;&gt;v0.10.14&lt;/a&gt; scope,
8 issues were resolved and 11 pull requests where merged.
This release includes 47 commits by 8 contributors.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;resolved-issues-8&quot;&gt;Resolved issues (8)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/256&quot;&gt;#256&lt;/a&gt; Per-method parameterization (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/429&quot;&gt;#429&lt;/a&gt; Detect multimodal distributions (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/496&quot;&gt;#496&lt;/a&gt; Integration with TravisCI (assignee: &lt;a href=&quot;https://github.com/jongalloway&quot;&gt;@jongalloway&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/684&quot;&gt;#684&lt;/a&gt; Horology.ClockTests.ChronometerTest fails on Travis CI (macOS) (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/689&quot;&gt;#689&lt;/a&gt; DisassemblyDiagnoser for Mono does not work on Windows and Linux (assignee: &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/691&quot;&gt;#691&lt;/a&gt; Cannot run F# benchmarks when benchmark returns F# generic (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/697&quot;&gt;#697&lt;/a&gt; Copy custom setting from app.config in multitarget projects (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/706&quot;&gt;#706&lt;/a&gt; Support private builds of .NET Runtime (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;merged-pull-requests-11&quot;&gt;Merged pull requests (11)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/577&quot;&gt;#577&lt;/a&gt; Arguments (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/647&quot;&gt;#647&lt;/a&gt; Histograms and multimodal distribution detection, fixes #429 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/674&quot;&gt;#674&lt;/a&gt; Cleanup suggested by VS2017 Code Analysis (plus one typo) (by &lt;a href=&quot;https://github.com/shoelzer&quot;&gt;@shoelzer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/675&quot;&gt;#675&lt;/a&gt; Fix IDE0034: &#39;default&#39; expression can be simplified (by &lt;a href=&quot;https://github.com/shoelzer&quot;&gt;@shoelzer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/676&quot;&gt;#676&lt;/a&gt; Correct NodeTime text which links to NodaTime api (by &lt;a href=&quot;https://github.com/MishaHusiuk&quot;&gt;@MishaHusiuk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/681&quot;&gt;#681&lt;/a&gt; Fix typo (Perdictor -&amp;gt; Predictor) (by &lt;a href=&quot;https://github.com/dmitry-ra&quot;&gt;@dmitry-ra&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/682&quot;&gt;#682&lt;/a&gt; Fix typo (Perdictor -&amp;gt; Predictor) (by &lt;a href=&quot;https://github.com/dmitry-ra&quot;&gt;@dmitry-ra&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/683&quot;&gt;#683&lt;/a&gt; Integration with TravisCI (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/694&quot;&gt;#694&lt;/a&gt; Fix 689 (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/695&quot;&gt;#695&lt;/a&gt; Rename Program to UniqueProgramName to avoid conflicts, fixes #691 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/696&quot;&gt;#696&lt;/a&gt; Build system: Update dotnet SDK and dotnet runtime. Enable FastTests netcoreapp1.1 on non-Windows. (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;commits-47&quot;&gt;Commits (47)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/41aeea864dc474089cc12e365b9f90aaaf30bcd7&quot;&gt;41aeea&lt;/a&gt; Histograms and multimodal distribution detection, fixes #429 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/960e58ae4574d28eba7e077d12bcae5da5617433&quot;&gt;960e58&lt;/a&gt; Handle measurements with zero operations (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/19cdddef766eaf575a4bbbcd4902dfbd05841c99&quot;&gt;19cddd&lt;/a&gt; Fix typo in BaselineScaledColumn.cs (by &lt;a href=&quot;https://github.com/dfederm&quot;&gt;@dfederm&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/a99594845336557f684d77a2ecfb6e38398d25df&quot;&gt;a99594&lt;/a&gt; Merge pull request #673 from dfederm/dfederm/fix-typo (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/5b34257e3a9f86c113a3fcb9561ffc00c33009b0&quot;&gt;5b3425&lt;/a&gt; Cleanup suggested by VS2017 Code Analysis (plus one typo) (#674) (by &lt;a href=&quot;https://github.com/shoelzer&quot;&gt;@shoelzer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/16b6118bcda1acb92966957f90400d3a2c53e0a1&quot;&gt;16b611&lt;/a&gt; Fix IDE0034: &#39;default&#39; expression can be simplified (by &lt;a href=&quot;https://github.com/shoelzer&quot;&gt;@shoelzer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/048b32a7f79c744614e497806fc761e7744f2e4f&quot;&gt;048b32&lt;/a&gt; Merge pull request #675 from shoelzer/master (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/9d5f718dd9e4ddaebc7b2d0a5ce55201a237bcca&quot;&gt;9d5f71&lt;/a&gt; Correct NodeTime text which links to NodaTime lib (by &lt;a href=&quot;https://github.com/MishaHusiuk&quot;&gt;@MishaHusiuk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/c450c7cb24bfd26299ca515d84b63cb75d260113&quot;&gt;c450c7&lt;/a&gt; Merge pull request #676 from MishaHusiuk/patch-1 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/9fad526013e8e920abdb78d6eca80967d291144c&quot;&gt;9fad52&lt;/a&gt; Fix typo (Perdictor -&amp;gt; Predictor) (by &lt;a href=&quot;https://github.com/dmitry-ra&quot;&gt;@dmitry-ra&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/3d906fcc7fcddbfa2868bd840dd1f1082993817a&quot;&gt;3d906f&lt;/a&gt; Fix typo (Perdictor -&amp;gt; Predictor) (by &lt;a href=&quot;https://github.com/dmitry-ra&quot;&gt;@dmitry-ra&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/d1a48e7387992a91cb12b4a059cea55714d31bc4&quot;&gt;d1a48e&lt;/a&gt; Merge pull request #681 from dmitry-ra/master (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/4ccd352ef4863e4836d87fe40037d0432ef51b11&quot;&gt;4ccd35&lt;/a&gt; Merge pull request #682 from dmitry-ra/patch-1 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f743a17cafa3a28899ae01f962c01b69a0d8c540&quot;&gt;f743a1&lt;/a&gt; CakeBuild 0.24.0 -&amp;gt; 0.26.1 (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/c5eb4054be58b67c7fd1b932da9f3a60af349028&quot;&gt;c5eb40&lt;/a&gt; Remove postProjects from solution file. (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e60387eeceffbd9b3cb89fadba5185f16b8dce65&quot;&gt;e60387&lt;/a&gt; Pass correct configuration to test settings (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/224ab8edaed6c510a2b812fac36bc1b3a51fd230&quot;&gt;224ab8&lt;/a&gt; Disable public sign option for F# project (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/ee98f30366a14c31b0cb794c8382e4c7b950d7e1&quot;&gt;ee98f3&lt;/a&gt; Limit Max CPU count for msbuild workers (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/17031d42b5bc716e1d4c472027334da5d0bb157e&quot;&gt;17031d&lt;/a&gt; Fix readme file (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/6fbae80e5f300ee1d6fd24f1847ebaea369a6484&quot;&gt;6fbae8&lt;/a&gt; One more update to readme file (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/cb90f264df1b1251b071487e9e2e703b767cbeda&quot;&gt;cb90f2&lt;/a&gt; disable Travis failing test #684 to unblock #683 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/782ca71b701fcbaf558d948da0fec5fae44cd79d&quot;&gt;782ca7&lt;/a&gt; Merge pull request #683 from Ky7m/Integration-with-TravisCI (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/eebf923782161fe908d8aa48d5b5ea4764f32456&quot;&gt;eebf92&lt;/a&gt; Merge branch &#39;master&#39; into multimodal (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/10511b74d525d6705e901c8fb6b2307e95f2cf17&quot;&gt;10511b&lt;/a&gt; Merge pull request #647 from dotnet/multimodal (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/57bc17826f153a34032d256253fc77677fdc3d02&quot;&gt;57bc17&lt;/a&gt; Fix bug in ClockTests.ChronometerTest, fixes #684 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7c4b14e4d68ad6dd595fa194be938245411d0e4f&quot;&gt;7c4b14&lt;/a&gt; Arguments (#577), fixes #256 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/40771c7ea54b1a2d8eda5492b953e3843eb2cac4&quot;&gt;40771c&lt;/a&gt; Update dotnet SDK (2.1.4 -&amp;gt; 2.1.101) and dotnet runtime (1.1.6 -&amp;gt; 1.1.7). (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/88a9db59c473b75935240dd98fa5788d7816fab5&quot;&gt;88a9db&lt;/a&gt; Merge pull request #696 from Ky7m/build-runtime-update (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/4ac6ad6fec08ef8cf5a7edf6008f964a24b7e9a7&quot;&gt;4ac6ad&lt;/a&gt; we need different name than typical &amp;quot;Program&amp;quot; to avoid problems with referenc... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/1178d6bb00746ba79681175bb9ca00f86086a499&quot;&gt;1178d6&lt;/a&gt; Update build badges (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/24ed1f45a8c69a6c1d0d6fa4e4c086acee4fc6ed&quot;&gt;24ed1f&lt;/a&gt; ProcessHelper: handle null Data values in OutputDataReceived, fix #689 (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7a3d2b523d18f00dbc0ebd5e1e4590458ca0f2c2&quot;&gt;7a3d2b&lt;/a&gt; MonoDisassembler improvements (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f1a0f5ba7acc35069d42f2a75bf976608f055b7d&quot;&gt;f1a0f5&lt;/a&gt; Merge pull request #694 from morgan-kn/Fix689 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/428905890bd88e341c83e8a8b68ba1d0841c1e01&quot;&gt;428905&lt;/a&gt; .NET Core apps are .dlls (not .exes), fixes #697 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/befbc8fb292689c6cca192fa5f6a125cde151bec&quot;&gt;befbc8&lt;/a&gt; Add FAQ notes about #692 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/b4504b925096dfe0887f6a5bf5a8aef6b439116e&quot;&gt;b4504b&lt;/a&gt; Support private builds of .NET Runtime, fixes #706 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/c93e1e0502b620d00881713123659ded30ca9b32&quot;&gt;c93e1e&lt;/a&gt; Introduce separate logic for Windows10 brand strings (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/68576625d19bfbd3c02ab7a7c194536b01a370b2&quot;&gt;685766&lt;/a&gt; Shortify Windows 10 brand strings in the summary (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/9bdd0cc6052d1f108ec371540685775fcd19d347&quot;&gt;9bdd0c&lt;/a&gt; Shortify cpu info in summary (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/2288ad2756f109a127953ab8b72d37e9b4a42cce&quot;&gt;2288ad&lt;/a&gt; Prettify macOS brand string (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/8a0b484804e237f5b20af3e6e8bbe24ff9cb88a0&quot;&gt;8a0b48&lt;/a&gt; Handle tailed nop instructions in mono disasm output (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/d808343a137ff82e8f0a2dea4813c9c43895621d&quot;&gt;d80834&lt;/a&gt; Advanced DryJob attributes (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/9a37ad2c2ec7235a36539b101d5419c736a3298f&quot;&gt;9a37ad&lt;/a&gt; Handle invalid mono disasm outputs (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/21d6d785b18418e52c884da2a3341e8e37588ba9&quot;&gt;21d6d7&lt;/a&gt; Add IntroDisasm (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/5e37b515b26d5c95032df6acc13dd7e52ecc0d11&quot;&gt;5e37b5&lt;/a&gt; Add &amp;quot;Disassembly Diagnoser for Mono on Windows&amp;quot; in docs (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/c2c4e8cc5ff71c8974b528d692096c6de0f0eba4&quot;&gt;c2c4e8&lt;/a&gt; set COMPLUS_Version env var for private Clr builds even if no env vars were d... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/88b088a6a1a6079a60e0f8847068939d2927559d&quot;&gt;88b088&lt;/a&gt; Set library version: 0.10.14 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;contributors-8&quot;&gt;Contributors (8)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Adam Sitnik (&lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Andrey Akinshin (&lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;David Federman (&lt;a href=&quot;https://github.com/dfederm&quot;&gt;@dfederm&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Dmitry Razumikhin (&lt;a href=&quot;https://github.com/dmitry-ra&quot;&gt;@dmitry-ra&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Igor Fesenko (&lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Irina Ananyeva (&lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;MishaHusiuk (&lt;a href=&quot;https://github.com/MishaHusiuk&quot;&gt;@MishaHusiuk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Steve Hoelzer (&lt;a href=&quot;https://github.com/shoelzer&quot;&gt;@shoelzer&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thank you very much!&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://benchmarkdotnet.org/&quot;&gt;Official documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/wiki/ChangeLog&quot;&gt;ChangeLog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/BenchmarkDotNet/0.10.14&quot;&gt;NuGet package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.14&quot;&gt;v0.10.14 milestone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.13...v0.10.14&quot;&gt;v0.10.14 commits&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>BenchmarkDotNet v0.10.13</title>
            <link>http://aakinshin.net/posts/bdn-v0_10_13/</link> 
            <pubDate>Fri, 02 Mar 2018 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/bdn-v0_10_13/</guid>
            <description>&lt;p&gt;BenchmarkDotNet v0.10.13 has been released! This release includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mono Support for DisassemblyDiagnoser:&lt;/strong&gt;
Now you can easily get an assembly listing not only on .NET Framework/.NET Core, but also on Mono.
It works on Linux, macOS, and Windows (Windows requires installed cygwin with &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;as&lt;/code&gt;).
(See &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/541&quot;&gt;#541&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Support ANY CoreFX and CoreCLR builds:&lt;/strong&gt;
BenchmarkDotNet allows the users to run their benchmarks against ANY CoreCLR and CoreFX builds.
You can compare your local build vs MyGet feed or Debug vs Release or one version vs another.
(See &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/651&quot;&gt;#651&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C# 7.2 support&lt;/strong&gt;
(See &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/643&quot;&gt;#643&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.NET 4.7.1 support&lt;/strong&gt;
(See &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/28aa946a9a277b6c2b1166af0397134b02bedf2d&quot;&gt;28aa94&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Support Visual Basic project files (.vbroj) targeting .NET Core&lt;/strong&gt;
(See &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/626&quot;&gt;#626&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DisassemblyDiagnoser now supports generic types&lt;/strong&gt;
(See &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/640&quot;&gt;#640&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Now it&#39;s possible to benchmark both Mono and .NET Core from the same app&lt;/strong&gt;
(See &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/653&quot;&gt;#653&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Many bug fixes&lt;/strong&gt;
(See details below)&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h2 id=&quot;milestone-details&quot;&gt;Milestone details&lt;/h2&gt;
&lt;p&gt;In the &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.13&quot;&gt;v0.10.13&lt;/a&gt; scope,
15 issues were resolved and 9 pull requests where merged.
This release includes 50 commits by 8 contributors.&lt;/p&gt;
&lt;h3 id=&quot;resolved-issues-15&quot;&gt;Resolved issues (15)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/541&quot;&gt;#541&lt;/a&gt; Mono Support for DisassemblyDiagnoser (assignee: &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/614&quot;&gt;#614&lt;/a&gt; Build fails with &amp;quot;&#39;Microsoft.NETCore.App&#39;, version &#39;1.1.2&#39; was not found&amp;quot; probably due to 1.1.4 runtime not being available&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/626&quot;&gt;#626&lt;/a&gt; Support Visual Basic project files (.vbroj) targeting .NET Core (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/630&quot;&gt;#630&lt;/a&gt; Bug: Statistics.DivMean - NullReferenceException (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/631&quot;&gt;#631&lt;/a&gt; Bug: Generic benchmark class fails for DisassemblyDiagnoser with &amp;quot;Sequence contains no matching element&amp;quot; (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/632&quot;&gt;#632&lt;/a&gt; ParamsSource no longer sorted in results (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/634&quot;&gt;#634&lt;/a&gt; Extend SummaryOrderPolicy (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/636&quot;&gt;#636&lt;/a&gt; Unable to run Runner.exe --method MethodName (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/640&quot;&gt;#640&lt;/a&gt; Disassembler fails with generic instance (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/643&quot;&gt;#643&lt;/a&gt; Feature &#39;private protected&#39; is not available in C# 7.0. Please use language version 7.2 or greater. (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/644&quot;&gt;#644&lt;/a&gt; BenchmarkDotNet.Mathematics.RankHelper again. (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/648&quot;&gt;#648&lt;/a&gt; BenchmarkDotNet requires dotnet cli toolchain to be installed (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/651&quot;&gt;#651&lt;/a&gt; Support ANY CoreFX and CoreCLR builds (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/652&quot;&gt;#652&lt;/a&gt; BenchmarkSwitcher should support generic types with parameterless public ctors (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/653&quot;&gt;#653&lt;/a&gt; Proper way to run BenchmarkDotNet on macOS/Linux (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;merged-pull-requests-9&quot;&gt;Merged pull requests (9)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/624&quot;&gt;#624&lt;/a&gt; Upgrade build tools (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/625&quot;&gt;#625&lt;/a&gt; Fix xunit warnings connected to usage of Assert.Equal() to check for Null (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/633&quot;&gt;#633&lt;/a&gt; HostEnvironmentInfo: remove LogicalCoreCount (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/637&quot;&gt;#637&lt;/a&gt; Mono Support for DisassemblyDiagnoser #541 (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/639&quot;&gt;#639&lt;/a&gt; Portability.Cpu tests improvements (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/642&quot;&gt;#642&lt;/a&gt; sync DataContracts to CopiedDataContracts (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/645&quot;&gt;#645&lt;/a&gt; Fixing --help display for options (by &lt;a href=&quot;https://github.com/ENikS&quot;&gt;@ENikS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/646&quot;&gt;#646&lt;/a&gt; Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAttribute (by &lt;a href=&quot;https://github.com/ENikS&quot;&gt;@ENikS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/666&quot;&gt;#666&lt;/a&gt; Plots...Examples...Added A config example in F# (by &lt;a href=&quot;https://github.com/ScottHutchinson&quot;&gt;@ScottHutchinson&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;commits-50&quot;&gt;Commits (50)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/a26e82671a8d5b2150a48f9b48327ccb0a0dda8f&quot;&gt;a26e82&lt;/a&gt; Upgrade build tools: (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/1643cbc27d269089f1ef8b14296e0674d6e2e3c9&quot;&gt;1643cb&lt;/a&gt; Merge pull request #624 from Ky7m/upgrade-build-tools (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/abae518a04f113adbe51a4b01c402fca11c839c4&quot;&gt;abae51&lt;/a&gt; Fix xunit warnings connected to usage of Assert.Equal() to check for null val... (by &lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/fb68bc7aef9624d6131062fbb4793291d5e2236a&quot;&gt;fb68bc&lt;/a&gt; support Visual Basic .NET Core projects, fixes #626 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/067a33df2498343df56608cccd58e7caef78b74a&quot;&gt;067a33&lt;/a&gt; Remove redundant properties in common.props (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/80deb95e26f1ff1fc3149cf6165cb3a37326f01c&quot;&gt;80deb9&lt;/a&gt; BuildNumber fix in common.props (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/87b45810afc262333afaa5e456a2eaaa282a0e7b&quot;&gt;87b458&lt;/a&gt; Add CONTRIBUTING.md (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/8bcf422f18c64b1f583fcc0cdf1dc80db78860b4&quot;&gt;8bcf42&lt;/a&gt; Add CODE_OF_CONDUCT.md (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/d3867daa99af931980b24370dd29cd865fca2505&quot;&gt;d3867d&lt;/a&gt; HostEnvironmentInfo: remove LogicalCoreCount (#633) (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/06e66aba6eac5045f063028baff5ca150b4804e5&quot;&gt;06e66a&lt;/a&gt; Specify PLACE_SIMPLE_EMBEDDED_STATEMENT_ON_SAME_LINE in DotSettings (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/d8ac43e5da1420c6a941091c04abc39c4816aa04&quot;&gt;d8ac43&lt;/a&gt; Mono Support for DisassemblyDiagnoser #541 (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/4356daafc64ea9bba84ee7b3cf6462875afc5c2b&quot;&gt;4356da&lt;/a&gt; Merge pull request #637 from morgan-kn/MonoSupportForDisassemblyDiagnoser (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7572f4dd18e80e8f5c24884a771a9fdef022f171&quot;&gt;7572f4&lt;/a&gt; Fix paths to images in docs (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f076df788e6f71dcc45cf83b04c6005a6e404fa8&quot;&gt;f076df&lt;/a&gt; Portability.Cpu tests improvements (by morgan_kn)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/da649942000a740e8e7156d1b31e1134ba03ea78&quot;&gt;da6499&lt;/a&gt; Merge pull request #639 from morgan-kn/TestsImprovment (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/5dd1a5309c0f0a8883203289f42690c562b705a4&quot;&gt;5dd1a5&lt;/a&gt; Disassembly Diagnoser: support for generic types, fixes #640 fixes #631 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/3c0e719360336014d0a0ed40d93f69436917421b&quot;&gt;3c0e71&lt;/a&gt; diassembly diangoser: different methods can have same metadata id, add type i... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/29480198d002ff62723802f62034e2d92326802a&quot;&gt;294801&lt;/a&gt; test fix &#128521; (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/9e66bbcdf44e1d1ac7aa0e18abbb7c7798f3bc68&quot;&gt;9e66bb&lt;/a&gt; sync DataContracts to CopiedDataContracts (by Irina Ananyeva)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/690f3436a190a49c2ff593758d44eea22a80e20f&quot;&gt;690f34&lt;/a&gt; Merge pull request #642 from morgan-kn/sync (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e1e3e2ab7a07f2f10e43ecd20b6deb1b8efcc24c&quot;&gt;e1e3e2&lt;/a&gt; don&#39;t use type.Fullname for file names, it&#39;s too long for generics (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/43d7c26ea8926c12c0926ca8c3b89110715a5c2b&quot;&gt;43d7c2&lt;/a&gt; we restore before build, so build does need to restore too (it&#39;s new default ... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/9d4c339e882d21a8d2dcdc516f55543d2b5b6570&quot;&gt;9d4c33&lt;/a&gt; trying harder to trick the JIT (#640, #631) (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f8f70f7eb08c9c1babc5780d72eebc26ea223bf8&quot;&gt;f8f70f&lt;/a&gt; Natural ordering for logical groups, fixes #632 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/a2ec340927a54b379b231e5298ff75944fe150d9&quot;&gt;a2ec34&lt;/a&gt; copy LanguageVersion to the output .csproj, fixes #643 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/31e6dd65aa95e9f05c39425218e56808496be231&quot;&gt;31e6dd&lt;/a&gt; Fixing --help display for options (#645), fixes #636 (by &lt;a href=&quot;https://github.com/ENikS&quot;&gt;@ENikS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/45ace978c9ce5a74afce4ae37e04e271b3110b04&quot;&gt;45ace9&lt;/a&gt; Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAtt... (by &lt;a href=&quot;https://github.com/ENikS&quot;&gt;@ENikS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/8811f295e895ad88fd6b7ea0221c6a0b81902b9d&quot;&gt;8811f2&lt;/a&gt; Fix typo in docs/guide/Contributing/Disassembler.md (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7da7b9e703c653f90db93b6bc53a7c354a31dc67&quot;&gt;7da7b9&lt;/a&gt; allow the users to customize Artifacts Path, #377 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7554bf70ce23080ced3162856639a93a0119f554&quot;&gt;7554bf&lt;/a&gt; validate CustomDotNetCliPath, fixes #648 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/683964f5a9c61b38996f81b92f3f555fe57b8adb&quot;&gt;683964&lt;/a&gt; Support ANY CoreFX and CoreCLR builds, fixes #651 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/695386b6d749f036d4519c78081ba0051c3d2063&quot;&gt;695386&lt;/a&gt; support also only custom CoreFX scenario (default runtime), part of #651 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/eb4dcf0345b72680c67ae16c65ed3be7e2e21686&quot;&gt;eb4dcf&lt;/a&gt; allow the users to copy some files after the publish, part of #651 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/b076a3d8f51505af3dac14484f0001bd858abd7d&quot;&gt;b076a3&lt;/a&gt; Add Newtonsoft.Json in the README (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/b4eef5abea970f3858b0048ec0c8be79517f9d6c&quot;&gt;b4eef5&lt;/a&gt; better generics support, fixes #652 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/77fd461f5dc34f7a0a102f3adbe8bb02b8a02e57&quot;&gt;77fd46&lt;/a&gt; Handle null values in Statistics.DivMean and Statistics.DivVariance, fixes #630 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e547f80056267fc064a5b9d0e6421cf44618402b&quot;&gt;e547f8&lt;/a&gt; Fix NRE in RankColumn, fixes #644 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/28aa946a9a277b6c2b1166af0397134b02bedf2d&quot;&gt;28aa94&lt;/a&gt; allow the users to choose .NET 4.7.1 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/503570e85753ec106f10b7ff6878a34636f20c74&quot;&gt;503570&lt;/a&gt; Fixed image link (by &lt;a href=&quot;https://github.com/svick&quot;&gt;@svick&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/93cc85d268a9762c3f6218548a1893665c09197e&quot;&gt;93cc85&lt;/a&gt; Merge pull request #655 from svick/patch-1 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/d33cdee359368cea6abb23cd0b266fd738955dc4&quot;&gt;d33cde&lt;/a&gt; Fixed code block formatting (by &lt;a href=&quot;https://github.com/svick&quot;&gt;@svick&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/cb7c0952d2b825cca69fe7daae620f026b3e75b9&quot;&gt;cb7c09&lt;/a&gt; Merge pull request #657 from svick/patch-1 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/650b4a8b1bc87194f30427b458e54cba2616197a&quot;&gt;650b4a&lt;/a&gt; host Mono process should be able to build .NET Core child process, fixes #653 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/d1dcabde23fc3b04e1ee7f98b990d2a20a67f194&quot;&gt;d1dcab&lt;/a&gt; List formatting for FAQ (by &lt;a href=&quot;https://github.com/svick&quot;&gt;@svick&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/fe52e37b0ee5dcc2d28ee6bb2b8a9b0896c16752&quot;&gt;fe52e3&lt;/a&gt; Merge pull request #663 from svick/faq-formatting (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7792cb98c7d8b249233523887e6b323fb7f99a2b&quot;&gt;7792cb&lt;/a&gt; Example in F#: with corrected code formatting (by &lt;a href=&quot;https://github.com/ScottHutchinson&quot;&gt;@ScottHutchinson&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e6b225615b6d3469434125bfbc75273ab41387c0&quot;&gt;e6b225&lt;/a&gt; Merge pull request #666 from ScottHutchinson/patch-2 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f902072d81637061e956f5694aa2b6d61cd6860e&quot;&gt;f90207&lt;/a&gt; Allow restore and build command override (#670) (by &lt;a href=&quot;https://github.com/Matthew-Bonner&quot;&gt;@Matthew-Bonner&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/4443cdec188cceaacfa6b4a3bfd0a7adc40045f8&quot;&gt;4443cd&lt;/a&gt; Update example in README (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/de0b682ef1804d58cb8a29d7611e29bd882c405d&quot;&gt;de0b68&lt;/a&gt; Set library version: 0.10.13 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;contributors-8&quot;&gt;Contributors (8)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Adam Sitnik (&lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Andrey Akinshin (&lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Eugene Sadovoi (&lt;a href=&quot;https://github.com/ENikS&quot;&gt;@ENikS&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Igor Fesenko (&lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Irina Ananyeva (&lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Matthew Bonner (&lt;a href=&quot;https://github.com/Matthew-Bonner&quot;&gt;@Matthew-Bonner&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Petr Onderka (&lt;a href=&quot;https://github.com/svick&quot;&gt;@svick&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Scott Hutchinson (&lt;a href=&quot;https://github.com/ScottHutchinson&quot;&gt;@ScottHutchinson&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thank you very much!&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://benchmarkdotnet.org/&quot;&gt;Official documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/wiki/ChangeLog&quot;&gt;ChangeLog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/BenchmarkDotNet/0.10.13&quot;&gt;NuGet package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.13&quot;&gt;v0.10.13 milestone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.12...v0.10.13&quot;&gt;v0.10.13 commits&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Analyzing distribution of Mono GC collections</title>
            <link>http://aakinshin.net/posts/mono-gc-collects/</link> 
            <pubDate>Tue, 20 Feb 2018 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/mono-gc-collects/</guid>
            <description>&lt;p&gt;Sometimes I want to understand the GC performance impact on an application quickly.
I know that there are many powerful diagnostic tools and approaches,
but I&#39;m a fan of the &amp;quot;right tool for the job&amp;quot; idea.
In simple cases, I prefer simple noninvasive approaches which provide a quick way
to get an overview of the current situation
(if everything is terrible, I always can switch to an advanced approach).
Today I want to share with you my favorite way to quickly get statistics
of GC pauses in Mono and generate nice plots like this:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/mono-gc-collects/plot-64.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/mono-gc-collects/plot-64.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;getting-raw-data&quot;&gt;Getting raw data&lt;/h3&gt;
&lt;p&gt;Mono has internal tools for getting brief data about GC events.
You just should set a few environment variables:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export MONO_LOG_LEVEL=debug
export MONO_LOG_MASK=gc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a result, we will get lines like follows in stdout:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;Mono: GC_MINOR: (Nursery full) time 4.29ms, stw 4.51ms promoted 1337K major size: 5456K in use: 4785K los size: 8192K in use: 6821K
Mono: GC_MINOR: (Nursery full) time 2.55ms, stw 2.88ms promoted 558K major size: 6304K in use: 5528K los size: 8192K in use: 7039K
Mono: GC_MINOR: (Nursery full) time 6.70ms, stw 7.04ms promoted 2035K major size: 8512K in use: 7715K los size: 9216K in use: 7818K
Mono: GC_MAJOR: (LOS overflow) time 7.72ms, stw 8.02ms los size: 6144K in use: 2039K
Mono: GC_MAJOR_SWEEP: major size: 7936K in use: 5779K
Mono: GC_MINOR: (Nursery full) time 5.18ms, stw 5.43ms promoted 2420K major size: 10352K in use: 8351K los size: 6144K in use: 3150K
Mono: GC_MINOR: (Nursery full) time 5.81ms, stw 6.14ms promoted 1810K major size: 12192K in use: 10374K los size: 6144K in use: 3167K
Mono: GC_MINOR: (Nursery full) time 2.87ms, stw 3.21ms promoted 702K major size: 13056K in use: 11235K los size: 6144K in use: 3303K
Mono: GC_MINOR: (Nursery full) time 4.36ms, stw 4.71ms promoted 1028K major size: 14160K in use: 12374K los size: 6144K in use: 3320K
Mono: GC_MINOR: (Nursery full) time 3.25ms, stw 3.55ms promoted 708K major size: 14912K in use: 13157K los size: 6144K in use: 3320K
Mono: GC_MINOR: (Nursery full) time 3.34ms, stw 3.56ms promoted 908K major size: 16032K in use: 14189K los size: 6144K in use: 3447K
Mono: GC_MINOR: (Nursery full) time 2.77ms, stw 3.02ms promoted 614K major size: 16672K in use: 14894K los size: 6144K in use: 3467K
Mono: GC_MINOR: (Nursery full) time 5.00ms, stw 5.40ms promoted 918K major size: 17664K in use: 15878K los size: 6144K in use: 3549K
Mono: GC_MINOR: (Nursery full) time 4.01ms, stw 4.27ms promoted 1728K major size: 19584K in use: 17733K los size: 6144K in use: 3614K
Mono: GC_MINOR: (Nursery full) time 4.60ms, stw 4.84ms promoted 3514K major size: 23440K in use: 21511K los size: 6144K in use: 3655K
Mono: GC_MAJOR: (LOS overflow) time 18.97ms, stw 19.27ms los size: 6144K in use: 2346K
Mono: GC_MAJOR_SWEEP: major size: 25664K in use: 22669K
Mono: GC_MINOR: (Nursery full) time 3.88ms, stw 4.13ms promoted 1912K major size: 27472K in use: 24707K los size: 6144K in use: 2675K
Mono: GC_MINOR: (Nursery full) time 3.82ms, stw 4.14ms promoted 980K major size: 28448K in use: 25788K los size: 6144K in use: 3372K
Mono: GC_MINOR: (Nursery full) time 2.98ms, stw 3.24ms promoted 617K major size: 29040K in use: 26448K los size: 6144K in use: 3434K
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we can find a lot of interesting information.
However, it&#39;s raw data, and it&#39;s not easy to manually process such logs
(especially if you have hundreds of lines).
Let&#39;s parse it and aggregate the most important data about GC pauses.&lt;/p&gt;
&lt;h3 id=&quot;the-script&quot;&gt;The script&lt;/h3&gt;
&lt;p&gt;I use the following simple regular expression for capturing most interesting lines: &lt;code&gt;^Mono: GC_(.{5}).*time ([0-9\\.]*)ms&lt;/code&gt;
(you can find an online version
&lt;a href=&quot;https://regex101.com/r/wovoAs/1&quot;&gt;here&lt;/a&gt; and
&lt;a href=&quot;https://regexper.com/#%5EMono%3A%20GC_(.%7B5%7D).*time%20(%5B0-9%5C%5C.%5D*)ms&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/mono-gc-collects/regex.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/mono-gc-collects/regex.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Usually, I use R for simple statistics/plotting tasks.
Here is my script for processing such logs (assuming that we have the full log in &lt;code&gt;output.txt&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(ggplot2);library(dplyr);library(stringr)

lines &amp;lt;- readLines(&amp;quot;output.txt&amp;quot;)
df &amp;lt;- data.frame(str_match(lines, &amp;quot;^Mono: GC_(.{5}).*time ([0-9\\.]*)ms&amp;quot;))[,2:3]
colnames(df) &amp;lt;- c(&amp;quot;type&amp;quot;, &amp;quot;time&amp;quot;)
df$time &amp;lt;- as.double(as.character(df$time))
df &amp;lt;- df %&amp;gt;% filter(type != &amp;quot;NA&amp;quot;)

ggplot(df, aes(x=time, color=type)) + 
  geom_histogram() +
  facet_grid(.~type, scales = &amp;quot;free&amp;quot;)
ggsave(&amp;quot;plot.png&amp;quot;)

summary(df %&amp;gt;% filter(type == &amp;quot;MINOR&amp;quot;))
summary(df %&amp;gt;% filter(type == &amp;quot;MAJOR&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;case-study&quot;&gt;Case study&lt;/h3&gt;
&lt;p&gt;Once, I decided to play with the &lt;code&gt;nursery-size&lt;/code&gt; value in &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt;.
The default value is &lt;code&gt;4 MB&lt;/code&gt;, but it&#39;s not the optimal value for Rider.
Let&#39;s open a simple solution in Rider and look at the statistics.&lt;/p&gt;
&lt;h4 id=&quot;nursery-size4m&quot;&gt;nursery-size=4m&lt;/h4&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/mono-gc-collects/plot-4.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/mono-gc-collects/plot-4.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&amp;gt; summary(df %&amp;gt;% filter(type == &amp;quot;MINOR&amp;quot;))
    type           time       
 MAJOR:   0   Min.   : 0.320  
 MINOR:2029   1st Qu.: 6.990  
              Median : 8.670  
              Mean   : 8.664  
              3rd Qu.: 9.910  
              Max.   :84.190  

&amp;gt; summary(df %&amp;gt;% filter(type == &amp;quot;MAJOR&amp;quot;))
    type         time        
 MAJOR:20   Min.   :  68.16  
 MINOR: 0   1st Qu.: 168.90  
            Median : 237.40  
            Mean   : 339.33  
            3rd Qu.: 402.62  
            Max.   :1068.22 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;nursery-size64m&quot;&gt;nursery-size=64m&lt;/h4&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/mono-gc-collects/plot-64.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/mono-gc-collects/plot-64.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;&amp;gt; summary(df %&amp;gt;% filter(type == &amp;quot;MINOR&amp;quot;))
    type          time       
 MAJOR:  0   Min.   :  3.42  
 MINOR:273   1st Qu.: 11.72  
             Median : 15.01  
             Mean   : 22.72  
             3rd Qu.: 20.79  
             Max.   :379.26  

&amp;gt; summary(df %&amp;gt;% filter(type == &amp;quot;MAJOR&amp;quot;))
    type         time        
 MAJOR:18   Min.   :  22.94  
 MINOR: 0   1st Qu.: 176.00  
            Median : 317.68  
            Mean   : 397.17  
            3rd Qu.: 567.48  
            Max.   :1052.87  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The average time of &lt;code&gt;GC_MINOR&lt;/code&gt; is bigger for &lt;code&gt;64 M&lt;/code&gt; (&lt;code&gt;22.72ms&lt;/code&gt; vs. &lt;code&gt;8.664ms&lt;/code&gt;),
but the amount of &lt;code&gt;GC_MINOR&lt;/code&gt; collections is &lt;code&gt;273&lt;/code&gt; instead of &lt;code&gt;2029&lt;/code&gt;!&lt;/p&gt;
&lt;h4 id=&quot;performance-impact&quot;&gt;Performance impact&lt;/h4&gt;
&lt;p&gt;Does it really affect the performance?
Let&#39;s find out!
I checked a subset of the Rider solution (212 projects) on Ubuntu 16.04.
I measured the startup time
(the time before solution is fully loaded include the full product initialization).
I have analyzed the full distributions, but let&#39;s look only at average numbers for simplification.
The results:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;Mono 4.8
nursery-size=4m      -&amp;gt; Time = ~75sec
nursery-size=64m     -&amp;gt; Time = ~47sec

Mono 5.2
nursery-size=4m      -&amp;gt; Time = ~95sec
nursery-size=64m     -&amp;gt; Time = ~40sec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After many additional checks on different solutions,
the nursery size was changed to &lt;code&gt;64 MB&lt;/code&gt; in Rider 2017.2,
it improved the startup experience for Linux and macOS users on huge solutions.&lt;/p&gt;
&lt;h3 id=&quot;default-way-to-get-statistics&quot;&gt;Default way to get statistics&lt;/h3&gt;
&lt;p&gt;You can also run mono with the &lt;code&gt;--stats&lt;/code&gt; arguments and get a lot of useful information includes a report about GC.
It looks like follows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GC statistics
Collection max time                 : 79.32 ms
Minor fragment clear                : 0.01 ms
Minor pinning                       : 6.78 ms
Minor scan remembered set           : 124.51 ms
Minor scan major blocks             : 47.46 ms
Minor scan los                      : 67.16 ms
Minor scan pinned                   : 0.01 ms
Minor scan roots                    : 14.70 ms
Minor fragment creation             : 1.38 ms
Major fragment clear                : 0.12 ms
Major pinning                       : 12.85 ms
Major scan pinned                   : 0.01 ms
Major scan roots                    : 128.16 ms
Major scan mod union blocks         : 48.61 ms
Major scan mod union los            : 4.63 ms
Major finish gray stack             : 190.74 ms
Major free big objects              : 0.00 ms
Major LOS sweep                     : 6.57 ms
Major sweep                         : 0.08 ms
Major fragment creation             : 0.56 ms
Number of pinned objects            : 11933
World stop                          : 7.60 ms
World restart                       : 2.77 ms
# major blocks allocated            : 9952
# major blocks freed                : 6202
# major blocks lazy swept           : 11
# major blocks freed ideally        : 2528
# major blocks freed less ideally   : 3674
# major blocks freed individually   : 0
# major blocks allocated less ideally: 0
# workers finished                  : 14
Memgov alloc                        : 190944712
Memgov max alloc                    : 318818244
Minor GC collections                : 14
Major GC collections                : 10
Minor GC time                       : 420.70 ms
Major GC time                       : 434.76 ms
Major GC time concurrent            : 757.94 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#39;s also a very useful trick, but I prefer to look at the distribution,
so I typically collect full information about all GC collections.&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;When you start a performance investigation,
you don&#39;t know the current runtime characteristics in advance.
These characteristics can be useful for initial hypotheses.
It&#39;s great when you can collect some high-level data without additional tools.
I like to start with a quick and dirty checks which allow me
to get a first impression about the current situation.&lt;/p&gt;
&lt;p&gt;Of course, you usually need advanced profiling tools for full performance investigations.
And you should use it at the end for verifying your hypotheses and making final conclusions.
But it&#39;s not always should be the first step because it takes too much time.
Also profilers are typically invasive tools,
the default &lt;a href=&quot;http://www.mono-project.com/docs/debug+profile/profile/profiler/&quot;&gt;Mono log profiler&lt;/a&gt; has huge overhead.
&lt;code&gt;MONO_LOG_LEVEL=debug&lt;/code&gt; is a non invasive approach with low overhead,
you need only ten seconds for the setup and
you can run it on a customer computer without additional tools.
Data can be processed with a small R script which can be easily modified
if you want to calculate some advanced statistics.&lt;/p&gt;</description>
        </item>
        <item>
            <title>BenchmarkDotNet v0.10.12</title>
            <link>http://aakinshin.net/posts/bdn-v0_10_12/</link> 
            <pubDate>Mon, 15 Jan 2018 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/bdn-v0_10_12/</guid>
            <description>&lt;p&gt;BenchmarkDotNet v0.10.12 has been released! This release includes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Improved DisassemblyDiagnoser:&lt;/strong&gt;
BenchmarkDotNet contains an embedded disassembler so that it can print assembly code for all benchmarks;
it&#39;s not easy, but the disassembler evolves in every release.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Improved MemoryDiagnoser:&lt;/strong&gt;
it has a better precision level, and it takes less time to evaluate memory allocations in a benchmark.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New TailCallDiagnoser:&lt;/strong&gt;
now you get notifications when JIT applies the tail call optimizations to your methods.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better environment info:&lt;/strong&gt;
when your share performance results, it&#39;s very important to share information about your environment.
The library generates the environment summary for you by default.
Now it contains information about the amount of physical CPU, physical cores, and logic cores.
If you run a benchmark on a virtual machine, you will get the name of the hypervisor
(e.g., Hyper-V, VMware, or VirtualBox).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better summary table:&lt;/strong&gt;
one of the greatest features of BenchmarkDotNet is the summary table.
It shows all important information about results in a compact and understandable form.
Now it has better customization options: you can display relative performance of different environments
(e.g., compare .NET Framework and .NET Core) and group benchmarks by categories.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;New GC settings:&lt;/strong&gt; now we support &lt;code&gt;NoAffinitize&lt;/code&gt;, &lt;code&gt;HeapAffinitizeMask&lt;/code&gt;, &lt;code&gt;HeapCount&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Other minor improvements and bug fixes&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;diagnosers&quot;&gt;Diagnosers&lt;/h3&gt;
&lt;p&gt;Diagnosers are helpers which print additional information about your benchmarks.&lt;/p&gt;
&lt;h4 id=&quot;improved-disassemblydiagnoser&quot;&gt;Improved DisassemblyDiagnoser&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;DisassemblyDiagnoser&lt;/code&gt; prints an assembly listing for your source code.
We already had this feature, but we continue to improve it.
Our goal is not just to provide a raw info about your code, but provide a comfortable way to explore the program internals.
In v0.10.12, Adam Sitnik (&lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;) &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/546&quot;&gt;implemented&lt;/a&gt;
advanced support of labels for jump targets.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When user hovers over a label, the mouse cursor changes to pointer and label get&#39;s highlighted&lt;/li&gt;
&lt;li&gt;When user clicks a label, all usages gets highlighted&lt;/li&gt;
&lt;li&gt;When user presses F3, we jump to next usage of given label&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/bdn-v0_10_12/disasm.gif&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/bdn-v0_10_12/disasm.gif&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h4 id=&quot;improved-memorydiagnoser&quot;&gt;Improved MemoryDiagnoser&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;MemoryDiagnoser&lt;/code&gt; show the memory traffic for each benchmark and the GC collection count for each generation.
In this release, we &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/606&quot;&gt;improved&lt;/a&gt; accuracy and
reduce the total time which you should spend to get the results.&lt;/p&gt;
&lt;h4 id=&quot;new-tailcalldiagnoser&quot;&gt;New TailCallDiagnoser&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/GeorgePlotnikov&quot;&gt;@GeorgePlotnikov&lt;/a&gt; implemented &lt;code&gt;TailCallDiagnoser&lt;/code&gt; which
detects &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail call&lt;/a&gt; optimizations and prints information about it.
This feature should be useful for F# developers.
Currently, it has some restrictions: it works only for x64 programs, and it&#39;s Windows-only.&lt;/p&gt;
&lt;p&gt;Demo:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Diagnostics.Windows.Configs.TailCallDiagnoser]
[LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job]
public class Jit_TailCalling
{
    [Benchmark]
    public long Calc()
        =&amp;gt; FactorialWithoutTailing(7) - FactorialWithTailing(7);

    private static long FactorialWithoutTailing(int depth)
        =&amp;gt; depth == 0 ? 1 : depth * FactorialWithoutTailing(depth - 1);

    private static long FactorialWithTailing(int pos, int depth)
        =&amp;gt; pos == 0 ? depth : FactorialWithTailing(pos - 1, depth * pos);

    private static long FactorialWithTailing(int depth)
        =&amp;gt; FactorialWithTailing(1, depth);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TailCallDiagnosers prints the following lines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// * Diagnostic Output - TailCallDiagnoser *
--------------------

--------------------
Jit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr)
--------------------

--------------------
Jit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr)
--------------------

--------------------
Jit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64)
--------------------
Caller: &amp;lt;null&amp;gt;.&amp;lt;null&amp;gt; - &amp;lt;null&amp;gt;
Callee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64  (int32,int32)
Tail prefix: False
Tail call type: RecursiveLoop
-------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;better-environment-info&quot;&gt;Better environment info&lt;/h3&gt;
&lt;p&gt;One of the most important parts of any performance report is the environment information.
People should understand what kind of machine did you use for your benchmarks.&lt;/p&gt;
&lt;p&gt;Irina Ananyeva (&lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;) &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/582&quot;&gt;implemented&lt;/a&gt; a cool feature
which displays the amount of physical CPU, logical cores, and physical cores (an example: &lt;code&gt;1 CPU, 8 logical cores and 4 physical cores&lt;/code&gt;).
Now the environment info section looks like this (it works on Windows/Linux/macOS; .NET Framework/.NET Core/Mono):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-md&quot;&gt;BenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192)
Intel Core i7-6700HQ CPU 2.60GHz (Skylake), 1 CPU, 8 logical cores and 4 physical cores
Frequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC
.NET Core SDK=2.0.3
  [Host] : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT
  Clr    : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0
  Core   : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT
  Mono   : Mono 5.4.0 (Visual Studio), 64bit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some people run benchmarks on virtual machines instead of real hardware,
and it&#39;s also an important fact.
With a new feature by Łukasz Pyrzyk (&lt;a href=&quot;https://github.com/lukasz-pyrzyk&quot;&gt;@lukasz-pyrzyk&lt;/a&gt;),
a special label (like &lt;code&gt;VM=VirtualBox&lt;/code&gt;) will be automatically added to the result.&lt;/p&gt;
&lt;h3 id=&quot;better-summary-table&quot;&gt;Better summary table&lt;/h3&gt;
&lt;p&gt;The summary table tries to help you understand performance data in a quick way.
In the old versions of BenchmarkDotNet, you can mark a method as a baseline and get &amp;quot;scaled&amp;quot; performance values for all other methods.
In v0.10.12 (thanks Marc Gravell (&lt;a href=&quot;https://github.com/mgravell&quot;&gt;@mgravell&lt;/a&gt;) for the &lt;a href=&quot;https://github.com/mgravell&quot;&gt;idea&lt;/a&gt;)),
you can introduce several baselines in a class (if you are using the benchmark categories) or
mark a job as a baseline (it allows evaluating the relative performance of different environments).&lt;/p&gt;
&lt;p&gt;Let&#39;s look at a few examples.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1: Methods&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;You can mark a method as a baseline with the help of &lt;code&gt;[Benchmark(Baseline = true)]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Sleeps
{
    [Benchmark]
    public void Time50() =&amp;gt; Thread.Sleep(50);

    [Benchmark(Baseline = true)]
    public void Time100() =&amp;gt; Thread.Sleep(100);

    [Benchmark]
    public void Time150() =&amp;gt; Thread.Sleep(150);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a result, you will have additional &lt;code&gt;Scaled&lt;/code&gt; column in the summary table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-md&quot;&gt;|  Method |      Mean |     Error |    StdDev | Scaled |
|-------- |----------:|----------:|----------:|-------:|
|  Time50 |  50.46 ms | 0.0779 ms | 0.0729 ms |   0.50 |
| Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms |   1.00 |
| Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms |   1.50 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example 2: Methods with categories&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The only way to have several baselines in the same class is to separate them by categories.
and mark the class with &lt;code&gt;[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)]
[CategoriesColumn]
public class Sleeps
{
    [BenchmarkCategory(&amp;quot;Fast&amp;quot;), Benchmark(Baseline = true)]        
    public void Time50() =&amp;gt; Thread.Sleep(50);

    [BenchmarkCategory(&amp;quot;Fast&amp;quot;), Benchmark]
    public void Time100() =&amp;gt; Thread.Sleep(100);
    
    [BenchmarkCategory(&amp;quot;Slow&amp;quot;), Benchmark(Baseline = true)]        
    public void Time550() =&amp;gt; Thread.Sleep(550);

    [BenchmarkCategory(&amp;quot;Slow&amp;quot;), Benchmark]
    public void Time600() =&amp;gt; Thread.Sleep(600);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-md&quot;&gt;|  Method | Categories |      Mean |     Error |    StdDev | Scaled |
|-------- |----------- |----------:|----------:|----------:|-------:|
|  Time50 |       Fast |  50.46 ms | 0.0745 ms | 0.0697 ms |   1.00 |
| Time100 |       Fast | 100.47 ms | 0.0955 ms | 0.0893 ms |   1.99 |
|         |            |           |           |           |        |
| Time550 |       Slow | 550.48 ms | 0.0525 ms | 0.0492 ms |   1.00 |
| Time600 |       Slow | 600.45 ms | 0.0396 ms | 0.0331 ms |   1.09 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Example 3: Jobs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you want to compare several runtime configurations,
you can mark one of your jobs with &lt;code&gt;isBaseline = true&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[ClrJob(isBaseline: true)]
[MonoJob]
[CoreJob]
public class RuntimeCompetition
{
    [Benchmark]
    public int SplitJoin() =&amp;gt; string.Join(&amp;quot;,&amp;quot;, new string[1000]).Split(&#39;,&#39;).Length;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-md&quot;&gt;    Method | Runtime |     Mean |     Error |    StdDev | Scaled | ScaledSD |
---------- |-------- |---------:|----------:|----------:|-------:|---------:|
 SplitJoin |     Clr | 19.42 us | 0.2447 us | 0.1910 us |   1.00 |     0.00 |
 SplitJoin |    Core | 13.00 us | 0.2183 us | 0.1935 us |   0.67 |     0.01 |
 SplitJoin |    Mono | 39.14 us | 0.7763 us | 1.3596 us |   2.02 |     0.07 |
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;new-gc-settings&quot;&gt;New GC Settings&lt;/h3&gt;
&lt;p&gt;BenchmarkDotNet allows configuring GC Settings for each job.
Now we &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/622&quot;&gt;support&lt;/a&gt; a few additional settings:
&lt;code&gt;NoAffinitize&lt;/code&gt;, &lt;code&gt;HeapAffinitizeMask&lt;/code&gt;, &lt;code&gt;HeapCount&lt;/code&gt;.
If you set them, the library generates &lt;code&gt;app.config&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
   &amp;lt;runtime&amp;gt;
      &amp;lt;GCHeapCount enabled=&amp;quot;6&amp;quot;/&amp;gt;
      &amp;lt;GCNoAffinitize enabled=&amp;quot;true&amp;quot;/&amp;gt;
      &amp;lt;GCHeapAffinitizeMask enabled=&amp;quot;144&amp;quot;/&amp;gt;
   &amp;lt;/runtime&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See the &lt;a href=&quot;https://support.microsoft.com/en-us/help/4014604/may-2017-description-of-the-quality-rollup-for-the-net-framework-4-6-4&quot;&gt;MSDN page&lt;/a&gt; for details.&lt;/p&gt;
&lt;h3 id=&quot;milestone-details&quot;&gt;Milestone details&lt;/h3&gt;
&lt;p&gt;In the &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.12&quot;&gt;v0.10.12&lt;/a&gt; scope,
14 issues were resolved and 10 pull requests where merged.
This release includes 42 commits by 9 contributors.&lt;/p&gt;
&lt;h4 id=&quot;resolved-issues-14&quot;&gt;Resolved issues (14)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/273&quot;&gt;#273&lt;/a&gt; Create a tail call diagnoser&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/543&quot;&gt;#543&lt;/a&gt; Run Disassembly Diagnoser without extra run (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/546&quot;&gt;#546&lt;/a&gt; Synthesizing labels for jump targets (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/574&quot;&gt;#574&lt;/a&gt; Display VM hypervisor in summary section (assignee: &lt;a href=&quot;https://github.com/lukasz-pyrzyk&quot;&gt;@lukasz-pyrzyk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/582&quot;&gt;#582&lt;/a&gt; Print amount of logical and physical core (assignee: &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/599&quot;&gt;#599&lt;/a&gt; Proper HTML escaping of BenchmarkAttribute Description&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/606&quot;&gt;#606&lt;/a&gt; Improve Memory Diagnoser (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/608&quot;&gt;#608&lt;/a&gt; Properly escaping generated markdown (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/612&quot;&gt;#612&lt;/a&gt; Disassembler DisassembleMethod fails with &amp;quot;Object reference not set to an instance of an object.&amp;quot;, (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/617&quot;&gt;#617&lt;/a&gt; Allow baseline per category (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/618&quot;&gt;#618&lt;/a&gt; Enable ApprovalTests in .NET Core 2.0 tests (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/621&quot;&gt;#621&lt;/a&gt; Try to search for missing references if build fails (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/622&quot;&gt;#622&lt;/a&gt; Support of new GC settings (assignee: &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/623&quot;&gt;#623&lt;/a&gt; RPlotExporter uses wrong path to csv measurements (assignee: &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;merged-pull-requests-10&quot;&gt;Merged pull requests (10)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/573&quot;&gt;#573&lt;/a&gt; Сreate a tail call diagnoser (by &lt;a href=&quot;https://github.com/GeorgePlotnikov&quot;&gt;@GeorgePlotnikov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/576&quot;&gt;#576&lt;/a&gt; Display VM name in summary section, fixes #574 (by &lt;a href=&quot;https://github.com/lukasz-pyrzyk&quot;&gt;@lukasz-pyrzyk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/595&quot;&gt;#595&lt;/a&gt; Migrate all project to new project system. (by &lt;a href=&quot;https://github.com/mfilippov&quot;&gt;@mfilippov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/598&quot;&gt;#598&lt;/a&gt; Added info about the new TailCallDiagnoser (by &lt;a href=&quot;https://github.com/GeorgePlotnikov&quot;&gt;@GeorgePlotnikov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/603&quot;&gt;#603&lt;/a&gt; Fix HTML Encoding for Html Exporter (by &lt;a href=&quot;https://github.com/Chrisgozd&quot;&gt;@Chrisgozd&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/605&quot;&gt;#605&lt;/a&gt; Grammar (by &lt;a href=&quot;https://github.com/onionhammer&quot;&gt;@onionhammer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/607&quot;&gt;#607&lt;/a&gt; Print amount of logical and physical core #582 (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/615&quot;&gt;#615&lt;/a&gt; Quick fix Disassembler.Program.GetMethod when more than one method found just return null (by &lt;a href=&quot;https://github.com/nietras&quot;&gt;@nietras&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/619&quot;&gt;#619&lt;/a&gt; Logical group support, fixes #617 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/620&quot;&gt;#620&lt;/a&gt; New README.md (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;commits-42&quot;&gt;Commits (42)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/6f587d99897ed67c94277c4c0d34f838e586ff92&quot;&gt;6f587d&lt;/a&gt; Migrate all project to new project system. (by &lt;a href=&quot;https://github.com/mfilippov&quot;&gt;@mfilippov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/47ba57d9e196a81710eb002eb3af4fb6401b7e78&quot;&gt;47ba57&lt;/a&gt; added info about the new TailCallDiagnoser (by &lt;a href=&quot;https://github.com/GeorgePlotnikov&quot;&gt;@GeorgePlotnikov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/c1a4b20b11165e696f198e0e68a0a5c2b991b65e&quot;&gt;c1a4b2&lt;/a&gt; Сreate a tail call diagnoser (#573) (by &lt;a href=&quot;https://github.com/GeorgePlotnikov&quot;&gt;@GeorgePlotnikov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/ebe3e2f90f2a974fdf1ec3524f8aa79674beccc5&quot;&gt;ebe3e2&lt;/a&gt; Merge pull request #598 from GeorgePlotnikov/patch-1 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/6249f0a4ee37904fac418cd8715af9d8f667c01d&quot;&gt;6249f0&lt;/a&gt; some polishing of the JIT diagnosers (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/119231c8ebf94673dcfdbd5bacc1cdfde4a294c4&quot;&gt;119231&lt;/a&gt; Fix HTML Encoding for Html Exporter (#603), fixes #599 (by &lt;a href=&quot;https://github.com/Chrisgozd&quot;&gt;@Chrisgozd&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/fe3f3046c26ef0a63e55c7f97651b5ee815e22ee&quot;&gt;fe3f30&lt;/a&gt; Disassembly Prettifier, fixes #546 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/3eb63ff8c6b4a571423bc2b2d2cf086e1c2f993f&quot;&gt;3eb63f&lt;/a&gt; Merge pull request #595 from mfilippov/new-fs-vb-proj (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/16d03f65cd6198fd0003c7608a986b823c638538&quot;&gt;16d03f&lt;/a&gt; make our F# samples work for .NET Core 2.0 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/d06de7af52d60a5d92b3665e9d20b0be3dfc29e7&quot;&gt;d06de7&lt;/a&gt; bring back our old Visual Basic and F# integration tests (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/63249b50ec6dfeb6719ba9edb911404e16bf7f02&quot;&gt;63249b&lt;/a&gt; &amp;quot;Kaby Lake R&amp;quot; and &amp;quot;Coffee Lake&amp;quot; support in ProcessorBrandStringHelper (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/a8a09ebbc86c51167cf90f18c1658d52afcf1b70&quot;&gt;a8a09e&lt;/a&gt; disassembly prettifier: highlighting references to labels, jumping to next on... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e6d747efd2d19380d8da388cceb3471b5e894dbd&quot;&gt;e6d747&lt;/a&gt; Grammar (by &lt;a href=&quot;https://github.com/onionhammer&quot;&gt;@onionhammer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/fef4aa67b3c3bf6aac8f2281ee8fbd763660cba4&quot;&gt;fef4aa&lt;/a&gt; Merge pull request #605 from onionhammer/patch-1 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/ffacd74b63f364e88aa8afa597fbbc84d6a564c2&quot;&gt;ffacd7&lt;/a&gt; don&#39;t require extra run for DisassemblyDiagnoser, fixes #543, #542 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/bcac26452dbed7ba310ecef8a4ec0814cd22591d&quot;&gt;bcac26&lt;/a&gt; revert last commit change (run global setup regardless of Jitting) (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/3e87d8699b27751ef05e8303f6ccb1f6d9c74b44&quot;&gt;3e87d8&lt;/a&gt; don&#39;t perform an extra run to get GC stats for .NET Core, part of #550 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f87dbc5357e7f15d7913e2136ac73c8d1af8cfd1&quot;&gt;f87dbc&lt;/a&gt; obtain GC stats in separate iteration run, no overhead, support for iteration... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e5fe0f87dc0043a10648faf01fc29805624c5c3a&quot;&gt;e5fe0f&lt;/a&gt; update to C# 7.1 so we can use all the latest features (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/bc50b2e851aabe15c47656897ef5024279e4e31c&quot;&gt;bc50b2&lt;/a&gt; build benchmarks in Parallel, part of #550 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e595902a377085cb2f44fca6fcab3efae82cda06&quot;&gt;e59590&lt;/a&gt; Display VM name in summary section, fixes #574 (#576) (by &lt;a href=&quot;https://github.com/lukasz-pyrzyk&quot;&gt;@lukasz-pyrzyk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/8908f8798f0914ce6abe925a0c14e063ace6964d&quot;&gt;8908f8&lt;/a&gt; fix GetMethod (by &lt;a href=&quot;https://github.com/nietras&quot;&gt;@nietras&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/4ca82db5857cda64732743bb5e47199f4300fcf5&quot;&gt;4ca82d&lt;/a&gt; Merge pull request #615 from nietras/disassembler-more-than-one-method-fix (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/387ae54f1fedffb78f5955c7935034ecde3cc856&quot;&gt;387ae5&lt;/a&gt; be more defensive when trying to read source code with disassembler, part of ... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7038155d914e5679696b17d18524e8066256d14e&quot;&gt;703815&lt;/a&gt; docs: how to contribute to disassembler (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/242671b88d188827f0cc83a6da1dfef4986f2e03&quot;&gt;242671&lt;/a&gt; Enable ApprovalTests in .NET Core 2.0 tests, fixes #618 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/c4d21bf7e7a022c6cffcc59ddd35415a83b93243&quot;&gt;c4d21b&lt;/a&gt; Print amount of logical and physical core #582 (#607) (by &lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e33e848e1679fc5ceb88ec27dc9ecad1041b0a34&quot;&gt;e33e84&lt;/a&gt; Add HtmlReady dialect for MarkdownExporter, fixes #608 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/cf167b9f092abc157677081bbf2955ee50ad6934&quot;&gt;cf167b&lt;/a&gt; Enable html escaping for GitHub markdown dialect, fixes #608 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/8bb28b30a0a2913ce8a92af8c60e27884cd7a90c&quot;&gt;8bb28b&lt;/a&gt; Logical group support, fixes #617 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/ae87c6d54670f21707069c7d4b432ba886212312&quot;&gt;ae87c6&lt;/a&gt; Merge pull request #619 from dotnet/logical-groups (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/14e90bfce8c1430b6235dd6c6e7e94d7136b0d67&quot;&gt;14e90b&lt;/a&gt; parallel build post fix: don&#39;t write the compilation errors to NullLogger, re... (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/db4ae81451251aaf5cce62b4bf059de9642e54f1&quot;&gt;db4ae8&lt;/a&gt; Try to search for missing references if build fails, fixes #621 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/0eba0f548400531c7992f0b12d7d1766e213ba9b&quot;&gt;0eba0f&lt;/a&gt; Support of new GC settings, fixes #622 (by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/e31b2d410def2b7f3941ff44059d0ffdce0dc2ab&quot;&gt;e31b2d&lt;/a&gt; Revert Samples/Program.cs (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/7f126ba124137155b146340f29117e0872be6d3e&quot;&gt;7f126b&lt;/a&gt; Add logs in RPlotExporter (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f8a4477120bcc8034fe5611db4de823b798cfe3a&quot;&gt;f8a447&lt;/a&gt; Fix path to csv in RPlotExporter, fixes #623 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/273f5083babb4d7fd19843cbf2a9401a68568e6c&quot;&gt;273f50&lt;/a&gt; New plots in RPlotExporter (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/f293f0d5cb6ac42457a22a7637af4bd979f2e131&quot;&gt;f293f0&lt;/a&gt; New README.md (#620) (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/5e3366729a9cd0a3064d90732610c3957d7f3efb&quot;&gt;5e3366&lt;/a&gt; Update copyright year in docs (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/ab74588dd79961887879d83bca0db590966bdc40&quot;&gt;ab7458&lt;/a&gt; Update index in docs (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/4616d48e55cc06ab777b1a5b14d95672df2a22f5&quot;&gt;4616d4&lt;/a&gt; Set library version: 0.10.12 (by &lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;contributors-9&quot;&gt;Contributors (9)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Adam Sitnik (&lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Andrey Akinshin (&lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Christopher Gozdziewski (&lt;a href=&quot;https://github.com/Chrisgozd&quot;&gt;@Chrisgozd&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Erik O&#39;Leary (&lt;a href=&quot;https://github.com/onionhammer&quot;&gt;@onionhammer&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;George Plotnikov (&lt;a href=&quot;https://github.com/GeorgePlotnikov&quot;&gt;@GeorgePlotnikov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Irina Ananyeva (&lt;a href=&quot;https://github.com/morgan-kn&quot;&gt;@morgan-kn&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Łukasz Pyrzyk (&lt;a href=&quot;https://github.com/lukasz-pyrzyk&quot;&gt;@lukasz-pyrzyk&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Mikhail Filippov (&lt;a href=&quot;https://github.com/mfilippov&quot;&gt;@mfilippov&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;nietras (&lt;a href=&quot;https://github.com/nietras&quot;&gt;@nietras&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thank you very much!&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://benchmarkdotnet.org/&quot;&gt;Official documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/wiki/ChangeLog&quot;&gt;ChangeLog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/BenchmarkDotNet/0.10.12&quot;&gt;NuGet package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.12&quot;&gt;v0.10.12 milestone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.11...v0.10.12&quot;&gt;v0.10.12 commits&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>BenchmarkDotNet v0.10.10</title>
            <link>http://aakinshin.net/posts/bdn-v0_10_10/</link> 
            <pubDate>Fri, 03 Nov 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/bdn-v0_10_10/</guid>
            <description>&lt;p&gt;BenchmarkDotNet v0.10.10 has been released!
This release includes many new features like Disassembly Diagnoser, ParamsSources, .NET Core x86 support, Environment variables, and more!&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;highlights&quot;&gt;Highlights&lt;/h3&gt;
&lt;p&gt;There are so many changes in this version!
In this post, I&#39;m going to tell you about the most useful features.&lt;/p&gt;
&lt;h4 id=&quot;disassembly-diagnoser&quot;&gt;Disassembly Diagnoser&lt;/h4&gt;
&lt;p&gt;This feature by &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt; allows looking at the assembly code of your methods.
It really helps when you investigate some CPU-bound benchmarks.
BenchmarkDotNet not only shows naive disasm, but it also prettify the listing can work with hardware counters:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/bdn-v0_10_10/branchpredictor.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/bdn-v0_10_10/branchpredictor.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;You can find the full info in the &lt;a href=&quot;http://adamsitnik.com/Disassembly-Diagnoser/&quot;&gt;Disassembling .NET Code with BenchmarkDotNet&lt;/a&gt; blog post by Adam Sitnik.&lt;/p&gt;
&lt;p&gt;It turned out that this feature is useful for comparing assembly for different versions of .NET JIT-compilers.
Check out a recent post from Microsoft .NET Blog by Joseph Tremoulet:
&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/10/16/ryujit-just-in-time-compiler-optimization-enhancements/&quot;&gt;RyuJIT Just-in-Time Compiler Optimization Enhancements&lt;/a&gt;.
In this post, Joseph compares RyuJIT assembly code for .NET Core 2.0 RTM and .NET Core 2.1.0-preview1-25719-04.&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/bdn-v0_10_10/ryujit.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/bdn-v0_10_10/ryujit.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It&#39;s really great to see that BenchmarkDotNet helps to develop such products like .NET Core.
By the way, the development process is also useful for BenchmarkDotNet.
Here are some great bug reports by Joseph which were fixed by Adam:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/535&quot;&gt;#535&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/536&quot;&gt;#536&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/559&quot;&gt;#559&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/562&quot;&gt;#562&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now BenchmarkDotNet can produce assembly for .NET Framework and .NET Core; Mono support is coming soon.
Of course, we have also many additional feature requests:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/543&quot;&gt;#543&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/544&quot;&gt;#544&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/545&quot;&gt;#545&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/546&quot;&gt;#546&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/560&quot;&gt;#560&lt;/a&gt;
(any help will be highly appreciated).&lt;/p&gt;
&lt;h4 id=&quot;paramssources&quot;&gt;ParamsSources&lt;/h4&gt;
&lt;p&gt;BenchmarkDotNet allows to parametrize your benchmark and run it against several parameter values.
v0.10.9 supported only a constant set of parameters which should be declared inside the attribute;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Params(100, 200)]
public int A { get; set; }

[Params(10, 20)]
public int B { get; set; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#39;s not always convenient, sometimes we need a way to define parameter values dynamically.
Now you can do it!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[ParamsSource(nameof(ValuesForA))]
public int A { get; set; } // property with public setter

[ParamsSource(nameof(ValuesForB))]
public int B; // public field

public IEnumerable&amp;lt;int&amp;gt; ValuesForA =&amp;gt; new[] { 100, 200 }; // public property

public static IEnumerable&amp;lt;int&amp;gt; ValuesForB() =&amp;gt; new[] { 10, 20 }; // public static method
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See also:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/350&quot;&gt;#350&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/571&quot;&gt;#571&lt;/a&gt;
and &lt;a href=&quot;http://benchmarkdotnet.org/Advanced/Params.htm&quot;&gt;docs&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;net-core-x86-support&quot;&gt;.NET Core x86 support&lt;/h4&gt;
&lt;p&gt;Since .NET Core 2.0, we can run it not only on x64, but also on x86.
If we have both versions of runtime installed, we can try the same code on both platforms at the same time.
Here is a config for you:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class CustomPathsConfig : ManualConfig
{
    public CustomPathsConfig() 
    {
        var dotnetCli32bit = NetCoreAppSettings
            .NetCoreApp20
            .WithCustomDotNetCliPath(@&amp;quot;C:\Program Files (x86)\dotnet\dotnet.exe&amp;quot;, &amp;quot;32 bit cli&amp;quot;);

        var dotnetCli64bit = NetCoreAppSettings
            .NetCoreApp20
            .WithCustomDotNetCliPath(@&amp;quot;C:\Program Files\dotnet\dotnet.exe&amp;quot;, &amp;quot;64 bit cli&amp;quot;);

        Add(Job.RyuJitX86.With(CsProjCoreToolchain.From(dotnetCli32bit)).WithId(&amp;quot;32 bit cli&amp;quot;));
        Add(Job.RyuJitX64.With(CsProjCoreToolchain.From(dotnetCli64bit)).WithId(&amp;quot;64 bit cli&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See also:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/310&quot;&gt;#310&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/534&quot;&gt;#534&lt;/a&gt;
and &lt;a href=&quot;http://benchmarkdotnet.org/Configs/Toolchains.htm&quot;&gt;docs&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;environment-variables-and-mono-args&quot;&gt;Environment variables and Mono args&lt;/h4&gt;
&lt;p&gt;One of the keys features of BenchmarkDotNet is comparing different environments.
And we add more and more options for you in each release.
Now you can specify Mono arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ConfigWithCustomArguments : ManualConfig
{
    public ConfigWithCustomArguments()
    {
        // --optimize=MODE , -O=mode
        // MODE is a comma separated list of optimizations. They also allow
        // optimizations to be turned off by prefixing the optimization name with a minus sign.

        Add(Job.Mono.With(new[] { new MonoArgument(&amp;quot;--optimize=inline&amp;quot;) }).WithId(&amp;quot;Inlining enabled&amp;quot;));
        Add(Job.Mono.With(new[] { new MonoArgument(&amp;quot;--optimize=-inline&amp;quot;) }).WithId(&amp;quot;Inlining disabled&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And environment variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ConfigWithCustomEnvVars : ManualConfig
{
    public ConfigWithCustomEnvVars()
    {
        Add(Job.Core.WithId(&amp;quot;Inlining enabled&amp;quot;));
        Add(Job.Core.With(
            new[] { new EnvironmentVariable(&amp;quot;COMPlus_JitNoInline&amp;quot;, &amp;quot;1&amp;quot;) })
            .WithId(&amp;quot;Inlining disabled&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can find hundreds of runtime knobs &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/project-docs/clr-configuration-knobs.md&quot;&gt;here&lt;/a&gt;.
Now it&#39;s so easy to compare performance between different knobs values!&lt;/p&gt;
&lt;p&gt;See also: &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/262&quot;&gt;#262&lt;/a&gt; and &lt;a href=&quot;http://benchmarkdotnet.org/Advanced/CustomizingMono.htm&quot;&gt;docs&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;better-environment-description&quot;&gt;Better environment description&lt;/h4&gt;
&lt;p&gt;When BenchmarkDotNet prints the summary about benchmarks, it always shows brief information about our environment.
Now we can detect situation when you run a benchmark on a virtual machine (at least, in some cases)
and print a warning about it
(thanks &lt;a href=&quot;https://github.com/lukasz-pyrzyk&quot;&gt;@lukasz-pyrzyk&lt;/a&gt;;
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/167&quot;&gt;#167&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/527&quot;&gt;#527&lt;/a&gt;).
We support detecting &lt;code&gt;HyperV&lt;/code&gt;, &lt;code&gt;VirtualBox&lt;/code&gt;, &lt;code&gt;VMware&lt;/code&gt; (Windows only for now).&lt;/p&gt;
&lt;p&gt;Also now we support Windows 10 [1709, Fall Creators Update] and always print the revision number of Windows 10 version
(like &lt;code&gt;10.0.15063.674&lt;/code&gt; instead of &lt;code&gt;10.0.15063&lt;/code&gt;).&lt;/p&gt;
&lt;h4 id=&quot;more&quot;&gt;More&lt;/h4&gt;
&lt;p&gt;Of course, v0.10.10 includes not only new features but also additional sections in the documentation, bug fixes, build script improvements, internal refactoring.
It&#39;s not so exciting to write about such stuff in the release notes, but it&#39;s also very important changes which improve the overall quality of the library.&lt;/p&gt;
&lt;h3 id=&quot;issues-and-pull-requests&quot;&gt;Issues and Pull Requests&lt;/h3&gt;
&lt;p&gt;In the v0.10.10 scope, &lt;strong&gt;34&lt;/strong&gt; issues were resolved and &lt;strong&gt;18&lt;/strong&gt; pull requests were merged.
This release includes &lt;strong&gt;95&lt;/strong&gt; commits by &lt;strong&gt;12&lt;/strong&gt; contributors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/aidmsu&quot;&gt;@aidmsu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AndreyAkinshin&quot;&gt;@AndreyAkinshin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ig-sinicyn&quot;&gt;@ig-sinicyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ipjohnson&quot;&gt;@ipjohnson&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jawn&quot;&gt;@jawn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Jiri Cincura&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Ky7m&quot;&gt;@Ky7m&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/lukasz-pyrzyk&quot;&gt;@lukasz-pyrzyk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/pentp&quot;&gt;@pentp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rolshevsky&quot;&gt;@rolshevsky&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Teknikaali&quot;&gt;@Teknikaali&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thank you very much!&lt;/p&gt;
&lt;h4 id=&quot;resolved-issues&quot;&gt;Resolved Issues&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/160&quot;&gt;#160&lt;/a&gt; Make ClrMd Source diagnoser working with new ClrMD api&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/167&quot;&gt;#167&lt;/a&gt; Detect virtual machine environment&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/262&quot;&gt;#262&lt;/a&gt; Runtime knobs&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/310&quot;&gt;#310&lt;/a&gt; Support 32bit benchmarks for .NET Core&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/350&quot;&gt;#350&lt;/a&gt; ParamsSource&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/437&quot;&gt;#437&lt;/a&gt; Add DisassemblyDiagnoser for outputting disassembled JITed code&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/466&quot;&gt;#466&lt;/a&gt; MSBuild parameters are not passed to generated benchmark project&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/495&quot;&gt;#495&lt;/a&gt; Attributes put on base methods are not considered in derived class&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/500&quot;&gt;#500&lt;/a&gt; Borken compilation for net46 projects when .NET Framework 4.7 is installed&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/505&quot;&gt;#505&lt;/a&gt; JsonExporterBase doesn&#39;t include MemoryDiagnoser stats in output&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/511&quot;&gt;#511&lt;/a&gt; [bug] Bug in GetTargetedMatchingMethod() logic&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/513&quot;&gt;#513&lt;/a&gt; IterationSetup not run in Job.InProcess&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/516&quot;&gt;#516&lt;/a&gt; Get a compilation error &amp;quot;CS1009: Unrecognized escape sequence&amp;quot; when using verbatim strings&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/519&quot;&gt;#519&lt;/a&gt; BenchmarkSwitcher.RunAllJoined throws InvalidOperationException&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/526&quot;&gt;#526&lt;/a&gt; Remove project.json support&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/529&quot;&gt;#529&lt;/a&gt; No namespace in export filenames can lead to data loss&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/530&quot;&gt;#530&lt;/a&gt; Build error on Appveyor with recent changes&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/533&quot;&gt;#533&lt;/a&gt; When I clone, build, and run BenchmarkDotNet.Samples I get an error&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/534&quot;&gt;#534&lt;/a&gt; Allow the users to compare 32 vs 64 RyuJit for .NET Core&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/535&quot;&gt;#535&lt;/a&gt; No way to set RuntimeFrameworkVersion in multiple-version config&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/536&quot;&gt;#536&lt;/a&gt; Strange disassembly ordering/truncation&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/537&quot;&gt;#537&lt;/a&gt; Can&#39;t benchmark a netstandard2.0 project&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/538&quot;&gt;#538&lt;/a&gt; Duplicate using causing benchmark not to work&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/539&quot;&gt;#539&lt;/a&gt; Target .NET Core 2.0 to take advantage of the new APIs&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/540&quot;&gt;#540&lt;/a&gt; Artifacts for disassembler projects&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/542&quot;&gt;#542&lt;/a&gt; Problems with Disassembler + Job.Dry&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/555&quot;&gt;#555&lt;/a&gt; Test &amp;quot;CanDisassembleAllMethodCalls&amp;quot; fails on Ubuntu&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/556&quot;&gt;#556&lt;/a&gt; Table in report is broken in VSCode markdown viewer&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/558&quot;&gt;#558&lt;/a&gt; Warn the users when running Benchmarks from xUnit with shadow copy enabled&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/559&quot;&gt;#559&lt;/a&gt; DissassemblyDiagnoser jit/arch info seems to be wrong&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/561&quot;&gt;#561&lt;/a&gt; Strange behaviour when benchmark project is build in debug mode&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/562&quot;&gt;#562&lt;/a&gt; DisassemblyDiagnoser crashes on overloaded benchmark&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/564&quot;&gt;#564&lt;/a&gt; [Bug] Benchmarking a method doesn&#39;t run global setup when filter is applied&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/571&quot;&gt;#571&lt;/a&gt; Allow users to use non compile-time constants as Parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;merged-pull-requests&quot;&gt;Merged Pull Requests&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/507&quot;&gt;#507&lt;/a&gt; Fix a typo in Jobs.md&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/508&quot;&gt;#508&lt;/a&gt; Fixed some typos and grammar&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/512&quot;&gt;#512&lt;/a&gt; Warning about antivirus software after benchmark failure&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/514&quot;&gt;#514&lt;/a&gt; #495 - Unit test for reading attributes from the base class&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/515&quot;&gt;#515&lt;/a&gt; Fix #513 - IterationSetup not run in Job.InProcess&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/518&quot;&gt;#518&lt;/a&gt; Fixed information about MemoryDiagnoser&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/520&quot;&gt;#520&lt;/a&gt; XML Exporter documentation and samples&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/525&quot;&gt;#525&lt;/a&gt; adding validator for setup cleanup attributes&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/527&quot;&gt;#527&lt;/a&gt; Detecting virtual machine hypervisor, #167&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/531&quot;&gt;#531&lt;/a&gt; Remove --no-build argument for dotnet test &amp;amp; pack commands&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/532&quot;&gt;#532&lt;/a&gt; Fix type of local in EmitInvokeMultipleBody&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/547&quot;&gt;#547&lt;/a&gt; Fix markdown headers&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/548&quot;&gt;#548&lt;/a&gt; Fix condition in package reference list and update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/549&quot;&gt;#549&lt;/a&gt; Project files cleanup&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/552&quot;&gt;#552&lt;/a&gt; Fix exporters to use fully qualified filenames&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/563&quot;&gt;#563&lt;/a&gt; Remove leading space character in a MD table row, #556&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/565&quot;&gt;#565&lt;/a&gt; Single point of full config creation&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/pull/569&quot;&gt;#569&lt;/a&gt; Update cakebuild scripts&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet on GitHub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://benchmarkdotnet.org/&quot;&gt;Official documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/wiki/ChangeLog&quot;&gt;ChangeLog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.10&quot;&gt;v0.10.10 milestone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/compare/v0.10.9...v0.10.10&quot;&gt;v0.10.10 commits&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Reflecting on performance testing</title>
            <link>http://aakinshin.net/posts/reflecting-on-performance-testing/</link> 
            <pubDate>Tue, 01 Aug 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/reflecting-on-performance-testing/</guid>
            <description>&lt;p&gt;Performance is an important feature for many projects.
Unfortunately, it&#39;s an all too common situation when a developer accidentally spoils the performance adding some new code.
After a series of such incidents, people often start to think about performance regression testing.&lt;/p&gt;
&lt;p&gt;As developers, we write unit tests all the time.
These tests check that our business logic work as designed and that new features don&#39;t break existing code.
It looks like a good idea to write some perf tests as well, which will verify that we don&#39;t have any performance regressions.&lt;/p&gt;
&lt;p&gt;Turns out this is harder than it sounds.
A lot of developers don&#39;t write perf tests at all.
Some teams write perf tests, but almost all of them use their own infrastructure for analysis
(which is not a bad thing in general because it&#39;s usually designed for specific projects and requirements).
There are a lot of books about test-driven development (TDD),
but there are no books about performance-driven development (PDD).
There are well-known libraries for unit-testing (like xUnit/NUnit/MSTest for .NET),
but there are almost no libraries for performance regression testing.
Yeah, of course, there are &lt;em&gt;some&lt;/em&gt; libraries which you can use.
But there are troubles with &lt;em&gt;well-known all recognized&lt;/em&gt; libraries, approaches, and tools.
Ask your colleagues about it: some of them will give you different answers, the rest of them will start Googling it.&lt;/p&gt;
&lt;p&gt;There is no common understanding of what performance testing should look like.
This situation exists because it&#39;s really hard to develop a solution which solves &lt;em&gt;all problems&lt;/em&gt; for &lt;em&gt;all kind of projects&lt;/em&gt;.
However, it doesn&#39;t mean that we shouldn&#39;t try.
And we should try, we should share our experience and discuss best practices.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Probably some of you know that I&#39;m the maintainer of &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;
(a popular .NET library for benchmarking).
It was designed as a library for benchmarking (especially for microbenchmarking), but not for regression testing.
However, more and more people ask how they can use it as a part of continues integration systems.
And it&#39;s a good idea to have a way to automatically prevent performance degradations.
Unfortunately, it&#39;s not enough to just run code several times and collect some statistics (and other typical benchmarking stuff).
There are a lot of additional challenges which should be solved before I can recommend this library for perf tests.&lt;/p&gt;
&lt;p&gt;At JetBrains, I&#39;m working on &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt;.
It&#39;s a cool cross-platform .NET IDE which is based on the IntelliJ platform and ReSharper.
It&#39;s a huge product with millions of lines of code and a crazy performance space.
Rider should be super-responsive and fast on any OS — performance is one of our best features.
It&#39;s so easy to write some code which spoils this for some people, and it&#39;s so hard to check it manually every time.
We already have some simple performance tests, but we feel like it&#39;s not enough.
Right now I&#39;m working on a new workflow for regression analysis and monitoring.
This system is not ready yet, but it already helped in finding some interesting performance anomalies.
However, I don&#39;t want to write another tool which can be used only for one project.
It would be nice to write a tool (and open source it) which can be easily adapted for a wide range of different projects.&lt;/p&gt;
&lt;p&gt;I write this post because I want to get some feedback.
I&#39;m going to briefly describe some basic problems of performance regression testing and suggest some points of discussion.
I would like to hear any kind of information about performance regression testing.
Do you practice it?
What kind of problems do you have?
How you solve it?
What kind of tools and approaches do you use?&lt;/p&gt;
&lt;p&gt;Ok, let&#39;s start a discussion with a short list of typical issues which can destroy all the fun of performance testing.&lt;/p&gt;
&lt;h3 id=&quot;problems&quot;&gt;Problems&lt;/h3&gt;
&lt;p&gt;Let&#39;s say we write a program which prints a number which somehow describes performance of our system.
It doesn&#39;t matter whether it is a super-reliable benchmark with many repetitions or a simple &amp;quot;let&#39;s take a few timestamps&amp;quot; approach.
The main point here is we have a program which provides a perf number (or a set of numbers), and we are completely satisfied with it.
Is our performance test ready when we have such number?
No!
We even didn&#39;t start to talk about testing.&lt;/p&gt;
&lt;h4 id=&quot;type-i-and-type-ii-errors&quot;&gt;Type I and Type II errors&lt;/h4&gt;
&lt;p&gt;The main point of performance testing (and any other kind of testing) is that it should be automatic.
We should be automatically notified if we have any kind of performance degradation.
The question then is: how should we define &lt;em&gt;a performance degradation&lt;/em&gt;?
At this point, many developers start to read about confidence intervals, statistics tests, p-values, and so on.
Sometimes I hear sentences like &amp;quot;The probability of performance degradation is 80%.&amp;quot;
This doesn&#39;t make any sense!
You have a degradation, or you don&#39;t have a degradation.
Otherwise, you have problems with your definition of a degradation.
You can&#39;t say to a developer something like &amp;quot;you must investigate this problem with 80% probability.&amp;quot;
The outcome of your checking system should be binary.
And here we should talk about &lt;a href=&quot;https://en.wikipedia.org/wiki/Type_I_and_type_II_errors&quot;&gt;Type I and type II errors&lt;/a&gt;.
Sometimes you will be notified about problems, but there aren&#39;t any problems.
When developers get a lot of such false alarms, they start to ignore it, and the whole idea stops making sense and loses value.
Sometimes, there are some critical performance problems, but you will not be notified.
In this case, you can miss the degradation and deploy a slow version of your software (the whole idea does not work).&lt;/p&gt;
&lt;p&gt;We should implement such checking system which minimizes both kinds of errors.
Very often this a project-specific and a team-specific problem.
It&#39;s impossible to write one set of conditions which makes everyone happy.
But we can try to create presets which help to quickly choose a good solution for your business requirements.&lt;/p&gt;
&lt;h4 id=&quot;small-amount-of-data&quot;&gt;Small amount of data&lt;/h4&gt;
&lt;p&gt;In theory, we can do as many iterations as we like.
It allows getting a huge data sets,
apply some statistical magic,
calculate all possible statistical characteristics,
and answer all our question include the ultimate question of life, the universe, and everything.
In practice, performance data is expensive.
We pay for it by the time of our CI server and the time of developers which should wait for the results.
Some of the performance tests (especially integration tests) could take minutes or even hours.
It would be nice to get the sample size N=1000, but sometimes our N is 3..5 or even 1.
A single measurement (+plus some historical data),
no information about the distribution,
but we still have to answer: do we have a performance degradation or not?&lt;/p&gt;
&lt;h4 id=&quot;tricky-distributions&quot;&gt;Tricky distributions&lt;/h4&gt;
&lt;p&gt;Even if we have enough data about the performance distributions,
this distribution usually looks strange.
Don&#39;t expect to see a lot of normal distributions, when you are working with performance.
Here are typical problems which you can get:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Huge standard deviation: the difference between sequential measurements (for the same codebase) can be huge&lt;/li&gt;
&lt;li&gt;Outliers: sometimes you get extremely high durations because of some unknown reasons
(especially if you have many I/O or network operation; or just have another heavy processes on the same build agent).&lt;/li&gt;
&lt;li&gt;Multimodal distribution: a distribution can have several local maximums
and you can&#39;t control which mode will be &amp;quot;activated&amp;quot; in each measurement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here is some historical data about duration of a single test from Rider:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/reflecting-on-performance-testing/plot1.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/reflecting-on-performance-testing/plot1.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The blue points denote Windows, the purple denote Linux, the yellow denote MacOS.
On the Y axis, you can see the amount of milliseconds.
Yes, two sequential measurements can be 100 seconds and 900 seconds.
It&#39;s a normal situation for an integration test.
(To be honest, it&#39;s one of the worst our tests, everything is not so bad in general.)
And yes, I know that&#39;s it&#39;s not a good performance test, I know what should be improved here, and so on.
I don&#39;t want to discuss how it happens (it&#39;s a topic for another post), I just want to show what real performance data can look like.
What happens if we make a mistake and wrote &lt;code&gt;Thread.Sleep(20 * 1000)&lt;/code&gt; somewhere?
Nothing!
No one will notice it (on this test at least).&lt;/p&gt;
&lt;p&gt;So, we should understand what our performance data looks like and understand what kind of checks we can apply in each situation.&lt;/p&gt;
&lt;h4 id=&quot;different-hardware-and-many-environments&quot;&gt;Different hardware and many environments&lt;/h4&gt;
&lt;p&gt;As you probably noticed on the previous image, the performance on different operating systems is different.
The easiest thing to say here is something like &amp;quot;Well, nothing special in this picture, .NET works well only on Windows&amp;quot;.
Here is another image for you:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/reflecting-on-performance-testing/plot2.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/reflecting-on-performance-testing/plot2.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;In this test, Linux takes around 100ms all the time, MacOS takes 100—200ms, Windows takes 1000-1200ms.
Why? That&#39;s also a topic for another post (a hint: this test is socket-related).
The point here is we have different performance configurations on different tests.
And we can&#39;t mix measurements from different operation systems (in general).
There are a lot of other parameters which can be considered.
For example, some of the build agents have an HDD, and some of them have an SSD which definitely affects all I/O bound tests.
Some of the build agents can have a small amount of RAM which can affect tests with massive memory traffic.
&lt;em&gt;In general&lt;/em&gt;, we can&#39;t compare absolute numbers from different machines if there are any differences in hardware configuration.
Even minor differences in the CPU model can play a vital role.
Sometimes, it&#39;s possible to analyze relative performance, but it&#39;s not always an option.&lt;/p&gt;
&lt;p&gt;It&#39;s great if you can buy several dedicated machines which will execute performance tests 24/7.
(And if you can replace broken perf machines with machines that have exactly the same configuration.)
However, it&#39;s another trade-off question:
how many tests do you want to run,
how many times do you want to repeat them,
how long does it take,
how many performance machines can you afford?&lt;/p&gt;
&lt;h4 id=&quot;microbenchmarks-vs.integration-benchmarks&quot;&gt;Microbenchmarks vs. integration benchmarks&lt;/h4&gt;
&lt;p&gt;As I mentioned before, BenchmarkDotNet is designed for microbenchmarks.
It can measure a method even if it takes a few nanoseconds.
It not easy, but BenchmarkDotNet protects you from even super-tiny performance deviations.
For this purpose, it generates a separate project where it invokes the method billions of times.&lt;/p&gt;
&lt;p&gt;But here is another situation.
Let&#39;s say we write Rider, and we want to measure how much does it take to debug a unit-test in a .NET Core project.
How many processes do we need?
Let&#39;s count.
We need a process for the &lt;code&gt;IntelliJ IDEA&lt;/code&gt; platform (aka frontend), a process for the &lt;code&gt;ReSharper host&lt;/code&gt; (aka backend).
Because of some infrastructure reasons,
we start tests on the frontend (we write it on Kotlin and run it on JVM),
but the benchmarking logic which should control the experiment is written in C#.
So, we have to add a process for the &lt;code&gt;BenchmarkDotNet host&lt;/code&gt; (yeah, I want to support some kind of distributed benchmarks).
Next, we should load the project model with the help of &lt;code&gt;MSBuild&lt;/code&gt; (another process for MSBuild),
discover tests with one &lt;code&gt;dotnet&lt;/code&gt; process,
run tests with another &lt;code&gt;dotnet&lt;/code&gt; process,
and attach to it from a &lt;code&gt;DebuggerWorker&lt;/code&gt; process.
Thus, our small integration benchmark involves 7 processes.
There now are huge amount of cases where we can&#39;t get super-precision
(because of cross-process interaction, 3rd logic, etc.),
so standard deviation will be huge.
The total duration is several dozens of seconds, so we can&#39;t repeat it a billion times.
Because we are limited in time and have large variance,
we can&#39;t get a tiny confidence interval,
and it&#39;s hard to detect a small performance regression.&lt;/p&gt;
&lt;p&gt;Another important point: if we write a tool for performance testing, we should keep in mind
that there are too many different cases and we can&#39;t cover all of them with a single approach.
At a minum, we need different approaches
for microbenchmarsk and for macrobenchmarks,
for single methods and for complicated integrated scenarios.&lt;/p&gt;
&lt;h3 id=&quot;perfect-place-for-performance-analysis&quot;&gt;Perfect place for performance analysis&lt;/h3&gt;
&lt;p&gt;How, where, and when we should do the performance analysis?
It&#39;s also a hard question, and it depends on the situation.
I can share my experience in Rider.
We have 3 places for performance analysis:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Each build.&lt;/strong&gt;
A small set of tests which are running on each build.
&lt;em&gt;Pros:&lt;/em&gt; commits with perf problems will not be merged into the master branch.
&lt;em&gt;Cons:&lt;/em&gt; We should run all the tests quickly, so we can&#39;t run a lot of them.
We can&#39;t do many iterations, so data is small.
Only huge degradation can be detected (like 1 second -&amp;gt; 15 seconds, it happens).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Daily tests.&lt;/strong&gt;
A big set of tests which are running one time per day on dedicated machines.
&lt;em&gt;Pros:&lt;/em&gt; we can do a lot of iterations, we can analyze historical data, we can detect even small performance problems.
&lt;em&gt;Cons:&lt;/em&gt; we will know about a problem only &lt;em&gt;after&lt;/em&gt; it&#39;s merged into master.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Retrospective analysis.&lt;/strong&gt;
A special system which analyzes &lt;em&gt;all&lt;/em&gt; collected performance data from &lt;em&gt;all&lt;/em&gt; build agents.
&lt;em&gt;Pros:&lt;/em&gt; we have a huge data set, we can run a lot of cool analysis, we can detect problems which were not detected by first two options.
&lt;em&gt;Cons:&lt;/em&gt; we will not know about a problem, unless it&#39;s too late (sometimes a week after a bad commit).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We continue to develop these ways and think about what else we can do.
Of course, you may have own way to analyze the performance (and I will be happy to hear about it).&lt;/p&gt;
&lt;h4 id=&quot;one-big-degradation-vs.many-small-degradations&quot;&gt;One big degradation vs. many small degradations.&lt;/h4&gt;
&lt;p&gt;Ok, let&#39;s say we solved all of the previous problems.
Let&#39;s also say that our test takes 10–15 seconds and the build is green if the total time is less than 20 seconds.
We are interested only in huge performance degradation (5 seconds or more),
so it should work well, and the big variance is not a problem for us anymore.
Next, Developer1 adds a new feature which takes 1 second.
It&#39;s a very good feature, the test takes 11–16 seconds which is fine, the build is green, everyone is happy.
Next, Developer2 adds another awesome feature which also takes 1 second.
Now test takes 12–17 seconds which also is fine.&lt;/p&gt;
&lt;p&gt;After another 4 iterations, the test will take 16–21 seconds and become flaky: it will fail the build &lt;em&gt;sometimes&lt;/em&gt;.
After another iteration, the test will take 17–22 seconds and become more flaky.
Developers will be angry because even a very simple typo fix can&#39;t be merged because some tests with strange names are suddenly red.&lt;/p&gt;
&lt;h4 id=&quot;technical-issues-vs.management-issues&quot;&gt;Technical issues vs. management issues&lt;/h4&gt;
&lt;p&gt;Here we meet another problem: what should we do if our super-system has detected some performance problems?
Especially if there are 10 developers, who are responsible for problems with performance.
Especially if all the implemented features are super useful,
you can&#39;t drop it,
you don&#39;t know how to optimize it,
but you want to keep the good level of performance.
While you are thinking, the developers suffer because tests are flaky and it slows down the development process.&lt;/p&gt;
&lt;p&gt;One day you decided that you are ready for this trade-off and you increase the timeout.
Then someone asks you: &amp;quot;So, we can change timeouts in such situations, yeah?&amp;quot;
Next, you will get a situation where every performance problem will be solved via increased timeouts without further investigation.&lt;/p&gt;
&lt;p&gt;Even if you have a perfect performance regression tests, they can be useless, if you don&#39;t have the performance culture in your company.
You should solve it somehow: find very responsible developers, assign special people for performance investigation, and so on.
If you are going to write performance tests, you should think about such things in advance.&lt;/p&gt;
&lt;h3 id=&quot;points-of-discussion&quot;&gt;Points of discussion&lt;/h3&gt;
&lt;p&gt;I named only a few main problems, there are too many of them.
I know how to solve some of them, but I don&#39;t know what I can do with others.
I&#39;m going to continue my research, implement best practices in BenchmarkDotNet, and share final results.
I would be really happy to hear any feedback from you.
How do you analyze performance?
How do you avoid performance degradation?
How do you solve management issues and find trade-offs between new features and performance?
What kind of other problems do you have which should be solved in a good performance testing library?&lt;/p&gt;</description>
        </item>
        <item>
            <title>Measuring Performance Improvements in .NET Core with BenchmarkDotNet (Part 1)</title>
            <link>http://aakinshin.net/posts/stephen-toub-benchmarks-part1/</link> 
            <pubDate>Fri, 09 Jun 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/stephen-toub-benchmarks-part1/</guid>
            <description>&lt;p&gt;A few days ago &lt;a href=&quot;https://github.com/stephentoub&quot;&gt;Stephen Toub&lt;/a&gt; published a great post
at the &lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/&quot;&gt;Microsoft .NET Blog&lt;/a&gt;:
&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/&quot;&gt;Performance Improvements in .NET Core&lt;/a&gt;.
He showed some significant performance changes in .NET Core 2.0 Preview 1 (compared with .NET Framework 4.7).
The .NET Core uses RyuJIT for generating assembly code.
When I first tried RyuJIT (e.g.,
&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2014/02/27/ryujit-ctp2-getting-ready-for-prime-time/&quot;&gt;CTP2&lt;/a&gt;,
&lt;a href=&quot;https://blogs.msdn.microsoft.com/clrcodegeneration/2014/10/30/ryujit-ctp5-getting-closer-to-shipping-and-with-better-simd-support/&quot;&gt;CTP5&lt;/a&gt;, 2014),
I wasn&#39;t excited about this: the preview versions had some bugs, and it worked slowly on my applications.
However, the idea of a rethought and open-source JIT-compiler was a huge step forward and investment in the future.
RyuJIT had been developed very actively in recent years: not only by Microsoft but with the help of the community.
I&#39;m still not happy about the generated assembly code in some methods, but I have to admit that the RyuJIT (as a part of .NET Core) works pretty well today:
it shows a good performance level not only on artificial benchmarks but also on real user code.
Also, there are a lot of changes
not only in &lt;a href=&quot;https://github.com/dotnet/coreclr&quot;&gt;dotnet/coreclr&lt;/a&gt; (the .NET Core runtime),
but also in &lt;a href=&quot;https://github.com/dotnet/corefx&quot;&gt;dotnet/corefx&lt;/a&gt; (the .NET Core foundational libraries).
It&#39;s very nice to watch how the community helps to optimize well-used classes which have not changed for years.&lt;/p&gt;
&lt;p&gt;Now let&#39;s talk about benchmarks.
For the demonstration, Stephen wrote a set of handwritten benchmarks.
A few people (in
&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2017/06/07/performance-improvements-in-net-core/#comments&quot;&gt;comments&lt;/a&gt; and on &lt;a href=&quot;https://news.ycombinator.com/item?id=14507936&quot;&gt;HackerNews&lt;/a&gt;)
asked about &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; regarding these samples (as a better tool for performance measurements).
So, I decided to try all these benchmarks on BenchmarkDotNet.&lt;/p&gt;
&lt;p&gt;In this post, we will discuss
how can BenchmarkDotNet help in such performance investigations,
which benchmarking approaches (and when) are better to use,
and how can we improve these measurements.&lt;/p&gt;
&lt;!--more--&gt;
&lt;div id=&quot;toc&quot;&gt;&lt;/div&gt;
&lt;h3 id=&quot;how-can-benchmarkdotnet-help&quot;&gt;How can BenchmarkDotNet help?&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If you have spent less than a week studying a benchmark result, it is probably wrong.&lt;/p&gt;
&lt;p&gt;— System Performance. Enterprise and the Cloud.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first question of the post: are Stephen&#39;s benchmarks valid?
Well... Yes and no.&lt;/p&gt;
&lt;p&gt;Yes,
we can see code which measures performance,
it prints some performance numbers,
the results are correct,
it helps to make the right conclusions.
Probably, when you see difference like &lt;code&gt;7.7sec&lt;/code&gt; vs &lt;code&gt;0.013sec&lt;/code&gt;,
you don&#39;t need a specialized benchmarking library: it&#39;s obvious that the second benchmark is faster.
So, it&#39;s ok to use such approach for getting quick raw results.&lt;/p&gt;
&lt;p&gt;However, in my world, a benchmark is more than just a program which somehow measures performance and prints some numbers.
I think that a benchmark is a performance investigation or a performance research (of course, you may have a different opinion).
For such investigation, I recommend using a powerful .NET library for benchmarking: &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;.
Disclaimer: I&#39;m the maintainer of this library, and my opinion may be biased.
I started it several years ago as a pet project, but now it&#39;s very popular tool:
BenchmarkDotNet has a lot of happy users,
it has 2000+ stars on GitHub,
and it&#39;s supported by the .NET Foundation.
A lot of popular projects use it, also it&#39;s used in some of the
coreclr &lt;a href=&quot;https://github.com/dotnet/coreclr/issues?utf8=%E2%9C%93&amp;amp;q=BenchmarkDotNet&quot;&gt;discussions&lt;/a&gt; and
corefx &lt;a href=&quot;https://github.com/dotnet/corefx/issues?utf8=%E2%9C%93&amp;amp;q=BenchmarkDotNet&quot;&gt;discussions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are already a BenchmarkDotNet user, you can skip this section and go to the benchmarks.
If you didn&#39;t use BenchmarkDotNet before, I try to explain why it can be a good choice for performance measurements.
Basically, BenchmarkDotNet solves the following two problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Getting results you can trust.&lt;/strong&gt;
When I look at a microbenchmark with &lt;code&gt;30%&lt;/code&gt; performance difference, I always ask myself: can I trust it?
Sometimes, we really have &lt;code&gt;30%&lt;/code&gt; difference.
Sometimes, it&#39;s just a statistical error due to a huge standard deviation.
How can we be sure?
Probably we have to warmup the benchmark.
Probably we have to do more iterations.
Probably JIT applies some crazy optimizations here and destroys our artificial benchmarks.
There are a lot of problems in the world of microbenchmarks,
you can not be sure that everything is fine without hours of additional checks even for a simple case.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comfortable research.&lt;/strong&gt;
As I said before, benchmarking is a kind of performance research.
You can&#39;t make any conclusions only by a single set of measurements: you always have to think about the performance space (source code + input data + environment).
Recently, I wrote a few post with performance exercises (&lt;a href=&quot;/blog/post/perfex-min/&quot;&gt;Minimum&lt;/a&gt; and &lt;a href=&quot;/blog/post/perfex-div/&quot;&gt;Division&lt;/a&gt;)
which demonstrate how hard it can be even in super simple cases.
Usually, benchmarking is not a one-time activity.
A good performance engineer always asks himself: what if we rewrote code in this way, what if we take a bigger sample, what if we run it on another OS, what if...
When you start to work with a benchmark and check different hypotheses, you also start to invent your own benchmarking infrastructure.
Sometimes you have to spend hours or days debugging this infrastructure instead of the actual performance investigation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&#39;s talk about how can BenchmarkDotNet help you.&lt;/p&gt;
&lt;h4 id=&quot;precision&quot;&gt;Precision&lt;/h4&gt;
&lt;p&gt;When someone run a benchmark 10 times, I always ask: why 10? Why not 5? Or 15? Or 100000?
Maybe you didn&#39;t execute the benchmark enough times for getting a good precision level.
Or maybe you did too many iterations, and you have to wait a lot longer without tangible precision improvements.
BenchmarkDotNet has set of heuristics for automatic choosing the best amount of benchmark repetition (of course you can specify it manually if you want).
Basically, BenchmarkDotNet tries to get the required confidence level (+some magic for corner cases).
Probably, it not a perfect solution for &lt;em&gt;all benchmarks in the world&lt;/em&gt;, but it works pretty well for the vast majority of cases:
you will get decent results and you will not wait too long (from some moment, additional iterations practically do not improve the benchmark accuracy).&lt;/p&gt;
&lt;p&gt;Also, with BenchmarkDotNet you can &lt;em&gt;usually&lt;/em&gt; skip &lt;em&gt;almost&lt;/em&gt; all of the benchmarking routine.
How many times should I repeat this method which takes a few nanoseconds?
Should I care about the benchmarking infrastructure overhead?
Can Roslyn/RyuJIT/CPU apply some tricky optimization and spoil the results?
Is it possible that one benchmark method will be inlined and other will be not inlined?
Should we care about hardware timers?
I also have a few post about internals of &lt;a href=&quot;/blog/post/stopwatch/&quot;&gt;Stopwatch&lt;/a&gt; and &lt;a href=&quot;/blog/post/datetime/&quot;&gt;DateTime&lt;/a&gt; which show
some important problems with timers.&lt;/p&gt;
&lt;p&gt;You can&#39;t imagine how many problems are there.
Some of them are related to &amp;quot;features&amp;quot; of modern CPUs.
Some of the Intel CPU optimizations are even not covered in official documentation (but they still can spoil your results).
I spent a huge amount of time on reverse engineering trying to create workarounds for these &amp;quot;features&amp;quot; (one day I&#39;ll write a post about it).
BenchmarkDotNet has a set of tricks, hacks, and workarounds which protect you from dozens of potential troubles.
Of course, you can be lucky and avoid all these problems without the corresponded knowledge.
But again: how can you be sure?&lt;/p&gt;
&lt;h4 id=&quot;environments&quot;&gt;Environments&lt;/h4&gt;
&lt;p&gt;In the original post, Stephen compare &lt;code&gt;.NET Core 2.0 Preview 1&lt;/code&gt; and &lt;code&gt;.NET Framework 4.7&lt;/code&gt; (with &lt;code&gt;RyuJIT-x64&lt;/code&gt;).
I believe that he ran each benchmark twice: on each runtime.
BenchmarkDotNet has special objects — &lt;a href=&quot;http://benchmarkdotnet.org/Configs/Jobs.htm&quot;&gt;Jobs&lt;/a&gt; which help you to compare several environments at once.
Basically, you can define a config for your benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class MyConfig : ManualConfig
{
  public MyConfig()
  {
    Add(Job.Default.With(Runtime.Clr).With(Jit.RyuJit).With(Platform.X64));
    Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RyuJIT-x64&lt;/code&gt; is not the only JIT in the full .NET Framework.
Some people still use &lt;code&gt;LegacyJIT-x64&lt;/code&gt; (because not all of the enterprise companies are ready for switching to a new JIT-compiler without a detailed performance research).
If you develop &lt;code&gt;x86&lt;/code&gt; application, you use &lt;code&gt;LegacyJIT-x86&lt;/code&gt;.
In BenchmarkDotNet, you can just add a few additional jobs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Add(Job.Default.With(Runtime.Clr).With(Jit.LegacyJit).With(Platform.X64));
Add(Job.Default.With(Runtime.Clr).With(Jit.LegacyJit).With(Platform.X86));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also it would be nice to check the &lt;a href=&quot;http://www.mono-project.com/&quot;&gt;mono&lt;/a&gt; performance:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Add(Job.Default.With(Runtime.Mono));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait!
I have two different mono on my Windows machine: &lt;code&gt;x86&lt;/code&gt; and &lt;code&gt;x64&lt;/code&gt;.
I want to check both versions!
How can I do it?
Easy peasy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Add(Job.Default.With(new MonoRuntime(&amp;quot;Mono_x64&amp;quot;, @&amp;quot;C:\Program Files\Mono\bin\mono.exe&amp;quot;)));
Add(Job.Default.With(new MonoRuntime(&amp;quot;Mono_x86&amp;quot;, @&amp;quot;C:\Program Files (x86)\Mono\bin\mono.exe&amp;quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also I want to compare &lt;code&gt;.NET Core 2.0 Preview 1&lt;/code&gt; with &lt;code&gt;.NET Core 1.1&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp11));
Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a huge amount of different environments.
You can&#39;t make any conclusion about C# performance based only on a single runtime
(remember that C# is just a language, it&#39;s an abstraction; it hasn&#39;t such property as &amp;quot;performance&amp;quot;; &amp;quot;performance&amp;quot; is a property of a runtime.)
If you want to get the results which you can apply, you have to check different configurations.
BenchmarkDotNet also helps you to check a lot of additional things like
GC settings (Server/Workstation, On/Off concurrent GC, and so on) and
benchmark mode parameters (e.g. you can automatically throw away all the outliers or include them in the final results).&lt;/p&gt;
&lt;p&gt;The main important fact here: you can define a config once and use it everywhere.
You can get the summary table with all results by a single click:
you shouldn&#39;t manually run the program in all environment after each change.&lt;/p&gt;
&lt;h4 id=&quot;automation-and-analysis&quot;&gt;Automation and analysis&lt;/h4&gt;
&lt;p&gt;BenchmarkDotNet has a lot of additional tools for performance engineers.&lt;/p&gt;
&lt;p&gt;For example, if you want to enumerate a parameter (e.g. size of an array), you can use &lt;code&gt;Params&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int[] a;

[Params(1, 100, 100_000, 10_000_000)]
public int N;

[GlobalSetup]
public void Setup()
{
  a = new int[N];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, you can do it manually.
But you can
spent a lot of time on this,
make a mistake,
try to debug a mistake,
collect all the result in a table,
prettify the console output,
spent more time,
and so on.
All the basic stuff for such kind of tasks is already implemented.&lt;/p&gt;
&lt;p&gt;Also BenchmarkDotNet
automatically warn you if something goes wrong with results,
it calculates statistics for you,
draw beautiful distribution plots,
export the results to markdown/xml/json/your_favorite_format,
check memory usage and an amount of allocations,
and so on.&lt;/p&gt;
&lt;h4 id=&quot;what-are-we-going-to-do&quot;&gt;What are we going to do?&lt;/h4&gt;
&lt;p&gt;Once again: if you don&#39;t use BenchmarkDotNet, it &lt;em&gt;doesn&#39;t mean&lt;/em&gt; that your results are incorrect.
Also, if you use BenchmarkDotNet, it &lt;em&gt;doesn&#39;t mean&lt;/em&gt; that you have correct results.
It&#39;s not a magic wand which will automatically fix all your benchmarks.
It&#39;s just a handy tool which helps you: it allows focusing on a problem instead of benchmarking stuff.&lt;/p&gt;
&lt;p&gt;So, today I&#39;m going to reimplement benchmarks of Stephen Toub with the help of BenchmarkDotNet and share my results.
I hope you know that you shouldn&#39;t trust a guy from the internet who present any performance measurements.
There is a quote which I really like:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are lies, damn lies and then there are performance measures.&lt;/p&gt;
&lt;p&gt;— Anon et al., “A Measure of Transaction Processing Power”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, I prepared a GitHub repo (&lt;a href=&quot;https://github.com/AndreyAkinshin/StephenToubBenchmarks&quot;&gt;AndreyAkinshin/StephenToubBenchmarks&lt;/a&gt;)
for you which contains almost all the samples.
You can download it and try it on your own machine.
You can modify the source code in any way and check the new results
(it&#39;s a good exercise if you want to improve your performance skills).
Write you own benchmarks.
Check out the performance of your production code on different runtimes.
Share and discuss results:
it will help you and others to better understand what&#39;s going on under the hood of the .NET runtime.
Also, this is a common situation these days
when some guy read such discussion and will go to improve coreclr or corefx on GitHub.
Remember that performance is a very tricky subject
and you will not get good knowledge based on a few blog posts without own experiments.&lt;/p&gt;
&lt;h4 id=&quot;preparation&quot;&gt;Preparation&lt;/h4&gt;
&lt;p&gt;Let&#39;s check how it works ont only on the &lt;code&gt;.NET Core 2.0 Preview 1&lt;/code&gt; and &lt;code&gt;.NET Framework 4.7&lt;/code&gt;, but also on &lt;code&gt;Mono 5.0.1&lt;/code&gt;.
Also, we would like to look at the distribution, so we add &lt;code&gt;RPlotExporter&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class MainConfig : ManualConfig
{
  public MainConfig()
  {
    Add(Job.Default.With(Runtime.Clr).With(Jit.RyuJit).With(Platform.X64).WithId(&amp;quot;NET4.7_RyuJIT-x64&amp;quot;));
    Add(Job.Default.With(Runtime.Mono).WithId(&amp;quot;Mono5.0.1-x64&amp;quot;));
    Add(Job.Default.With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20).WithId(&amp;quot;Core2.0-x64&amp;quot;));
    Add(RPlotExporter.Default);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;BenchmarkDotNet will print such lines before each summary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.10.8, OS=Windows 10 Redstone 1 (10.0.14393)
Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8
Frequency=2531250 Hz, Resolution=395.0617 ns, Timer=TSC
dotnet cli version=2.0.0-preview1-005977
  [Host]            : .NET Core 4.6.25302.01, 64bit RyuJIT
  Core2.0-x64       : .NET Core 4.6.25302.01, 64bit RyuJIT
  Mono5.0.1-x64     : Mono 5.0.1 (Visual Studio), 64bit
  NET4.7_RyuJIT-x64 : Clr 4.0.30319.42000, 64bit RyuJIT-v4.7.2053.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the summary table legend:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Mean   : Arithmetic mean of all measurements
  Error  : Half of 99.9% confidence interval
  StdDev : Standard deviation of all measurements

  Gen 0     : GC Generation 0 collects per 1k Operations
  Gen 1     : GC Generation 1 collects per 1k Operations
  Gen 2     : GC Generation 2 collects per 1k Operations
  Allocated : Allocated memory per single operation (managed only, inclusive, 1KB = 1024B)

  1 ns   : 1 Nanosecond  (0.000000001 sec)
  1 us   : 1 Microsecond (0.000001 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, now we are ready.&lt;/p&gt;
&lt;h3 id=&quot;collections&quot;&gt;Collections&lt;/h3&gt;
&lt;p&gt;In this post (probably the first one from a series), we will talk only about collections.
We will look at all the benchmark from the original post,
reimplement it with the help of BenchmarkDotNet,
think about possible improvements,
and analyze the results.&lt;/p&gt;
&lt;h4 id=&quot;queue&quot;&gt;Queue&lt;/h4&gt;
&lt;p&gt;There is the source code of the first benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;while (true)
{
  var q = new Queue&amp;lt;int&amp;gt;();
  var sw = Stopwatch.StartNew();
  for (int i = 0; i &amp;lt; 100_000_000; i++)
  {
    q.Enqueue(i);
    q.Dequeue();
  }
  Console.WriteLine(sw.Elapsed);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In BenchmarkDotNet, you shouldn&#39;t do a lot of repetitions of a quick piece of code:
the library will do it for you
(by the way, why we do exactly &lt;code&gt;100_000_000&lt;/code&gt; repetitions here?).
Here is our benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
public class QueueBenchmark1
{
  private Queue&amp;lt;int&amp;gt; q = new Queue&amp;lt;int&amp;gt;();

  [Benchmark]
  public void Run()
  {
    q.Enqueue(0);
    q.Dequeue();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is my results (BenchmarkDotNet generated a pretty markdown table for me which I copy-pasted to my blog):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Core2.0-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;6.228 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0120 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0079 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;10.514 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0288 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0240 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;11.150 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0592 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0525 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Usually, it&#39;s also a good idea to look at the distribution.
BenchmarkDotNet provides plots like this:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/QueueBenchmark1-Run-density.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/QueueBenchmark1-Run-density.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Now everything is fine, but don&#39;t forget to check out the distribution
when you are investigation a new performance space.&lt;/p&gt;
&lt;p&gt;The original results:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// .NET Framework 4.7
00:00:00.9392595
00:00:00.9390453
00:00:00.9455784
00:00:00.9508294
00:00:01.0107745
// .NET Core 2.0 Preview 1
00:00:00.5514887
00:00:00.5662477
00:00:00.5627481
00:00:00.5685286
00:00:00.5262378
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#39;s nice to see &lt;code&gt;~1.8x&lt;/code&gt; speedup on the .NET Core (both original and BenchmarkDotNet results).
But here we are talking about too artificial benchmarks: we measure a single &lt;code&gt;Enqueue&lt;/code&gt;/&lt;code&gt;Dequeue&lt;/code&gt; pair with a zero-size queue.
The &lt;code&gt;Enqueue&lt;/code&gt; doesn&#39;t have a fixed performance because it can trigger resizing of the internal array.
Let&#39;s write another benchmark with &lt;code&gt;N&lt;/code&gt; elements:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
public class QueueBenchmark2
{
  private Queue&amp;lt;int&amp;gt; q = new Queue&amp;lt;int&amp;gt;();

  [Params(10, 100, 1_000, 10_000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    for (int i = 0; i &amp;lt; N; i++)
      q.Enqueue(i);
    for (int i = 0; i &amp;lt; N; i++)
      q.Dequeue();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;Mean&lt;/th&gt;
&lt;th&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;72.68 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;0.1578 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.1318 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;180.29 ns&lt;/td&gt;
&lt;td&gt;0.5868 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5489 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;152.73 ns&lt;/td&gt;
&lt;td&gt;0.4126 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.3658 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;100&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;738.99 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1.5047 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;1.4075 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;2,200.55 ns&lt;/td&gt;
&lt;td&gt;43.0554 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;67.0321 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;2,023.59 ns&lt;/td&gt;
&lt;td&gt;5.1311 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;4.5486 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;6,978.27 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;21.7015 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;19.2378 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;22,917.90 ns&lt;/td&gt;
&lt;td&gt;65.6376 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;51.2455 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;20,632.16 ns&lt;/td&gt;
&lt;td&gt;49.7627 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;41.5541 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10000&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;70,749.93 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;97.2220 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;75.9045 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;228,853.60 ns&lt;/td&gt;
&lt;td&gt;728.0385 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;681.0076 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;206,463.21 ns&lt;/td&gt;
&lt;td&gt;351.8959 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;293.8490 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Let&#39;s look at the bar chart for this benchmark:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/QueueBenchmark2-barplot.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/QueueBenchmark2-barplot.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;With &lt;code&gt;N=10_000&lt;/code&gt;, we have &lt;code&gt;~2.95x&lt;/code&gt; speedup which is pretty great.
You should understand that it&#39;s still is not a perfect benchmark for &lt;code&gt;Queue&lt;/code&gt;.
If we want to have a complete performance investigation,
we should check corner cases (e.g., moments before and after the array resizing),
we should check cases with different initial capacity,
we should check how it works in a real situation (e.g., solve a classic computer science problem with a queue),
we should check many-many cases.
We skip this &amp;quot;complete investigation&amp;quot; (but you can do it yourself) because it&#39;s not our aim for today and we have a lot of other interesting examples.
I will be happy if someone else continues this research, writes a set of benchmarks and presents the results.
It will be a good exercise for you and a good example of a nice performance investigation for the community.
Feel free to pick up any other example from this post or create you own.&lt;/p&gt;
&lt;h4 id=&quot;sortedset&quot;&gt;SortedSet&lt;/h4&gt;
&lt;p&gt;The next benchmark is about &lt;code&gt;SortedSet&lt;/code&gt;.
We skip the constructor demo (comparing &lt;code&gt;~7.7sec&lt;/code&gt; and &lt;code&gt;~0.013s&lt;/code&gt; is not interesting)
and continue with the &lt;code&gt;Min&lt;/code&gt; performance.&lt;/p&gt;
&lt;p&gt;Here is the original code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;while (true)
{
  var s = new SortedSet&amp;lt;int&amp;gt;();
  for (int n = 0; n &amp;lt; 100_000; n++)
  {
    s.Add(n);
  }

  var sw = Stopwatch.StartNew();
  for (int i = 0; i &amp;lt; 10_000_000; i++)
  {
    s_result = s.Min;
  }
  Console.WriteLine(sw.Elapsed);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Original results:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// .NET Framework 4.7
00:00:01.1427246
00:00:01.1295220
00:00:01.1350696
00:00:01.1502784
00:00:01.1677880
// .NET Core 2.0 Preview 1
00:00:00.0861391
00:00:00.0861183
00:00:00.0866616
00:00:00.0848434
00:00:00.0860198
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why we put exactly &lt;code&gt;100_000&lt;/code&gt; in the &lt;code&gt;SortedSet&lt;/code&gt;?
Let&#39;s try different values!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
public class SortedSetBenchmark1
{
  private SortedSet&amp;lt;int&amp;gt; s = new SortedSet&amp;lt;int&amp;gt;();

  [Params(1, 100, 100_000, 10_000_000)]
  public int N;

  [GlobalSetup]
  public void Setup()
  {
    for (int i = 0; i &amp;lt; N; i++)
      s.Add(i);
  }

  [Benchmark]
  public int Run() =&amp;gt; s.Min;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;2.010 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0061 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0057 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;81.355 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.6598 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;2.6802 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;38.103 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.7885 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.4015 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;100&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;4.040 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0166 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0139 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;147.587 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;2.9271 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;4.8093 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;72.091 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2088 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2404 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;100000&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;12.193 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0471 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0440 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;257.729 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.6381 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5657 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;145.400 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5647 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5282 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10000000&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;55.452 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.1196 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.1119 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;10000000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;476.941 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.2562 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.1136 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;10000000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;202.415 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5968 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5290 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Here are some interesting facts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In the original post, for &lt;code&gt;N=100_000&lt;/code&gt; we have &lt;code&gt;~14.5x&lt;/code&gt; speedup on &lt;code&gt;.NET Core&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In our experiment, we have &lt;code&gt;~12x&lt;/code&gt; speedup. &lt;code&gt;.NET Core&lt;/code&gt; is still super-fast, but we have a difference between speedup results.&lt;/li&gt;
&lt;li&gt;For &lt;code&gt;N=10_000_000&lt;/code&gt; we have &lt;code&gt;~3.7x&lt;/code&gt; speedup.
Be careful with the parameters of your benchmark: they can significantly affect your results.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mono&lt;/code&gt; works &lt;code&gt;~2.35&lt;/code&gt; times slower than &lt;code&gt;.NET Framework 4.7&lt;/code&gt; + &lt;code&gt;RyuJIT-x64&lt;/code&gt; for &lt;code&gt;N=10_000_000&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;list&quot;&gt;List&lt;/h4&gt;
&lt;p&gt;Now it&#39;s time for the &lt;code&gt;List&lt;/code&gt;.
The original benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;while (true)
{
  var l = new List&amp;lt;int&amp;gt;();
  var sw = Stopwatch.StartNew();
  for (int i = 0; i &amp;lt; 100_000_000; i++)
  {
    l.Add(i);
    l.RemoveAt(0);
  }
  Console.WriteLine(sw.Elapsed);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The original results:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// .NET Framework 4.7
00:00:00.4434135
00:00:00.4394329
00:00:00.4496867
00:00:00.4496383
00:00:00.4515505
// .NET Core 2.0 Preview 1
00:00:00.3213094
00:00:00.3211772
00:00:00.3179631
00:00:00.3198449
00:00:00.3164009
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#39;s write a simple benchmark for &lt;code&gt;Add&lt;/code&gt;/&lt;code&gt;RemoveAt&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
public class ListBenchmark1
{
  private List&amp;lt;int&amp;gt; l = new List&amp;lt;int&amp;gt;();

  [Benchmark]
  public void Run()
  {
    l.Add(0);
    l.RemoveAt(0);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Core2.0-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;3.375 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0053 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0057 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;3.374 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.942 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.1972 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.3556 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;8.229 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;5.914 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0126 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0098 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;5.913 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;We can see here &lt;code&gt;~1.8x&lt;/code&gt; speedup on .NET Core, in the original post it was &lt;code&gt;~1.4x&lt;/code&gt;.
Another interesting fact: did you noticed that BenchmarkDotNet added the &lt;code&gt;Median&lt;/code&gt; column in this table (it was skipped in previous benchmarks)?
By default, BenchmarkDotNet tries not to bore you with statistics (however, you can request any statistics manually).
If BenchmarkDotNet discovers something strange in the results, it adds additional columns with interesting values.
By default, the &lt;code&gt;Median&lt;/code&gt; column is skipped because &lt;em&gt;usually&lt;/em&gt; the &lt;code&gt;Median&lt;/code&gt; and &lt;code&gt;Mean&lt;/code&gt; values are too close.
Here we have a difference for Mono:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.942 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;8.229 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Let&#39;s look at the timeline plot for mono:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/ListBenchmark1-Run-Mono5.0.1-x64-timelineSmooth.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/ListBenchmark1-Run-Mono5.0.1-x64-timelineSmooth.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;The usual amount of iterations for a benchmark is 15.
In most cases, it allows getting &lt;em&gt;acceptable&lt;/em&gt; results.
I tried to increase it before, but people don&#39;t want to wait too long for results;
they start to manually set a small amount of iterations,
and our default &amp;quot;automatic choosing the amount of iterations&amp;quot; logic becomes useless.
So, the default value is 15 (at least), but BenchmarkDotNet can increase it if something is going wrong.
On Mono, we can see that the amount of iterations is around 40. (Hooray, it works!)
Also, we can observe two modes: around &lt;code&gt;~7.6ns&lt;/code&gt; and &lt;code&gt;~8.2ns&lt;/code&gt;.
So, let&#39;s check the distribution!&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/ListBenchmark1-Run-Mono5.0.1-x64-density.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/ListBenchmark1-Run-Mono5.0.1-x64-density.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Yep, it&#39;s a bimodal distribution.
If BenchmarkDotNet is so smart, why it didn&#39;t warn us about such distribution?
Well, it&#39;s an open issue: &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/429&quot;&gt;BenchmarkDotNet#429: Detect multimodal distributions&lt;/a&gt;.
I tried to implement this,
but performance distribution are too tricky,
it&#39;s not easy to write such logic without huge percent of false-positive results.
I will try it again in the future, but if somebody knows a good solution, pull requests are welcome!&lt;/p&gt;
&lt;p&gt;Why does the distribution look like this?
I don&#39;t know.
And it&#39;s not a topic of this post:
the full performance investigation takes too much time:
we have to play with initial configurations,
check out the source code,
try different versions of mono,
different machines,
and so on.
In this post, I want to talk only about benchmarking.
The important point here is that such phenomena can be easily skipped during handwritten measurements.&lt;/p&gt;
&lt;p&gt;Now le&#39;ts check how it works on huge lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
public class ListBenchmark2
{
  private List&amp;lt;int&amp;gt; l = new List&amp;lt;int&amp;gt;();

  [Params(10, 100, 1000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    for (int i = 0; i &amp;lt; N; i++)
      l.Add(i);
    for (int i = 0; i &amp;lt; N; i++)
      l.RemoveAt(N - 1 - i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;10&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;42.87 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.1396 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.1166 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;42.83 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;115.27 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.7361 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.9040 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;115.55 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;59.53 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.3000 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2506 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;59.45 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;100&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;430.05 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.7114 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.6307 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;429.95 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;871.77 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;17.3243 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;32.9613 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;897.37 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;664.19 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.3559 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.9804 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;663.97 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1000&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;4,059.05 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;13.0940 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;10.2230 ns&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;4,060.99 ns&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7,623.19 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;95.4478 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;79.7032 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7,610.51 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;6,271.42 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123.4688 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;209.6594 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;6,398.59 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;For &lt;code&gt;N=1000&lt;/code&gt;, we have &lt;code&gt;~1.55x&lt;/code&gt; speedup.
And we still have a bimodal distribution for mono.
Here is the timeline plot for &lt;code&gt;N=100&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/ListBenchmark2-Run-Mono5.0.1-x64 N=100-timelineSmooth.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/ListBenchmark2-Run-Mono5.0.1-x64 N=100-timelineSmooth.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h4 id=&quot;concurrentqueue&quot;&gt;ConcurrentQueue&lt;/h4&gt;
&lt;p&gt;Now let&#39;s play with &lt;code&gt;ConcurrentQueue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The original code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;while (true)
{
  var q = new ConcurrentQueue&amp;lt;int&amp;gt;();
  int gen0 = GC.CollectionCount(0), gen1 = GC.CollectionCount(1), gen2 = GC.CollectionCount(2);
  for (int i = 0; i &amp;lt; 100_000_000; i++)
  {
    q.Enqueue(i);
    q.TryDequeue(out int _);
  }
  Console.WriteLine($&amp;quot;Gen0={GC.CollectionCount(0) - gen0} Gen1={GC.CollectionCount(1) - gen1} Gen2={GC.CollectionCount(2) - gen2}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The original results:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// .NET Framework 4.7
00:00:02.6485174  Gen0=162 Gen1=80 Gen2=0
00:00:02.6144919  Gen0=162 Gen1=81 Gen2=0
00:00:02.6699958  Gen0=162 Gen1=81 Gen2=0
00:00:02.6441047  Gen0=162 Gen1=81 Gen2=0
00:00:02.6255135  Gen0=162 Gen1=81 Gen2=0
// .NET Core 2.0 Preview 1
00:00:01.7700190  Gen0=0 Gen1=0 Gen2=0
00:00:01.8324078  Gen0=0 Gen1=0 Gen2=0
00:00:01.7552966  Gen0=0 Gen1=0 Gen2=0
00:00:01.7518632  Gen0=0 Gen1=0 Gen2=0
00:00:01.7560811  Gen0=0 Gen1=0 Gen2=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we manually check GC collections.
In general case, it can be heard because such measurements have own problems.
In BenchmarkDotNet, you mark the benchmark class with the &lt;code&gt;[MemoryDiagnoser]&lt;/code&gt; attribute,
and GC statistics will be automatically calculated.
And it&#39;s not only about high-precision GC collection values, it also prints average allocated size in bytes!
Check out a post of &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;Adam Sitnik&lt;/a&gt;
about &lt;code&gt;MemoryDiagnoser&lt;/code&gt;: &lt;a href=&quot;http://adamsitnik.com/the-new-Memory-Diagnoser/&quot;&gt;&amp;quot;The new MemoryDiagnoser is now better than ever!&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let&#39;s write a new benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
[MemoryDiagnoser]
public class ConcurrentQueueBenchmark1
{
  private ConcurrentQueue&amp;lt;int&amp;gt; q = new ConcurrentQueue&amp;lt;int&amp;gt;();

  [Benchmark]
  public void Run()
  {
    q.Enqueue(0);
    q.TryDequeue(out int _);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Gen 0&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Gen 1&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Gen 2&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Core2.0-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;18.92 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0272 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0227 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;45.41 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.1918 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.1498 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0018&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0001&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;31.24 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0826 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0773 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0017&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0008&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;9 B&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Now we know average GC collection counts for all generations (&lt;code&gt;Gen 0&lt;/code&gt;/&lt;code&gt;Gen 1&lt;/code&gt;/&lt;code&gt;Gen 2&lt;/code&gt; are values per 1000 operations)
and the amount of allocated memory.
The original speedup is &lt;code&gt;~1.45x&lt;/code&gt;, our value is &lt;code&gt;~1.65x&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
public class ConcurrentQueueBenchmark2
{
  private ConcurrentQueue&amp;lt;int&amp;gt; q = new ConcurrentQueue&amp;lt;int&amp;gt;();

  [Params(100, 100_000, 1_000_000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    for (int i = 0; i &amp;lt; N; i++)
      q.Enqueue(0);
    for (int i = 0; i &amp;lt; N; i++)
      q.TryDequeue(out int _);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;100&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;2.490 us&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0022 us&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;0.0019 us&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;4.283 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0784 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0695 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;3.174 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0206 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0183 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;100000&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;2,720.496 us&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;4.2448 us&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;3.3141 us&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;4,130.617 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;13.7123 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;12.1556 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;100000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;3,211.175 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;5.8462 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;5.4685 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Core2.0-x64&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1000000&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;27,249.183 us&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;74.8775 us&lt;/strong&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;&lt;strong&gt;66.3769 us&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;41,757.702 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;123.4342 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;126.7578 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;1000000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;34,823.063 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;694.9357 us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1,161.0814 us&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Thus, speedup for &lt;code&gt;N=1_000_000&lt;/code&gt; is &lt;code&gt;~1.26x&lt;/code&gt;.
Let&#39;s look at the timelines:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark2-Run-facetTimeline.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark2-Run-facetTimeline.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Plots are cool: we immediately see a suspicious place: &lt;code&gt;.NET Framework 4.7&lt;/code&gt; + &lt;code&gt;N=1_000_000&lt;/code&gt;.
Looks like another bimodal distribution: a good candidate for detailed research, if we continue this investigation.&lt;/p&gt;
&lt;p&gt;Now let&#39;s look at a more interesting example with multithreading.
The original code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (true)
{
  const int Items = 100_000_000;
  var q = new ConcurrentQueue&amp;lt;int&amp;gt;();
  var sw = Stopwatch.StartNew();

  Task consumer = Task.Run(() =&amp;gt;
  {
    int total = 0;
     while (total &amp;lt; Items) if (q.TryDequeue(out int _)) total++;
  });
  for (int i = 0; i &amp;lt; Items; i++) q.Enqueue(i);
  consumer.Wait();

  Console.WriteLine(sw.Elapsed);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The original results:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// .NET Framework 4.7
00:00:06.1366044
00:00:05.7169339
00:00:06.3870274
00:00:05.5487718
00:00:06.6069291
// .NET Core 2.0 Preview 1
00:00:01.2052460
00:00:01.5269184
00:00:01.4638793
00:00:01.4963922
00:00:01.4927520
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#39;s not easy to write multithreading benchmarks.
People asked me several times about multithreading support in BenchmarkDotNet, but it&#39;s not easy to implement.
Of course, it&#39;s easy to provide a nice API for such benchmark, but it&#39;s hard to achieve stable results.
I don&#39;t want to write another benchmarking library which prints &lt;em&gt;some numbers&lt;/em&gt;.
If we have a feature, it should work great.
So, we don&#39;t support it out of the box, but we can just rewrite the original benchmark with the help of BenchmarkDotNet in a simple way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MonitoringConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
public class ConcurrentQueueBenchmark3
{
  private ConcurrentQueue&amp;lt;int&amp;gt; q = new ConcurrentQueue&amp;lt;int&amp;gt;();

  [Params(100_000_000)]
  public int N;

  [Benchmark]
  public void Run()
  {
    Task consumer = Task.Run(() =&amp;gt;
    {
      int total = 0;
      while (total &amp;lt; N) if (q.TryDequeue(out int _)) total++;
    });
    for (int i = 0; i &amp;lt; N; i++)
      q.Enqueue(i);
    consumer.Wait();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we use &lt;code&gt;MonitoringConfig&lt;/code&gt; instead of &lt;code&gt;MainConfig&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MonitoringConfig : ManualConfig
{
  public MonitoringConfig()
  {
    Add(Job.Default.With(RunStrategy.Monitoring).With(Runtime.Clr).With(Jit.RyuJit).With(Platform.X64).WithId(&amp;quot;NET4.7_RyuJIT-x64&amp;quot;));
    Add(Job.Default.With(RunStrategy.Monitoring).With(Runtime.Mono).WithId(&amp;quot;Mono5.0.1-x64&amp;quot;));
    Add(Job.Default.With(RunStrategy.Monitoring).With(Runtime.Core).With(CsProjCoreToolchain.NetCoreApp20).WithId(&amp;quot;Core2.0-x64&amp;quot;));
    Add(RPlotExporter.Default);
    KeepBenchmarkFiles = true;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mainly, BenchmarkDotNet is focusing on microbenchmarking.
If you measure a method which takes seconds, the whole benchmarking process can take too much time.
&lt;code&gt;RunStrategy.Monitoring&lt;/code&gt; is designed for macrobenchmarks, it allows getting good results in a short period of time.
One day we will support such method out of the box, but currently &lt;code&gt;Monitoring&lt;/code&gt; is our choice (&lt;a href=&quot;http://benchmarkdotnet.org/Guides/ChoosingRunStrategy.htm&quot;&gt;more about run strategies&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The results:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Core2.0-x64&lt;/td&gt;
&lt;td&gt;100000000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.720 s&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.3313 s&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2191 s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td&gt;100000000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;6.829 s&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.9576 s&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.6334 s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td&gt;100000000&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;6.042 s&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.4212 s&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2786 s&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The original speedup is &lt;code&gt;~4x..5.3x&lt;/code&gt;, the new speedup is &lt;code&gt;~3.5x&lt;/code&gt;.
The important point here is the following: the standard deviation is huge.
Let&#39;s look again at a few of the original results for &lt;code&gt;.NET Framework 4.7&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00:00:05.5487718
00:00:06.6069291
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is a huge difference between measurements.
It&#39;s not enough to do only five iterations in such case!
Here is the box plot:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark3-boxplot.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark3-boxplot.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Probably another case of a bimodal distribution?
Let&#39;s look at the density plot:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark3-Run-density.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentQueueBenchmark3-Run-density.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;It&#39;s not a bimodal distribution; it&#39;s just a distribution of strange form with huge &lt;code&gt;StdDev&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;concurrentbag&quot;&gt;ConcurrentBag&lt;/h4&gt;
&lt;p&gt;The original benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;while (true)
{
  var q = new ConcurrentBag&amp;lt;int&amp;gt;() { 1, 2 };
  var sw = new Stopwatch();

  int gen0 = GC.CollectionCount(0), gen1 = GC.CollectionCount(1), gen2 = GC.CollectionCount(2);
  sw.Start();

  for (int i = 0; i &amp;lt; 100_000_000; i++)
  {
    q.Add(i);
    q.TryTake(out int _);
  }

  sw.Stop();
  Console.WriteLine($&amp;quot;Elapsed={sw.Elapsed} Gen0={GC.CollectionCount(0) - gen0} Gen1={GC.CollectionCount(1) - gen1} Gen2={GC.CollectionCount(2) - gen2}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The original results:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// .NET Framework 4.7
Elapsed=00:00:06.5672723 Gen0=953 Gen1=0 Gen2=0
Elapsed=00:00:06.4829793 Gen0=954 Gen1=1 Gen2=0
Elapsed=00:00:06.9008532 Gen0=954 Gen1=0 Gen2=0
Elapsed=00:00:06.6485667 Gen0=953 Gen1=1 Gen2=0
Elapsed=00:00:06.4671746 Gen0=954 Gen1=1 Gen2=0
// .NET Core 2.0 Preview 1
Elapsed=00:00:04.3377355 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.2892791 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.3101593 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.2652497 Gen0=0 Gen1=0 Gen2=0
Elapsed=00:00:04.2808077 Gen0=0 Gen1=0 Gen2=0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A new benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(MainConfig))]
[BenchmarkCategory(&amp;quot;Collections&amp;quot;)]
[MemoryDiagnoser]
public class ConcurrentBag
{
  private ConcurrentBag&amp;lt;int&amp;gt; q = new ConcurrentBag&amp;lt;int&amp;gt; { 1, 2 };

  [Benchmark]
  public void Run()
  {
    q.Add(0);
    q.TryTake(out int _);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Mean&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Error&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Gen 0&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Core2.0-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;56.47 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.1561 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;2.1140 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;-&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0 B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono5.0.1-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;162.82 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2874 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2548 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0086&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;N/A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NET4.7_RyuJIT-x64&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;82.52 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2572 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2008 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0126&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;40 B&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The original speedup is &lt;code&gt;~1.5x&lt;/code&gt;, the new speedup is &lt;code&gt;~1.37x&lt;/code&gt; (almost the same).&lt;/p&gt;
&lt;p&gt;By the way, Mono works slowly again: about two times slower than the full framework.
On &lt;code&gt;.NET Core 2.0 Preview 1&lt;/code&gt;, we got another bimodal distributions, here is a timeline plot:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentBag-Run-Core2.0-x64-timelineSmooth.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/stephen-toub-benchmarks-part1/ConcurrentBag-Run-Core2.0-x64-timelineSmooth.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Could we say that .NET Core is always the fastest runtime?
No.
We looked only at specific cases related to coreclr-specific optimizations.
These benchmarks &lt;em&gt;are designed&lt;/em&gt; to show how fast .NET Core is.
I&#39;m no saying that .NET Core is a bad runtime,
I&#39;m saying that I can write an own set of benchmarks which show that the best runtime is the .NET Framework or Mono.
Anyway, .NET Core is a great project.
Guys from Microsoft (with the help of the community) did (and continue to do) an awesome job.
The .NET Core indeed has awesome performance improvements.
However, it&#39;s not a good idea to blindly believe that the .NET Core will always be super-fast for all the cases.
(Also it&#39;s not a good idea to blindly believe in any information which you read on the internet.)&lt;/p&gt;
&lt;p&gt;If you are want to migrate to .NET Core and get better performance for free, you should write own benchmarks first.
Find bottleneck methods in your software,
design the corresponded benchmarks based on users use cases,
check different environment,
perform a thoughtful analysis (it&#39;s the most important part).
Only after this, you can make correct conclusions about the best .NET runtime &lt;em&gt;for you&lt;/em&gt;.
I hope now you understand that it&#39;s not easy to design proper benchmarks (even if you use BenchmarkDotNet).
This activity requires a lot of time and skills.&lt;/p&gt;
&lt;p&gt;If you want to check out how it&#39;s work in your environment (or make some additional experiments), here is a repo for you:
&lt;a href=&quot;https://github.com/AndreyAkinshin/StephenToubBenchmarks&quot;&gt;AndreyAkinshin/StephenToubBenchmarks&lt;/a&gt;.
In this post, I didn&#39;t make real performance investigations (it wasn&#39;t my purpose):
I just tried to explain basic benchmarking concepts and show how to use BenchmarkDotNet.
This post contains only &lt;em&gt;drafts&lt;/em&gt; of future benchmarks.
I wrote it in a few hours and maybe I made mistakes (actually, 90% of any benchmarking activity is making mistakes).
However, I hope that you have learned a few interesting benchmarking tricks.&lt;/p&gt;
&lt;p&gt;You may notice that I didn&#39;t show all the benchmarks from the original post.
I implemented almost all of them in the GitHub repo, but
I just didn&#39;t have enough time to collect all measurements and write explanations.
There are a lot of interesting fundamental benchmark errors there,
but I want to get some feedback first.
Is it an interesting topic?
Is it worth to explain all the benchmarks and how they can be improved?
If so, I will be happy to explain in detail what happens in each case
(I hope that these explanations will help people to design correct benchmark for similar cases).&lt;/p&gt;</description>
        </item>
        <item>
            <title>BenchmarkDotNet v0.10.7</title>
            <link>http://aakinshin.net/posts/bdn-v0_10_7/</link> 
            <pubDate>Mon, 05 Jun 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/bdn-v0_10_7/</guid>
            <description>&lt;p&gt;BenchmarkDotNet v0.10.7 has been released.
In this post, I will briefly cover the following features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LINQPad support&lt;/li&gt;
&lt;li&gt;Filters and categories&lt;/li&gt;
&lt;li&gt;Updated Setup/Cleanup attributes&lt;/li&gt;
&lt;li&gt;Better Value Types support&lt;/li&gt;
&lt;li&gt;Building Sources on Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;linqpad-support&quot;&gt;LINQPad support&lt;/h3&gt;
&lt;p&gt;We already supported LinqPad some time ago, but the support was broken in recent version of BenchmarkDotNet.
It turned out that there was a conflict between the Roslyn assemblies in LINQPad and those referenced by BenchmarkDotNet.
With the help of &lt;a href=&quot;https://github.com/albahari&quot;&gt;@albahari&lt;/a&gt; (the author of LinqPad), the issue &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/445#issuecomment-300683997&quot;&gt;was fixed&lt;/a&gt;.
The fix was on the LINQPad side, so you need LINQPad 5.22.05+ to get it worked (currently it&#39;s a beta version, it can be downloaded from &lt;a href=&quot;https://www.linqpad.net/Download.aspx&quot;&gt;the official site&lt;/a&gt;).&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/bdn-v0_10_7/linqpad.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/bdn-v0_10_7/linqpad.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;See also:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/66&quot;&gt;BenchmarkDotNet#66&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/445&quot;&gt;BenchmarkDotNet#445&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;filters-and-categories&quot;&gt;Filters and categories&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/248&quot;&gt;This issue&lt;/a&gt; by &lt;a href=&quot;https://github.com/jskeet&quot;&gt;@jskeet&lt;/a&gt; was pretty old,
but I finally found some time to implement it.
BenchmarkDotNet becomes very popular, some of our users have a lot of benchmarks, and they don&#39;t want to run all the benchmarks each time.
In this case, they can &lt;em&gt;filter&lt;/em&gt; some of them with the help of &lt;em&gt;filters&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Usage examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(Config))]
public class IntroFilters
{
    private class Config : ManualConfig
    {
        // We will benchmark ONLY method with names with names (which contains &amp;quot;A&amp;quot; OR &amp;quot;1&amp;quot;) AND (have length &amp;lt; 3)
        public Config()
        {
            Add(new DisjunctionFilter(
                new NameFilter(name =&amp;gt; name.Contains(&amp;quot;A&amp;quot;)),
                new NameFilter(name =&amp;gt; name.Contains(&amp;quot;1&amp;quot;))
            )); // benchmark with names which contains &amp;quot;A&amp;quot; OR &amp;quot;1&amp;quot;
            Add(new NameFilter(name =&amp;gt; name.Length &amp;lt; 3)); // benchmark with names with length &amp;lt; 3
        }
    }

    [Benchmark] public void A1() =&amp;gt; Thread.Sleep(10); // Will be benchmarked
    [Benchmark] public void A2() =&amp;gt; Thread.Sleep(10); // Will be benchmarked
    [Benchmark] public void A3() =&amp;gt; Thread.Sleep(10); // Will be benchmarked
    [Benchmark] public void B1() =&amp;gt; Thread.Sleep(10); // Will be benchmarked
    [Benchmark] public void B2() =&amp;gt; Thread.Sleep(10);
    [Benchmark] public void B3() =&amp;gt; Thread.Sleep(10);
    [Benchmark] public void C1() =&amp;gt; Thread.Sleep(10); // Will be benchmarked
    [Benchmark] public void C2() =&amp;gt; Thread.Sleep(10);
    [Benchmark] public void C3() =&amp;gt; Thread.Sleep(10);
    [Benchmark] public void Aaa() =&amp;gt; Thread.Sleep(10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An example of &lt;code&gt;BenchmarkCategory&lt;/code&gt; usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DryJob]
[CategoriesColumn]
[BenchmarkCategory(&amp;quot;Awesome&amp;quot;)]
[AnyCategoriesFilter(&amp;quot;A&amp;quot;, &amp;quot;1&amp;quot;)]
public class IntroCategories
{
    [Benchmark]
    [BenchmarkCategory(&amp;quot;A&amp;quot;, &amp;quot;1&amp;quot;)]
    public void A1() =&amp;gt; Thread.Sleep(10); // Will be benchmarked

    [Benchmark]
    [BenchmarkCategory(&amp;quot;A&amp;quot;, &amp;quot;2&amp;quot;)]
    public void A2() =&amp;gt; Thread.Sleep(10); // Will be benchmarked

    [Benchmark]
    [BenchmarkCategory(&amp;quot;B&amp;quot;, &amp;quot;1&amp;quot;)]
    public void B1() =&amp;gt; Thread.Sleep(10); // Will be benchmarked

    [Benchmark]
    [BenchmarkCategory(&amp;quot;B&amp;quot;, &amp;quot;2&amp;quot;)]
    public void B2() =&amp;gt; Thread.Sleep(10);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The filtering can be performed via command line.
Examples:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--category=A
--allCategories=A,B
--anyCategories=A,B
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are using &lt;code&gt;BenchmarkSwitcher&lt;/code&gt; and want to run all the benchmarks with a category from all types and join them into one summary table, use the &lt;code&gt;--join&lt;/code&gt; option (or &lt;code&gt;BenchmarkSwitcher.RunAllJoined&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* --join --category=MyAwesomeCategory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last feature was inspired by a &lt;a href=&quot;https://github.com/NickCraver&quot;&gt;@NickCraver&lt;/a&gt; &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/248#issuecomment-300652000&quot;&gt;comment&lt;/a&gt;,
it should be useful in &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;See also:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/248&quot;&gt;BenchmarkDotNet#248&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;updated-setupcleanup-attributes&quot;&gt;Updated Setup/Cleanup attributes&lt;/h3&gt;
&lt;p&gt;Sometimes we want to write some logic which should be executed &lt;em&gt;before&lt;/em&gt; or &lt;em&gt;after&lt;/em&gt; a benchmark, but we don&#39;t want to measure it.
For this purpose, BenchmarkDotNet provides a set of attributes: &lt;code&gt;[GlobalSetup]&lt;/code&gt;, &lt;code&gt;[GlobalCleanup]&lt;/code&gt;, &lt;code&gt;[IterationSetup]&lt;/code&gt;, &lt;code&gt;[IterationCleanup]&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;globalsetup&quot;&gt;GlobalSetup&lt;/h4&gt;
&lt;p&gt;A method which is marked by the &lt;code&gt;[GlobalSetup]&lt;/code&gt; attribute will be executed only once per a benchmarked method
after initialization of benchmark parameters and before all the benchmark method invocations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class GlobalSetupExample
{
    [Params(10, 100, 1000)]
    public int N;

    private int[] data;

    [GlobalSetup]
    public void GlobalSetup()
    {
        data = new int[N]; // executed once per each N value
    }

    [Benchmark]
    public int Logic()
    {
        int res = 0;
        for (int i = 0; i &amp;lt; N; i++)
            res += data[i];
        return res;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;globalcleanup&quot;&gt;GlobalCleanup&lt;/h4&gt;
&lt;p&gt;A method which is marked by the &lt;code&gt;[GlobalCleanup]&lt;/code&gt; attribute will be executed only once per a benchmarked method
after all the benchmark method invocations.
If you are using some unmanaged resources (e.g., which were created in the &lt;code&gt;GlobalSetup&lt;/code&gt; method), they can be disposed in the &lt;code&gt;GlobalCleanup&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void GlobalCleanup()
{
    // Disposing logic
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;iterationsetup&quot;&gt;IterationSetup&lt;/h4&gt;
&lt;p&gt;A method which is marked by the &lt;code&gt;[IterationSetup]&lt;/code&gt; attribute will be executed only once &lt;em&gt;before each an iteration&lt;/em&gt;.
It&#39;s not recommended to use this attribute in microbenchmarks because it can spoil the results.
However, if you are writing a macrobenchmark (e.g. a benchmark which takes at least 100ms) and
you want to prepare some data before each iteration, &lt;code&gt;[IterationSetup]&lt;/code&gt; can be useful.
BenchmarkDotNet doesn&#39;t support setup/cleanup method for a single method invocation (&lt;em&gt;an operation&lt;/em&gt;), but you can perform only one operation per iteration.
It&#39;s recommended to use &lt;code&gt;RunStrategy.Monitoring&lt;/code&gt; for such cases.
Be careful: if you allocate any objects in the &lt;code&gt;[IterationSetup]&lt;/code&gt; method, the MemoryDiagnoser results can also be spoiled.&lt;/p&gt;
&lt;h4 id=&quot;iterationcleanup&quot;&gt;IterationCleanup&lt;/h4&gt;
&lt;p&gt;A method which is marked by the &lt;code&gt;[IterationCleanup]&lt;/code&gt; attribute will be executed only once &lt;em&gt;after each an iteration&lt;/em&gt;.
This attribute has the same set of constraint with &lt;code&gt;[IterationSetup]&lt;/code&gt;: it&#39;s not recommended to use &lt;code&gt;[IterationCleanup]&lt;/code&gt; in microbenchmarks or benchmark which also&lt;/p&gt;
&lt;h4 id=&quot;an-example&quot;&gt;An example&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[SimpleJob(RunStrategy.Monitoring, launchCount: 1, warmupCount: 2, targetCount: 3)]
public class SetupAndCleanupExample
{
  private int setupCounter;
  private int cleanupCounter;

  [IterationSetup]
  public void IterationSetup() =&amp;gt; Console.WriteLine(&amp;quot;// &amp;quot; + &amp;quot;IterationSetup&amp;quot; + &amp;quot; (&amp;quot; + ++setupCounter + &amp;quot;)&amp;quot;);

  [IterationCleanup]
  public void IterationCleanup() =&amp;gt; Console.WriteLine(&amp;quot;// &amp;quot; + &amp;quot;IterationCleanup&amp;quot; + &amp;quot; (&amp;quot; + ++cleanupCounter + &amp;quot;)&amp;quot;);

  [GlobalSetup]
  public void GlobalSetup() =&amp;gt; Console.WriteLine(&amp;quot;// &amp;quot; + &amp;quot;GlobalSetup&amp;quot;);

  [GlobalCleanup]
  public void GlobalCleanup() =&amp;gt; Console.WriteLine(&amp;quot;// &amp;quot; + &amp;quot;GlobalCleanup&amp;quot;);

  [Benchmark]
  public void Benchmark() =&amp;gt; Console.WriteLine(&amp;quot;// &amp;quot; + &amp;quot;Benchmark&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The order of method calls:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// GlobalSetup

// IterationSetup (1)    // IterationSetup Jitting
// IterationCleanup (1)  // IterationCleanup Jitting

// IterationSetup (2)    // MainWarmup1
// Benchmark             // MainWarmup1
// IterationCleanup (2)  // MainWarmup1

// IterationSetup (3)    // MainWarmup2
// Benchmark             // MainWarmup2
// IterationCleanup (3)  // MainWarmup2

// IterationSetup (4)    // MainTarget1
// Benchmark             // MainTarget1
// IterationCleanup (4)  // MainTarget1

// IterationSetup (5)    // MainTarget2
// Benchmark             // MainTarget2
// IterationCleanup (5)  // MainTarget2

// IterationSetup (6)    // MainTarget3
// Benchmark             // MainTarget3
// IterationCleanup (6)  // MainTarget3

// GlobalCleanup
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;some-additional-comments&quot;&gt;Some additional comments&lt;/h4&gt;
&lt;p&gt;In &lt;code&gt;v0.10.6&lt;/code&gt;, we had only the &lt;code&gt;[Setup]&lt;/code&gt; and &lt;code&gt;[Cleanup]&lt;/code&gt; attributes which were renamed to &lt;code&gt;[GlobalSetup]&lt;/code&gt; and &lt;code&gt;[GlobalCleanup]&lt;/code&gt;.
In &lt;code&gt;v0.10.7&lt;/code&gt;, we still have &lt;code&gt;[Setup]&lt;/code&gt; and &lt;code&gt;[Cleanup]&lt;/code&gt; (so, your benchmarks will not be broken after the update) with a simple trick which is very popular for backward compatibility:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Obsolete(&amp;quot;Use GlobalSetupAttribute&amp;quot;)]
public class SetupAttribute : GlobalSetupAttribute
{
}
[Obsolete(&amp;quot;Use GlobalCleanupAttribute&amp;quot;)]
public class CleanupAttribute : GlobalCleanupAttribute
{
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&#39;s recommended to fix your benchmarks because we are going to drop in in a few months.
Here is discussion about renaming: &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/456&quot;&gt;BenchmarkDotNet#456&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Historically, BenchmarkDotNet was focused only on microbenchmarking.
We didn&#39;t implement &lt;code&gt;[IterationSetup]&lt;/code&gt;/&lt;code&gt;[IterationCleanup]&lt;/code&gt; before because these attributes can&#39;t be applied for benchmarking of methods which take nanoseconds (if you want good precision):
Since a lot of our users use it for macrobenchmarking now (and they don&#39;t need super-precision in this case),
it makes sense to support it now and provide a way to use all the BenchmarkDotNet features for such cases.&lt;/p&gt;
&lt;p&gt;See also:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/270&quot;&gt;BenchmarkDotNet#270&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/274&quot;&gt;BenchmarkDotNet#274&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/325&quot;&gt;BenchmarkDotNet#325&lt;/a&gt;,
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/456&quot;&gt;BenchmarkDotNet#456&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;better-value-types-support&quot;&gt;Better Value Types support&lt;/h3&gt;
&lt;p&gt;Microbenchmarking is tricky.
And it&#39;s super-tricky if you are working on the nanosecond-level with value types.
It turned out that we had some troubles with benchmarks that were returning value types prior to v0.10.7,
but &lt;a href=&quot;https://github.com/adamsitnik&quot;&gt;@adamsitnik&lt;/a&gt; solved it, and now we have better support for such cases.
Probably, it&#39;s not the last such problem, so we are going to continue to improve precision with each release!&lt;/p&gt;
&lt;p&gt;See also:
&lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/commit/afa803d0e38c0e11864b2e4394d4a85d3801d944&quot;&gt;BenchmarkDotNet/afa803d0&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;building-sources-on-linux&quot;&gt;Building Sources on Linux&lt;/h3&gt;
&lt;p&gt;BenchmarkDotNet is a cross-platform NuGet package so that you can use all the basic features on Windows, Linux, and MacOS.
We develop BenchmarkDotNet on Windows, but it&#39;s already possible to develop it on Linux and MacOS (with some limitations).
If you have latest &lt;a href=&quot;https://www.microsoft.com/net/download/core&quot;&gt;.NET Core SDK&lt;/a&gt; and &lt;a href=&quot;mon&quot;&gt;http://www.mono-project.com/download/&lt;/a&gt;,
you should be able to build the solution (with unloaded F#/VB projects), run samples (for both &lt;code&gt;net46&lt;/code&gt;/&lt;code&gt;netcoreapp1.1&lt;/code&gt;), run unit tests (for &lt;code&gt;netcoreapp1.1&lt;/code&gt; only).&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;&lt;a href=&quot;/img/posts/bdn-v0_10_7/linux-xunit.png&quot; target=&quot;_blank&quot;&gt;&lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/bdn-v0_10_7/linux-xunit.png&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, I don&#39;t know how to run unit tests on &lt;code&gt;net46&lt;/code&gt; and how to pack NuGet packages on Linux:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;akinshin@xu:~/RiderProjects/BenchmarkDotNet/tests$ dotnet test BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj --configuration Release --framework net46
Build started, please wait...
/usr/share/dotnet/sdk/1.0.4/Microsoft.Common.CurrentVersion.targets(1111,5): error MSB3644: The reference assemblies for framework &amp;quot;.NETFramework,Version=v4.6&amp;quot; were not found. To resolve this, install the SDK or Targeting Pack for this framework version or retarget your application to a version of the framework for which you have the SDK or Targeting Pack installed. Note that assemblies will be resolved from the Global Assembly Cache (GAC) and will be used in place of reference assemblies. Therefore your assembly may not be correctly targeted for the framework you intend. [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018: The &amp;quot;GenerateRuntimeConfigurationFiles&amp;quot; task failed unexpectedly. [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018: System.IO.DirectoryNotFoundException: Could not find a part of the path &#39;/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/bin/Release/net46/BenchmarkDotNet.Tests.runtimeconfig.json&#39;. [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Interop.CheckIo[TSafeHandle](TSafeHandle handle, String path, Boolean isDirectory, Func`2 errorRewriter) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at System.IO.UnixFileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options, FileStream parent) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at System.IO.UnixFileSystem.Open(String fullPath, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options, FileStream parent) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Microsoft.NET.Build.Tasks.GenerateRuntimeConfigurationFiles.WriteToJsonFile(String fileName, Object value) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Microsoft.NET.Build.Tasks.GenerateRuntimeConfigurationFiles.WriteRuntimeConfig(ProjectContext projectContext) [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Microsoft.NET.Build.Tasks.GenerateRuntimeConfigurationFiles.ExecuteCore() [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Microsoft.NET.Build.Tasks.TaskBase.Execute() [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
/usr/share/dotnet/sdk/1.0.4/Sdks/Microsoft.NET.Sdk/build/Microsoft.NET.Sdk.targets(129,5): error MSB4018:    at Microsoft.Build.BackEnd.TaskBuilder.&amp;lt;ExecuteInstantiatedTask&amp;gt;d__25.MoveNext() [/home/akinshin/RiderProjects/BenchmarkDotNet/tests/BenchmarkDotNet.Tests/BenchmarkDotNet.Tests.csproj]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://developercommunity.visualstudio.com/content/problem/61641/targeting-multiple-frameworks-causes-build-to-fail.html&quot;&gt;It seems&lt;/a&gt; that it&#39;s impossible now (.NET Core SDK 1.0.4) by design.
I hope that it will be possible in the future and BenchmarkDotNet will become xplat not only for our users, but also for core BenchmarkDotNet developers.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;v0.10.7&lt;/code&gt; is a small (but important) step forward to &lt;code&gt;v1.0&lt;/code&gt;.
We didn&#39;t release it yet because we are still not sure about how perfect API should look like and what kind of features should be included in a decent benchmarking library.
Any feedback is very valuable, don&#39;t hesitate to &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/issues/new&quot;&gt;create issues&lt;/a&gt; on GitHub if you don&#39;t like the current API or you need some additional features.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BenchmarkDotNet on GitHub: &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;https://github.com/dotnet/BenchmarkDotNet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Official documentation: &lt;a href=&quot;http://benchmarkdotnet.org/&quot;&gt;http://benchmarkdotnet.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;ChangeLog: &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet/wiki/ChangeLog&quot;&gt;https://github.com/dotnet/BenchmarkDotNet/wiki/ChangeLog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>65535 interfaces ought to be enough for anybody</title>
            <link>http://aakinshin.net/posts/mono-and-65535interfaces/</link> 
            <pubDate>Tue, 14 Feb 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/mono-and-65535interfaces/</guid>
            <description>&lt;p&gt;It was a bright, sunny morning.
There were no signs of trouble.
I came to work, opened Slack, and received many messages from my coworkers about failed tests.&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;
  &lt;img class=&quot;mx-auto d-block&quot; width=&quot;800&quot; src=&quot;/img/posts/dotnet/mono-and-65535interfaces/front.png&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;After a few hours of investigation, the situation became clear:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I&#39;m responsible for the unit tests subsystem in &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt;, and only tests from this subsystem were failing.&lt;/li&gt;
&lt;li&gt;I didn&#39;t commit anything to the subsystem for a week because I worked with a local branch.
Other developers also didn&#39;t touch this code.&lt;/li&gt;
&lt;li&gt;The unit tests subsystem is completely independent.
It&#39;s hard to imagine a situation when only the corresponded tests would fail, thousands of other tests pass, and there are no changes in the source code.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git blame&lt;/code&gt; helped to find the &amp;quot;bad commit&amp;quot;: it didn&#39;t include anything suspicious, only a few additional classes in other subsystems.&lt;/li&gt;
&lt;li&gt;Only tests on Linux and MacOS were red.
On Windows, everything was ok.&lt;/li&gt;
&lt;li&gt;Stacktraces in failed tests were completely random.
We had a new stack trace in each test from different subsystems.
There was no connection between these stack traces, unit tests source code, and the changes in the &amp;quot;bad commit.&amp;quot;
There was no clue where we should look for a problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, what was special about this &amp;quot;bad commit&amp;quot;? Spoiler: after these changes, we sometimes have more than 65535 interface implementations at runtime.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;going-back-to-2005&quot;&gt;Going back to 2005&lt;/h3&gt;
&lt;p&gt;Do you remember these days?
It was time of the
&lt;a href=&quot;https://en.wikipedia.org/wiki/.NET_Framework_version_history#.NET_Framework_1.1&quot;&gt;.NET Framework 1.1&lt;/a&gt;,
&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/aa289527(v=vs.71).aspx&quot;&gt;C# 1.2&lt;/a&gt;, and
&lt;a href=&quot;http://www.mono-project.com/docs/about-mono/releases/1.1.3/&quot;&gt;Mono 1.1.3&lt;/a&gt;.
Yes, Mono already existed, but no one ran huge applications on it.
So, it seemed ok &lt;a href=&quot;https://github.com/mono/mono/commit/4e68cba74f65110cf894867c43754f9655bac297&quot;&gt;to use&lt;/a&gt; 16-bit integer type &lt;code&gt;guint16&lt;/code&gt; for &lt;code&gt;interface_id&lt;/code&gt;.
Indeed, who needs more than 65535 interfaces?&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;
  &lt;img class=&quot;mx-auto d-block&quot; width=&quot;800&quot; src=&quot;/img/posts/dotnet/mono-and-65535interfaces/commit2005.png&quot; /&gt;
&lt;/div&gt;
&lt;h3 id=&quot;present-day&quot;&gt;Present day&lt;/h3&gt;
&lt;p&gt;Rider uses the &lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt; codebase which is really big.
Of course, we have many generic classes.
A short fact about .NET: if you have an interface &lt;code&gt;IFoo&amp;lt;T&amp;gt;&lt;/code&gt;, the runtime generates a separate method table per each &lt;code&gt;IFoo&amp;lt;int&amp;gt;&lt;/code&gt;, &lt;code&gt;IFoo&amp;lt;double&amp;gt;&lt;/code&gt;, &lt;code&gt;IFoo&amp;lt;bool&amp;gt;&lt;/code&gt;, and so on.
A short fact about the unit tests subsystem in ReSharper: it uses &lt;em&gt;a lot&lt;/em&gt; of generic classes (especially in the tests for unit tests).&lt;/p&gt;
&lt;p&gt;On Windows, everything worked fine because Rider uses the full .NET Framework which doesn&#39;t have such limitation on the number of interfaces.
On Linux and MacOS, we use Mono as a runtime.
And tests were failing because we have too many interfaces!
It took a week of debugging to find the problem, but we finally did it.&lt;/p&gt;
&lt;p&gt;We found a report in the Mono bug tracking system: &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=10784&quot;&gt;bugzilla.xamarin#10784&lt;/a&gt; (2013-02-28).
We also found a &lt;a href=&quot;https://github.com/mono/mono/pull/2408&quot;&gt;pull request&lt;/a&gt; (2016-01-08) which should solve this problem.
Unfortunately, it was unmerged without any progress.
A &lt;a href=&quot;https://github.com/mono/mono/pull/2408#issuecomment-255080892&quot;&gt;friendly reminder&lt;/a&gt; (2016-10-20) helped, and it was eventually &lt;a href=&quot;https://github.com/mono/mono/pull/2408#event-850109553&quot;&gt;merged&lt;/a&gt; into master (2016-11-07).&lt;/p&gt;
&lt;p&gt;This fix is not a part of the latest stable mono yet.
Fortunately, Rider uses its own Mono fork.
So, we just cherry-picked this commit, and now all of our tests are green again.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=10784&quot;&gt;bugzilla.xamarin#10784: Too many classes implementing an interface? Assertion at class.c:2586, condition `iid ⇐ 65535&#39; not met&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mono/mono/pull/2408&quot;&gt;mono/mono#2408: Enhance maximum number of supported interfaces from 2^16&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mono/mono/commit/4e68cba74f65110cf894867c43754f9655bac297&quot;&gt;mono/mono/4e68cba: class.c, object.c, class-internals.h, marshal.c: rearrange some fields and tweak some types to lower memory usage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>A bug story about named mutex on Mono</title>
            <link>http://aakinshin.net/posts/namedmutex-on-mono/</link> 
            <pubDate>Mon, 13 Feb 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/namedmutex-on-mono/</guid>
            <description>&lt;p&gt;When you write some multithreading magic on .NET,
you can use a cool synchronization primitive called &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.threading.mutex(v=vs.110).aspx&quot;&gt;Mutex&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var mutex = new Mutex(false, &amp;quot;Global\\MyNamedMutex&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You also can make it &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/f55ddskf(v=vs.110).aspx&quot;&gt;named&lt;/a&gt; (and share the mutex between processes)
which works perfectly on Windows:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;
  &lt;img class=&quot;mx-auto d-block&quot; width=&quot;600&quot; src=&quot;/img/posts/dotnet/namedmutex-on-mono/front.png&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;However, today the .NET Framework is cross-platform, so this code should work on any operation system.
What will happen if you use named mutex on Linux or MacOS with the help of Mono or CoreCLR?
Is it possible to create some tricky bug based on this case?
Of course, it does.
Today I want to tell you a story about such bug in &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt; which was a headache for several weeks.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;preamble&quot;&gt;Preamble&lt;/h3&gt;
&lt;p&gt;The easiest way to avoid troubles with named mutex is the following: don&#39;t use them at all.
However, it&#39;s not always possible because you may use 3rd party libraries that use named mutex.
Recently, we had such situation in Rider.
We used &lt;a href=&quot;https://www.nuget.org/packages/NuGet.Client/3.4.3&quot;&gt;NuGet.Client-3.4.3&lt;/a&gt; which contained the &lt;code&gt;Settings.LoadDefaultSettings&lt;/code&gt; method.
This method reads the content of the &lt;a href=&quot;https://docs.microsoft.com/en-us/nuget/consume-packages/configuring-nuget-behavior&quot;&gt;NuGet.Config&lt;/a&gt; files with useful information about package feeds and some other NuGet settings.
Of course, other threads or processes can also write to this file (or read from it) at the same time.
So, we have to protect the access to &lt;code&gt;NuGet.Config&lt;/code&gt; with a synchronization primitive.
NuGet.Client-3.4.3 uses a named mutex for this purpose.
It worked fine in Rider when you used it as a client application.
We also have many integration tests for the NuGet logic and run them on &lt;a href=&quot;https://www.jetbrains.com/teamcity/&quot;&gt;TeamCity&lt;/a&gt; after each commit.
Sometimes, one of these tests was failing on Linux with the following exception:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;at &amp;lt;unknown&amp;gt; &amp;lt;0xffffffff&amp;gt;
at (wrapper managed-to-native) System.Threading.WaitHandle.WaitOne_internal (System.Threading.WaitHandle,intptr,int,bool) &amp;lt;0xffffffff&amp;gt;
at System.Threading.WaitHandle.WaitOne (System.TimeSpan,bool) &amp;lt;0x0009b&amp;gt;
at System.Threading.WaitHandle.WaitOne (System.TimeSpan) &amp;lt;0x0001d&amp;gt;
at NuGet.Configuration.Settings.ExecuteSynchronizedCore (System.Action) &amp;lt;0x00143&amp;gt;
at NuGet.Configuration.Settings.ExecuteSynchronized (System.Action) &amp;lt;0x00019&amp;gt;
at NuGet.Configuration.Settings..ctor (string,string,bool) &amp;lt;0x0032b&amp;gt;
at NuGet.Configuration.Settings.ReadSettings (string,string,bool) &amp;lt;0x0008a&amp;gt;
at NuGet.Configuration.Settings.LoadUserSpecificSettings (System.Collections.Generic.List`1&amp;lt;NuGet.Configuration.Settings&amp;gt;,string,string,NuGet.Configuration.IMachineWideSettings,bool) &amp;lt;0x00418&amp;gt;
at NuGet.Configuration.Settings.LoadDefaultSettings (string,string,NuGet.Configuration.IMachineWideSettings,bool,bool) &amp;lt;0x0031e&amp;gt;
at NuGet.Configuration.Settings.LoadDefaultSettings (string,string,NuGet.Configuration.IMachineWideSettings) &amp;lt;0x00026&amp;gt;

Native stacktrace:

0   mono-sgen                           0x000000010e7c976a mono_handle_native_sigsegv + 282
1   libsystem_platform.dylib            0x00007fff8e929f1a _sigtramp + 26
2   mono-sgen                           0x000000010eab167f tmp_dir + 5471
3   libsystem_c.dylib                   0x00007fff86e909b3 abort + 129
4   mono-sgen                           0x000000010e96f7f3 monoeg_log_default_handler + 211
5   mono-sgen                           0x000000010e96f702 monoeg_g_logv + 114
6   mono-sgen                           0x000000010e96fb04 monoeg_assertion_message + 356
7   mono-sgen                           0x000000010e951740 own_if_owned + 0
8   mono-sgen                           0x000000010e8b8430 ves_icall_System_Threading_WaitHandle_WaitOne_internal + 96
9   ???                                 0x0000000113feccb4 0x0 + 4630432948
10  mscorlib.dll.dylib                  0x0000000110ac347e System_Threading_WaitHandle_WaitOne_System_TimeSpan + 30
11  ???                                 0x00000001264dffda 0x0 + 4937613274
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It was awful because we couldn&#39;t obtain a permanent green build status.
Here is the &lt;a href=&quot;https://github.com/NuGet/NuGet.Client/blob/58bd2dffe9cee8bf62b601f1610df4e9bbb91106/src/NuGet.Core/NuGet.Configuration/Settings/Settings.cs#L1134&quot;&gt;origin&lt;/a&gt; of this exception:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Global: ensure mutex is honored across TS sessions 
using (var mutex = new Mutex(false, $&amp;quot;Global\\{EncryptionUtility.GenerateUniqueToken(fileName)}&amp;quot;))
{
    var owner = false;
    try
    {
        // operations on NuGet.config should be very short lived
        owner = mutex.WaitOne(TimeSpan.FromMinutes(1));
        // decision here is to proceed even if we were not able to get mutex ownership
        // and let the potential IO errors bubble up. Reasoning is that failure to get
        // ownership probably means faulty hardware and in this case it&#39;s better to report
        // back than hang
        ioOperation();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems that the culprit is a named mutex.&lt;/p&gt;
&lt;h3 id=&quot;investigation&quot;&gt;Investigation&lt;/h3&gt;
&lt;p&gt;We have a bug in NuGet here, so I created an issue: &lt;a href=&quot;https://github.com/NuGet/Home/issues/2860&quot;&gt;NuGet/Home#2860&lt;/a&gt;.
This bug is based on a Mono bug with named mutex.
It was almost impossible to reproduce bug locally, so we started to try to create a minimal repro.
After a few weeks (yep, it wasn&#39;t easy), we finally did it (here is the bug report: &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=41914&quot;&gt;bugzilla.xamarin#41914&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;internal class Program
{
    public static void Main(string[] args)
    {
        var a = &amp;quot;&amp;quot;;
        for (var i = 0; i &amp;lt; 100; i++)
        {
            new Thread(Crasher).Start();
        }
        Console.WriteLine(a);
        Console.ReadLine();
    }

    private static void Crasher()
    {
        var rnd = new Random();
        while (true)
        {
            Thread.Sleep(rnd.Next(100, 10000));
            using (var mutex = new Mutex(false, &amp;quot;Global\\TEST&amp;quot;))
            {
                var owner = false;
                try
                {
                    owner = mutex.WaitOne(TimeSpan.FromMinutes(1));
                }
                finally
                {
                    if (owner)
                    {
                        mutex.ReleaseMutex();
                    }
                }
                Console.WriteLine(&amp;quot;PING&amp;quot;);
            }
            Thread.Sleep(rnd.Next(100, 10000));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mono 4.4 crashed with the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;namedmutex_create: error creating mutex handle
PING
PING
PING
PING
PING
PING
PING
PING
PING
PING
PING
PING
PING
PING
_wapi_handle_unref_full: Attempting to unref unused handle 0x4e0
PING
PING
namedmutex_create: error creating mutex handle
PING
PING
PING
PING
PING
PING
_wapi_handle_ref: Attempting to ref unused handle 0x4e3
* Assertion at ../../mono/utils/mono-os-mutex.h:135, condition `res != EINVAL&#39; not met

Stacktrace:

  at &amp;lt;unknown&amp;gt; &amp;lt;0xffffffff&amp;gt;
  at (wrapper managed-to-native) System.Threading.WaitHandle.WaitOne_internal (System.Threading.WaitHandle,intptr,int,bool) &amp;lt;0x00073&amp;gt;
  at System.Threading.WaitHandle.WaitOne (System.TimeSpan,bool) &amp;lt;0x0009b&amp;gt;
  at System.Threading.WaitHandle.WaitOne (System.TimeSpan) &amp;lt;0x0001d&amp;gt;
  at Crasher.Program.Crasher () &amp;lt;0x000f0&amp;gt;
  at System.Threading.ThreadHelper.ThreadStart_Context (object) &amp;lt;0x0009a&amp;gt;
  at System.Threading.ExecutionContext.RunInternal (System.Threading.ExecutionContext,System.Threading.ContextCallback,object,bool) &amp;lt;0x001c6&amp;gt;
  at System.Threading.ExecutionContext.Run (System.Threading.ExecutionContext,System.Threading.ContextCallback,object,bool) &amp;lt;0x00020&amp;gt;
  at System.Threading.ExecutionContext.Run (System.Threading.ExecutionContext,System.Threading.ContextCallback,object) &amp;lt;0x00059&amp;gt;
  at System.Threading.ThreadHelper.ThreadStart () &amp;lt;0x0002e&amp;gt;
  at (wrapper runtime-invoke) object.runtime_invoke_void__this__ (object,intptr,intptr,intptr) &amp;lt;0x000e0&amp;gt;

Native stacktrace:

        0   mono                                0x0000000103f9b0ca mono_handle_native_sigsegv + 271
        1   libsystem_platform.dylib            0x00007fff854c252a _sigtramp + 26
        2   mono                                0x00000001042036a4 tmp_dir + 5316
        3   libsystem_c.dylib                   0x00007fff935536e7 abort + 129
        4   mono                                0x000000010410d1f0 monoeg_g_log + 0
        5   mono                                0x000000010410d175 monoeg_g_logv + 83
        6   mono                                0x000000010410d31a monoeg_assertion_message + 143
        7   mono                                0x00000001040e453d _wapi_handle_timedwait_signal_handle + 1153
        8   mono                                0x00000001040f4aec wapi_WaitForSingleObjectEx + 606
        9   mono                                0x000000010406c01c mono_wait_uninterrupted + 130
        10  mono                                0x000000010406c1ff ves_icall_System_Threading_WaitHandle_WaitOne_internal + 73
        11  ???                                 0x0000000108130b54 0x0 + 4430433108
        12  mscorlib.dll.dylib                  0x00000001062ed7ae System_Threading_WaitHandle_WaitOne_System_TimeSpan + 30
        13  mscorlib.dll.dylib                  0x0000000106140e5b System_Threading_ThreadHelper_ThreadStart_Context_object + 155
        14  mscorlib.dll.dylib                  0x000000010613f331 System_Threading_ExecutionContext_Run_System_Threading_ExecutionContext_System_Threading_ContextCallback_object_bool + 33
        15  mono                                0x0000000103f04876 mono_jit_runtime_invoke + 1578
        16  mono                                0x0000000104090c23 mono_runtime_invoke + 130
        17  mono                                0x0000000104070409 start_wrapper + 424
        18  mono                                0x0000000104106cb1 inner_start_thread + 305
        19  libsystem_pthread.dylib             0x00007fff989c399d _pthread_body + 131
        20  libsystem_pthread.dylib             0x00007fff989c391a _pthread_body + 0
        21  libsystem_pthread.dylib             0x00007fff989c1351 thread_start + 13
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, we have troubles with both NuGet and Mono. Let&#39;s talk about each bug story.&lt;/p&gt;
&lt;h3 id=&quot;nuget&quot;&gt;NuGet&lt;/h3&gt;
&lt;p&gt;After a few weeks, we received a useful &lt;a href=&quot;https://github.com/NuGet/Home/issues/2860#issuecomment-228174849&quot;&gt;comment&lt;/a&gt; by &lt;a href=&quot;https://github.com/migueldeicaza&quot;&gt;@migueldeicaza&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Named mutexes in Mono are process-local, they are not global like they are on Windows, so on the Mono case, it should use the same setup.
In the past, many years ago, mono supported global mutexes across a processes in the user namespace, but that support was very brittle and we removed the code some 4-5 years ago.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The first idea was to avoid named mutexes.
It was implemented in &lt;a href=&quot;https://github.com/NuGet/NuGet.Client/pull/720&quot;&gt;NuGet/NuGet.Client#720&lt;/a&gt;:
NuGet uses a named mutex only on Windows;
otherwise, it uses a process-wide global mutex.
However, it wasn&#39;t a perfect solution because our global mutex isn&#39;t shared between processes.
So, this commit was reverted and replaced by another approach:
&lt;a href=&quot;https://github.com/NuGet/NuGet.Client/pull/725&quot;&gt;NuGet/NuGet.Client#725: use a common locking mechanism (filestream) for all platforms while writing to settings file&lt;/a&gt;.
A &lt;a href=&quot;https://github.com/NuGet/NuGet.Client/pull/725#issue-163279546&quot;&gt;comment&lt;/a&gt; by &lt;a href=&quot;https://github.com/rohit21agrawal&quot;&gt;@rohit21agrawal&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This makes use of a synchronized version of file locking by acquiring a filestream handle on a lock file.
This approach works across all platforms and can do inter-process synchronization too.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can find the current implementation in the &lt;a href=&quot;https://github.com/NuGet/NuGet.Client/blob/release-4.0.0-rc4/src/NuGet.Core/NuGet.Common/ConcurrencyUtilities.cs&quot;&gt;NuGet.Client-4.0.0-rc4/ConcurrencyUtilities.cs&lt;/a&gt; file.
Thus, the issue was resolved.
Due to the fact that we always try to use the latest published version of &lt;a href=&quot;https://github.com/NuGet/NuGet.Client&quot;&gt;NuGet.Client&lt;/a&gt;,
our integration tests were fixed after a dependencies update.
However, there is still a bug in Mono which should also be fixed.&lt;/p&gt;
&lt;h3 id=&quot;mono&quot;&gt;Mono&lt;/h3&gt;
&lt;p&gt;As I mentioned before, we create an &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=41914&quot;&gt;issue&lt;/a&gt; in mono bug tracking system (2016-06-16).
Over time (2016-09-14), it was fixed
(&lt;a href=&quot;https://github.com/mono/mono/pull/3560&quot;&gt;mono/mono#3560: [w32handle] Fix race condition when creating named mutex/event/semaphore&lt;/a&gt;);
the most interesting changes are in the &lt;a href=&quot;https://github.com/mono/mono/pull/3560/files#diff-2fa9d2ef24b4fd347ae97a87829a5f59&quot;&gt;w32handle.c&lt;/a&gt;.
So, we don&#39;t have the described race condition anymore.
However, mutexes in Mono are still process-local, you can&#39;t use it across processes.
Also, the MOBILE profile does not support named mutexes at all: &lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.6.2.16/mcs/class/corlib/System.Threading/Mutex.cs#L164&quot;&gt;mono-4.6.2.16/Mutex.cs#L164&lt;/a&gt;,
it just throws a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.notsupportedexception(v=vs.110).aspx&quot;&gt;NotSupportedException&lt;/a&gt;
(see also &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=26067&quot;&gt;bugzilla.xamarin#26067&lt;/a&gt;).
Be careful!&lt;/p&gt;
&lt;h3 id=&quot;coreclr&quot;&gt;CoreCLR&lt;/h3&gt;
&lt;p&gt;Mono is not the only xplat .NET runtime; we also have &lt;a href=&quot;https://github.com/dotnet/coreclr&quot;&gt;CoreCLR&lt;/a&gt;!
How are things going with named mutexes on Linux and MacOS here?&lt;/p&gt;
&lt;p&gt;Early versions of CoreCLR just throw a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.platformnotsupportedexception(v=vs.110).aspx&quot;&gt;PlatformNotSupportedException&lt;/a&gt;
when users try to create named primitives (see &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/1387&quot;&gt;coreclr#1387&lt;/a&gt;, &lt;a href=&quot;https://github.com/dotnet/corefx/pull/2796&quot;&gt;corefx#2796&lt;/a&gt;).
It wasn&#39;t great because there is a lot of legacy code which already uses named mutexes.
So, after some discussions
(e.g., see &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/1237&quot;&gt;coreclr#1237&lt;/a&gt;, &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/3422&quot;&gt;coreclr#3422&lt;/a&gt;),
the cross-process named mutexes were implemented.
Here is an awesome PR by &lt;a href=&quot;https://github.com/kouvel&quot;&gt;@kouvel&lt;/a&gt;: &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/5030&quot;&gt;coreclr#5030&lt;/a&gt;.
A fragment from the issue summary:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;On systems that support pthread process-shared robust recursive mutexes, they will be used&lt;/li&gt;
&lt;li&gt;On other systems, file locks are used. File locks unfortunately don&#39;t have a timeout in the blocking wait call, and I didn&#39;t find any other sync object with a timed wait with the necessary properties, so polling is done for timed waits.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;When you write cross-platform .NET applications, think twice before using any OS-specific API.
Always check how it&#39;s implemented on your favorite runtime (Mono or CoreCLR).
Even if you are sure that &lt;em&gt;your code&lt;/em&gt; is completely cross-platform,
you still should be ready that there are some xplat bugs in libraries which you are using
(especially if these libraries were originally written for Windows + the full .NET Framework).
Don&#39;t forget about unit and integration tests for multithreading code which execute your methods under load.
And make sure that your CI build server runs these tests on all target operation systems.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/NuGet/Home/issues/2860&quot;&gt;NuGet/Home#2860: Bug in ExecuteSynchronizedCore on Linux/MacOS + Mono&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/NuGet/NuGet.Client/pull/720&quot;&gt;NuGet/NuGet.Client#720: make mono use global mutex instead of named mutex, like in CoreCLR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/NuGet/NuGet.Client/pull/725&quot;&gt;NuGet/NuGet.Client#725: use a common locking mechanism (filestream) for all platforms while writing to settings file&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/NuGet/NuGet.Client/blob/release-4.0.0-rc4/src/NuGet.Core/NuGet.Common/ConcurrencyUtilities.cs&quot;&gt;NuGet.Client-4.0.0-rc4/ConcurrencyUtilities.cs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=26067&quot;&gt;bugzilla.xamarin#26067: Mutexes cannot be created with names without resulting in error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=41914&quot;&gt;bugzilla.xamarin#41914: Race condition in named mutex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mono/mono/pull/3560&quot;&gt;mono/mono#3560: [w32handle] Fix race condition when creating named mutex/event/semaphore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mono/mono/pull/3828&quot;&gt;mono/mono#3828: Change clock source to CLOCK_MONOTONIC in &#39;pthread_cond_timedwait&#39;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/1237&quot;&gt;dotnet/coreclr#1237: Implement named synchronization primitives to be system wide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/1387&quot;&gt;dotnet/coreclr#1387: Throw PlatformNotSupported for named sync primitives on Unix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/3422&quot;&gt;dotnet/coreclr#3422: Named mutex not supported on Unix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/5030&quot;&gt;dotnet/coreclr#5030: Add named mutex for cross-process synchronization &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/pull/2796&quot;&gt;dotnet/corefx#2796: Throw PlatformNotSupportedException for named Semaphore on Unix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>InvalidDataException in Process.GetProcesses</title>
            <link>http://aakinshin.net/posts/invaliddataexception-in-getprocesses/</link> 
            <pubDate>Fri, 10 Feb 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/invaliddataexception-in-getprocesses/</guid>
            <description>&lt;p&gt;Consider the following program:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static void Main(string[] args)
{
    try
    {
        Process.GetProcesses();
    }
    catch (Exception e)
    {
        Console.WriteLine(e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It seems that all exceptions should be caught.
However, &lt;em&gt;sometimes&lt;/em&gt;, I had the following exception on Linux with &lt;code&gt;dotnet cli-1.0.0-preview2&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dotnet run
System.IO.InvalidDataException: Found invalid data while decoding.
   at System.IO.StringParser.ParseNextChar()
   at Interop.procfs.TryParseStatFile(String statFilePath, ParsedStat&amp;amp; result, ReusableTextReader reusableReader)
   at System.Diagnostics.ProcessManager.CreateProcessInfo(ParsedStat procFsStat, ReusableTextReader reusableReader)
   at System.Diagnostics.ProcessManager.CreateProcessInfo(Int32 pid, ReusableTextReader reusableReader)
   at System.Diagnostics.ProcessManager.GetProcessInfos(String machineName)
   at System.Diagnostics.Process.GetProcesses(String machineName)
   at System.Diagnostics.Process.GetProcesses()
   at DotNetCoreConsoleApplication.Program.Main(String[] args) in /home/akinshin/Program.cs:line 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How is that possible?&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;preamble&quot;&gt;Preamble&lt;/h3&gt;
&lt;p&gt;I&#39;m the guy who writes unit testing support in &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt;.
And it works fine with classic unit tests on the full .NET framework and mono.
I know that there are many bugs here (Rider is still in the EAP stage), but at least it works:
you can discover tests, run them, and even debug them.
However, we also have to support new dotnet cli test toolchain.
And there are many troubles with coreclr (probably because it is also in the preview stage).
Even if our communication logic with &lt;code&gt;dotnet test&lt;/code&gt; works on Windows, it doesn&#39;t mean that it works on Linux and MacOS.
Today I want to tell you a story about one bug investigation.
In fact, we have a lot of such stories, but this one is in my favorite bug list.
This story happened in October 2016, so I will tell you about &lt;code&gt;dotnet cli-1.0.0-preview2&lt;/code&gt; (in &lt;code&gt;preview4&lt;/code&gt; bug was fixed).&lt;/p&gt;
&lt;h3 id=&quot;situation&quot;&gt;Situation&lt;/h3&gt;
&lt;p&gt;Do you know what happens when you click &#39;Run&#39; on a unit test from a modern C# project (e.g. based on project.json) in Rider?
It starts a new process like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ dotnet test --port 36513 --parentProcessId 3624 --no-build --framework net451
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it works perfectly on Windows. On Linux, I had the following exception:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dotnet-test Error: 0 : System.IO.InvalidDataException: Found invalid data while decoding.
   at System.IO.StringParser.ParseNextChar()
   at Interop.procfs.TryParseStatFile(String statFilePath, ParsedStat&amp;amp; result, ReusableTextReader reusableReader)
   at System.Diagnostics.ProcessManager.CreateProcessInfo(ParsedStat procFsStat, ReusableTextReader reusableReader)
   at System.Diagnostics.ProcessManager.CreateProcessInfo(Int32 pid, ReusableTextReader reusableReader)
   at System.Diagnostics.ProcessManager.GetProcessInfos(String machineName)
   at System.Diagnostics.Process.GetProcesses(String machineName)
   at System.Diagnostics.Process.GetProcesses()
   at Microsoft.DotNet.Tools.Test.TestCommand.RegisterForParentProcessExit(Int32 id)
   at Microsoft.DotNet.Tools.Test.TestCommand.DoRun(String[] args)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;investigation&quot;&gt;Investigation&lt;/h3&gt;
&lt;p&gt;It seems that the problem is in &lt;code&gt;Process.GetProcesses()&lt;/code&gt;.
It was easy to write a minimal repro which produces this bug (you can find it at the beginning of the post).
Usually, I do a final check for such bugs in a sterile environment: I close all applications and run it from the terminal.
Guess what?
My little program works without any exception now.
Hmmm...
Ok, open this wonderful program in Rider and run it: the &lt;code&gt;InvalidDataException&lt;/code&gt; is back.
Hmmm...
Ok, another experiment: keep Rider opened and run the program from the terminal: we again see &lt;code&gt;InvalidDataException&lt;/code&gt;.
Huh!
It seems that if we want to reproduce the bug, we have to run the program while Rider is running too.&lt;/p&gt;
&lt;p&gt;At this point, I decided to create an issue on GitHub: &lt;a href=&quot;https://github.com/dotnet/corefx/issues/12755&quot;&gt;dotnet/corefx#12755&lt;/a&gt;.
Thanks to &lt;a href=&quot;https://github.com/stephentoub&quot;&gt;@stephentoub&lt;/a&gt;, he helped me to understand what is going on here.&lt;/p&gt;
&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;
&lt;p&gt;Rider is based on the &lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ&lt;/a&gt; platform and &lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt;.
So, we have two main processes: a JVM process and a CLR process.
The name if the CLR process is &lt;code&gt;JetBrains.ReSharper.Host.exe&lt;/code&gt; which includes a lot of threads.
ReSharper is very complicated multithreading application, and we have our own pool of threads (each one has its own name).
Here is a bug &lt;a href=&quot;https://github.com/dotnet/corefx/issues/12755#issuecomment-254853345&quot;&gt;explanation&lt;/a&gt; by &lt;a href=&quot;https://github.com/stephentoub&quot;&gt;@stephentoub&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The JetBrains.ReSharper.Host.exe process has a thread in it with a name that includes spaces: &amp;quot;JetPool (S) Reg&amp;quot;.
When we&#39;re parsing the processes&#39; task list looking for its threads, we parse the stat file for each task, and in doing so, we misinterpret the space in the name as a space separator for the other items in the line.
The fix in System.Diagnostics.Process is likely to track the parens and ensure we treat the whole parenthesized unit as the name.
In the meantime, as a workaround, if you have control over the thread/task&#39;s name (something somewhere is probably calling a function like pthread_setname_np, or using prctl with PR_SET_NAME), you could try using a name that doesn&#39;t include spaces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;workaround&quot;&gt;Workaround&lt;/h3&gt;
&lt;p&gt;Now the bug if fixed, it is a part of
&lt;a href=&quot;https://github.com/dotnet/corefx/pull/12791&quot;&gt;.NET Core 2.0&lt;/a&gt; and
&lt;a href=&quot;https://github.com/dotnet/cli/issues/4452&quot;&gt;dotnet cli 1.0.0-preview4&lt;/a&gt;.
However, many people still use dotnet cli 1.0.0-preview2 and Rider should support it for some time.
We came up with a workaround which allows running unit tests with preview2:
we just don&#39;t specify &lt;code&gt;--parentProcessId&lt;/code&gt; on Linux/MacOS:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var commonArgs = string.Format(&amp;quot;test --port {0} --no-build{1}&amp;quot;,
    server.PortNumber, frameworkArg);
var windowsArgs = string.Format(&amp;quot;test --port {0} --parentProcessId {1} --no-build{2}&amp;quot;,
    server.PortNumber, Process.GetCurrentProcess().Id, frameworkArg);
var args = PlatformUtil.IsRunningUnderWindows ? windowsArgs : commonArgs;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, &lt;code&gt;dotnet&lt;/code&gt; doesn&#39;t call &lt;code&gt;Process.GetProcesses()&lt;/code&gt; and everything works fine.
Rider is able to establish a connection even when the &lt;code&gt;--parentProcessId&lt;/code&gt; parameter is omitted.&lt;/p&gt;
&lt;p&gt;Of course, we could also rename our threads, but I wanted to fix the bug without any changes in the ReSharper core libraries.&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In Rider, we should support many bleeding edge technologies which contain a lot of bugs.
Hopefully, a big part of such technologies will die soon (and will be replaced by stable version).
However, people can&#39;t update all their projects on the same day with the next release of its dependencies.
So, we have to maintain a lot of hacks and ugly pieces of code for several months after the date when another preview was released.
It&#39;s not easy, and it conflicts with our sense of beauty,
but we still try to do everything to make our users happy regardless of which version of runtime they use.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/issues/12755&quot;&gt;dotnet/corefx#12755: InvalidDataException in Process.GetProcesses on Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/pull/12791&quot;&gt;dotnet/corefx#12791: Fix parsing of procfs stat files when comm name contains spaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/issues/12834&quot;&gt;dotnet/corefx#12834: Linux: System.Diagnostics.Process.GetProcesses can throw if reading from /proc for any process fails&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/cli/issues/4452&quot;&gt;dotnet/cli#4452: &amp;quot;dotnet test&amp;quot; crashes if another process or thread has a name with a space&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Why is NuGet search in Rider so fast?</title>
            <link>http://aakinshin.net/posts/rider-nuget-search/</link> 
            <pubDate>Wed, 08 Feb 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/rider-nuget-search/</guid>
            <description>&lt;p&gt;I&#39;m the guy who develops the NuGet manager in &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt;.
It&#39;s not ready yet, there are some bugs here and there, but it already works pretty well.
The feature which I am most proud of is smart and fast search:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;
  &lt;img class=&quot;mx-auto d-block&quot; width=&quot;400&quot; src=&quot;/img/posts/dotnet/rider-nuget-search/front.gif&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;Today I want to share with you some technical details about how it was implemented.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;caching&quot;&gt;Caching&lt;/h3&gt;
&lt;p&gt;In Rider, we are using &lt;a href=&quot;https://www.nuget.org/packages/NuGet.Client/&quot;&gt;NuGet.Client&lt;/a&gt;.
It is a package with a set of APIs which allows doing all the basic NuGet operations: install, uninstall, restore, and search.
So, we can write something like this&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;packageSearchResource.SearchAsync(searchTerm, searchFilters, skip, take, logger, cancellationToken);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and get a list of packages.
And this method is a bottleneck: searching for ten packages can take about 1 second for a remote feed.
If you want to form a big list of search results, you have to wait tens of seconds.&lt;/p&gt;
&lt;p&gt;But we don&#39;t want to wait so long!
We want to look at the package list right now without any delays!
Our solution is the following: we create a local packages cache.
Of course, we don&#39;t want to use a lot of storage space.
So, we keep only a few important fields per package (like &lt;code&gt;Id&lt;/code&gt;, &lt;code&gt;DownloadCount&lt;/code&gt;, &lt;code&gt;IconUrl&lt;/code&gt;, and so on).
When you search a NuGet package in Rider, you always search in our cache!
That is why you have zero-latency typing in the NuGet manager.&lt;/p&gt;
&lt;p&gt;The NuGet package cache is persisted between Rider sessions.
Free bonus: if you launch Rider the second time, you already have a warmed cache.
The search will work as soon as the NuGet component was initialized without additional network requests.&lt;/p&gt;
&lt;h3 id=&quot;fetching&quot;&gt;Fetching&lt;/h3&gt;
&lt;p&gt;Ok, we can take data for search results from cache.
However, we still have to fetch the metadata of packages from a remote feed.
Let&#39;s introduce &lt;em&gt;fetchers&lt;/em&gt;.
Each fetcher can handle fetch requests of a special kind to a specific feed
There are several interesting decisions about fetchers.&lt;/p&gt;
&lt;p&gt;Rider allows searching the same package in several feeds.
Each feed can have own request latency.
We want to show top packages into the cache as soon as possible, and we can&#39;t allow feeds with low latency affect other feeds.
So, we have a separated set of fetchers per feed.&lt;/p&gt;
&lt;p&gt;Next, we create two fetchers per feed: one for the general search and one for fetching metadata of a specific package.
It allows updating
information about installed packages (some of them can have updates) and
information about a selected package (which should be shown on the right panel)
in the background: it doesn&#39;t affect the search process.&lt;/p&gt;
&lt;p&gt;Each search fetcher should fetch information about a big amount of packages.
By default, we are fetching the top 300 packages for each search term.
However, we can&#39;t ask for 300 packages at once: such request has huge latency.
It will take a lot of time before we can update our cache.
We also can&#39;t ask several times for one package one after the other
because each request (even we ask for only one package) also has some minimum latency.
Thus, we found a trade-off: we ask 30 times for a ten package batch.
Maybe there are better values, but it&#39;s a point for future investigation.
Current values work pretty well for now.&lt;/p&gt;
&lt;p&gt;Thus, we have a queue of requests.
Internally, it&#39;s an asynchronous mergeable queue with priorities.
Each request has
&lt;code&gt;searchTerm&lt;/code&gt; (what are we looking for),
&lt;code&gt;skip&lt;/code&gt; (how many packages we should skip),
&lt;code&gt;take&lt;/code&gt; (how many packages we should take),
and a few additional flags.
When you open the NuGet windows for the first time and the search box text is empty, the queue looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;&#39; Skip=0, Take=10
&#39;&#39; Skip=10, Take=10
&#39;&#39; Skip=20, Take=10
&#39;&#39; Skip=30, Take=10
&#39;&#39; Skip=40, Take=10
// ...
&#39;&#39; Skip=280, Take=10
&#39;&#39; Skip=290, Take=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you start to type some text, we add additional 30 requests per typed symbol.
So, if you open the NuGet window, type &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt;, press backspace, then the queue will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;&#39; Skip=0, Take=10
&#39;&#39; Skip=10, Take=10
&#39;&#39; Skip=20, Take=10
&#39;&#39; Skip=30, Take=10
&#39;&#39; Skip=40, Take=10
// ...
&#39;&#39; Skip=280, Take=10
&#39;&#39; Skip=290, Take=10
&#39;a&#39; Skip=0, Take=10
&#39;a&#39; Skip=10, Take=10
&#39;a&#39; Skip=20, Take=10
&#39;a&#39; Skip=30, Take=10
&#39;a&#39; Skip=40, Take=10
// ...
&#39;a&#39; Skip=280, Take=10
&#39;a&#39; Skip=290, Take=10
&#39;ab&#39; Skip=0, Take=10
&#39;ab&#39; Skip=10, Take=10
&#39;ab&#39; Skip=20, Take=10
&#39;ab&#39; Skip=30, Take=10
&#39;ab&#39; Skip=40, Take=10
// ...
&#39;ab&#39; Skip=280, Take=10
&#39;ab&#39; Skip=290, Take=10
&#39;a&#39; Skip=0, Take=10
&#39;a&#39; Skip=10, Take=10
&#39;a&#39; Skip=20, Take=10
&#39;a&#39; Skip=30, Take=10
&#39;a&#39; Skip=40, Take=10
// ...
&#39;a&#39; Skip=280, Take=10
&#39;a&#39; Skip=290, Take=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The source code looks very simple: we just add additional requests and don&#39;t think about anything.
Internally, the queue is very smart; it can optimize this list before it starts to process the next request:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The obsolete requests (&lt;code&gt;request.SearchTerm&lt;/code&gt; ≠ &lt;code&gt;searchBox.Text&lt;/code&gt;) will be deleted.&lt;/li&gt;
&lt;li&gt;The same requests will be merged.&lt;/li&gt;
&lt;li&gt;The rest of the requests will be sorted.&lt;/li&gt;
&lt;li&gt;The first request in the result list will be handled.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;This queue has many additional nice features.
For example, each queue has its own local history.
If we already handled 30 requests for empty string,
next, we type &lt;code&gt;&amp;quot;a&amp;quot;&lt;/code&gt;,
press backspace,
new 30 requests for the empty string will not be handled:
the queue remembers that we already fetched all this information in the recent past.
Of course, each item in the local history has a timestamp,
so you shouldn&#39;t be worried about obsolete results for cases
when remote packages were updated.&lt;/p&gt;
&lt;h3 id=&quot;smart-search&quot;&gt;Smart search&lt;/h3&gt;
&lt;p&gt;Ok, we fetched all the packages and put them into the cache.
Now you should filter all the cached packages and sort them according to the &lt;code&gt;searchTerm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here we use our awesome &lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;R#&lt;/a&gt; search engine.
For example, if I want to find &lt;code&gt;&amp;quot;BenchmarkDotNet&amp;quot;&lt;/code&gt;, I can type:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;BnechmarkDotNet&amp;quot;&lt;/code&gt;: typos will be detected&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;BeDoNe&amp;quot;&lt;/code&gt;: &lt;a href=&quot;https://www.jetbrains.com/help/resharper/2016.3/Navigation_and_Search__CamelHumps.html&quot;&gt;CamelHumps&lt;/a&gt; is supported&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;ИутсрьфклВщеТуе&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;quot;BקמביצשרלDםאNקא&amp;quot;&lt;/code&gt;: no problem if you forget to switch keyboard layout from Russian or Hebrew to English&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;mx-auto&quot;&gt;
  &lt;img class=&quot;mx-auto d-block&quot; width=&quot;400&quot; src=&quot;/img/posts/dotnet/rider-nuget-search/search.gif&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;However, it&#39;s not enough for the NuGet search.
For example, if I type &lt;code&gt;&amp;quot;Json&amp;quot;&lt;/code&gt;,
I probably want to find &lt;a href=&quot;https://www.nuget.org/packages/Newtonsoft.Json/&quot;&gt;Newtonsoft.Json&lt;/a&gt;
instead of &lt;a href=&quot;https://www.nuget.org/packages/JSON/&quot;&gt;JSON&lt;/a&gt;.
So, we have a set of heuristics which try to improve sorting order and put the package which you really want to install in the first place.
For example, for the situation described above, we always move &amp;quot;popular&amp;quot; packages on the top.
But which package is &amp;quot;popular&amp;quot;?
It&#39;s a very hard question especially when you are working with a custom set of packages which are matched to your &lt;code&gt;searchTerm&lt;/code&gt;.
An obvious idea: we can sort all the matched packages by &lt;code&gt;DownloadCount&lt;/code&gt; and take first &lt;code&gt;N&lt;/code&gt;.
But how we should choose &lt;code&gt;N&lt;/code&gt;?
It can not be a constant because our algorithm should work for sets of packages of any size (from 2 to thousands).
Popular packages could have
millions of downloads (like Newtonsoft.Json),
thousands of downloads or
even hundreds of downloads
(depends on particular set of packages).&lt;br /&gt;
You can come up with many different approaches, but here is our way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Build a sorted list of &lt;code&gt;DownloadCount&lt;/code&gt; values&lt;/li&gt;
&lt;li&gt;Peek top 20&lt;/li&gt;
&lt;li&gt;Take the natural logarithm of each number&lt;/li&gt;
&lt;li&gt;Find the largest gap between two neighboring packages,&lt;/li&gt;
&lt;li&gt;All the packages before the gap are popular; they should be moved to the top of the list.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This algorithm can look strange and illogical, but it works very well.
There is no perfect solution for such problems.
So, we just try to create heuristics which work fast and somehow produce the result which you want in each specific situation.&lt;/p&gt;
&lt;h3 id=&quot;future-development&quot;&gt;Future development&lt;/h3&gt;
&lt;p&gt;For now, Rider is in the EAP stage, and there are many features that we want to implement before release.
Some examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Search by &lt;a href=&quot;https://www.jetbrains.com/help/resharper/2016.3/Finding_Exploring_and_Installing_NuGet_Packages.html&quot;&gt;type and namespace&lt;/a&gt;.
It&#39;s hard to integrate such feature in our search engine, but we already have some cool ideas.&lt;/li&gt;
&lt;li&gt;Feed statistics: we want to get the detailed diagnostics information about each feed.
It will allow to predict latency of each request and improve fetcher algorithms.&lt;/li&gt;
&lt;li&gt;Handle &amp;quot;slow&amp;quot; feeds: some private feeds can spend about &lt;em&gt;2 minutes(!)&lt;/em&gt; per one request (I don&#39;t have any idea why).
And it&#39;s a big problem, so we should handle such feeds in a special way.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;In this post, I covered only a few things which are implemented in our NuGet search engine.
There are many technical details under the hood of the small NuGet search box.
And we try to improve it all the time and create the best NuGet manager in the world. =)
If you have any complaints or feature requests, you are welcome on our &lt;a href=&quot;https://youtrack.jetbrains.com/issues?q=project:Rider%20&quot;&gt;issue tracker&lt;/a&gt;.
Your feedback is very important for us.&lt;/p&gt;</description>
        </item>
        <item>
            <title>NuGet2 and a DirectorySeparatorChar bug</title>
            <link>http://aakinshin.net/posts/nuget2-and-directoryseparatorchar/</link> 
            <pubDate>Mon, 06 Feb 2017 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/nuget2-and-directoryseparatorchar/</guid>
            <description>&lt;p&gt;In &lt;a href=&quot;https://www.jetbrains.com/rider/&quot;&gt;Rider&lt;/a&gt;, we care a lot about performance.
I like to improve the application responsiveness and do interesting optimizations all the time.
Rider is already well-optimized, and it&#39;s often hard to make significant performance improvements, so usually I do micro-optimizations which do not have a very big impact on the whole application.
However, sometimes it&#39;s possible to improve the speed of a feature 100 times with just a few lines of code.&lt;/p&gt;
&lt;p&gt;Rider is based on &lt;a href=&quot;https://www.jetbrains.com/resharper/&quot;&gt;ReSharper&lt;/a&gt;, so we have a lot of cool features out of the box.
One of these features is &lt;a href=&quot;https://www.jetbrains.com/help/resharper/2016.3/Code_Analysis__Solution-Wide_Analysis.html&quot;&gt;Solution-Wide Analysis&lt;/a&gt;
which lets you constantly keep track of issues in your solution.
Sometimes, solution-wide analysis takes a lot of time to run because there are many files which should be analyzed.
Of course, it works super fast on small and projects.&lt;/p&gt;
&lt;p&gt;Let&#39;s talk about a performance bug (&lt;a href=&quot;https://youtrack.jetbrains.com/issue/RIDER-3742&quot;&gt;#RIDER-3742&lt;/a&gt;) that we recently had.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Repro:&lt;/em&gt; Open Rider, create a new &amp;quot;ASP .NET MVC Application&amp;quot;, enable solution wide-analysis.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Expected:&lt;/em&gt; The analysis should take 1 second.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Actual:&lt;/em&gt; The analysis takes 1 second on Windows and &lt;strong&gt;2 minutes&lt;/strong&gt; on Linux and MacOS.&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;The solution-wide analysis builds a list of files which should be analyzed.
New asp.net applications depend on eleven NuGet packages include &lt;code&gt;bootstrap&lt;/code&gt; and &lt;code&gt;jQuery&lt;/code&gt;.
Thus, we have many css and JavaScript files in our project model.
Obviously, such files don&#39;t include any user code and should be ignored during the analysis.
On Windows, we have a nice optimization which checks the content of NuGet packages and creates an ignore list.
It turned out that for some reason the ignore list is empty on Linux and MacOS, so all the project model files are added into the analysis list.
As a result, the solution-wide analysis takes 2 minutes (instead of 1 second) to process all these files.&lt;/p&gt;
&lt;p&gt;We use NuGet.Client 4.x for all new features in ReSharper and Rider.
However, we still have a huge amount of legacy code which uses NuGet.Core 2.x.
In particular, the solution-wide analysis still uses NuGet 2.13.
It&#39;s hard to rewrite our entire codebase to make use of the new NuGet API at once, so we still have to use the older one for some time.
Hopefully, it will be completely rewritten soon, but for now, we have issues with a higher priority.&lt;/p&gt;
&lt;p&gt;So, the main question here is the following: why can&#39;t we read the content of the NuGet packages and get the complete content file list.
Let&#39;s look at the corresponding logic:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;foreach (var contentFile in package.GetContentFiles())
    newContent.Add(GetEffectivePath(contentFile));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is the NuGet &lt;a href=&quot;https://github.com/NuGet/NuGet2/blob/2.13/src/Core/Extensions/PackageExtensions.cs#L64&quot;&gt;source code&lt;/a&gt; (v2.13):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static class Constants
{
    /// &amp;lt;summary&amp;gt;
    /// Represents the content directory in the package.
    /// &amp;lt;/summary&amp;gt;
    public static readonly string ContentDirectory = &amp;quot;content&amp;quot;;
}

public static class PackageExtensions
{
    public static IEnumerable&amp;lt;IPackageFile&amp;gt; GetContentFiles(this IPackage package)
    {
        return package.GetFiles(Constants.ContentDirectory);
    }
    
    public static IEnumerable&amp;lt;IPackageFile&amp;gt; GetFiles(this IPackage package, string directory)
    {
        string folderPrefix = directory + Path.DirectorySeparatorChar;
        return package.GetFiles().Where(file =&amp;gt; file.Path.StartsWith(folderPrefix, StringComparison.OrdinalIgnoreCase));
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next interesting thing here is what &lt;code&gt;file.Path&lt;/code&gt; looks like.
Let&#39;s download the &lt;code&gt;bootstrap.4.0.0-alpha6&lt;/code&gt; package and extract metadata (&lt;code&gt;.nuspec&lt;/code&gt;).
Here is the &lt;code&gt;files&lt;/code&gt; section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;&amp;lt;files&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-grid.css&amp;quot; target=&amp;quot;content\Content\bootstrap-grid.css&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-grid.css.map&amp;quot; target=&amp;quot;content\Content\bootstrap-grid.css.map&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-grid.min.css&amp;quot; target=&amp;quot;content\Content\bootstrap-grid.min.css&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-grid.min.css.map&amp;quot; target=&amp;quot;content\Content\bootstrap-grid.min.css.map&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-reboot.css&amp;quot; target=&amp;quot;content\Content\bootstrap-reboot.css&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-reboot.css.map&amp;quot; target=&amp;quot;content\Content\bootstrap-reboot.css.map&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-reboot.min.css&amp;quot; target=&amp;quot;content\Content\bootstrap-reboot.min.css&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap-reboot.min.css.map&amp;quot; target=&amp;quot;content\Content\bootstrap-reboot.min.css.map&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap.css&amp;quot; target=&amp;quot;content\Content\bootstrap.css&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap.css.map&amp;quot; target=&amp;quot;content\Content\bootstrap.css.map&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap.min.css&amp;quot; target=&amp;quot;content\Content\bootstrap.min.css&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Content\bootstrap.min.css.map&amp;quot; target=&amp;quot;content\Content\bootstrap.min.css.map&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Scripts\bootstrap.js&amp;quot; target=&amp;quot;content\Scripts\bootstrap.js&amp;quot; /&amp;gt;
    &amp;lt;file src=&amp;quot;content\Scripts\bootstrap.min.js&amp;quot; target=&amp;quot;content\Scripts\bootstrap.min.js&amp;quot; /&amp;gt;
&amp;lt;/files&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see those file paths in the &lt;code&gt;nuspec&lt;/code&gt; files use the Windows path separator &lt;code&gt;\&lt;/code&gt;
(see &lt;a href=&quot;https://en.wikipedia.org/wiki/Path_(computing)#Representations_of_paths_by_operating_system_and_shell&quot;&gt;Representations of paths by operating system and shell&lt;/a&gt;).
In the source code, we form a &lt;code&gt;folderPrefix&lt;/code&gt; with the help of
&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.io.path.directoryseparatorchar(v=vs.110).aspx&quot;&gt;Path.DirectorySeparatorChar&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;string folderPrefix = directory + Path.DirectorySeparatorChar;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Path.DirectorySeparatorChar&lt;/code&gt; equals to &lt;code&gt;/&lt;/code&gt; on Linux and MacOS and doesn&#39;t equal to the actual &lt;code&gt;nuspec&lt;/code&gt; separator.
So, &lt;code&gt;PackageExtensions.GetContentFiles&lt;/code&gt; returns an empty list.
Let&#39;s do an experiment and rewrite &lt;code&gt;GetContentFiles&lt;/code&gt; in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private static IEnumerable&amp;lt;IPackageFile&amp;gt; GetContentFilesXPlat(IPackage package)
{
  // In a nuspec file we can use any path separator, it&#39;s impossible to say which one is used in advance.
  var folderPrefix1 = Constants.ContentDirectory + @&amp;quot;/&amp;quot;;
  var folderPrefix2 = Constants.ContentDirectory + @&amp;quot;\&amp;quot;;
  return package.GetFiles().Where(file =&amp;gt;
    file.Path.StartsWith(folderPrefix1, StringComparison.OrdinalIgnoreCase) ||
    file.Path.StartsWith(folderPrefix2, StringComparison.OrdinalIgnoreCase));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can use &lt;code&gt;GetContentFilesXPlat&lt;/code&gt; in our code and get the actual list of content files.
I checked that this method now works fine, so I made a commit, pushed it, closed the issue, and started to solve our next performance puzzle.&lt;/p&gt;
&lt;p&gt;The next day, I saw that the issue was reopened.
Our QA engineer told me that the bug is still here.&lt;/p&gt;
&lt;p&gt;Hmm, ok, let&#39;s debug this logic again.
If you read the first code snippet carefully, you may notice that we are working with &amp;quot;effective paths&amp;quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;newContent.Add(GetEffectivePath(contentFile));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each &lt;code&gt;IPackageFile&lt;/code&gt; package has &lt;code&gt;Path&lt;/code&gt; and &lt;code&gt;EffectivePath&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public interface IPackageFile : IFrameworkTargetable
{
    string Path { get; }
    string EffectivePath { get; }
    FrameworkName TargetFramework { get; }
    Stream GetStream();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I did a few more debugging sessions and discovered the following values for the &lt;code&gt;bootstrap-theme&lt;/code&gt; package file:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OS&lt;/th&gt;
&lt;th&gt;Path&lt;/th&gt;
&lt;th&gt;EffectivePath&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;content\Content\bootstrap-theme.css&lt;/td&gt;
&lt;td&gt;Content\bootstrap-theme.css&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;content\Content\bootstrap-theme.css&lt;/td&gt;
&lt;td&gt;content\Content\bootstrap-theme.css&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;You can see that we have the wrong effective path on Linux (&lt;code&gt;content\Content\bootstrap-theme.css&lt;/code&gt; instead of &lt;code&gt;Content\bootstrap-theme.css&lt;/code&gt;).
So, how does NuGet calculate the effective paths? Let&#39;s look at the source code again.
&lt;a href=&quot;https://github.com/NuGet/NuGet2/blob/2.13/src/Core/Utility/VersionUtility.cs#L773&quot;&gt;NuGet-2.13, VersionUtility.cs&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static FrameworkName ParseFrameworkNameFromFilePath(string filePath, out string effectivePath)
{
    var knownFolders = new string[]
    {
        Constants.ContentDirectory,
        Constants.LibDirectory,
        Constants.ToolsDirectory,
        Constants.BuildDirectory
    };
    for (int i = 0; i &amp;lt; knownFolders.Length; i++)
    {
        string folderPrefix = knownFolders[i] + System.IO.Path.DirectorySeparatorChar;
        if (filePath.Length &amp;gt; folderPrefix.Length &amp;amp;&amp;amp;
            filePath.StartsWith(folderPrefix, StringComparison.OrdinalIgnoreCase))
        {
            string frameworkPart = filePath.Substring(folderPrefix.Length);
            try
            {
                return VersionUtility.ParseFrameworkFolderName(
                    frameworkPart,
                    strictParsing: knownFolders[i] == Constants.LibDirectory,
                    effectivePath: out effectivePath);
            }
            catch (ArgumentException)
            {
                // if the parsing fails, we treat it as if this file
                // doesn&#39;t have target framework.
                effectivePath = frameworkPart;
                return null;
            }
        }
    }
    effectivePath = filePath;
    return null;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And again, we have a &lt;code&gt;DirectorySeparatorChar&lt;/code&gt; bug here:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;string folderPrefix = knownFolders[i] + System.IO.Path.DirectorySeparatorChar;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I rewrote this method too; now everything works fine.
I built Rider, checked, and double-checked that the solution-wide analysis takes only 1 second on Linux and MacOS.&lt;/p&gt;
&lt;p&gt;Usually, we send pull requests to 3rd projects with our fixes.
However, it turned out that there are 53 usages of &lt;code&gt;DirectorySeparatorChar&lt;/code&gt; in the NuGet2 source code.
So, I just created an issue: &lt;a href=&quot;https://github.com/NuGet/Home/issues/4509&quot;&gt;NuGet/Home#4509&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Of course, it wasn&#39;t the first bug with &lt;code&gt;\&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;: we fight with them all the time.
I suspect that we will meet a lot of such bugs in the future.
For now, we have a significant performance improvement for the solution-wide analysis for new asp.net projects on Linux and MacOS
(this fix will be included in Rider EAP17).&lt;/p&gt;</description>
        </item>
        <item>
            <title>Performance exercise: Division</title>
            <link>http://aakinshin.net/posts/perfex-div/</link> 
            <pubDate>Mon, 26 Dec 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/perfex-div/</guid>
            <description>&lt;p&gt;In the previous post, we &lt;a href=&quot;/en/blog/dotnet/perfex-min/&quot;&gt;discussed&lt;/a&gt; the performance space of the minimum function
which was implemented via a simple ternary operator and with the help of bit magic.
Now we continue to talk about performance and bit hacks.
In particular, we will divide a positive number by three:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;uint Div3Simple(uint n)   =&amp;gt; n / 3;
uint Div3BitHacks(uint n) =&amp;gt; (uint)((n * (ulong)0xAAAAAAAB) &amp;gt;&amp;gt; 33);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, it&#39;s hard to say which method is faster in advanced because the performance depends on the environment.
Here are some interesting results:&lt;/p&gt;
&lt;table class=&quot;table table-sm&quot;&gt;
  &lt;tr&gt; &lt;th&gt;&lt;/th&gt;              &lt;th&gt;Simple&lt;/th&gt;              &lt;th&gt;BitHacks&lt;/th&gt;             &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x86&lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈8.3ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈2.6ns&lt;/td&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x64&lt;/th&gt; &lt;td class=&quot;fast&quot;&gt;≈2.6ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈1.7ns&lt;/td&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;RyuJIT-x64   &lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈6.9ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈1.5ns&lt;/td&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;Mono4.6.2-x86&lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈8.5ns&lt;/td&gt; &lt;td class=&quot;slow&quot;&gt;≈14.4ns&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;Mono4.6.2-x64&lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈8.3ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈2.8ns&lt;/td&gt;  &lt;/tr&gt;
&lt;/table&gt;
&lt;!--more--&gt;
&lt;p&gt;Let&#39;s try to understand why we could have such results.
Note that it is just an exercise:
we will not discuss which JIT or runtime is better,
how we should write production code, and so on.
Our main goal is to understand which kind of pitfalls we should expect during benchmarking
and why it&#39;s very important to check different environments.&lt;/p&gt;
&lt;h3 id=&quot;bit-hacks&quot;&gt;Bit hacks&lt;/h3&gt;
&lt;p&gt;The first method (&lt;code&gt;n / 3&lt;/code&gt;) looks very obvious.
However, it includes an integer division which is an expensive operation.
Fortunately, there is an &lt;a href=&quot;https://en.wikipedia.org/wiki/Division_algorithm#Division_by_a_constant&quot;&gt;old hack&lt;/a&gt;
which allows replacing &amp;quot;Division by a constant&amp;quot; by &amp;quot;multiplication + bit shift&amp;quot;.&lt;br /&gt;
The basic idea is the following: we should hide the division inside a constant.
In our case, &lt;code&gt;0xAAAAAAAB = RoundUp(2^33 / 3)&lt;/code&gt;.
Thus, we multiply &lt;code&gt;n&lt;/code&gt; by &lt;code&gt;2^33 / 3&lt;/code&gt; and divide it by &lt;code&gt;2^33&lt;/code&gt; (&lt;code&gt;&amp;gt;&amp;gt; 33&lt;/code&gt;).
The result is equal to &lt;code&gt;n/3&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h3&gt;
&lt;p&gt;It&#39;s always hard to benchmark tiny methods.
There are many different ways to benchmark division, each of them will show own results.
Today we will try to measure &lt;em&gt;latency&lt;/em&gt; of our operations.
It means that the next operation in the loop should be started only after the previous operation finished.
So, we create a dependency chain that use the result of previous operation as an input for the next one.
Such construction helps to prevent &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction-level_parallelism&quot;&gt;instruction-level parallelism&lt;/a&gt;.
As usual, we design a benchmark with the help of &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job, MonoJob]
public class DivBench
{
    private uint x = 1, initialValue = uint.MaxValue;

    [Benchmark(OperationsPerInvoke = 32)]
    public void Simple()
    {
        x = initialValue;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
        x = x / 3;
    }

    [Benchmark(OperationsPerInvoke = 32)]
    public void BitHacks()
    {
        x = initialValue;
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
        x = (uint) ((x * (ulong) 0xAAAAAAAB) &amp;gt;&amp;gt; 33);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that &lt;code&gt;x&lt;/code&gt; is a field here.
Here is a little homework exercise for you: check out what happens, if we declare &lt;code&gt;x&lt;/code&gt; as a local variable.&lt;/p&gt;
&lt;p&gt;Another note: BenchmarkDotNet doesn&#39;t allow to run a benchmark against two different version of Mono at the same time
(hopefully, will be fixed soon).
So, I launched it twice and combined output manually.
Raw results on my laptop:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.10.1, OS=Microsoft Windows NT 6.2.9200.0
Processor=Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8
Frequency=2143475 Hz, Resolution=466.5321 ns, Timer=TSC
  LegacyJitX86 : Clr 4.0.30319.42000, 32bit LegacyJIT-v4.6.1586.0
  LegacyJitX64 : Clr 4.0.30319.42000, 64bit LegacyJIT/clrjit-v4.6.1586.0;compatjit-v4.6.1586.0
  RyuJitX64    : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1586.0
  MonoX86      : Mono 4.6.2 (Visual Studio built mono), 32bit
  MonoX64      : Mono 4.6.2 (Visual Studio built mono), 64bit
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th&gt;Mean&lt;/th&gt;
&lt;th&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Simple&lt;/td&gt;
&lt;td&gt;LegacyJitX86&lt;/td&gt;
&lt;td&gt;8.3387 ns&lt;/td&gt;
&lt;td&gt;0.1021 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;LegacyJitX86&lt;/td&gt;
&lt;td&gt;2.5719 ns&lt;/td&gt;
&lt;td&gt;0.0049 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Simple&lt;/td&gt;
&lt;td&gt;LegacyJitX64&lt;/td&gt;
&lt;td&gt;2.5649 ns&lt;/td&gt;
&lt;td&gt;0.0264 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;LegacyJitX64&lt;/td&gt;
&lt;td&gt;1.6595 ns&lt;/td&gt;
&lt;td&gt;0.0136 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Simple&lt;/td&gt;
&lt;td&gt;RyuJitX64&lt;/td&gt;
&lt;td&gt;6.8538 ns&lt;/td&gt;
&lt;td&gt;0.0352 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;RyuJitX64&lt;/td&gt;
&lt;td&gt;1.5413 ns&lt;/td&gt;
&lt;td&gt;0.0138 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Simple&lt;/td&gt;
&lt;td&gt;MonoX86&lt;/td&gt;
&lt;td&gt;8.4779 ns&lt;/td&gt;
&lt;td&gt;0.0136 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;MonoX86&lt;/td&gt;
&lt;td&gt;14.4434 ns&lt;/td&gt;
&lt;td&gt;0.0935 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Simple&lt;/td&gt;
&lt;td&gt;MonoX64&lt;/td&gt;
&lt;td&gt;8.2883 ns&lt;/td&gt;
&lt;td&gt;0.0590 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;MonoX64&lt;/td&gt;
&lt;td&gt;2.8300 ns&lt;/td&gt;
&lt;td&gt;0.0101 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;A nice form:&lt;/p&gt;
&lt;table class=&quot;table table-sm&quot;&gt;
  &lt;tr&gt; &lt;th&gt;&lt;/th&gt;              &lt;th&gt;Simple&lt;/th&gt;              &lt;th&gt;BitHacks&lt;/th&gt;             &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x86&lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈8.3ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈2.6ns&lt;/td&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x64&lt;/th&gt; &lt;td class=&quot;fast&quot;&gt;≈2.6ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈1.7ns&lt;/td&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;RyuJIT-x64   &lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈6.9ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈1.5ns&lt;/td&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;Mono4.6.2-x86&lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈8.5ns&lt;/td&gt; &lt;td class=&quot;slow&quot;&gt;≈14.4ns&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;Mono4.6.2-x64&lt;/th&gt; &lt;td class=&quot;norm&quot;&gt;≈8.3ns&lt;/td&gt; &lt;td class=&quot;fast&quot;&gt;≈2.8ns&lt;/td&gt;  &lt;/tr&gt;
&lt;/table&gt;
&lt;h3 id=&quot;analysis&quot;&gt;Analysis&lt;/h3&gt;
&lt;p&gt;In the table, you can observe two performance mysteries:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;LegacyJIT-x64&lt;/code&gt;+&lt;code&gt;Simple&lt;/code&gt;: it works suspiciously quickly (the same order as in the &lt;code&gt;BitHacks&lt;/code&gt; case).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mono4.6.2-x86&lt;/code&gt;+&lt;code&gt;BitHacks&lt;/code&gt;: it works slowly (&lt;code&gt;BitHacks&lt;/code&gt; made the situation worse).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In other cases, &lt;code&gt;BitHacks&lt;/code&gt; works 3–4 times faster than &lt;code&gt;Simple&lt;/code&gt; which is nice.
Now let&#39;s look at the asm code of both methods in all cases.
The total listings are huge (because of the 32 same operations in each method), so we will look only at a single iteration.&lt;/p&gt;
&lt;h4 id=&quot;legacyjit-x86&quot;&gt;LegacyJIT-x86&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Simple
mov         eax,dword ptr ds:[0089C8FCh]  
mov         ecx,3  
xor         edx,edx  
div         eax,ecx  
mov         dword ptr ds:[0089C8FCh],eax  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; BitHacks
mov         eax,dword ptr ds:[0089C8FCh]  
mov         edx,0AAAAAAABh  
mul         eax,edx  
mov         eax,edx  
shr         eax,1  
xor         edx,edx  
mov         dword ptr ds:[0089C8FCh],eax 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As usual, &lt;code&gt;LegacyJIT-x86&lt;/code&gt; generates really simple code, no magic here.&lt;/p&gt;
&lt;h4 id=&quot;ryujit-x64&quot;&gt;RyuJIT-x64&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Simple
mov         ecx,3 ; Only before the first iteration  
xor         edx,edx  
div         eax,ecx  
mov         dword ptr [00007FFEEDB2338Ch],eax  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; BitHacks
and         eax,0FFFFFFFFh  
imul        rax,rdx  
shr         rax,21h  
and         eax,0FFFFFFFFh  
mov         dword ptr [00007FFEEDB2338Ch],eax 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;RyuJIT-x64&lt;/code&gt; also generates simple code, but it&#39;s a little smarter than &lt;code&gt;LegacyJIT-x86&lt;/code&gt;.
Here we keep the result in &lt;code&gt;eax&lt;/code&gt; and only flush it to memory at the end of an iteration.
&lt;code&gt;LegacyJIT-x86&lt;/code&gt; also loads value from memory to &lt;code&gt;eax&lt;/code&gt; at the start of the iteration.&lt;/p&gt;
&lt;h4 id=&quot;legacyjit-x64&quot;&gt;LegacyJIT-x64&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Simple
mov         ecx,dword ptr [7FFEEDB2338Ch]  
mov         eax,0AAAAAAABh  
mul         eax,ecx  
shr         edx,1  
mov         dword ptr [7FFEEDB2338Ch],edx 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; BitHacks
mov         eax,dword ptr [7FFEEDB2338Ch]  
mov         ecx,0AAAAAAABh  
imul        rax,rcx  
shr         rax,21h  
mov         dword ptr [7FFEEDB2338Ch],eax  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LegacyJIT-x64&lt;/code&gt; is smart enough to replace division by multiplication himself.
Therefore &lt;code&gt;LegacyJIT-x64&lt;/code&gt;+&lt;code&gt;Simple&lt;/code&gt; works fast (the first mystery solved).&lt;/p&gt;
&lt;h4 id=&quot;mono4.6.2-x64&quot;&gt;Mono4.6.2-x64&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;&amp;lt;Simple&amp;gt;:
1c:  movabs $0x1cbc89a1880,%rax
23: 
26:  mov    (%rax),%eax
28:  mov    $0x3,%ecx
2d:  xor    %rdx,%rdx
30:  div    %ecx
32:  mov    %rax,%rcx
35:  movabs $0x1cbc89a1880,%rax
3c: 
3f:  mov    %ecx,(%rax)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;&amp;lt;BitHacks&amp;gt;:
1c:  movabs $0x1cbc89a1880,%rax
23:
26:  mov    (%rax),%eax
28:  mov    %eax,%ecx
2a:  mov    $0xaaaaaaab,%eax
2f:  imul   %rax,%rcx
33:  shr    $0x21,%rcx
37:  shr    $0x0,%ecx
3a:  movabs $0x1cbc89a1880,%rax
41:
44:  mov    %ecx,(%rax)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The asm code produced by &lt;code&gt;Mono4.6.2-x64&lt;/code&gt; doesn&#39;t look so smart, but it&#39;s still simple.
The performance results are almost the same as in the &lt;code&gt;LegacyJIT-x86&lt;/code&gt; and &lt;code&gt;RyuJIT-x64&lt;/code&gt; cases.&lt;/p&gt;
&lt;h4 id=&quot;mono4.6.2-x86&quot;&gt;Mono4.6.2-x86&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;&amp;lt;Simple&amp;gt;:
 d:  mov    0x5dc638(%rip),%eax        # 5dc64b &amp;lt;Simple+0x5dc64b&amp;gt;
13:  mov    $0x3,%ecx
18:  xor    %edx,%edx
1a:  div    %ecx
1c:  mov    %eax,%ecx
1e:  mov    $0x5dc638,%eax
23:  mov    %ecx,(%rax)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For some reasons, it&#39;s not easy to show only one iteration from the original methods.
Therefore we look at the full listings of the following one-iteration version of the &lt;code&gt;BitHacks&lt;/code&gt; benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void BitHacks()
{
    x = initialValue;
    x = (uint)((x * (ulong)0xAAAAAAAB) &amp;gt;&amp;gt; 33);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here is the listing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;&amp;lt;BitHacks&amp;gt;:
 0:  push   %rbp
 1:  mov    %esp,%ebp
 3:  push   %rdi
 4:  sub    $0x34,%esp
 7:  mov    0x8(%rbp),%eax
 a:  mov    %eax,-0x10(%rbp)
 d:  movl   $0x0,-0xc(%rbp)
14:  movl   $0xaaaaaaab,-0x18(%rbp)
1b:  movl   $0x0,-0x14(%rbp)
22:  mov    -0x14(%rbp),%eax
25:  mov    %eax,0xc(%rsp)
29:  mov    -0x18(%rbp),%eax
2c:  mov    %eax,0x8(%rsp)
30:  mov    -0xc(%rbp),%eax
33:  mov    %eax,0x4(%rsp)
37:  mov    -0x10(%rbp),%eax
3a:  mov    %eax,(%rsp)
3d:  callq  c2b9cee &amp;lt;BitHacks+0xc2b9cee&amp;gt;
42:  mov    %edx,-0xc(%rbp)
45:  mov    %eax,-0x10(%rbp)
48:  mov    0x10378794(%rip),%eax        # 103787e2 &amp;lt;BitHacks+0x103787e2&amp;gt;
4e:  mov    -0x10(%rbp),%ecx
51:  mov    %ecx,-0x18(%rbp)
54:  mov    -0xc(%rbp),%ecx
57:  mov    %ecx,-0x14(%rbp)
5a:  test   %eax,%eax
5c:  jne    a0 &amp;lt;BitHacks+0xa0&amp;gt;
5e:  jmp    6c &amp;lt;BitHacks+0x6c&amp;gt;
60:  mov    -0x20(%rbp),%eax
63:  mov    %eax,-0x18(%rbp)
66:  mov    -0x1c(%rbp),%eax
69:  mov    %eax,-0x14(%rbp)
6c:  mov    -0x18(%rbp),%eax
6f:  mov    %eax,-0x10(%rbp)
72:  mov    -0x14(%rbp),%eax
75:  mov    %eax,-0xc(%rbp)
78:  mov    -0xc(%rbp),%eax
7b:  shr    %eax
7d:  lea    -0x4(%rbp),%esp
80:  lea    -0x4(%rbp),%esp
83:  pop    %rdi
84:  leaveq 
85:  retq   
86:  sub    $0xc,%esp
89:  push   %rdi
8a:  nop
8b:  callq  fffffffffe9d6110 &amp;lt;BitHacks+0xfffffffffe9d6110&amp;gt;
90:  movl   $0x0,-0x10(%rbp)
97:  movl   $0x0,-0xc(%rbp)
9e:  jmp    60 &amp;lt;BitHacks+0x60&amp;gt;
a0:  lea    0x0(%rbp),%ebp
a3:  callq  fffffffffffc6ae4 &amp;lt;BitHacks+0xfffffffffffc6ae4&amp;gt;
a8:  mov    %eax,%ecx
aa:  mov    -0x18(%rbp),%edx
ad:  mov    %edx,-0x20(%rbp)
b0:  mov    -0x14(%rbp),%edx
b3:  mov    %edx,-0x1c(%rbp)
b6:  mov    %ecx,%edi
b8:  test   %eax,%eax
ba:  jne    86 &amp;lt;BitHacks+0x86&amp;gt;
bc:  jmp    60 &amp;lt;BitHacks+0x60&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It doesn&#39;t look as simple as previous listings.
&lt;code&gt;Mono4.6.2-x86&lt;/code&gt; generates a huge amount of instructions which explains pure performance (the second mystery solved).
A detailed description of the generated code is beyond the scope of this post, but you can do it yourself as an another homework.
(&lt;em&gt;Hint: check out how &lt;code&gt;Mono4.6.2-x86&lt;/code&gt; works with the &lt;code&gt;uint*ulong&lt;/code&gt; operation.&lt;/em&gt;)&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;If you care about the performance of integer division, you should also care about your runtime and JIT compiler.
&lt;code&gt;LegacyJIT-x64&lt;/code&gt; can apply the described optimization himself and produce fast code.
If you wrote such optimization manually, &lt;code&gt;Mono4.6.2-x86&lt;/code&gt; will run it slowly because it has some troubles with the 64bit multiplication.&lt;/p&gt;
&lt;p&gt;Please, don&#39;t make general conclusions about .NET, Mono, or a particular JIT compiler from this post.
Main idea of my performance exercises is to show how hard microbenchmarking can be.
If you are trying to measure operations which take nanoseconds, you should think about all the target environments.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Performance exercise: Minimum</title>
            <link>http://aakinshin.net/posts/perfex-min/</link> 
            <pubDate>Tue, 20 Dec 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/perfex-min/</guid>
            <description>&lt;p&gt;Performance is tricky. Especially, if you are working with very fast operations. In today benchmarking exercise, we will try to measure performance of two simple methods which calculate minimum of two numbers. Sounds easy? Ok, let&#39;s do it, here are our guinea pigs for today:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int MinTernary(int x, int y)  =&amp;gt; x &amp;lt; y ? x : y;
int MinBitHacks(int x, int y) =&amp;gt; x &amp;amp; ((x - y) &amp;gt;&amp;gt; 31) | y &amp;amp; (~(x - y) &amp;gt;&amp;gt; 31);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here are some results:&lt;/p&gt;
&lt;table class=&quot;table table-sm&quot;&gt;
  &lt;style type=&quot;text/css&quot; scoped&gt;
    td.slow { color: #ff4444; } 
    td.fast { color: #00C851; }
  &lt;/style&gt;
  
  &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;Random&lt;/th&gt;        &lt;th colspan=&quot;2&quot;&gt;Const&lt;/th&gt;          &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;Ternary&lt;/th&gt; &lt;th&gt;BitHacks&lt;/th&gt; &lt;th&gt;Ternary&lt;/th&gt; &lt;th&gt;BitHacks&lt;/th&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x86&lt;/th&gt;
       &lt;td class=&quot;slow&quot;&gt;≈643&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈227&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈160&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈226&#181;s&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x64&lt;/th&gt;
       &lt;td class=&quot;slow&quot;&gt;≈450&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈123&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈68&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈123&#181;s&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;RyuJIT-x64&lt;/th&gt;
       &lt;td class=&quot;slow&quot;&gt;≈594&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈241&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈180&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈241&#181;s&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;Mono-x64&lt;/th&gt;
       &lt;td class=&quot;fast&quot;&gt;≈203&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈283&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈204&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈282&#181;s&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;What&#39;s going on here? Let&#39;s discuss it in detail.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;bit-hacks&quot;&gt;Bit hacks&lt;/h3&gt;
&lt;p&gt;The first implementation looks obvious, but it has one significant problem: it could suffer from branch mispredictions because of a condition in the expression. Fortunately, it is possible to rewrite it without a branch with the help of bit hacks:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int MinBitHacks(int x, int y) =&amp;gt; x &amp;amp; ((x - y) &amp;gt;&amp;gt; 31) | y &amp;amp; (~(x - y) &amp;gt;&amp;gt; 31);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we calculate &lt;code&gt;(x-y)&lt;/code&gt;, the sign of this expression depends on which number is less. Then, &lt;code&gt;(x-y) &amp;gt;&amp;gt; 31&lt;/code&gt; gives a bit mask which contains only zeros or ones. Next, we calculate an inverted mask: &lt;code&gt;~(x - y) &amp;gt;&amp;gt; 31&lt;/code&gt;. Now we &lt;code&gt;and&lt;/code&gt; our operands and the corresponded bit masks (the minimum number get the &lt;code&gt;11...11&lt;/code&gt; mask). That&#39;s all: the &lt;code&gt;or&lt;/code&gt; operator returns the correct result.&lt;/p&gt;
&lt;p&gt;Here is an example for &lt;code&gt;x=8&lt;/code&gt; and &lt;code&gt;y=3&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;mx-auto&quot;&gt;
  &lt;img class=&quot;mx-auto d-block&quot; width=&quot;400&quot; src=&quot;/img/posts/dotnet/perfex-min/hacks.png&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;As you can see, here is no a branch here: we compute the minimum using only bit operations.&lt;/p&gt;
&lt;h3 id=&quot;performance-spaces&quot;&gt;Performance spaces&lt;/h3&gt;
&lt;p&gt;It&#39;s wrong to discuss the performance of some operations in general; we always should think about a space of the performance results (I call it &lt;em&gt;performance space&lt;/em&gt;). Simplifying, you have to consider the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Source code:&lt;/strong&gt; there are different ways to write a benchmark which includes the &lt;code&gt;Min&lt;/code&gt; methods. Today we will take two &lt;code&gt;int&lt;/code&gt; arrays &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; with some data and calculate the third array &lt;code&gt;int[] c&lt;/code&gt; where &lt;code&gt;c[i] = Min(a[i], b[i])&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data:&lt;/strong&gt; we always should check different data patterns. In our case, we are analyzing the branch predictor, so it makes sense to check const and random input patterns.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Environment:&lt;/strong&gt; there are many different environments, today we will check only Full .NET Framework 4.6.2 (with 3 main JIT compilers: &lt;code&gt;LegacyJIT-x86&lt;/code&gt;, &lt;code&gt;LegacyJIT-x64&lt;/code&gt;, &lt;code&gt;RyuJIT-x64&lt;/code&gt;) and Mono 4.6.2 on Windows.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h3&gt;
&lt;p&gt;Here the source code of my benchmarks (based on &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; v0.10.1):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job, MonoJob]
public class MinBench
{
    const int N = 100001;

    private int[] a, b, c;

    public enum StrategyKind
    {
        Const, Random
    }

    [Params(StrategyKind.Const, StrategyKind.Random)]
    public StrategyKind Strategy;

    [Setup]
    public void Setup()
    {
        a = new int[N];
        b = new int[N];
        c = new int[N];
        var rnd = new Random(42);
        for (int i = 0; i &amp;lt; N; i++)
        {
            switch (Strategy)
            {
                case StrategyKind.Const:
                {
                    a[i] = 42;
                    b[i] = 42;
                }
                    break;
                case StrategyKind.Random:
                {
                    a[i] = rnd.Next();
                    b[i] = rnd.Next();
                }
                    break;
            }
        }
    }

    [Benchmark]
    public void Ternary()
    {
        for (int i = 0; i &amp;lt; N; i++)
        {
            int x = a[i], y = b[i];
            c[i] = x &amp;lt; y ? x : y;
        }
    }

    [Benchmark]
    public void BitHacks()
    {
        for (int i = 0; i &amp;lt; N; i++)
        {
            int x = a[i], y = b[i];
            c[i] = x &amp;amp; ((x - y) &amp;gt;&amp;gt; 31) | y &amp;amp; (~(x - y) &amp;gt;&amp;gt; 31);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Raw results:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.10.1, OS=Microsoft Windows NT 6.2.9200.0
Processor=Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8
Frequency=2143475 Hz, Resolution=466.5321 ns, Timer=TSC
  [Host]       : Clr 4.0.30319.42000, 32bit LegacyJIT-v4.6.1586.0
  LegacyJitX64 : Clr 4.0.30319.42000, 64bit LegacyJIT/clrjit-v4.6.1586.0;compatjit-v4.6.1586.0
  LegacyJitX86 : Clr 4.0.30319.42000, 32bit LegacyJIT-v4.6.1586.0
  Mono         : Mono 4.6.2 (Visual Studio built mono), 64bit
  RyuJitX64    : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1586.0
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Job&lt;/th&gt;
&lt;th&gt;Strategy&lt;/th&gt;
&lt;th&gt;Mean&lt;/th&gt;
&lt;th&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;LegacyJitX86&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;643.9113 us&lt;/td&gt;
&lt;td&gt;2.8095 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;LegacyJitX86&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;227.1344 us&lt;/td&gt;
&lt;td&gt;1.3270 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;LegacyJitX86&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;160.0779 us&lt;/td&gt;
&lt;td&gt;0.9276 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;LegacyJitX86&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;225.7077 us&lt;/td&gt;
&lt;td&gt;0.7597 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;LegacyJitX64&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;450.7977 us&lt;/td&gt;
&lt;td&gt;1.1618 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;LegacyJitX64&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;123.3894 us&lt;/td&gt;
&lt;td&gt;0.3052 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;LegacyJitX64&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;68.6997 us&lt;/td&gt;
&lt;td&gt;0.7440 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;LegacyJitX64&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;123.0449 us&lt;/td&gt;
&lt;td&gt;0.7931 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;RyuJitX64&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;594.5310 us&lt;/td&gt;
&lt;td&gt;1.1537 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;RyuJitX64&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;241.1466 us&lt;/td&gt;
&lt;td&gt;1.1446 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;RyuJitX64&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;179.7262 us&lt;/td&gt;
&lt;td&gt;0.4236 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;RyuJitX64&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;240.8385 us&lt;/td&gt;
&lt;td&gt;0.7296 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;203.6173 us&lt;/td&gt;
&lt;td&gt;1.7580 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Random&lt;/td&gt;
&lt;td&gt;283.5624 us&lt;/td&gt;
&lt;td&gt;2.2254 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ternary&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;204.5277 us&lt;/td&gt;
&lt;td&gt;1.5814 us&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BitHacks&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Const&lt;/td&gt;
&lt;td&gt;282.5178 us&lt;/td&gt;
&lt;td&gt;1.9491 us&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Results in a nice form:&lt;/p&gt;
&lt;table class=&quot;table table-sm&quot;&gt;
  &lt;style type=&quot;text/css&quot; scoped&gt;
    td.slow { color: #ff4444; } 
    td.fast { color: #00C851; }
  &lt;/style&gt;
  
  &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th colspan=&quot;2&quot;&gt;Random&lt;/th&gt;        &lt;th colspan=&quot;2&quot;&gt;Const&lt;/th&gt;          &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;&lt;/th&gt; &lt;th&gt;Ternary&lt;/th&gt; &lt;th&gt;BitHacks&lt;/th&gt; &lt;th&gt;Ternary&lt;/th&gt; &lt;th&gt;BitHacks&lt;/th&gt;  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x86&lt;/th&gt;
       &lt;td class=&quot;slow&quot;&gt;≈643&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈227&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈160&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈226&#181;s&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;LegacyJIT-x64&lt;/th&gt;
       &lt;td class=&quot;slow&quot;&gt;≈450&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈123&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈68&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈123&#181;s&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;RyuJIT-x64&lt;/th&gt;
       &lt;td class=&quot;slow&quot;&gt;≈594&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈241&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈180&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈241&#181;s&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt; &lt;th&gt;Mono-x64&lt;/th&gt;
       &lt;td class=&quot;fast&quot;&gt;≈203&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈283&#181;s&lt;/td&gt;
       &lt;td class=&quot;fast&quot;&gt;≈204&#181;s&lt;/td&gt;
       &lt;td class=&quot;slow&quot;&gt;≈282&#181;s&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;h3 id=&quot;analysis&quot;&gt;Analysis&lt;/h3&gt;
&lt;p&gt;First, let&#39;s look at the right part of the table with const input. Here &lt;code&gt;Ternary&lt;/code&gt; is always faster than &lt;code&gt;BitHacks&lt;/code&gt; because it takes a small amount of instruction and the branch predictor works perfectly. For the random input on Full .NET Framework the &lt;code&gt;BitHacks&lt;/code&gt; is faster for all JIT compilers. And there is an explanation for this: &lt;code&gt;Ternary&lt;/code&gt; has a big performance penalty because it&#39;s hard to predict the correct branch. Performance of &lt;code&gt;BitHacks&lt;/code&gt; is the same for both input patterns and it also makes sense: this method doesn&#39;t depend on branch predictor. However, we could also make a few interesting observation about Mono:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ternary&lt;/code&gt; works faster than &lt;code&gt;BitHacks&lt;/code&gt; even on the random input.&lt;/li&gt;
&lt;li&gt;Mono version of &lt;code&gt;Ternary&lt;/code&gt; on the random input works much quicker than the same code on Full .NET Framework.&lt;/li&gt;
&lt;li&gt;Mono shows the same performance for &lt;code&gt;Ternary&lt;/code&gt; and &lt;code&gt;BitHacks&lt;/code&gt; for both input arrays.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;How is it possible? Let&#39;s look at the asm. Here is the asm code for &lt;code&gt;RyuJIT-x64&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; RyuJIT-x64
cmp       ecx,edx         ; check x &amp;lt; y
jl        LESS
mov       eax,edx         ; return y
ret
LESS:
mov       eax,ecx         ; return x
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It looks very simple. How does it possible to rewrite this code and make it faster? Let&#39;s think. The bottleneck here is the &lt;code&gt;jl&lt;/code&gt; instruction which has a significant penalty because of the high-value misprediction rate. Is it possible to rewrite it without conditional jumps? Yes! &lt;a href=&quot;http://x86.renejeschke.de/html/file_module_x86_id_34.html&quot;&gt;Conditional move&lt;/a&gt; to the rescue!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Mono4.6.2-x64
sub       $0x18,%rsp
mov       %rsi,(%rsp)
mov       %rdi,0x8(%rsp)
mov       %rcx,%rdi
mov       %rdx,%rsi
cmp       %esi,%edi
mov       %rsi,%rax
cmovl     %rdi,%rax       ; Move if less (SF&amp;lt;&amp;gt;OF).
mov       (%rsp),%rsi
mov       0x8(%rsp),%rdi
add       $0x18,%rsp
retq
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here Mono uses the &lt;code&gt;cmovl&lt;/code&gt; instruction (&lt;code&gt;0F4C&lt;/code&gt;). So, it will not suffer from branch mispredictions because there is no branch on the asm level (despite we have a condition in the source C# code).&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Thus, we can&#39;t make a conclusion about &lt;code&gt;MinTernary&lt;/code&gt; and &lt;code&gt;MinBitHacks&lt;/code&gt; performance &lt;em&gt;in general&lt;/em&gt;. It&#39;s impossible to say which implementation is better &lt;em&gt;for your problem&lt;/em&gt; without additional measurements because it depends on different conditions (like input data pattern and target runtime).&lt;/p&gt;
&lt;p&gt;Is it a complete performance investigation? Of course, it&#39;s not. We miss something in each component of our performance space:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Source:&lt;/strong&gt; We considered &lt;em&gt;synthetic methods&lt;/em&gt; which calculate minimums in a special way. We easily can do small changes which significantly affect results.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data:&lt;/strong&gt; We checked only &lt;em&gt;two input patterns&lt;/em&gt;: a const pattern and a random pattern with a particular seed. If we take another input array (e.g. some data from real life), we get another performance picture.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Environment:&lt;/strong&gt; We didn&#39;t check Linux and MacOS, CoreCLR, different versions of Mono, and so on. Also, we checked only Intel Core i7 Haswell; another processor micro-architectures have own characteristics of the branch predictor which is the bottleneck in this benchmark.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, we get a good result: we have shown a part of performance space for target operations, and we have found relevant conditions which could affect the speed of our program. Note that it was just a benchmarking exercise, I wanted to show that there are a lot of troubles with benchmarking even in this simple case. Be careful with your performance measurements.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Stopwatch under the hood</title>
            <link>http://aakinshin.net/posts/stopwatch/</link> 
            <pubDate>Fri, 09 Sep 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/stopwatch/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt;
You can find an updated and significantly improved version of this post in my book &lt;a href=&quot;https://www.apress.com/us/book/9781484249406&quot;&gt;&amp;quot;Pro .NET Benchmarking&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;/en/blog/dotnet/datetime/&quot;&gt;the previous post&lt;/a&gt;, we discussed &lt;code&gt;DateTime&lt;/code&gt;.
This structure can be used in situations when you don&#39;t need a good level of precision.
If you want to do high-precision time measurements, you need a better tool because &lt;code&gt;DateTime&lt;/code&gt; has a small resolution and a big latency.
Also, time is tricky, you can create wonderful bugs if you don&#39;t understand how it works (see &lt;a href=&quot;http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time&quot;&gt;Falsehoods programmers believe about time&lt;/a&gt; and &lt;a href=&quot;http://infiniteundo.com/post/25509354022/more-falsehoods-programmers-believe-about-time&quot;&gt;More falsehoods programmers believe about time&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In this post, we will briefly talk about the &lt;a href=&quot;https://msdn.microsoft.com/library/system.diagnostics.stopwatch.aspx&quot;&gt;Stopwatch&lt;/a&gt; class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Which kind of hardware timers could be a base for &lt;code&gt;Stopwatch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;High precision timestamp API on Windows and Linux&lt;/li&gt;
&lt;li&gt;Latency and Resolution of &lt;code&gt;Stopwatch&lt;/code&gt; in different environments&lt;/li&gt;
&lt;li&gt;Common pitfalls: which kind of problems could we get trying to measure small time intervals&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you are not a .NET developer, you can also find a lot of useful information in this post: mainly we will discuss low-level details of high-resolution timestamping (probably your favorite language also uses the same API).
As usual, you can also find useful links for further reading.&lt;/p&gt;
&lt;!--more--&gt;
&lt;div id=&quot;toc&quot;&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;hardware-timers&quot;&gt;Hardware timers&lt;/h3&gt;
&lt;h4 id=&quot;tsc&quot;&gt;TSC&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;TSC&lt;/strong&gt; — &lt;a href=&quot;https://en.wikipedia.org/wiki/Time_Stamp_Counter&quot;&gt;Time Stamp Counter&lt;/a&gt;.
It is an internal 64-bit register present on all x86 processors since the Pentium.
Can be read into &lt;code&gt;EDX:EAX&lt;/code&gt; using the instruction &lt;code&gt;RDTSC&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You can fine a lot of useful information in &lt;a href=&quot;http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf&quot;&gt;Intel: Intel&#174; 64 and IA-32 Architectures Software Developer’s Manual&lt;/a&gt;. In this section, I will often refer to this manual and will call it just “the manual”.&lt;/p&gt;
&lt;p&gt;Opcode for &lt;code&gt;RDTSC&lt;/code&gt; is &lt;code&gt;0F 31&lt;/code&gt; (the manual, Vol. 2B 4-545).
On Windows, it can be read directly from C# code with help of the following asm injection:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;const uint PAGE_EXECUTE_READWRITE = 0x40;
const uint MEM_COMMIT = 0x1000;

[DllImport(&amp;quot;kernel32.dll&amp;quot;, SetLastError = true)]
static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, 
                                  uint flAllocationType, uint flProtect);

static IntPtr Alloc(byte[] asm)
{
    var ptr = VirtualAlloc(IntPtr.Zero, (uint)asm.Length, 
                           MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    Marshal.Copy(asm, 0, ptr, asm.Length);
    return ptr;
}

delegate long RdtscDelegate();

static readonly byte[] rdtscAsm =
{
    0x0F, 0x31, // rdtsc
    0xC3        // ret
};

static void Main()
{
    var rdtsc = Marshal.GetDelegateForFunctionPointer&amp;lt;RdtscDelegate&amp;gt;(Alloc(rdtscAsm));
    Console.WriteLine(rdtsc());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On modern hardware and modern operation systems, TSC works well, but it has a long history and people often consider TSC as an unreliable source of timestamps.
Let&#39;s discuss different generations of TSC and problems which we could get with TSC (you can find more information about it in the manual, Vol. 3B 17-40, section 17.15).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Variant TSC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The first version of TSC (see the list of the processors families in the manual, Vol. 3B 17-40, section 17.15) was very simple: it just counts internal processor clock cycle.&lt;/p&gt;
&lt;p&gt;It&#39;s not a good way to measure time on modern hardware because the processor can dynamically change own frequency (e.g. see &lt;a href=&quot;https://en.wikipedia.org/wiki/SpeedStep&quot;&gt;SpeedStep&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;There is another problem: each processor core has own TSC, and these TSCs are not synchronized.
If a thread starts measurement on one core and ends on another core, the obtained result can&#39;t be reliable.
For example, there is a nice bug report on &lt;code&gt;support.microsoft.com&lt;/code&gt; (see &lt;a href=&quot;https://support.microsoft.com/en-us/kb/895980&quot;&gt;Programs that use the QueryPerformanceCounter function may perform poorly&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\&amp;gt;ping x.x.x.x

Pinging x.x.x.x with 32 bytes of data:

Reply from x.x.x.x: bytes=32 time=-59ms TTL=128
Reply from x.x.x.x: bytes=32 time=-59ms TTL=128
Reply from x.x.x.x: bytes=32 time=-59ms TTL=128
Reply from x.x.x.x: bytes=32 time=-59ms TTL=128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The cause:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This problem occurs when the computer has the AMD Cool&#39;n&#39;Quiet technology (AMD dual cores) enabled in the BIOS or some Intel multi core processors. Multi core or multiprocessor systems may encounter Time Stamp Counter (TSC) drift when the time between different cores is not synchronized. The operating systems which use TSC as a timekeeping resource may experience the issue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you want to use TSC on old hardware/software, you should probably set processor affinity for you thread (see &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/ms686247.aspx&quot;&gt;&lt;code&gt;SetThreadAffinityMask&lt;/code&gt;&lt;/a&gt; for Windows, &lt;a href=&quot;http://linux.die.net/man/2/sched_setaffinity&quot;&gt;&lt;code&gt;sched_setaffinity&lt;/code&gt;&lt;/a&gt; for Linux).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Constant TSC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Constant TSC&lt;/code&gt; is the next generation of TSC which solves the dynamic frequency problem: this kind of TSC increments at a constant rate. It&#39;s a good step forward, but &lt;code&gt;Constant TSC&lt;/code&gt; still has some issues (e.g. it could be stopped when CPU run into deep C-state, see also &lt;a href=&quot;https://software.intel.com/en-us/articles/power-management-states-p-states-c-states-and-package-c-states&quot;&gt;Power Management States: P-States, C-States, and Package C-States&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Invariant TSC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Invariant TSC&lt;/code&gt; is the latest version of the counter which works well.
From the manual:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The invariant TSC will run at a constant rate in all ACPI P-, C-. and T-states. This is the architectural behavior moving forward. On processors with invariant TSC support, the OS may use the TSC for wall clock timer services (instead of ACPI or HPET timers).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You can check which kind of &lt;code&gt;TSC&lt;/code&gt; do you have with the help of the &lt;a href=&quot;https://en.wikipedia.org/wiki/CPUID&quot;&gt;CPUID&lt;/a&gt; opcode.
For example, processors support for invariant TSC is indicated by &lt;code&gt;CPUID.80000007H:EDX[8]&lt;/code&gt; (the manual, Vol. 2A 3-190, Table 3-17).&lt;/p&gt;
&lt;p&gt;On Windows, you can also check it via the &lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/cc835722&quot;&gt;Coreinfo&lt;/a&gt; utility:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-dos&quot;&gt;&amp;gt; Coreinfo.exe | grep -i &amp;quot;tsc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output on my laptop:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Coreinfo v3.31 - Dump information on system CPU and memory topology
Copyright (C) 2008-2014 Mark Russinovich
Sysinternals - www.sysinternals.com
RDTSCP          *       Supports RDTSCP instruction
TSC             *       Supports RDTSC instruction
TSC-DEADLINE    *       Local APIC supports one-shot deadline timer
TSC-INVARIANT   *       TSC runs at constant rate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You can read more about &lt;code&gt;TSC-DEADLINE&lt;/code&gt; in the same manual, Vol. 3A 10-17, section 10.5.4.1)&lt;/p&gt;
&lt;p&gt;You can do the same thing on Linux with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat /proc/cpuinfo | tr &#39; &#39; &#39;\n&#39; | sort -u | grep -i &amp;quot;tsc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output on my laptop:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;constant_tsc
nonstop_tsc
rdtscp
tsc
tsc_adjust
tsc_deadline_timer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Invariant TSC&lt;/code&gt; is specified by a combination of &lt;code&gt;constant_tsc&lt;/code&gt; and &lt;code&gt;nonstop_tsc&lt;/code&gt; flags.&lt;/p&gt;
&lt;p&gt;In the most cases, you can trust &lt;code&gt;Invariant TSC&lt;/code&gt; and use it for high-precision measurements (however, there are still some problems, e.g. synchronization problems on large multi-processor systems).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TSC and out-of-order execution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;There is another interesting fact which you should consider if you want to read the TSC value directly via the &lt;code&gt;RDTSC&lt;/code&gt; instruction: processor can reorder your instruction and spoil your measurements.&lt;/p&gt;
&lt;p&gt;From the manual, Vol. 3B 17-41, section 17.15:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The RDTSC instruction is not serializing or ordered with other instructions. It does not necessarily wait until all previous instructions have been executed before reading the counter. Similarly, subsequent instructions may begin execution before the RDTSC instruction operation is performed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;From &lt;a href=&quot;http://www.agner.org/optimize/optimizing_assembly.pdf&quot;&gt;Optimizing subroutines in assembly language&lt;/a&gt; by Agner Fog (section 18.1):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;On all processors with out-of-order execution, you have to insert &lt;code&gt;XOR EAX,EAX&lt;/code&gt;/&lt;code&gt;CPUID&lt;/code&gt; before and after each read of the counter to prevent it from executing in parallel with anything else. &lt;code&gt;CPUID&lt;/code&gt; is a serializing instruction, which means that it flushes the pipeline and waits for all pending operations to finish before proceeding. This is very useful for testing purposes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So, we can&#39;t just call &lt;code&gt;RDTSC&lt;/code&gt; and be sure that there is no out-of-order execution here.
How can we call it the right way?
Here is a C++ example by Agner Fog (see &lt;a href=&quot;http://www.agner.org/optimize/optimizing_cpp.pdf&quot;&gt;Optimizing software in C++. An optimization guide for Windows, Linux and Mac platforms&lt;/a&gt;, section 16 &amp;quot;Testing speed&amp;quot;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;// Example 16.1
#include &amp;lt;intrin.h&amp;gt;         // Or #include &amp;lt;ia32intrin.h&amp;gt; etc.
long long ReadTSC() {       // Returns time stamp counter
    int dummy[4];           // For unused returns
    volatile int DontSkip;  // Volatile to prevent optimizing
    long long clock;        // Time
    __cpuid(dummy, 0);      // Serialize
    DontSkip = dummy[0];    // Prevent optimizing away cpuid
    clock = __rdtsc();      // Read time
    return clock;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is another interesting instruction: &lt;code&gt;RDTSCP&lt;/code&gt;, it reads time stamp counter and processor ID (see the manual, Vol. 2B 4-547):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reads the current value of the processor’s time-stamp counter (a 64-bit &lt;code&gt;MSR&lt;/code&gt;) into the &lt;code&gt;EDX:EAX&lt;/code&gt; registers and also
reads the value of the &lt;code&gt;IA32_TSC_AUX MSR&lt;/code&gt; (address &lt;code&gt;C0000103H&lt;/code&gt;) into the &lt;code&gt;ECX&lt;/code&gt; register.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;RDTSCP&lt;/code&gt; instruction &lt;strong&gt;waits until all previous instructions have been executed before reading the counter&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;From the manual, Vol. 2B 4-545:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If software requires RDTSC to be executed only after all previous instructions have completed locally, it can either use &lt;code&gt;RDTSCP&lt;/code&gt; (if the processor supports that instruction) or execute the sequence &lt;code&gt;LFENCE&lt;/code&gt;;&lt;code&gt;RDTSC&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Thus, you can use &lt;code&gt;RDTSCP&lt;/code&gt; instead of &lt;code&gt;RDTSC&lt;/code&gt; (if your hardware supports this instruction) and not to be afraid of out-of-order execution.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Latency and resolution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Here is a list of reciprocal throughputs (CPU clock cycles) of &lt;code&gt;RDTSC&lt;/code&gt; from &lt;a href=&quot;http://www.agner.org/optimize/instruction_tables.pdf&quot;&gt;Instruction tables by Agner Fog&lt;/a&gt; &lt;em&gt;(2016-01-09)&lt;/em&gt; for different processors:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Processor Name&lt;/th&gt;
&lt;th&gt;Reciprocal throughput&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AMD K7&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMD K8&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMD K10&lt;/td&gt;
&lt;td&gt;67&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMD Bulldozer&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMD Pilediver&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMD Steamroller&lt;/td&gt;
&lt;td&gt;78&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMD Bobcat&lt;/td&gt;
&lt;td&gt;87&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AMD Jaguar&lt;/td&gt;
&lt;td&gt;41&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Pentium II/III&lt;/td&gt;
&lt;td&gt;42&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Core 2 (Merom)&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Core 2 (Wolfdale)&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Nehalem&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Sandy Bridge&lt;/td&gt;
&lt;td&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Ivy Bridge&lt;/td&gt;
&lt;td&gt;27&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Haswell&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Broadwell&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Skylake&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Pentium 4&lt;/td&gt;
&lt;td&gt;80&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Intel Pentium 4 w. EM64T (Prescott)&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VIA Nano 2000 series&lt;/td&gt;
&lt;td&gt;39&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VIA Nano 3000 series&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;How can we interpret these numbers?
Let&#39;s say that we have Intel Haswell (our reciprocal throughput is &lt;code&gt;24&lt;/code&gt;) with fixed CPU frequency = &lt;code&gt;2.2GHz&lt;/code&gt;.
So, &lt;code&gt;1&lt;/code&gt; CPU clock cycle is about &lt;code&gt;0.45ns&lt;/code&gt; (it&#39;s our resolution).
We can say that single &lt;code&gt;RDTSC&lt;/code&gt; invocation takes approximately &lt;code&gt;24 x 0.45ns ≈ 10.8ns&lt;/code&gt; (for &lt;code&gt;RDTSC&lt;/code&gt; we can assume that latency is approximate equals to reciprocal throughput).&lt;/p&gt;
&lt;p&gt;You can also evaluate throughput of &lt;code&gt;RDTSC&lt;/code&gt; on your machine. Download &lt;a href=&quot;www.agner.org/optimize/testp.zip&quot;&gt;&lt;code&gt;testp.zip&lt;/code&gt;&lt;/a&gt; from the Anger Fog site, build it, and run &lt;code&gt;misc_int.sh1&lt;/code&gt;.
Here are results on my laptop (Intel Haswell):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rdtsc Throughput

Processor 0
     Clock   Core cyc   Instruct       Uops     uop p0     uop p1     uop p2 
      1686       2384        100       1500        255        399          0 
      1686       2384        100       1500        255        399          0 
      1686       2384        100       1500        255        399          0 
      1686       2384        100       1500        254        399          0 
      1686       2384        100       1500        255        399          0 
      1686       2384        100       1500        255        399          0 
      1686       2384        100       1500        255        399          0 
      1686       2384        100       1500        254        399          0 
      1686       2384        100       1500        255        399          0 
      1686       2384        100       1500        255        399          0 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we have 2384 CPU cycles per 100 &lt;code&gt;RDTSC&lt;/code&gt; instructions which mean approximately 24 cycles per instruction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;As we can see, TSC has a high resolution and low latency.
However, you don&#39;t want to use it in general because there are a lot of problems with TSC.
Here is a brief summary:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some old processors don&#39;t have TSC registers.&lt;/li&gt;
&lt;li&gt;The processor can change the frequency and affect the old version of TSC.&lt;/li&gt;
&lt;li&gt;There are synchronization problems on multi-core systems.&lt;/li&gt;
&lt;li&gt;Even if we have &lt;code&gt;Invariant TSC&lt;/code&gt;, there are still synchronization problems on large multi-processor systems.&lt;/li&gt;
&lt;li&gt;Some processors can execute &lt;code&gt;RDTSC&lt;/code&gt; out of order.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is another detailed problems summary in MSDN: &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/dn553408.aspx#AppendixB&quot;&gt;Acquiring high-resolution time stamps, &amp;quot;TSC Register&amp;quot; section&lt;/a&gt;. Also, you can find a nice problems overview in this article: &lt;a href=&quot;http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/&quot;&gt;Pitfalls of TSC usage&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Thus, TSC is not a good choice for time measurements in general case because you can&#39;t be sure in advance that it produces reliable measurements.
Fortunately, modern operation systems provide nice API which allows getting the most reliable timestamps for current hardware.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;acpi-pm-and-hpet&quot;&gt;ACPI PM and HPET&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;ACPI PM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;ACPI&lt;/em&gt; is Advanced Configuration and Power Interface. It defines a power management timer that provides accurate time values. By &lt;a href=&quot;http://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf&quot;&gt;specification&lt;/a&gt; (&lt;em&gt;v6.0, April 2015&lt;/em&gt;), frequency of the Power Management Timer should be &lt;code&gt;3.579545 MHz&lt;/code&gt; (see section &lt;em&gt;4.8.2.1&lt;/em&gt;):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The power management timer is a 24-bit or 32-bit fixed rate free running count-up timer that runs off a &lt;code&gt;3.579545 MHz&lt;/code&gt; clock. The ACPI OS checks the &lt;code&gt;FADT&lt;/code&gt; to determine whether the PM Timer is a 32-bit or 24-bit timer. The programming model for the PM Timer consists of event logic and a read port to the counter value. The event logic consists of an event status and enables bit. The status bit is set any time the last bit of the timer (bit 23 or bit 31) goes from set to clear or clear to set. If the &lt;code&gt;TMR_EN&lt;/code&gt; bit is set, then the setting of the &lt;code&gt;TMR_STS&lt;/code&gt; will generate an ACPI event in the &lt;code&gt;PM1_EVT&lt;/code&gt; register grouping (referred to as &lt;code&gt;PMTMR_PME&lt;/code&gt; in the diagram). The event logic is only used to emulate a larger timer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;But why do we have exactly &lt;code&gt;3.579545 MHz&lt;/code&gt; (which equals to &lt;code&gt;5&#215;7&#215;9/(8&#215;11) MHz&lt;/code&gt;)?
Historically, this number comes from The National Television System Committee (&lt;a href=&quot;https://en.wikipedia.org/wiki/NTSC&quot;&gt;NTSC&lt;/a&gt;),
here is &lt;a href=&quot;https://en.wikipedia.org/wiki/NTSC#History&quot;&gt;a nice explanation&lt;/a&gt; from Wikipedia:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In January 1950, the Committee was reconstituted to standardize color television. In December 1953, it unanimously approved what is now called the NTSC color television standard (later defined as RS-170a). The &amp;quot;compatible color&amp;quot; standard retained full backward compatibility with existing black-and-white television sets. Color information was added to the black-and-white image by introducing a color subcarrier of precisely &lt;code&gt;3.579545 MHz&lt;/code&gt; (nominally &lt;code&gt;3.58 MHz&lt;/code&gt;). The precise frequency was chosen so that horizontal line-rate modulation components of the chrominance signal would fall exactly in between the horizontal line-rate modulation components of the luminance signal, thereby enabling the chrominance signal to be filtered out of the luminance signal with minor degradation of the luminance signal. Due to limitations of frequency divider circuits at the time the color standard was promulgated, the color subcarrier frequency was constructed as composite frequency assembled from small integers, in this case, 5&#215;7&#215;9/(8&#215;11) MHz. The horizontal line rate was reduced to approximately 15,734 lines per second (&lt;code&gt;3.579545&#215;2/455 MHz&lt;/code&gt;) from 15,750 lines per second, and the frame rate was reduced to approximately 29.970 frames per second (the horizontal line rate divided by 525 lines/frame) from 30 frames per second. These changes amounted to 0.1 percent and were readily tolerated by existing television receivers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;HPET&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;From &lt;a href=&quot;https://en.wikipedia.org/wiki/High_Precision_Event_Timer&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The High Precision Event Timer (HPET) is a hardware timer used in personal computers. It was developed jointly by AMD and Microsoft and has been incorporated in PC chipsets since circa 2005.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;According to (&lt;a href=&quot;http://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/software-developers-hpet-spec-1-0a.pdf&quot;&gt;IA-PC HPET Specification Rev 1.0a&lt;/a&gt;, section 2.2), minimum HPET clock frequency is &lt;code&gt;10 MHz&lt;/code&gt;.
However, default HPET frequency is &lt;code&gt;14.31818 MHz&lt;/code&gt; or 4x the ACPI clock
(it allows to use the same crystal oscillator in HPET and ACPI PM, see also &lt;a href=&quot;https://en.wikipedia.org/wiki/Colorburst#Crystals&quot;&gt;wiki/Colorburst#Crystals&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;On Windows you can enable or disable HPET with the help of the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;:: Enable HPET (reboot is required): 
bcdedit /set useplatformclock true
:: Disable HPET (reboot is required):
bcdedit /deletevalue useplatformclock
:: View all Windows Boot Manager/Loader values:
bcdedit /enum
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are some useful commands on Linux:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Get available clocksource:
$ cat /sys/devices/system/clocksource/clocksource0/available_clocksource
tsc hpet acpi_pm 

# Get current clocksource:
$ cat /sys/devices/system/clocksource/clocksource0/current_clocksource 
tsc

# Set current clocksource:
$ sudo /bin/sh -c &#39;echo hpet &amp;gt; /sys/devices/system/clocksource/clocksource0/current_clocksource&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usually, HPET is disabled by default on modern hardware because of large latency (see the &lt;a href=&quot;#benchmarks&quot;&gt;Benchmarks&lt;/a&gt; section).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;operation-systems&quot;&gt;Operation Systems&lt;/h3&gt;
&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;The best article about time stamps on Windows is &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/dn553408.aspx&quot;&gt;Acquiring high-resolution time stamps&lt;/a&gt;.
Brief summary:&lt;/p&gt;
&lt;p&gt;On Windows, the primary API for high-resolution time stamps is &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/ms644904.aspx&quot;&gt;QueryPerformanceCounter (QPC)&lt;/a&gt;.
For device drivers, the kernel-mode API is &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/ff553053.aspx&quot;&gt;KeQueryPerformanceCounter&lt;/a&gt;.
If you need high-resolution time-of-day measurements, use &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/hh706895.aspx&quot;&gt;GetSystemTimePreciseAsFileTime&lt;/a&gt; (available since Windows 8 / Windows Server 2012).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;QPC&lt;/code&gt; is completely independent of the system time and UTC (it is not affected by daylight savings time, leap seconds, time zones).
It is also not affected by processor frequency changes.
Thus, it is th best option, if you want to measure duration of an operation. If you want to know high-precision DateTime, use &lt;code&gt;GetSystemTimePreciseAsFileTime&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;QPC is available on &lt;em&gt;Windows XP and Windows 2000&lt;/em&gt; and works well on most systems. However, some hardware systems BIOS did not indicate the hardware CPU characteristics correctly (a non-invariant TSC), and some multi-core or multi-processor systems used processors with TSCs that could not be synchronized across cores. Systems with flawed firmware that run these versions of Windows might not provide the same QPC reading on different cores if they used the TSC as the basis for QPC.&lt;/li&gt;
&lt;li&gt;All computers that shipped with &lt;em&gt;Windows Vista and Windows Server 2008&lt;/em&gt; used the HPET or the ACPI PM as the basis for QPC.&lt;/li&gt;
&lt;li&gt;The majority of &lt;em&gt;Windows 7 and Windows Server 2008 R2&lt;/em&gt; computers have processors with constant-rate TSCs and use these counters as the basis for QPC.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Windows 8, Windows 8.1, Windows Server 2012, and Windows Server 2012 R2&lt;/em&gt; use TSCs as the basis for the performance counter.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are two main functions for high-resolution time stamps in &lt;code&gt;kernel32.dll&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DllImport(&amp;quot;kernel32.dll&amp;quot;)]
private static extern bool QueryPerformanceCounter(out long value);

[DllImport(&amp;quot;kernel32.dll&amp;quot;)]
private static extern bool QueryPerformanceFrequency(out long value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, we can get tick counter via &lt;code&gt;QueryPerformanceCounter&lt;/code&gt;.
But how does it work?
Let&#39;s write a simple program:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;static void Main(string[] args)
{
    long ticks;
    QueryPerformanceCounter(out ticks);
}

[DllImport(&amp;quot;kernel32.dll&amp;quot;)]
private static extern bool QueryPerformanceCounter(out long value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;build it (Release-x64) and open the executable in WinDbg.
There is a difference between x86 and x64 asm code, but x64 asm code will be enough to understand what&#39;s going on.
Let&#39;s go to to the &lt;code&gt;KERNEL32!QueryPerformanceCounter&lt;/code&gt; (we even don&#39;t need &lt;code&gt;sos.dll&lt;/code&gt; here):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; bp KERNEL32!QueryPerformanceCounter
&amp;gt; g
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;KERNEL32!QueryPerformanceCounter:
00007ffe6ccbb720  jmp     qword ptr [KERNEL32!QuirkIsEnabled2Worker+0x9ec8 (00007ffe6cd16378)] 
                                    ds:00007ffe6cd16378={ntdll!RtlQueryPerformanceCounter (00007ffe6d83a7b0)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are not able to set a breakpoint to &lt;code&gt;KERNEL32!QueryPerformanceCounter&lt;/code&gt;, you can try to use &lt;code&gt;KERNEL32!QueryPerformanceCounterStub&lt;/code&gt;
(I have observed both situations on Windows 10):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; bp KERNEL32!QueryPerformanceCounterStub
&amp;gt; g
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;KERNEL32!QueryPerformanceCounterStub:
00007fff431f5750 jmp      qword ptr [KERNEL32!_imp_QueryPerformanceCounter (00007fff`43255290)]
                                    ds:00007fff43255290={ntdll!RtlQueryPerformanceCounter (00007fff`45300ff0)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;KERNEL32!QueryPerformanceCounter&lt;/code&gt; (or &lt;code&gt;KERNEL32!QueryPerformanceCounterStub&lt;/code&gt;) just redirects us to &lt;code&gt;ntdll!RtlQueryPerformanceCounter&lt;/code&gt;.
Let&#39;s look at the disassembly of this method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; uf ntdll!RtlQueryPerformanceCounter
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;ntdll!RtlQueryPerformanceCounter:
00007ffe6d83a7b0  push    rbx
00007ffe6d83a7b2  sub     rsp,20h
00007ffe6d83a7b6  mov     al,byte ptr [SharedUserData+0x3c6 (000000007ffe03c6)]
00007ffe6d83a7bd  mov     rbx,rcx
00007ffe6d83a7c0  cmp     al,1
00007ffe6d83a7c2  jne     ntdll!RtlQueryPerformanceCounter+0x44 (00007ffe6d83a7f4)

ntdll!RtlQueryPerformanceCounter+0x14:
00007ffe6d83a7c4  mov     rcx,qword ptr [SharedUserData+0x3b8 (000000007ffe03b8)]
00007ffe6d83a7cc  rdtsc
00007ffe6d83a7ce  shl     rdx,20h
00007ffe6d83a7d2  or      rax,rdx
00007ffe6d83a7d5  mov     qword ptr [rbx],rax
00007ffe6d83a7d8  lea     rdx,[rax+rcx]
00007ffe6d83a7dc  mov     cl,byte ptr [SharedUserData+0x3c7 (000000007ffe03c7)]
00007ffe6d83a7e3  shr     rdx,cl
00007ffe6d83a7e6  mov     qword ptr [rbx],rdx

ntdll!RtlQueryPerformanceCounter+0x39:
00007ffe6d83a7e9  mov     eax,1
00007ffe6d83a7ee  add     rsp,20h
00007ffe6d83a7f2  pop     rbx
00007ffe6d83a7f3  ret

ntdll!RtlQueryPerformanceCounter+0x44:
00007ffe6d83a7f4  lea     rdx,[rsp+40h]
00007ffe6d83a7f9  lea     rcx,[rsp+38h]
00007ffe6d83a7fe  call    ntdll!NtQueryPerformanceCounter (00007ffe6d8956f0)
00007ffe6d83a803  mov     rax,qword ptr [rsp+38h]
00007ffe6d83a808  mov     qword ptr [rbx],rax
00007ffe6d83a80b  jmp     ntdll!RtlQueryPerformanceCounter+0x39 (00007ffe6d83a7e9)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I will try to explain the situation in simple terms.
There is a special flag in &lt;code&gt;[SharedUserData+0x3c6 (000000007ffe03c6)]&lt;/code&gt; that determines which QPC algorithm we will use.
If everything is fine (we are working on modern hardware with invariant TSC and we can directly use it), we are going to the fast algorithm (&lt;code&gt;ntdll!RtlQueryPerformanceCounter+0x14&lt;/code&gt;). Otherwise, we are going to call &lt;code&gt;ntdll!NtQueryPerformanceCounter&lt;/code&gt; which produces a &lt;code&gt;syscall&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; uf ntdll!NtQueryPerformanceCounter
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ntdll!NtQueryPerformanceCounter:
00007ffe6d8956f0  mov     r10,rcx
00007ffe6d8956f3  mov     eax,31h
00007ffe6d8956f8  test    byte ptr [SharedUserData+0x308 (000000007ffe0308)],1
00007ffe6d895700  jne     ntdll!NtQueryPerformanceCounter+0x15 (00007ffe6d895705)

ntdll!NtQueryPerformanceCounter+0x12:
00007ffe6d895702  syscall
00007ffe6d895704  ret

ntdll!NtQueryPerformanceCounter+0x15:
00007ffe6d895705  int     2Eh
00007ffe6d895707  ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An important fact about the fast algorithm (&lt;code&gt;ntdll!RtlQueryPerformanceCounter+0x14&lt;/code&gt;): it directly calls &lt;code&gt;rdtsc&lt;/code&gt; without any syscalls. It allows achieving low latency for simple situations (when we really can use TSC without any troubles).&lt;/p&gt;
&lt;p&gt;Another interesting fact: &lt;code&gt;QPC&lt;/code&gt; use shifted value of &lt;code&gt;rdtsc&lt;/code&gt;: after it puts full value of the counter in &lt;code&gt;rdx&lt;/code&gt;, it performs &lt;code&gt;shr rdx,cl&lt;/code&gt; (where &lt;code&gt;cl&lt;/code&gt; typically equals to &lt;code&gt;0xA&lt;/code&gt;).
Thus, one &lt;code&gt;QPC&lt;/code&gt; tick is 1024 &lt;code&gt;rdtsc&lt;/code&gt; ticks.
We can say the same thing about &lt;code&gt;QPF&lt;/code&gt;: nominal Windows frequency for high-precision measurements is 1024 times less than &lt;code&gt;rdtsc&lt;/code&gt; frequency.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;On Linux, there are many different time functions:
&lt;a href=&quot;http://linux.die.net/man/2/time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;http://linux.die.net/man/3/clock&quot;&gt;&lt;code&gt;clock()&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;http://linux.die.net/man/3/clock_gettime&quot;&gt;&lt;code&gt;clock_gettime()&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;http://linux.die.net/man/2/getrusage&quot;&gt;&lt;code&gt;getrusage()&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;http://linux.die.net/man/2/gettimeofday&quot;&gt;&lt;code&gt;gettimeofday()&lt;/code&gt;&lt;/a&gt;,
&lt;a href=&quot;https://developer.apple.com/library/mac/#qa/qa1398/_index.html&quot;&gt;&lt;code&gt;mach_absolute_time()&lt;/code&gt;&lt;/a&gt;
(you can find a nice overview &lt;a href=&quot;http://stackoverflow.com/a/12480485/184842&quot;&gt;here&lt;/a&gt;).
Both CoreCLR and Mono uses &lt;code&gt;clock_getttime&lt;/code&gt; as a primary way (with fallbacks to &lt;code&gt;mach_absolute_time&lt;/code&gt; and &lt;code&gt;gettimeofday&lt;/code&gt;) because it&#39;s the best way to get high-precision time stamp. This function has the following signature:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;int clock_gettime(clockid_t clk_id, struct timespec *tp);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;clockid_t&lt;/code&gt; is ID of the target clock. For high precision timestamping, we should use &lt;code&gt;CLOCK_MONOTONIC&lt;/code&gt; (if this option is available on current hardware) but there are other clock option (like &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; for real-time clock or &lt;code&gt;CLOCK_THREAD_CPUTIME_ID&lt;/code&gt; for thread-specific CPU-time clock). The target timestamp will be returned as a &lt;code&gt;timespec&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct timespec {
    time_t tv_sec; /* seconds */
    long tv_nsec;  /* nanoseconds */ };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A usage example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;struct timespec ts;
uint64_t timestamp;
clock_gettime(CLOCK_MONOTONIC, &amp;amp;ts);
timestamp = (static_cast&amp;lt;uint64_t&amp;gt;(ts.tv_sec) * 1000000000) + static_cast&amp;lt;uint64_t&amp;gt;(ts.tv_nsec);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, minimal possible resolution of &lt;code&gt;clock_gettime&lt;/code&gt; is &lt;code&gt;1 ns&lt;/code&gt;. Internally, &lt;code&gt;clock_gettime(CLOCK_MONOTONIC, ...)&lt;/code&gt; is based on the current high precision hardware timer (usually &lt;code&gt;TSC&lt;/code&gt;, but it can also be &lt;code&gt;HPET&lt;/code&gt; or &lt;code&gt;ACPI_PM&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;To reduce &lt;code&gt;clock_gettime&lt;/code&gt; latency, Linux kernel uses the &lt;code&gt;vsyscalls&lt;/code&gt; (virtual system calls) and &lt;code&gt;VDSOs&lt;/code&gt; (Virtual Dynamically linked Shared Objects) instead of direct &lt;code&gt;syscall&lt;/code&gt; (you can find some useful implementation details &lt;a href=&quot;http://linuxmogeb.blogspot.co.il/2013/10/how-does-clockgettime-work.html&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://lwn.net/Articles/615809/&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;Invariant TSC&lt;/code&gt; is available, &lt;code&gt;clock_gettime(CLOCK_MONOTONIC, ...)&lt;/code&gt; will use it directly via the &lt;code&gt;rdtsc&lt;/code&gt; instruction.
Of course, it adds some overhead, but in general case, you should use &lt;code&gt;clock_gettime&lt;/code&gt; instead of &lt;code&gt;rdtsc&lt;/code&gt; because it solves a lot of portability problems.
For example, see this nice commit: &lt;a href=&quot;https://github.com/torvalds/linux/commit/d8bb6f4c1670c8324e4135c61ef07486f7f17379&quot;&gt;x86: tsc prevent time going backward&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;source-code&quot;&gt;Source code&lt;/h3&gt;
&lt;h4 id=&quot;full.net-framework&quot;&gt;Full .NET Framework&lt;/h4&gt;
&lt;p&gt;Stopwatch on the Full .NET Framework simply uses QPC/QPF, let&#39;s look at the source code.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Stopwatch.cs,28&quot;&gt;&lt;code&gt;Stopwatch.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Stopwatch
{
    private const long TicksPerMillisecond = 10000;
    private const long TicksPerSecond = TicksPerMillisecond * 1000;

    // &amp;quot;Frequency&amp;quot; stores the frequency of the high-resolution performance counter, 
    // if one exists. Otherwise it will store TicksPerSecond. 
    // The frequency cannot change while the system is running,
    // so we only need to initialize it once. 
    public static readonly long Frequency;
    public static readonly bool IsHighResolution;

    // performance-counter frequency, in counts per ticks.
    // This can speed up conversion from high frequency performance-counter 
    // to ticks. 
    private static readonly double tickFrequency;

    static Stopwatch()
    {
        bool succeeded = SafeNativeMethods.QueryPerformanceFrequency(out Frequency);
        if (!succeeded)
        {
            IsHighResolution = false;
            Frequency = TicksPerSecond;
            tickFrequency = 1;
        }
        else
        {
            IsHighResolution = true;
            tickFrequency = TicksPerSecond;
            tickFrequency /= Frequency;
        }
    }

    public static long GetTimestamp()
    {
        if (IsHighResolution)
        {
            long timestamp = 0;
            SafeNativeMethods.QueryPerformanceCounter(out timestamp);
            return timestamp;
        }
        else
        {
            return DateTime.UtcNow.Ticks;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#System/compmod/microsoft/win32/SafeNativeMethods.cs,122&quot;&gt;&lt;code&gt;SafeNativeMethods.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DllImport(ExternDll.Kernel32)]
[ResourceExposure(ResourceScope.None)]
public static extern bool QueryPerformanceCounter(out long value);

[DllImport(ExternDll.Kernel32)]
[ResourceExposure(ResourceScope.None)]
public static extern bool QueryPerformanceFrequency(out long value);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What do you think, is it possible to get a negative elapsed time interval using Stopwatch?
There was a bug until .NET 3.5 because of which you can observe such situation.
The bug was fixed in .NET 4.0 (originally with &lt;code&gt;#if NET_4_0&lt;/code&gt;..&lt;code&gt;#endif&lt;/code&gt;; without these directives since .NET 4.5).
&lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/System.Runtime.Extensions/src/System/Diagnostics/Stopwatch.cs#L82&quot;&gt;Here is&lt;/a&gt; a comment with explanation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;if (_elapsed &amp;lt; 0)
{
    // When measuring small time periods the StopWatch.Elapsed* 
    // properties can return negative values.  This is due to 
    // bugs in the basic input/output system (BIOS) or the hardware
    // abstraction layer (HAL) on machines with variable-speed CPUs
    // (e.g. Intel SpeedStep).

    _elapsed = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;coreclr&quot;&gt;CoreCLR&lt;/h4&gt;
&lt;p&gt;Basically, CoreCLR 1.0.0 contains almost the same &lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/System.Runtime.Extensions/src/System/Diagnostics/Stopwatch.cs&quot;&gt;Stopwatch.cs&lt;/a&gt; as in a case of the Full .NET Framework except for some minor changes in private variable names, &lt;code&gt;SecuritySafeCritical&lt;/code&gt; attribute usages, and &lt;code&gt;FEATURE_NETCORE&lt;/code&gt; depended on code.
The main difference is the following: CoreCLR uses another declaration of QPC and QPF methods depend on the target platform (instead of using fixed &lt;code&gt;SafeNativeMethods.cs&lt;/code&gt; implementation).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/System.Runtime.Extensions/src/System/Diagnostics/Stopwatch.Windows.cs&quot;&gt;&lt;code&gt;Stopwatch.Windows.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public partial class Stopwatch
{
    private static bool QueryPerformanceFrequency(out long value)
    {
        return Interop.mincore.QueryPerformanceFrequency(out value);
    }

    private static bool QueryPerformanceCounter(out long value)
    {
        return Interop.mincore.QueryPerformanceCounter(out value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/Common/src/Interop/Windows/mincore/Interop.QueryPerformanceCounter.cs&quot;&gt;&lt;code&gt;Interop/Windows/mincore/Interop.QueryPerformanceCounter.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;internal partial class mincore
{
    [DllImport(Libraries.Profile)]
    internal static extern bool QueryPerformanceCounter(out long value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/Common/src/Interop/Windows/mincore/Interop.QueryPerformanceFrequency.cs&quot;&gt;&lt;code&gt;Interop/Windows/mincore/Interop.QueryPerformanceFrequency.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;internal partial class mincore
{
    [DllImport(Libraries.Profile)]
    internal static extern bool QueryPerformanceFrequency(out long value);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, on Windows, we just call usual QPC/QPF API.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Unix&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/System.Runtime.Extensions/src/System/Diagnostics/Stopwatch.Unix.cs&quot;&gt;&lt;code&gt;Stopwatch.Unix.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public partial class Stopwatch
{
    private static bool QueryPerformanceFrequency(out long value)
    {
        return Interop.Sys.GetTimestampResolution(out value);
    }

    private static bool QueryPerformanceCounter(out long value)
    {
        return Interop.Sys.GetTimestamp(out value);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/Common/src/Interop/Unix/System.Native/Interop.GetTimestamp.cs&quot;&gt;&lt;code&gt;Interop/Unix/System.Native/Interop.GetTimestamp.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;internal static partial class Sys
{
    [DllImport(Libraries.SystemNative, EntryPoint = &amp;quot;SystemNative_GetTimestampResolution&amp;quot;)]
    internal static extern bool GetTimestampResolution(out long resolution);

    [DllImport(Libraries.SystemNative, EntryPoint = &amp;quot;SystemNative_GetTimestamp&amp;quot;)]
    internal static extern bool GetTimestamp(out long timestamp);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/corefx/blob/v1.0.0/src/Native/System.Native/pal_time.cpp&quot;&gt;&lt;code&gt;Native/System.Native/pal_time.cpp&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;extern &amp;quot;C&amp;quot; int32_t SystemNative_GetTimestampResolution(uint64_t* resolution)
{
    assert(resolution);

#if HAVE_CLOCK_MONOTONIC
    // Make sure we can call clock_gettime with MONOTONIC.  Stopwatch invokes
    // GetTimestampResolution as the very first thing, and by calling this here
    // to verify we can successfully, we don&#39;t have to branch in GetTimestamp.
    struct timespec ts;
    if (clock_gettime(CLOCK_MONOTONIC, &amp;amp;ts) == 0) 
    {
        *resolution = SecondsToNanoSeconds;
        return 1;
    }
    else
    {
        *resolution = 0;
        return 0;
    }

#elif HAVE_MACH_ABSOLUTE_TIME
    mach_timebase_info_data_t mtid;
    if (mach_timebase_info(&amp;amp;mtid) == KERN_SUCCESS)
    {
        *resolution = SecondsToNanoSeconds * (static_cast&amp;lt;uint64_t&amp;gt;(mtid.denom) / static_cast&amp;lt;uint64_t&amp;gt;(mtid.numer));
        return 1;
    }
    else
    {
        *resolution = 0;
        return 0;
    }

#else /* gettimeofday */
    *resolution = SecondsToMicroSeconds;
    return 1;

#endif
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;extern &amp;quot;C&amp;quot; int32_t SystemNative_GetTimestamp(uint64_t* timestamp)
{
    assert(timestamp);

#if HAVE_CLOCK_MONOTONIC
    struct timespec ts;
    int result = clock_gettime(CLOCK_MONOTONIC, &amp;amp;ts);
    assert(result == 0); // only possible errors are if MONOTONIC isn&#39;t supported or &amp;amp;ts is an invalid address
    (void)result; // suppress unused parameter warning in release builds
    *timestamp = (static_cast&amp;lt;uint64_t&amp;gt;(ts.tv_sec) * SecondsToNanoSeconds) + static_cast&amp;lt;uint64_t&amp;gt;(ts.tv_nsec);
    return 1;

#elif HAVE_MACH_ABSOLUTE_TIME
    *timestamp = mach_absolute_time();
    return 1;

#else
    struct timeval tv;
    if (gettimeofday(&amp;amp;tv, NULL) == 0)
    {
        *timestamp = (static_cast&amp;lt;uint64_t&amp;gt;(tv.tv_sec) * SecondsToMicroSeconds) + static_cast&amp;lt;uint64_t&amp;gt;(tv.tv_usec);
        return 1;
    }
    else
    {
        *timestamp = 0;
        return 0;
    }

#endif
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, primarily we are trying to use &lt;code&gt;clock_gettime&lt;/code&gt; (in the &lt;code&gt;HAVE_CLOCK_MONOTONIC&lt;/code&gt; mode),
otherwise we are trying to use &lt;code&gt;mach_absolute_time&lt;/code&gt; (in the &lt;code&gt;HAVE_MACH_ABSOLUTE_TIME&lt;/code&gt; mode), otherwise we are using &lt;code&gt;gettimeofday&lt;/code&gt; (with corresponded conversions).&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;mono&quot;&gt;Mono&lt;/h4&gt;
&lt;p&gt;Let&#39;s look at an implementation of &lt;code&gt;Stopwatch&lt;/code&gt; in Mono (we will work with &lt;code&gt;mono-4.4.2.11&lt;/code&gt; in this post).&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mcs/class/System/System.Diagnostics/Stopwatch.cs&quot;&gt;&lt;code&gt;Stopwatch.cs&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Stopwatch
{
    [MethodImplAttribute(MethodImplOptions.InternalCall)]
    public static extern long GetTimestamp();

    public static readonly long Frequency = 10000000;

    public static readonly bool IsHighResolution = true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the frequency of &lt;code&gt;Stopwatch&lt;/code&gt; in Mono is a const (10&#39;000&#39;000).
For some historical reasons, this &lt;code&gt;Stopwatch&lt;/code&gt; uses the same tick value (&lt;code&gt;100ns&lt;/code&gt;) as the &lt;code&gt;DateTime&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now let&#39;s look at the internal implementation.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mono/metadata/icall-def.h#L218&quot;&gt;&lt;code&gt;icall-def.h&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ICALL_TYPE(STOPWATCH, &amp;quot;System.Diagnostics.Stopwatch&amp;quot;, STOPWATCH_1)
ICALL(STOPWATCH_1, &amp;quot;GetTimestamp&amp;quot;, mono_100ns_ticks)
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mono/utils/mono-time.c#L30&quot;&gt;&lt;code&gt;mono-time.c#L30&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;/* Returns the number of 100ns ticks from unspecified time: this should be monotonic */
gint64
mono_100ns_ticks (void)
{
    static LARGE_INTEGER freq;
    static UINT64 start_time;
    UINT64 cur_time;
    LARGE_INTEGER value;

    if (!freq.QuadPart) {
        if (!QueryPerformanceFrequency (&amp;amp;freq))
            return mono_100ns_datetime ();
        QueryPerformanceCounter (&amp;amp;value);
        start_time = value.QuadPart;
    }
    QueryPerformanceCounter (&amp;amp;value);
    cur_time = value.QuadPart;
    /* we use unsigned numbers and return the difference to avoid overflows */
    return (cur_time - start_time) * (double)MTICKS_PER_SEC / freq.QuadPart;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;br /&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mono/utils/mono-time.c#L128&quot;&gt;&lt;code&gt;mono-time.c#L128&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;/* Returns the number of 100ns ticks from unspecified time: this should be monotonic */
gint64
mono_100ns_ticks (void)
{
    struct timeval tv;
#ifdef CLOCK_MONOTONIC
    struct timespec tspec;
    static struct timespec tspec_freq = {0};
    static int can_use_clock = 0;
    if (!tspec_freq.tv_nsec) {
        can_use_clock = clock_getres (CLOCK_MONOTONIC, &amp;amp;tspec_freq) == 0;
        /*printf (&amp;quot;resolution: %lu.%lu\n&amp;quot;, tspec_freq.tv_sec, tspec_freq.tv_nsec);*/
    }
    if (can_use_clock) {
        if (clock_gettime (CLOCK_MONOTONIC, &amp;amp;tspec) == 0) {
            /*printf (&amp;quot;time: %lu.%lu\n&amp;quot;, tspec.tv_sec, tspec.tv_nsec); */
            return ((gint64)tspec.tv_sec * MTICKS_PER_SEC + tspec.tv_nsec / 100);
        }
    }
    
#elif defined(PLATFORM_MACOSX)
    /* http://developer.apple.com/library/mac/#qa/qa1398/_index.html */
    static mach_timebase_info_data_t timebase;
    guint64 now = mach_absolute_time ();
    if (timebase.denom == 0) {
        mach_timebase_info (&amp;amp;timebase);
        timebase.denom *= 100; /* we return 100ns ticks */
    }
    return now * timebase.numer / timebase.denom;
#endif
    if (gettimeofday (&amp;amp;tv, NULL) == 0)
        return ((gint64)tv.tv_sec * 1000000 + tv.tv_usec) * 10;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the algorithms Mono internally uses the same API as API in CoreCLR:
&lt;code&gt;QPC&lt;/code&gt;/&lt;code&gt;clock_gettime&lt;/code&gt; as a primary way,
&lt;code&gt;mono_100ns_datetime&lt;/code&gt;/&lt;code&gt;gettimeofday&lt;/code&gt; as a fallback case.&lt;/p&gt;
&lt;p&gt;Is it possible to get a negative elapsed interval on Mono?
It&#39;s theoretically possible on the old version on Mono and old hardware.
This bug was &lt;a href=&quot;https://github.com/mono/mono/commit/dbc021772a8c0a8bf97615523c73d55cf9b376c3&quot;&gt;fixed&lt;/a&gt; by me and &lt;a href=&quot;https://github.com/mono/mono/commit/226af94a2345f88d3170823646e1c25a276ba281&quot;&gt;merged&lt;/a&gt; into the master (Sep 23, 2015).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;pitfalls&quot;&gt;Pitfalls&lt;/h3&gt;
&lt;h4 id=&quot;small-time-intervals&quot;&gt;Small time intervals&lt;/h4&gt;
&lt;p&gt;When you are trying to measure time of an operation, it&#39;s really important to understand order of this measurement and order of &lt;code&gt;Stopwatch&lt;/code&gt; resolution and latency
(it will be covered in details in the &lt;a href=&quot;#benchmarks&quot;&gt;Benchmarks&lt;/a&gt; section).
If your operations take 1 second and you both latency and resolution are less than &lt;code&gt;1 μs&lt;/code&gt;, everything is fine.
But if you are trying to measure an operation which takes &lt;code&gt;10 ns&lt;/code&gt; and &lt;code&gt;Stopwatch&lt;/code&gt; Resolution is about &lt;code&gt;300-400ns&lt;/code&gt;, you will have some problems.
Of course, you can repeat the target operation several times, but there are still many microbenchmark problems (which &lt;a href=&quot;https://github.com/PerfDotNet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; trying to solve).
Be careful in such situations; it&#39;s really easy to make wrong measurements of short operations.&lt;/p&gt;
&lt;h4 id=&quot;sequential-reads&quot;&gt;Sequential reads&lt;/h4&gt;
&lt;p&gt;Let&#39;s say that we do two sequential reads of &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var a = Stopwatch.GetTimestamp();
var b = Stopwatch.GetTimestamp();
var delta = b - a;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can you say possible values of &lt;code&gt;delta&lt;/code&gt;? Let&#39;s check it with help of the following program:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;const int N = 1000000;
var values = new long[N];
for (int i = 0; i &amp;lt; N; i++)
    values[i] = Stopwatch.GetTimestamp();
var deltas = new long[N - 1];
for (int i = 0; i &amp;lt; N - 1; i++)
    deltas[i] = values[i + 1] - values[i];
var table =
    from d in deltas
    group d by d into g
    orderby g.Key
    select new
    {
        Ticks = g.Key,
        Microseconds = g.Key * 1000000.0 / Stopwatch.Frequency,
        Count = g.Count()
    };
Console.WriteLine(&amp;quot;Ticks | Time(μs) | Count   &amp;quot;);
Console.WriteLine(&amp;quot;------|----------|---------&amp;quot;);
foreach (var line in table)
{
    var ticks = line.Ticks.ToString().PadRight(5);
    var us = line.Microseconds.ToString(&amp;quot;0.0&amp;quot;).PadRight(8);
    var count = line.Count.ToString();
    Console.WriteLine($&amp;quot;{ticks} | {μs} | {count}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is a typical output on my laptop:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ticks | Time(μs) | Count
------|----------|---------
0     | 0.0      | 931768
1     | 0.4      | 66462
2     | 0.7      | 1155
3     | 1.1      | 319
4     | 1.5      | 59
5     | 1.8      | 21
6     | 2.2      | 46
7     | 2.6      | 39
8     | 2.9      | 31
9     | 3.3      | 10
10    | 3.7      | 6
11    | 4.0      | 3
13    | 4.8      | 2
15    | 5.5      | 3
16    | 5.9      | 1
18    | 6.6      | 1
19    | 7.0      | 2
20    | 7.3      | 1
22    | 8.1      | 1
23    | 8.4      | 4
24    | 8.8      | 8
25    | 9.2      | 12
27    | 9.9      | 13
28    | 10.3     | 10
30    | 11.0     | 6
31    | 11.4     | 1
34    | 12.5     | 4
35    | 12.8     | 1
36    | 13.2     | 1
44    | 16.1     | 1
47    | 17.2     | 1
56    | 20.5     | 1
66    | 24.2     | 1
68    | 24.9     | 1
71    | 26.0     | 1
123   | 45.1     | 1
314   | 115.1    | 1
2412  | 884.1    | 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, once I had a delta between two sequential &lt;code&gt;GetTimestamp&lt;/code&gt; which equals to &lt;code&gt;2412 ticks&lt;/code&gt; or &lt;code&gt;0.8ms&lt;/code&gt; (my current &lt;code&gt;Stopwatch.Frequency = 2728068&lt;/code&gt;)! This fact is not obvious for most developers. There are two popular kinds of mistakes here.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Handwritten benchmarks.&lt;/strong&gt; Here is a popular pattern for time measurements:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var sw = Stopwatch.StartNew();
// Target method
sw.Stop();
var time = sw.Elapsed;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code usually works fine for target method that takes seconds and works awfully for method that takes milliseconds. Let&#39;s write another check program:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var maxTime = 0.0;
for (int i = 0; i &amp;lt; 10000000; i++)
{
    var sw = Stopwatch.StartNew();
    sw.Stop();
    maxTime = Math.Max(maxTime, sw.Elapsed.TotalMilliseconds);
}
Console.WriteLine(maxTime + &amp;quot; ms&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Usually, I get &lt;code&gt;maxTime&lt;/code&gt; is about &lt;code&gt;1ms&lt;/code&gt; but sometimes it equals to &lt;code&gt;6–7ms&lt;/code&gt;.
But we even don&#39;t have any target method here; we are trying to measure nothing!
Of course, it is a rare situation. Usually, you get plausible measurements.
But you can never be sure!
Besides, it is methodologically wrong.
Please, don&#39;t write such benchmarks.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Two GetTimestamp in an expression.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Can you say where is a bug in the following expression?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;  stopwatch.ElapsedMilliseconds &amp;gt; timeout ? 0 : timeout - (int)stopwatch.ElapsedMilliseconds
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The answer: we can&#39;t be sure that two invocations of &lt;code&gt;stopwatch.ElapsedMilliseconds&lt;/code&gt; will return the same value.
For example, let&#39;s say that &lt;code&gt;timeout&lt;/code&gt; equals to &lt;code&gt;100&lt;/code&gt;.
We are trying to evaluate &lt;code&gt;stopwatch.ElapsedMilliseconds &amp;gt; timeout&lt;/code&gt;, &lt;code&gt;stopwatch.ElapsedMilliseconds&lt;/code&gt; returns &lt;code&gt;99&lt;/code&gt;, the expression value is &lt;code&gt;false&lt;/code&gt;.
Next, we are going to evaluate &lt;code&gt;timeout - (int)stopwatch.ElapsedMilliseconds&lt;/code&gt;.
But we have another &lt;code&gt;stopwatch.ElapsedMilliseconds&lt;/code&gt; here!
Let&#39;s say, it returns &lt;code&gt;101&lt;/code&gt;.
Then, result value will be equal to &lt;code&gt;-1&lt;/code&gt;!
Probably, the author of this code did not expect negative values here.&lt;/p&gt;
&lt;p&gt;You can say that nobody writes such code.
Or that such code never is a cause of a bug in the real application.
But it can.
This expression was taken from the &lt;a href=&quot;https://github.com/somdoron/AsyncIO&quot;&gt;AsyncIO&lt;/a&gt; library (this code was already &lt;a href=&quot;https://github.com/somdoron/AsyncIO/commit/5c838f3d30d483dcadb4181233a4437fb5e7f327&quot;&gt;fixed&lt;/a&gt;).
Once I really had a bug because this value was negative!
By the way, such kind of bugs is &lt;em&gt;really&lt;/em&gt; hard to reproduce.
So, just don&#39;t write code like this.&lt;/p&gt;
&lt;h4 id=&quot;reciprocal-frequency-and-actual-resolution&quot;&gt;Reciprocal frequency and actual resolution&lt;/h4&gt;
&lt;p&gt;A lot of developers think that these values are equal.
But they can be not equal in the general case.
In fact, we have only one guarantee here: actual resolution ≥ reciprocal frequency because we can&#39;t achieve resolution better than one tick.
However, there are a lot of cases when one tick defined by &lt;code&gt;Stopwatch.Frequency&lt;/code&gt; does not correspond to actual resolution (for example, on Mono or on Hypervisors).
But what if we really want to know the actual resolution?
Unfortunately, there is no API for that.
But we can calculate an approximation of this value.
For example, if we take the table from the &lt;a href=&quot;#sequential-reads&quot;&gt;Sequential reads&lt;/a&gt; section and remove the first line (where &lt;code&gt;ticks=0&lt;/code&gt;), we get an observable resolution distribution for an interval of time.
We can calculate a minimal observable resolution and average/median observable resolution.
But be careful: keep in mind that it&#39;s just &lt;em&gt;observable&lt;/em&gt; values for a single series of measurements.
You can get a new distribution per each run.
You can not trust these values, but sometimes you can use them for some resolution approximation (may be useful in some applications).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h3&gt;
&lt;p&gt;Let&#39;s write the following benchmark with the help of &lt;a href=&quot;https://github.com/PerfDotNet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[ClrJob, CoreJob, MonoJob]
public class StopwatchBenchmarks
{
    [Benchmark]
    public long Latency() =&amp;gt; Stopwatch.GetTimestamp();

    [Benchmark]
    public long Resolution()
    {
        long lastTimestamp = Stopwatch.GetTimestamp();
        while (Stopwatch.GetTimestamp() == lastTimestamp)
        {
        }
        return lastTimestamp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Be careful: the &lt;code&gt;Resolution&lt;/code&gt; methods does not produce correct value of Resolution when Latency is much bigger than actual resolution (see the Interpretation subsection).
We will omit results for such situations.&lt;/p&gt;
&lt;h4 id=&quot;windows-1&quot;&gt;Windows&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.9.9.0
OS=Microsoft Windows NT 6.2.9200.0 (Windows 10 anniversary update)
Processor=Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8
Frequency=2143473 ticks, Resolution=466.5326 ns, Timer=TSC
CLR1=CORE, Arch=64-bit ? [RyuJIT]
CLR2=MS.NET 4.0.30319.42000
CLR3=Mono JIT compiler version 4.2.3
JitModules=clrjit-v4.6.1586.0
dotnet cli version: 1.0.0-preview2-003121
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TSC:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Clr&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;17.1918 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2723 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Clr&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;475.1302 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.4886 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;15.6241 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.3809 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;467.9744 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.1308 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;40.4701 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5814 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;475.2795 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;4.4417 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;HPET:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Clr&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;598.5198 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;78.7814 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;603.3178 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;18.0963 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;737.9618 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;4.5637 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;linux-1&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;Xubuntu 16.04.01, the same hardware:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.9.9.0
OS=Unix 4.4.0.34
Processor=Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8
CLR1=CORE, Arch=64-bit ? [RyuJIT]
CLR2=Mono 4.4.2 (Stable 4.4.2.11/f72fe45 Fri Jul 29 09:58:49 UTC 2016), Arch=64-bit RELEASE
dotnet cli version: 1.0.0-preview2-003121
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TSC:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;31.9727 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.8880 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;22.4036 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.3299 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;97.6713 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0971 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;ACPI_PM:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;683.2088 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;16.5555 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;653.4289 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.5812 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;HPET:&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;536.0179 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.4501 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;526.4265 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.8113 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;interpretation&quot;&gt;Interpretation&lt;/h4&gt;
&lt;p&gt;Ok, we got a lot of interesting numbers, but we should interpret it in the right way.
The latency benchmark looks great; it produced a nice approximation of real timestamp latency.&lt;/p&gt;
&lt;p&gt;But there are some troubles with the resolution benchmark because it&#39;s hard to design correct microbenchmark in this situation.&lt;/p&gt;
&lt;p&gt;It works well only for cases where Latency is much smaller than resolution: for example, it produces believable numbers for Windows+TSC.
In this case we get &lt;code&gt;Resolution&lt;/code&gt; ≈ (&lt;code&gt;1 second&lt;/code&gt; / &lt;code&gt;Stopwatch.Frequency&lt;/code&gt;) ≈ (&lt;code&gt;1 second&lt;/code&gt; / (&lt;code&gt;rdstc Frequency&lt;/code&gt; / 1024)).&lt;/p&gt;
&lt;p&gt;In the case of &lt;code&gt;HPET&lt;/code&gt;/&lt;code&gt;ACPI_PM&lt;/code&gt; benchmarks show that &lt;code&gt;Resolution&lt;/code&gt; ≈ 2 x &lt;code&gt;Latency&lt;/code&gt; because we call &lt;code&gt;Stopwatch.GetTimestamp&lt;/code&gt; at least twice per the &lt;code&gt;Resolution&lt;/code&gt; method invocation.
It&#39;s hard to say something about real resolution because the value of &lt;code&gt;HPET&lt;/code&gt;/&lt;code&gt;ACPI_PM&lt;/code&gt; ticks is much smaller than the latency.
For practical use, you can assume that the Resolution has the same order as Latency.&lt;/p&gt;
&lt;p&gt;Now let&#39;s consider the Linux+&lt;code&gt;TSC&lt;/code&gt; case. On Mono, we have &lt;code&gt;Resolution&lt;/code&gt; = &lt;code&gt;100 ns&lt;/code&gt; because it is the value of &lt;code&gt;1 tick&lt;/code&gt; (and it can be achieved).
On CoreCLR, &lt;code&gt;1 ticks&lt;/code&gt; is &lt;code&gt;1 ns&lt;/code&gt;, and it use &lt;code&gt;rdtsc&lt;/code&gt; which works on frequency = &lt;code&gt;≈2.20GHz&lt;/code&gt;.
Thus, we have a situation which is similar to the &lt;code&gt;HPET&lt;/code&gt;/&lt;code&gt;ACPI_PM&lt;/code&gt; case: latency is much bigger than resolution.
So, it&#39;s hard to evaluate it via a microbenchmark.
Let&#39;s use the program from the &lt;a href=&quot;#pitfalls&quot;&gt;Pitfalls&lt;/a&gt; section (where we played with sequential reads).
We will use &lt;code&gt;ns&lt;/code&gt; instead of &lt;code&gt;μs&lt;/code&gt; and run it on Linux+&lt;code&gt;TSC&lt;/code&gt;+CoreCLR.
Result on my laptop (the middle part was cut):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ticks | Time(ns) | Count   
------|----------|---------
22    | 22.0     | 2
23    | 23.0     | 485
24    | 24.0     | 1919
25    | 25.0     | 7516
26    | 26.0     | 7683
27    | 27.0     | 825
28    | 28.0     | 8
30    | 30.0     | 2
31    | 31.0     | 2296
32    | 32.0     | 20916
33    | 33.0     | 52925
34    | 34.0     | 172174
35    | 35.0     | 110923
36    | 36.0     | 100979
37    | 37.0     | 322173
38    | 38.0     | 159638
39    | 39.0     | 9510
40    | 40.0     | 2270
41    | 41.0     | 808
42    | 42.0     | 993
43    | 43.0     | 2154
44    | 44.0     | 1114
45    | 45.0     | 2551
46    | 46.0     | 3234
47    | 47.0     | 5828
48    | 48.0     | 4342
49    | 49.0     | 3695
50    | 50.0     | 162
...
807   | 807.0    | 5
809   | 809.0    | 1
810   | 810.0    | 4
811   | 811.0    | 8
812   | 812.0    | 19
813   | 813.0    | 22
814   | 814.0    | 17
815   | 815.0    | 22
816   | 816.0    | 10
817   | 817.0    | 17
818   | 818.0    | 20
819   | 819.0    | 20
820   | 820.0    | 9
821   | 821.0    | 29
822   | 822.0    | 23
823   | 823.0    | 31
824   | 824.0    | 22
825   | 825.0    | 14
826   | 826.0    | 19
827   | 827.0    | 16
828   | 828.0    | 20
829   | 829.0    | 27
830   | 830.0    | 29
831   | 831.0    | 29
832   | 832.0    | 37
833   | 833.0    | 21
834   | 834.0    | 10
835   | 835.0    | 7
836   | 836.0    | 11
837   | 837.0    | 8
838   | 838.0    | 10
839   | 839.0    | 4
840   | 840.0    | 11
841   | 841.0    | 6
842   | 842.0    | 7
843   | 843.0    | 7
844   | 844.0    | 5
845   | 845.0    | 4
846   | 846.0    | 3
...
32808 | 32808.0  | 1
110366 | 110366.0 | 1
112423 | 112423.0 | 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The minimal resolution &lt;em&gt;in this experiment&lt;/em&gt; is &lt;code&gt;22 ns&lt;/code&gt; but it was achieved only twice (&lt;code&gt;N = 1000000&lt;/code&gt;).
Once we had two sequential timestamp invocation with difference in &lt;code&gt;112423 ticks&lt;/code&gt; (or &lt;code&gt;≈112 μs&lt;/code&gt;).
So, we can&#39;t say that there is a specific value of resolution in this case, but we can say that the resolution has the same order as latency.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;This was a brief overview of the &lt;code&gt;Stopwatch&lt;/code&gt; class.
It is hard to cover all the details of &lt;code&gt;Stopwatch&lt;/code&gt; behavior because there is a lot of different combinations of runtimes / operation systems / hardware.
When we are using &lt;code&gt;Stopwatch&lt;/code&gt;, usually we care about its latency and resolution because these values determine what we can measure with &lt;code&gt;Stopwatch&lt;/code&gt; and what we can&#39;t.
There are some possible configurations:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th&gt;OS&lt;/th&gt;
&lt;th&gt;Hardware Timer&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;1 tick&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Latency&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Resolution&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Full .NET&lt;/td&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;TSC&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;300-400ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;15-18ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;300-400ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Full .NET&lt;/td&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;HPET&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;69.8ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5-0.8us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;≈Latency&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Full .NET&lt;/td&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;100ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7-10ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5-55ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;TSC&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;100ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;35-45ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;300-400ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;HPET&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;100ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5-0.8us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;≈Latency&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Windows&lt;/td&gt;
&lt;td&gt;NA&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;100ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;30-40ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5-55ms&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CoreCLR&lt;/td&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;TSC&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;30-35ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;≈Latency&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CoreCLR&lt;/td&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;HPET/ACPI_PM&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5-0.8us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;≈Latency&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;TSC&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;100ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;20-25ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;100ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;HPET/ACPI_PM&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;100ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5-0.8us&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;≈Latency&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;Here &lt;code&gt;Hardware Timer = NA&lt;/code&gt; means that there is no high-precision timer in the system, i.e. &lt;code&gt;Stopwatch.IsHighResolution = false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 tick&lt;/code&gt; is calculated based on nominal frequency (&lt;code&gt;1 second&lt;/code&gt; / &lt;code&gt;Stopwatch.Frequency&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Resolution = ≈Latency&lt;/code&gt; means that the actual Resolution is less than the Latency, the observed Resolution has the same order as the Latency.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note that it&#39;s only examples, you can get different values in different situations.
This tables just shows that sometimes it&#39;s not easy to guess target latency and resolution, there are a lot of things which can affect these values.
Anyway, you should be careful, if you want to measure time intervals.
Especially, if you want to measure small time intervals: it&#39;s really easy to make a mistake and get wrong results.
If you want to know more about high-resolution time measurements, there are a lot of links in the &lt;a href=&quot;#links&quot;&gt;next section&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As you can see, the topic is very hard because there are a lot of different environments in the modern world.
If I missed something important or wrote something wrong, feel free to leave any feedback.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Best&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/dn553408.aspx&quot;&gt;MSDN: Acquiring high-resolution time stamps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.windowstimestamp.com/description&quot;&gt;The Windows Timestamp Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/&quot;&gt;Pitfalls of TSC usage&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Useful software&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cpuid.com/softwares/cpu-z.html&quot;&gt;CPU-Z&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/bb897568.aspx&quot;&gt;ClockRes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/cc835722&quot;&gt;Coreinfo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.thesycon.de/deu/latency_check.shtml&quot;&gt;DPC Latency Checker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.bytemedev.com/programs/harmonic-help/&quot;&gt;Harmonic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.resplendence.com/latencymon&quot;&gt;LatencyMon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MSDN&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/hardware/ff542202%28v=vs.85%29.aspx&quot;&gt;MSDN: BCDEdit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.utcnow.aspx&quot;&gt;MSDN: DateTime.UtcNow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.diagnostics.stopwatch.aspx&quot;&gt;MSDN: Stopwatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/ms686247.aspx&quot;&gt;MSDN: SetThreadAffinityMask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ee417693.aspx&quot;&gt;MSDN: Game Timing and Multicore Processors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/aa366887.aspx&quot;&gt;MSDN: VirtualAlloc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/twchhe95.aspx&quot;&gt;MSDN: __rdtsc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Wiki&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/System_time&quot;&gt;Wiki: System time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/CPUID&quot;&gt;Wiki: CPUID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Intel&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf&quot;&gt;Intel: How to Benchmark Code Execution Times on Intel&#174;IA-32 and IA-64 Instruction Set Architectures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/software-developers-hpet-spec-1-0a.pdf&quot;&gt;Intel: IA-PC HPET Specification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;ftp://download.intel.com/design/processor/manuals/253668.pdf&quot;&gt;Intel: Intel&#174; 64 and IA-32 Architectures Software Developer’s Manual Volume 3A: System Programming Guide, Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf&quot;&gt;Intel: Intel&#174; 64 and IA-32 Architectures Software Developer’s Manual&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ccsl.carleton.ca/%7Ejamuir/rdtscpm1.pdf&quot;&gt;Intel&#39;s original CPU TSC Counter guidance for use in game timing (1998)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://software.intel.com/en-us/articles/power-management-states-p-states-c-states-and-package-c-states&quot;&gt;Power Management States: P-States, C-States, and Package C-States&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Blog posts&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/&quot;&gt;Random ASCII: Windows Timer Resolution: Megawatts Wasted (2013)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://randomascii.wordpress.com/2013/04/02/sleep-variation-investigated/&quot;&gt;Random ASCII: Sleep Variation Investigated (2013)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://randomascii.wordpress.com/2011/07/29/rdtsc-in-the-age-of-sandybridge/&quot;&gt;Random ASCII: rdtsc in the Age of Sandybridge (2011)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/oldnewthing/20050902-00/?p=34333/#460003&quot;&gt;The Old New Thing: Precision is not the same as accuracy (2005)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.virtualdub.org/blog/pivot/entry.php?id=106&quot;&gt;VirtualDub: Beware of QueryPerformanceCounter() (2006)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://computerperformancebydesign.com/high-resolution-clocks-and-timers-for-performance-measurement-in-windows/&quot;&gt;Computer Performance By Design: High Resolution Clocks and Timers for Performance Measurement in Windows (2012)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://algo2.iti.kit.edu/wassenberg/timing/timing_pitfalls.pdf&quot;&gt;Jan Wassenberg: Timing Pitfalls and Solutions (2007)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mathpirate.net/log/2010/03/20/temporal-mechanics-changing-the-speed-of-time-part-ii/&quot;&gt;MathPirate: Temporal Mechanics: Changing the Speed of Time, Part II (2010)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mikemartin.co/system_guides/hardware/motherboard/disable_high_precision_event_timer_hpet&quot;&gt;Mike Martin: Disable HPET (2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://manski.net/2014/07/high-resolution-clock-in-csharp/&quot;&gt;Manski`s blog: High Resolution Clock in C# (2014)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.codinghorror.com/keeping-time-on-the-pc/&quot;&gt;Coding Horror: Keeping Time on the PC (2007)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://chabster.blogspot.ru/2007/09/high-resolution-timer-time-stamp.html&quot;&gt;Hungry Mind: High-Resolution Timer = Time Stamp Counter = RDTSC (2007, In Russian)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jvns.ca/blog/2016/02/20/measuring-cpu-time-with-clock-gettime/&quot;&gt;How to measure your CPU time: clock_gettime! (2016)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jvns.ca/blog/2016/02/07/cpu-load-averages/&quot;&gt;How CPU load averages work (and using them to triage webserver performance!) (2016)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stas-blogspot.blogspot.co.il/2012/02/what-is-behind-systemnanotime.html&quot;&gt;Stat&#39;s blog: What is behind System.nanoTime()? (2012)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linuxmogeb.blogspot.co.il/2013/10/how-does-clockgettime-work.html&quot;&gt;Linux: virtualization and tracing: How does clock_gettime work (2013)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aufather.wordpress.com/2010/09/08/high-performance-time-measuremen-in-linux/&quot;&gt;Software ahoy!: High Performance Time Measurement in Linux (2010)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Misc&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.uefi.org/sites/default/files/resources/ACPI_6.0.pdf&quot;&gt;Advanced Configuration and Power Interface  Specification 6.0 (April 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_MRG/2/html/Realtime_Reference_Guide/chap-Timestamping.html&quot;&gt;RedHat Documentation: Timestamping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.luxford.com/high-performance-windows-timers&quot;&gt;Luxford: High Performance Windows Timers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mmo-champion.com/threads/1215396-WinTimerTester&quot;&gt;Mmo-champion: WinTimerTester&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/en-us/kb/895980&quot;&gt;support.microsoft.com: Programs that use the QueryPerformanceCounter function may perform poorly&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/en-us/kb/821893&quot;&gt;support.microsoft.com: The system clock may run fast when you use the ACPI power management timer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linux.die.net/man/2/sched_setaffinity&quot;&gt;linux.die.net: sched_setaffinity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.ncrunch.net/post/How-to-set-a-threads-processor-affinity-in-NET.aspx&quot;&gt;NCrunch: How to set a thread&#39;s processor affinity in .NET&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://x86.renejeschke.de/html/file_module_x86_id_278.html&quot;&gt;x86 Instruction Set Reference: RDTSC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lkml.org/lkml/2005/11/4/173&quot;&gt;TSC and Power Management Events on AMD Processors (2005)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lwn.net/Articles/209101/&quot;&gt;Counting on the time stamp counter (2006)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6313903&quot;&gt;JDK-6313903: Thread.sleep(3) might wake up immediately on windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/NTSC&quot;&gt;Wikipedia: NTSC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Colorburst&quot;&gt;Wikipedia: Colorburst&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://dl.acm.org/citation.cfm?id=2278530&quot;&gt;3.579545 MHz Can be More Than the Color Burst (1980)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lwn.net/Articles/615809/&quot;&gt;Implementing virtual system calls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/torvalds/linux/commit/d8bb6f4c1670c8324e4135c61ef07486f7f17379&quot;&gt;github.com/torvalds/linux: x86: tsc prevent time going backwards&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;StackOverflow&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3400254/can-the-net-stopwatch-class-be-this-terrible/3400490#3400490&quot;&gt;StackOverflow: Can the .NET Stopwatch class be THIS terrible?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2607263/how-precise-is-the-internal-clock-of-a-modern-pc&quot;&gt;StackOverflow: How precise is the internal clock of a modern PC?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/7685762/184842&quot;&gt;StackOverflow: Windows 7 timing functions - How to use GetSystemTimeAdjustment correctly?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/7987671/184842&quot;&gt;StackOverflow: What is the acpi_pm linux clocksource used for, what hardware implements it?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/22942123/184842&quot;&gt;StackOverflow: Is QueryPerformanceFrequency accurate when using HPET?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/36318291/measure-precision-of-timer-e-g-stopwatch-queryperformancecounter&quot;&gt;StackOverflow: Measure precision of timer (e.g. Stopwatch/QueryPerformanceCounter)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/23251795/184842&quot;&gt;StackOverflow: How to calculate the frequency of CPU cores&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/18343188/184842&quot;&gt;StackOverflow: Precise Linux Timing - What Determines the Resolution of clock_gettime()?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>DateTime under the hood</title>
            <link>http://aakinshin.net/posts/datetime/</link> 
            <pubDate>Fri, 19 Aug 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/datetime/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt;
You can find an updated and significantly improved version of this post in my book &lt;a href=&quot;https://www.apress.com/us/book/9781484249406&quot;&gt;&amp;quot;Pro .NET Benchmarking&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.aspx&quot;&gt;DateTime&lt;/a&gt; is a widely used .NET type. A lot of developers use it all the time, but not all of them really know how it works. In this post, I discuss &lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.utcnow.aspx&quot;&gt;DateTime.UtcNow&lt;/a&gt;: how it&#39;s implemented, what the latency and the resolution of &lt;code&gt;DateTime&lt;/code&gt; on Windows and Linux, how the resolution can be changed, and how it can affect your application. This post is an overview, so you probably will not see super detailed explanations of some topics, but you will find a lot of useful links for further reading.&lt;/p&gt;
&lt;!--more--&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;source&quot;&gt;Source&lt;/h3&gt;
&lt;p&gt;In the .NET Framework, the &lt;code&gt;DateTime&lt;/code&gt; struct is represented by a &lt;code&gt;long&lt;/code&gt; value called &lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.ticks.aspx&quot;&gt;Ticks&lt;/a&gt;. One tick equals to &lt;code&gt;100 ns&lt;/code&gt;, ticks are counted starting from 12:00 AM January 1, year 1 A.D. (Gregorian Calendar).&lt;/p&gt;
&lt;p&gt;In Windows, there is another structure for time called &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/ms724284.aspx&quot;&gt;FILETIME&lt;/a&gt;. It also uses &lt;code&gt;100 ns&lt;/code&gt;-ticks, but the starting point is January 1, 1601 (UTC). You can get current &lt;code&gt;FILETIME&lt;/code&gt; via &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724397.aspx&quot;&gt;GetSystemTimeAsFileTime&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now, let&#39;s look at the source code of &lt;code&gt;DateTime&lt;/code&gt; in the coreclr repo: &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs&quot;&gt;DateTime.cs&lt;/a&gt; (&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/datetime.cs&quot;&gt;the corresponded class&lt;/a&gt; in the Full .NET Framework looks almost the same; Mono uses code from the full framework directly). The implementation is based on &lt;code&gt;GetSystemTimeAsFileTime&lt;/code&gt; and use &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs#L93&quot;&gt;FileTimeOffset&lt;/a&gt; for conversion. A simplified version of &lt;code&gt;UtcNow&lt;/code&gt; from &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs#L915&quot;&gt;DateTime.cs&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static DateTime UtcNow {
    get {
        long ticks = 0;
        ticks = GetSystemTimeAsFileTime();
        return new DateTime( ((UInt64)(ticks + FileTimeOffset)) | KindUtc);
    }
}

[MethodImplAttribute(MethodImplOptions.InternalCall)]
internal static extern long GetSystemTimeAsFileTime();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You may have noticed &lt;code&gt;KindUtc&lt;/code&gt; in the constructor argument. In fact, &lt;code&gt;DateTime&lt;/code&gt; keeps actual &lt;code&gt;Ticks&lt;/code&gt; only in bits 01-62 of the &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs#L137&quot;&gt;dateData&lt;/a&gt; field; bits 63-64 are used for &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/shx7s921.aspx&quot;&gt;DateTimeKind&lt;/a&gt; (&lt;code&gt;Local&lt;/code&gt;, &lt;code&gt;Utc&lt;/code&gt;, or &lt;code&gt;Unspecified&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extern long GetSystemTimeAsFileTime()&lt;/code&gt; is implemented as follows: on Windows, it uses the &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/ms724397.aspx&quot;&gt;GetSystemTimeAsFileTime&lt;/a&gt; function from &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows.h&quot;&gt;windows.h&lt;/a&gt;, on Unix it uses &lt;a href=&quot;http://man7.org/linux/man-pages/man2/gettimeofday.2.html&quot;&gt;gettimeofday&lt;/a&gt; and transforms the received value from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix epoch&lt;/a&gt; (&lt;em&gt;January&#160;1,&#160;1970&lt;/em&gt;) to the Win32 epoch (&lt;em&gt;January&#160;1,&#160;1601&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Let&#39;s dive deeper into the source code for CoreCLR and Mono (you can skip the next two sections if you are not interested in the implementation details).&lt;/p&gt;
&lt;h4 id=&quot;coreclr-v1.0.0&quot;&gt;CoreCLR v1.0.0&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/vm/ecalllist.h#L2219&quot;&gt;src/vm/ecalllist.h&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;FCClassElement(&amp;quot;DateTime&amp;quot;, &amp;quot;System&amp;quot;, gDateTimeFuncs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/vm/ecalllist.h#L279&quot;&gt;src/vm/ecalllist.h&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;FCFuncStart(gDateTimeFuncs)
    FCFuncElement(&amp;quot;GetSystemTimeAsFileTime&amp;quot;, SystemNative::__GetSystemTimeAsFileTime)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/classlibnative/bcltype/system.cpp#L48&quot;&gt;classlibnative/bcltype/system.cpp/system.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;FCIMPL0(INT64, SystemNative::__GetSystemTimeAsFileTime)
{
    FCALL_CONTRACT;

    INT64 timestamp;

    ::GetSystemTimeAsFileTime((FILETIME*)&amp;amp;timestamp);

#if BIGENDIAN
    timestamp = (INT64)(((UINT64)timestamp &amp;gt;&amp;gt; 32) | ((UINT64)timestamp &amp;lt;&amp;lt; 32));
#endif

    return timestamp;
}
FCIMPLEND;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can find the definition of &lt;code&gt;FCIMPL0&lt;/code&gt; in &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/vm/fcall.h&quot;&gt;src/vm/fcall.h&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/pal/src/file/filetime.cpp#L502&quot;&gt;pal/src/file/filetime.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;VOID
PALAPI
GetSystemTimeAsFileTime(
            OUT LPFILETIME lpSystemTimeAsFileTime)
{
    struct timeval Time;

    PERF_ENTRY(GetSystemTimeAsFileTime);
    ENTRY(&amp;quot;GetSystemTimeAsFileTime(lpSystemTimeAsFileTime=%p)\n&amp;quot;, 
          lpSystemTimeAsFileTime);

    if ( gettimeofday( &amp;amp;Time, NULL ) != 0 )
    {
        ASSERT(&amp;quot;gettimeofday() failed&amp;quot;);
        /* no way to indicate failure, so set time to zero */
        *lpSystemTimeAsFileTime = FILEUnixTimeToFileTime( 0, 0 );
    }
    else
    {
        /* use (tv_usec * 1000) because 2nd arg is in nanoseconds */
        *lpSystemTimeAsFileTime = FILEUnixTimeToFileTime( Time.tv_sec,
                                                          Time.tv_usec * 1000 );
    }

    LOGEXIT(&amp;quot;GetSystemTimeAsFileTime returns.\n&amp;quot;);
    PERF_EXIT(GetSystemTimeAsFileTime);
}

/*++
Convert a time_t value to a win32 FILETIME structure, as described in
MSDN documentation. time_t is the number of seconds elapsed since 
00:00 01 January 1970 UTC (Unix epoch), while FILETIME represents a 
64-bit number of 100-nanosecond intervals that have passed since 00:00 
01 January 1601 UTC (win32 epoch).
--*/
FILETIME FILEUnixTimeToFileTime( time_t sec, long nsec )
{
    __int64 Result;
    FILETIME Ret;

    Result = ((__int64)sec + SECS_BETWEEN_1601_AND_1970_EPOCHS) * SECS_TO_100NS +
        (nsec / 100);

    Ret.dwLowDateTime = (DWORD)Result;
    Ret.dwHighDateTime = (DWORD)(Result &amp;gt;&amp;gt; 32);

    TRACE(&amp;quot;Unix time = [%ld.%09ld] converts to Win32 FILETIME = [%#x:%#x]\n&amp;quot;, 
          sec, nsec, Ret.dwHighDateTime, Ret.dwLowDateTime);

    return Ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;mono-4.4.2.11&quot;&gt;Mono 4.4.2.11&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mono/metadata/icall-def.h#L135&quot;&gt;icall-def.h&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ICALL_TYPE(DTIME, &amp;quot;System.DateTime&amp;quot;, DTIME_1)
ICALL(DTIME_1, &amp;quot;GetSystemTimeAsFileTime&amp;quot;, mono_100ns_datetime)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mono/utils/mono-time.c&quot;&gt;mono-time.c&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;#ifdef HOST_WIN32
#include &amp;lt;windows.h&amp;gt;
//...

/* Returns the number of 100ns ticks since Jan 1, 1601, UTC timezone */
gint64
mono_100ns_datetime (void)
{
    ULARGE_INTEGER ft;

    if (sizeof(ft) != sizeof(FILETIME))
        g_assert_not_reached ();

    GetSystemTimeAsFileTime ((FILETIME*) &amp;amp;ft);
    return ft.QuadPart;
}

#else

// ...

/*
 * Magic number to convert unix epoch start to windows epoch start
 * Jan 1, 1970 into a value which is relative to Jan 1, 1601.
 */
#define EPOCH_ADJUST    ((guint64)11644473600LL)

/* Returns the number of 100ns ticks since 1/1/1601, UTC timezone */
gint64
mono_100ns_datetime (void)
{
    struct timeval tv;
    if (gettimeofday (&amp;amp;tv, NULL) == 0)
        return mono_100ns_datetime_from_timeval (tv);
    return 0;
}

gint64
mono_100ns_datetime_from_timeval (struct timeval tv)
{
    return (((gint64)tv.tv_sec + EPOCH_ADJUST) * 1000000 + tv.tv_usec) * 10;
}

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;resolution&quot;&gt;Resolution&lt;/h3&gt;
&lt;h4 id=&quot;windows&quot;&gt;Windows&lt;/h4&gt;
&lt;p&gt;As I mentioned previously, the WinAPI function for getting current time is &lt;code&gt;GetSystemTimeAsFileTime&lt;/code&gt;. If you want to get the &lt;code&gt;FILETIME&lt;/code&gt; with with the highest possible level of precision, you should use &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/hh706895.aspx&quot;&gt;GetSystemTimePreciseAsFileTime&lt;/a&gt;. There is also the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724390.aspx&quot;&gt;GetSystemTime&lt;/a&gt; function which returns &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950.aspx&quot;&gt;SYSTEMTIME&lt;/a&gt;: it works slowly but it returns current time in a well-suited format. You can convert &lt;code&gt;FILETIME&lt;/code&gt; to &lt;code&gt;SYSTEMTIME&lt;/code&gt; manually with help of the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms724280.aspx&quot;&gt;FileTimeToSystemTime&lt;/a&gt; function.&lt;/p&gt;
&lt;p&gt;In this section, only &lt;code&gt;GetSystemTimeAsFileTime&lt;/code&gt; will be discussed. The resolution of this function may take different values. You can easily get the configuration of your OS with the help of the &lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/bb897568.aspx&quot;&gt;ClockRes&lt;/a&gt; utility from the &lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/bb842062.aspx&quot;&gt;Sysinternals Suite&lt;/a&gt;. Here is a typical output on my laptop:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; Clockres.exe
Clockres v2.1 - Clock resolution display utility
Copyright (C) 2016 Mark Russinovich
Sysinternals

Maximum timer interval: 15.625 ms
Minimum timer interval: 0.500 ms
Current timer interval: 1.000 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First of all, look at the maximum timer interval: it equals to &lt;code&gt;15.625 ms&lt;/code&gt; (this corresponds to a frequency of 64 &lt;a href=&quot;https://en.wikipedia.org/wiki/Hertz&quot;&gt;Hz&lt;/a&gt;). It&#39;s my default DateTime resolution when I don&#39;t have any non-system running applications. This value can be changed programmatically by &lt;em&gt;any application&lt;/em&gt;. For example, my current timer interval is &lt;code&gt;1 ms&lt;/code&gt;  (frequency = &lt;code&gt;1000 Hz&lt;/code&gt;). However, there is a limit: my minimum timer interval equals to &lt;code&gt;0.5 ms&lt;/code&gt; (frequency = &lt;code&gt;2000 Hz&lt;/code&gt;). The current timer interval may only take value from the specified range.&lt;/p&gt;
&lt;p&gt;It&#39;s a typical configuration for the modern version of Windows. However, you can observe other resolution values on the older version of Windows. For example, &lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.utcnow.aspx#Anchor_1&quot;&gt;according&lt;/a&gt; to MSDN, default resolution of &lt;code&gt;DateTime&lt;/code&gt; on Windows 98 is about &lt;code&gt;55ms&lt;/code&gt;. You can also find a lot of useful information about different configuration here: &lt;a href=&quot;http://www.windowstimestamp.com/description&quot;&gt;The Windows Timestamp Project&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;windows-resolution-api&quot;&gt;Windows Resolution API&lt;/h4&gt;
&lt;p&gt;So, how it can be changed? There are some Windows API which can be used: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd757624.aspx&quot;&gt;timeBeginPeriod&lt;/a&gt;/&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd757626.aspx&quot;&gt;timeEndPeriod&lt;/a&gt; from &lt;code&gt;winmm.dll&lt;/code&gt; and &lt;code&gt;NtQueryTimerResolution&lt;/code&gt;/&lt;code&gt;NtSetTimerResolution&lt;/code&gt; from &lt;code&gt;ntdll.dll&lt;/code&gt;. You can use it directly from C#, here is a helper class for you:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct ResolutionInfo
{
  public uint Min;
  public uint Max;
  public uint Current;
}

public static class WinApi
{
  [DllImport(&amp;quot;winmm.dll&amp;quot;, EntryPoint = &amp;quot;timeBeginPeriod&amp;quot;, SetLastError = true)]
  public static extern uint TimeBeginPeriod(uint uMilliseconds);

  [DllImport(&amp;quot;winmm.dll&amp;quot;, EntryPoint = &amp;quot;timeEndPeriod&amp;quot;, SetLastError = true)]
  public static extern uint TimeEndPeriod(uint uMilliseconds);

  [DllImport(&amp;quot;ntdll.dll&amp;quot;, SetLastError = true)]
  private static extern uint NtQueryTimerResolution(out uint min, out uint max, out uint current);

  [DllImport(&amp;quot;ntdll.dll&amp;quot;, SetLastError = true)]
  private static extern uint NtSetTimerResolution(uint desiredResolution, bool setResolution,
    ref uint currentResolution);

  public static ResolutionInfo QueryTimerResolution()
  {
    var info = new ResolutionInfo();
    NtQueryTimerResolution(out info.Min, out info.Max, out info.Current);
    return info;
  }

  public static ulong SetTimerResolution(uint ticks)
  {
    uint currentRes = 0;
    NtSetTimerResolution(ticks, true, ref currentRes);
    return currentRes;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let&#39;s play a little bit with this class. First of all, we can write own &lt;code&gt;ClockRes&lt;/code&gt; based on the described API:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var resolutioInfo = WinApi.QueryTimerResolution();
Console.WriteLine($&amp;quot;Min     = {resolutioInfo.Min}&amp;quot;);
Console.WriteLine($&amp;quot;Max     = {resolutioInfo.Max}&amp;quot;);
Console.WriteLine($&amp;quot;Current = {resolutioInfo.Current}&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Output (without any running apps):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Min     = 156250
Max     = 5000
Current = 156250
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let&#39;s manually check that &lt;code&gt;resolutioInfo.Current&lt;/code&gt; is the actual resolution of &lt;code&gt;DateTime&lt;/code&gt;. Here is a very simple code which shows observed &lt;code&gt;DateTime&lt;/code&gt; behaviour:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 10; i++)
{
  var current = DateTime.UtcNow;
  var last = current;
  while (last == current)
    current = DateTime.UtcNow;
  var diff = current - last;
  Console.WriteLine(diff.Ticks);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typical output:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;155934
156101
156237
156256
156237
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the received numbers are not exactly equal to &lt;code&gt;156250&lt;/code&gt;. So, the difference between two sequential different &lt;code&gt;DateTime&lt;/code&gt; values is approximately equal to the current timer interval.&lt;/p&gt;
&lt;h4 id=&quot;powercfg&quot;&gt;powercfg&lt;/h4&gt;
&lt;p&gt;For example, your current timer interval is not the maximum timer interval. How do you know who&#39;s to blame? Which program increased the system timer frequency? You can check it with the help of &lt;a href=&quot;https://en.wikipedia.org/wiki/Powercfg&quot;&gt;powercfg&lt;/a&gt;. For example, run the following command as administrator:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;powercfg -energy duration 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command will monitor you system for 10 seconds and generate an html report (&lt;code&gt;energy-report.html&lt;/code&gt; in the current directory) with a lot of useful information include information about Platform Timer Resolution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Platform Timer Resolution:Platform Timer Resolution
The default platform timer resolution is 15.6ms (15625000ns) and should be used whenever the system is idle.
If the timer resolution is increased, processor power management technologies may not be effective.
The timer resolution may be increased due to multimedia playback or graphical animations.
  Current Timer Resolution (100ns units) 5003 
  Maximum Timer Period (100ns units) 156250 

Platform Timer Resolution:Outstanding Timer Request
A program or service has requested a timer resolution smaller than the platform maximum timer resolution.
  Requested Period 5000 
  Requesting Process ID 6676 
  Requesting Process Path \Device\HarddiskVolume4\Users\akinshin\ConsoleApplication1.exe 

Platform Timer Resolution:Outstanding Timer Request
A program or service has requested a timer resolution smaller than the platform maximum timer resolution.
  Requested Period 10000 
  Requesting Process ID 10860 
  Requesting Process Path \Device\HarddiskVolume4\Program Files (x86)\Mozilla Firefox\firefox.exe 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, default interval is 15.6ms, Firefox requires 1.0ms interval, and &lt;code&gt;ConsoleApplication1.exe&lt;/code&gt; in my home directory (which just call &lt;code&gt;WinApi.SetTimerResolution(5000)&lt;/code&gt;) requires 0.5ms interval. &lt;code&gt;ConsoleApplication1.exe&lt;/code&gt; won, now I have the maximal possible platform timer frequency.&lt;/p&gt;
&lt;h4 id=&quot;thread.sleep&quot;&gt;Thread.Sleep&lt;/h4&gt;
&lt;p&gt;Ok, it sounds interesting, but why we should care about the system timer resolution?
Here I want to ask you a question: what the following call does?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Thread.Sleep(1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Somebody can answer: it suspend the current thread for &lt;code&gt;1 ms&lt;/code&gt;. Unfortunately, it&#39;s a wrong answer. The documentation &lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx&quot;&gt;states&lt;/a&gt; the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In fact, the elapsed time depends on system timer resolution. Let&#39;s write another naive benchmark (we don&#39;t need any accuracy here, we just want to show the &lt;code&gt;Sleep&lt;/code&gt; behavior in a simple way; so, we don&#39;t need usual benchmarking routine here like a warmup, statistics, and so on):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 5; i++)
{
  var sw = Stopwatch.StartNew();
  Thread.Sleep(1);
  sw.Stop();
  var time = sw.ElapsedTicks * 1000.0 / Stopwatch.Frequency;
  Console.WriteLine(time + &amp;quot; ms&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Typical output (for current timer interval = &lt;code&gt;15.625ms&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;14.8772437280584 ms
15.5369201880125 ms
18.6300283418281 ms
15.5728431635545 ms
15.6129649284456 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the elapsed intervals are much more than &lt;code&gt;1 ms&lt;/code&gt;. Now, let&#39;s run Firefox (which sets the interval to &lt;code&gt;1ms&lt;/code&gt;) and repeat our stupid benchmark:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.72057056881932 ms
1.48123957592228 ms
1.47983997947259 ms
1.47237546507424 ms
1.49756820116866 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Firefox affected the &lt;code&gt;Sleep&lt;/code&gt; call and reduced elapsed interval by ~ten times. You can find a good explanation of the &lt;code&gt;Sleep&lt;/code&gt; behavior in &lt;a href=&quot;http://www.windowstimestamp.com/description&quot;&gt;The Windows Timestamp Project&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Say the &lt;em&gt;ActualResolution&lt;/em&gt; is set to 156250, the interrupt heartbeat of the system will run at 15.625 ms periods or 64 Hz, and a call to Sleep is made with the desired delay of 1 ms. Two scenarios are to be looked at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The call was made &amp;lt; 1ms (ΔT) ahead of the next interrupt. The next interrupt will not confirm that the desired period of time has expired. Only the following interrupt will cause the call to return. The resulting sleep delay will be ΔT + 15.625ms.&lt;/li&gt;
&lt;li&gt;The call was made ≥ 1ms (ΔT) ahead of the next interrupt. The next interrupt will force the call to return. The resulting sleep delay will be ΔT.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;There are many others &lt;code&gt;Sleep&lt;/code&gt; “features”, but they are beyond the scope of this post. You can read another interesting read about the subject here: &lt;a href=&quot;https://randomascii.wordpress.com/2013/04/02/sleep-variation-investigated/&quot;&gt;Random ASCII: Sleep Variation Investigated (2013)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Of course, there are another Windows API which depends on the system timer resolution (e.g. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms687012.aspx&quot;&gt;Waitable Timer &lt;/a&gt;). We will not discuss this class in detail, I just want to recommend you once again to read this great text: &lt;a href=&quot;http://www.windowstimestamp.com/description&quot;&gt;The Windows Timestamp Project&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;As I mentioned before, on Linux, &lt;code&gt;DateTime.UtcNow&lt;/code&gt; uses the &lt;a href=&quot;http://man7.org/linux/man-pages/man2/gettimeofday.2.html&quot;&gt;gettimeofday&lt;/a&gt; function. There are a lot of interesting posts on the internet about how it&#39;s work (see the &lt;a href=&quot;#links&quot;&gt;Links&lt;/a&gt; section), so I will not repeat them, I will just put some short summary here.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gettimeofday&lt;/code&gt; allows you to get time in microseconds. Thus, &lt;code&gt;1us&lt;/code&gt; is the minimal possible resolution. The actual resolution depends on linux version and hardware, but nowadays &lt;code&gt;1us&lt;/code&gt; is also your actual resolution (this is not guaranteed). Internally it&#39;s usually based on a high-precision hardware timer and use &lt;a href=&quot;https://lwn.net/Articles/446528/&quot;&gt;vsyscall/vDSO&lt;/a&gt; to reduce latency (you can find some asm code &lt;a href=&quot;http://stackoverflow.com/a/7269039/184842&quot;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h3&gt;
&lt;p&gt;Let&#39;s write simple benchmarks with the help of &lt;a href=&quot;https://github.com/PerfDotNet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; (&lt;em&gt;v0.9.9&lt;/em&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[ClrJob, CoreJob, MonoJob]
public class DateTimeBenchmarks
{
  [Benchmark]
  public long Latency() =&amp;gt; DateTime.UtcNow.Ticks;

  [Benchmark]
  public long Resolution()
  {
    long lastTicks = DateTime.UtcNow.Ticks;
    while (DateTime.UtcNow.Ticks == lastTicks)
    {
    }
    return lastTicks;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;windows-1&quot;&gt;Windows&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.9.9.0
OS=Microsoft Windows NT 6.2.9200.0 (Windows 10 anniversary update)
Processor=Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8
Frequency=2143473 ticks, Resolution=466.5326 ns, Timer=TSC
CLR1=CORE, Arch=64-bit ? [RyuJIT]
CLR2=MS.NET 4.0.30319.42000
CLR3=Mono JIT compiler version 4.2.3
JitModules=clrjit-v4.6.1586.0
dotnet cli version: 1.0.0-preview2-003121
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Current Timer Interval = &lt;code&gt;15.625ms&lt;/code&gt;:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Clr&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.0471 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0342 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Clr&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;15,599,814.5300 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;2,754.4628 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.0481 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0367 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;15,597,438.1294 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;2,655.8045 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;30.4011 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2043 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;15,550,311.0491 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;6,562.2114 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Current Timer Interval = &lt;code&gt;0.5ms&lt;/code&gt; (running AIMP):&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Clr&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.3655 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.1102 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Clr&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;499,666.4219 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;811.5021 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;7.3545 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.0602 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;499,357.0707 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1,021.2058 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;31.5868 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.2685 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;499,696.0358 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;673.2927 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;linux-1&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;Xubuntu 16.04.01, the same hardware:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.9.9.0
OS=Unix 4.4.0.34
Processor=Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8
CLR1=CORE, Arch=64-bit ? [RyuJIT]
CLR2=Mono 4.4.2 (Stable 4.4.2.11/f72fe45 Fri Jul 29 09:58:49 UTC 2016), Arch=64-bit RELEASE
dotnet cli version: 1.0.0-preview2-003121
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Runtime&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;Median&lt;/th&gt;
&lt;th style=&quot;text-align: right;&quot;&gt;StdDev&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;27.2925 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.4665 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Core&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1,000.7250 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;0.5176 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;26.6243 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.3973 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Resolution&lt;/td&gt;
&lt;td&gt;Mono&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;998.2508 ns&lt;/td&gt;
&lt;td style=&quot;text-align: right;&quot;&gt;1.4941 ns&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;Now we know that the resolution and the latency of &lt;code&gt;DateTime&lt;/code&gt; may be tricky. On Windows, the resolutions depend on Windows System Timer; it can be changed programmatically by any application. Usually, it&#39;s about &lt;code&gt;0.5 ms&lt;/code&gt;..&lt;code&gt;15.625 ms&lt;/code&gt;. On Linux, the resolution is typical &lt;code&gt;1 us&lt;/code&gt;. However, the latency on Windows is usually several times smaller that the latency on Linux (but you should not care about it in most cases).&lt;/p&gt;
&lt;p&gt;Typically, &lt;code&gt;DateTime&lt;/code&gt; is a good choice when you want to know the current time (e.g. for logging) and you don&#39;t need high precision. However, beware of DateTime-specific phenomena (see &lt;a href=&quot;http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time&quot;&gt;Falsehoods programmers believe about time&lt;/a&gt; and &lt;a href=&quot;http://infiniteundo.com/post/25509354022/more-falsehoods-programmers-believe-about-time&quot;&gt;More falsehoods programmers believe about time&lt;/a&gt;). If you need to measure some time interval (not just put an approximate timestamp into a log file), you probably need a better tool. In the next post, I will tell about &lt;code&gt;Stopwatch&lt;/code&gt;: how it&#39;s implemented, what the latency and the resolution of &lt;code&gt;Stopwatch&lt;/code&gt;, how it works on different operating systems and runtimes, and why we should use &lt;code&gt;Stopwatch&lt;/code&gt; on .NET, rather than alternative measurements tools.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;h4 id=&quot;msdn&quot;&gt;MSDN&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.aspx&quot;&gt;MSDN: DateTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.utcnow.aspx&quot;&gt;MSDN: DateTime.UtcNow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.ticks.aspx&quot;&gt;MSDN: DateTime.Ticks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.datetime.aspx#Resolution&quot;&gt;MSDN: DateTime — Resolution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/hh706895.aspx&quot;&gt;MSDN: GetSystemTimePreciseAsFileTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd757624.aspx&quot;&gt;MSDN: timeBeginPeriod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dd757626.aspx&quot;&gt;MSDN: timeEndPeriod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/windows/desktop/dn553408.aspx&quot;&gt;MSDN: Acquiring high-resolution time stamps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;sources&quot;&gt;Sources&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/datetime.cs&quot;&gt;ReferenceSource: system/datetime.cs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs&quot;&gt;coreclr-v1.0.0: mscorlib/src/System/DateTime.cs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/pal/src/file/filetime.cpp&quot;&gt;coreclr-v1.0.0: pal/src/file/filetime.cpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/v1.0.0/src/classlibnative/bcltype/system.cpp#L48&quot;&gt;coreclr-v1.0.0: classlibnative/bcltype/system.cpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mono/utils/mono-time.c&quot;&gt;mono-4.4.2.11: mono-time.c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mono/mono/blob/mono-4.4.2.11/mono/metadata/icall-def.h&quot;&gt;mono-4.4.2.11: icall-def.h&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;useful-software&quot;&gt;Useful software&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/bb897568.aspx&quot;&gt;ClockRes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/bb842062.aspx&quot;&gt;Sysinternals Suite&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;misc&quot;&gt;Misc&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.windowstimestamp.com/description&quot;&gt;The Windows Timestamp Project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/System_time&quot;&gt;Wiki: System time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man2/gettimeofday.2.html&quot;&gt;man7.org: gettimeofday(2)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lwn.net/Articles/446528/&quot;&gt;lwn.net: On vsyscalls and the vDSO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://tldp.org/HOWTO/Clock.html&quot;&gt;The Clock Mini-HOWTO (2000)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;blog-posts&quot;&gt;Blog posts&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time&quot;&gt;Infinite Undo!: Falsehoods programmers believe about time (2012)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://infiniteundo.com/post/25509354022/more-falsehoods-programmers-believe-about-time&quot;&gt;Infinite Undo!: More falsehoods programmers believe about time (2012)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/&quot;&gt;Random ASCII: Windows Timer Resolution: Megawatts Wasted (2013)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://randomascii.wordpress.com/2013/04/02/sleep-variation-investigated/&quot;&gt;Random ASCII: Sleep Variation Investigated (2013)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mathpirate.net/log/2010/03/20/temporal-mechanics-changing-the-speed-of-time-part-ii/&quot;&gt;MathPirate: Temporal Mechanics: Changing the Speed of Time, Part II (2010)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programgo.com/article/91674336979/&quot;&gt;The accuracy of gettimeofday in ARM architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;stackoverflow&quot;&gt;StackOverflow&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/7685762/184842&quot;&gt;StackOverflow: Windows 7 timing functions - How to use GetSystemTimeAdjustment correctly?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/307582/184842&quot;&gt;StackOverflow: How frequent is DateTime.Now updated?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/37898579/184842&quot;&gt;StackOverflow: How is the CLR faster than me when calling Windows API&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/13230719/184842&quot;&gt;StackOverflow: How is the microsecond time of linux gettimeofday() obtained and what is its accuracy?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/12392278/184842&quot;&gt;StackOverflow: Measure time in Linux - time vs clock vs getrusage vs clock_gettime vs gettimeofday vs timespec_get?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/7266813/184842&quot;&gt;StackOverflow: Anyone can understand how gettimeofday works?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/19938324/184842&quot;&gt;StackOverflow: What are vdso and vsyscall?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>LegacyJIT-x86 and first method call</title>
            <link>http://aakinshin.net/posts/legacyjitx86-and-first-method-call/</link> 
            <pubDate>Mon, 04 Apr 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/legacyjitx86-and-first-method-call/</guid>
            <description>&lt;p&gt;Today I tell you about one of my favorite benchmarks (this method doesn&#39;t return a useful value, we need it only as an example):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Benchmark]
public string Sum()
{
    double a = 1, b = 1;
    var sw = new Stopwatch();
    for (int i = 0; i &amp;lt; 10001; i++)
        a = a + b;
    return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;An interesting fact: if you call &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt; before the first call of the &lt;code&gt;Sum&lt;/code&gt; method, you improve &lt;code&gt;Sum&lt;/code&gt; performance several times (works only with LegacyJIT-x86).&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;source-code-and-asm&quot;&gt;Source code and ASM&lt;/h3&gt;
&lt;p&gt;Let&#39;s consider the following programs (platform target is &lt;code&gt;x86&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class ProgramA
{
    static void Main()
    {
        Sum();
    }

    public static string Sum()
    {
        double a = 1, b = 1;
        var sw = new Stopwatch();
        for (int i = 0; i &amp;lt; 10001; i++)
            a = a + b;
        return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class ProgramB
{
    static void Main()
    {
        Stopwatch.GetTimestamp(); // !!!
        Sum();
    }

    public static string Sum()
    {
        double a = 1, b = 1;
        var sw = new Stopwatch();
        for (int i = 0; i &amp;lt; 10001; i++)
            a = a + b;
        return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only difference between these programs is the &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt; call. Now, let&#39;s look at the asm code for the loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; ProgramA
;  for (int i = 0; i &amp;lt; 10001; i++)
xor         eax,eax  
;  a = a + b;
fld1  
fadd        qword ptr [ebp-14h]  
fstp        qword ptr [ebp-14h]

; ProgramB
;  for (int i = 0; i &amp;lt; 10001; i++)
xor         eax,eax  
;  a = a + b;
fld1  
faddp       st(1),st  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It turns out, that in &lt;code&gt;ProgramA&lt;/code&gt; keeps data on the stack, &lt;code&gt;ProgramB&lt;/code&gt; keeps data in FPU registers.&lt;/p&gt;
&lt;h3 id=&quot;how-so&quot;&gt;How so?&lt;/h3&gt;
&lt;p&gt;In fact, in &lt;code&gt;ProgramB&lt;/code&gt; we can call &lt;code&gt;Stopwatch.IsHighResolution&lt;/code&gt; or &lt;code&gt;Stopwatch.Frequency&lt;/code&gt; instead of &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt;. The main things is that we want to implicitly call the static constructor of the &lt;code&gt;Stopwatch&lt;/code&gt; class. It affects how the call of the &lt;code&gt;Stopwatch&lt;/code&gt; instance constructor will be jitted:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Program A
;  var sw = new Stopwatch();
mov         ecx,71CDF3D4h  
call        005D30F4         ; basic ctor logic

mov         ecx,5E5F60h      ; !!! Here we should check
mov         edx,4F6h         ; !!! that static constructor
call        005D348C         ; !!! has been called

; // inlined Stopwatch::.ctor body
mov         dword ptr [esi+4],0   ; elapsed = 0
mov         dword ptr [esi+8],0   ; elapsed = 0
mov         byte ptr [esi+14h],0  ; isRunning = false
mov         dword ptr [esi+0Ch],0 ; startTimeStamp = 0
mov         dword ptr [esi+10h],0 ; startTimeStamp = 0

; Program B
;  var sw = new Stopwatch();
mov         ecx,71CDF3D4h  
call        005D30F4         ; basic ctor logic

; // inlined Stopwatch::.ctor body
mov         dword ptr [esi+4],0   ; elapsed = 0
mov         dword ptr [esi+8],0   ; elapsed = 0
mov         byte ptr [esi+14h],0  ; isRunning = false
mov         dword ptr [esi+0Ch],0 ; startTimeStamp = 0
mov         dword ptr [esi+10h],0 ; startTimeStamp = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we have two call sites for &lt;code&gt;ProgramA&lt;/code&gt; and one call site for &lt;code&gt;ProgramB&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The FP enregistration logic for the LegacyJIT-x86 uses the number of call sites as a factor in choosing to enregister or not to enregister floating point locals. Thus, we have different asm code for &lt;code&gt;ProgramA&lt;/code&gt; and &lt;code&gt;ProgramB&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;benchmarks&quot;&gt;Benchmarks&lt;/h3&gt;
&lt;p&gt;But should we care about it? How it affects method performance? Let&#39;s benchmark it! I wrote the following benchmark (based on &lt;a href=&quot;https://github.com/PerfDotNet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; v0.9.4):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(Config))]
public class FirstCall
{
    [Params(false, true)]
    public bool CallTimestamp { get; set; }

    [Setup]
    public void Setup()
    {
        if (CallTimestamp)
            Stopwatch.GetTimestamp();
    }

    [Benchmark]
    public string Sum()
    {
        double a = 1, b = 1;
        var sw = new Stopwatch();
        for (int i = 0; i &amp;lt; 10001; i++)
            a = a + b;
        return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
    }

    private class Config : ManualConfig
    {
        public Config()
        {
            Add(Job.LegacyJitX86);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Results:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.9.4.0
OS=Microsoft Windows NT 6.2.9200.0
Processor=Intel(R) Core(TM) i7-4810MQ CPU 2.80GHz, ProcessorCount=8
Frequency=2728072 ticks, Resolution=366.5592 ns, Timer=TSC
HostCLR=MS.NET 4.0.30319.42000, Arch=32-bit RELEASE
JitModules=clrjit-v4.6.1073.0

Type=FirstCall  Mode=Throughput  Platform=X86
Jit=LegacyJit

 Method |     Median |    StdDev | CallTimestamp |
------- |----------- |---------- |-------------- |
    Sum | 27.0464 us | 0.4958 us |         False |
    Sum |  8.3247 us | 0.0293 us |          True |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A single call of &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt; before the first call of the &lt;code&gt;Sum&lt;/code&gt; method improved performance 3.5 times!&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Sometimes, performance is tricky and benchmarking is super-tricky.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In general case, you can&#39;t just take a method without a context and start to discuss about its performance because method jitted code can depend on CLR state at the moment of the first method call. (However, in practice, this is a rare situation).&lt;/li&gt;
&lt;li&gt;Your benchmark methods can affect each other (not only because of static constructors; e.g., self-tuned GC and interface method dispatching are important). Thus, it is a good practice to run each benchmark method in a separated process (default behaviour of &lt;a href=&quot;https://github.com/PerfDotNet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;) .&lt;/li&gt;
&lt;li&gt;It is really easy to make a mistake in a handwritten benchmark. In the above example, a careless call of a &lt;code&gt;Stopwatch&lt;/code&gt; method can spoil benchmark results.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;see-also&quot;&gt;See also&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/32114308/weird-performance-increase-in-simple-benchmark&quot;&gt;Stackoverflow: Weird performance increase in simple benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/k9x6w0hc.aspx&quot;&gt;MSDN: Static Constructors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>LegacyJIT-x86 и первый вызов метода</title>
            <link>http://aakinshin.net/ru/posts/legacyjitx86-and-first-method-call/</link> 
            <pubDate>Mon, 04 Apr 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/legacyjitx86-and-first-method-call/</guid>
            <description>&lt;p&gt;Сегодня я расскажу вам об одном из моих любимых бенчмарков (данный метод не возвращает ничего полезного, он нам нужен только в качестве примера):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Benchmark]
public string Sum()
{
    double a = 1, b = 1;
    var sw = new Stopwatch();
    for (int i = 0; i &amp;lt; 10001; i++)
        a = a + b;
    return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Интересный факт: если вы вызовете &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt; перед первым вызовом метода &lt;code&gt;Sum&lt;/code&gt;, то это увеличит скорость работы метода в несколько раз (фокус работает только для LegacyJIT-x86).&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;asm&quot;&gt;Исходный код и ASM&lt;/h3&gt;
&lt;p&gt;Рассмотрим две следующие программы (работаем на &lt;code&gt;x86&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class ProgramA
{
    static void Main()
    {
        Sum();
    }

    public static string Sum()
    {
        double a = 1, b = 1;
        var sw = new Stopwatch();
        for (int i = 0; i &amp;lt; 10001; i++)
            a = a + b;
        return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class ProgramB
{
    static void Main()
    {
        Stopwatch.GetTimestamp(); // !!!
        Sum();
    }

    public static string Sum()
    {
        double a = 1, b = 1;
        var sw = new Stopwatch();
        for (int i = 0; i &amp;lt; 10001; i++)
            a = a + b;
        return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Единственное отличие между этими программами состоит в лишнем вызове &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt;. А теперь взглянем на asm-код нашего цикла внутри метода &lt;code&gt;Sum&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; ProgramA
;  for (int i = 0; i &amp;lt; 10001; i++)
xor         eax,eax  
;  a = a + b;
fld1  
fadd        qword ptr [ebp-14h]  
fstp        qword ptr [ebp-14h]

; ProgramB
;  for (int i = 0; i &amp;lt; 10001; i++)
xor         eax,eax  
;  a = a + b;
fld1  
faddp       st(1),st  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Оказывается, программа &lt;code&gt;ProgramA&lt;/code&gt; хранит данные на стеке, а &lt;code&gt;ProgramB&lt;/code&gt; хранит их в регистрах.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Как так?&lt;/h3&gt;
&lt;p&gt;На самом деле в программе &lt;code&gt;ProgramB&lt;/code&gt; мы можем вызвать &lt;code&gt;Stopwatch.IsHighResolution&lt;/code&gt; или &lt;code&gt;Stopwatch.Frequency&lt;/code&gt; вместо &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt;. Главный момент заключается в том, что для достижения нужного эффекта нам необходимо неявно вызвать статический конструктор класса &lt;code&gt;Stopwatch&lt;/code&gt;. Это повлияет на то, как экзеплярный конструктор &lt;code&gt;Stopwatch&lt;/code&gt; будет обработан JIT-компилятором:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Program A
;  var sw = new Stopwatch();
mov         ecx,71CDF3D4h  
call        005D30F4         ; базовая логика конструктора

mov         ecx,5E5F60h      ; !!! Тут мы должны проверить,
mov         edx,4F6h         ; !!! что статический конструктор
call        005D348C         ; !!! был вызван

; // заинлайненный Stopwatch::.ctor
mov         dword ptr [esi+4],0   ; elapsed = 0
mov         dword ptr [esi+8],0   ; elapsed = 0
mov         byte ptr [esi+14h],0  ; isRunning = false
mov         dword ptr [esi+0Ch],0 ; startTimeStamp = 0
mov         dword ptr [esi+10h],0 ; startTimeStamp = 0

; Program B
;  var sw = new Stopwatch();
mov         ecx,71CDF3D4h  
call        005D30F4         ; базовая логика конструктора

; // заинлайненный Stopwatch::.ctor
mov         dword ptr [esi+4],0   ; elapsed = 0
mov         dword ptr [esi+8],0   ; elapsed = 0
mov         byte ptr [esi+14h],0  ; isRunning = false
mov         dword ptr [esi+0Ch],0 ; startTimeStamp = 0
mov         dword ptr [esi+10h],0 ; startTimeStamp = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно увидеть из листинга, у нас имеется два &lt;code&gt;call&lt;/code&gt; для &lt;code&gt;ProgramA&lt;/code&gt; и один &lt;code&gt;call&lt;/code&gt; для &lt;code&gt;ProgramB&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;LegacyJIT-x86 использует количество &lt;code&gt;call&lt;/code&gt;-ов в качестве одного из факторов для того, чтобы решить использовать ли регистры для локальных floating point-переменных или не использовать. Таким образом, мы получили разный asm-код для &lt;code&gt;ProgramA&lt;/code&gt; и &lt;code&gt;ProgramB&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Бенчмарки&lt;/h3&gt;
&lt;p&gt;Но должна ли нас волновать эта разница? Как это влияет на производительность? Давайте забенчмаркаем! Я написал следующий бенчмарк для оценки ситуации (основано на &lt;a href=&quot;https://github.com/PerfDotNet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; v0.9.4):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Config(typeof(Config))]
public class FirstCall
{
    [Params(false, true)]
    public bool CallTimestamp { get; set; }

    [Setup]
    public void Setup()
    {
        if (CallTimestamp)
            Stopwatch.GetTimestamp();
    }

    [Benchmark]
    public string Sum()
    {
        double a = 1, b = 1;
        var sw = new Stopwatch();
        for (int i = 0; i &amp;lt; 10001; i++)
            a = a + b;
        return string.Format(&amp;quot;{0}{1}&amp;quot;, a, sw.ElapsedMilliseconds);
    }

    private class Config : ManualConfig
    {
        public Config()
        {
            Add(Job.LegacyJitX86);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ini&quot;&gt;BenchmarkDotNet=v0.9.4.0
OS=Microsoft Windows NT 6.2.9200.0
Processor=Intel(R) Core(TM) i7-4810MQ CPU 2.80GHz, ProcessorCount=8
Frequency=2728072 ticks, Resolution=366.5592 ns, Timer=TSC
HostCLR=MS.NET 4.0.30319.42000, Arch=32-bit RELEASE
JitModules=clrjit-v4.6.1073.0

Type=FirstCall  Mode=Throughput  Platform=X86
Jit=LegacyJit

 Method |     Median |    StdDev | CallTimestamp |
------- |----------- |---------- |-------------- |
    Sum | 27.0464 us | 0.4958 us |         False |
    Sum |  8.3247 us | 0.0293 us |          True |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Получается так, что вызов &lt;code&gt;Stopwatch.GetTimestamp()&lt;/code&gt; перед первым вызовом метода &lt;code&gt;Sum&lt;/code&gt; увеличил скорость работы в 3.5 раза!&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Заключение&lt;/h3&gt;
&lt;p&gt;Производительность — тема сложная. Бенчмаркинг — тема очень сложная. Постараюсь сформулировать мораль данной истории:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;В общем случае мы не можем просто так взять метод без контекста и начать рассуждать о его производительности, ведь его asm-код может зависеть от состояния CLR в момент первого вызова (однако, на практике это редко имеет значение).&lt;/li&gt;
&lt;li&gt;Бенчмарки могут влиять друг на друга (не только из-за статических конструкторов; например, имеют большое значение самонастраиваемый сборщик мусора и диспатчинг интерфейсных методов). Поэтому хорошей практикой является запуск каждого бенчмарк-метода в отдельном процессе (&lt;a href=&quot;https://github.com/PerfDotNet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; так и делает) .&lt;/li&gt;
&lt;li&gt;Очень легко сделать ошибку в самописном бенчмарке. Если бы мы писали руками бенчмарк для метода &lt;code&gt;Sum&lt;/code&gt;, то лишний случайный вызов метода класса &lt;code&gt;Stopwatch&lt;/code&gt; в корне бы изменил результаты нашего маленького эксперимента.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-3&quot;&gt;См. также&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/32114308/weird-performance-increase-in-simple-benchmark&quot;&gt;Stackoverflow: Weird performance increase in simple benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/k9x6w0hc.aspx&quot;&gt;MSDN: Static Constructors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Visual Studio and ProjectTypeGuids.cs</title>
            <link>http://aakinshin.net/posts/projecttypeguids/</link> 
            <pubDate>Sat, 27 Feb 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/projecttypeguids/</guid>
            <description>&lt;p&gt;It&#39;s a story about how I tried to open a project in Visual Studio for a few hours. The other day, I was going to do some work. I pulled last commits from a repo, opened Visual Studio, and prepared to start coding. However, one of a project in my solution failed to open with a strange message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error  : The operation could not be completed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the Solution Explorer, I had &lt;em&gt;&amp;quot;load failed&amp;quot;&lt;/em&gt; as a project status and the following message instead of the file tree: &lt;em&gt;&amp;quot;The project requires user input. Reload the project for more information.&amp;quot;&lt;/em&gt; Hmm, ok, I reloaded the project and got a few more errors:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error  : The operation could not be completed.
error  : The operation could not be completed.
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Long story short, I did the following things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;del /s *.suo *.user&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clean -xfd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutdown -r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Northing helps. Then I started to investigate which commit broke project loading. Long live &lt;code&gt;git bisect&lt;/code&gt;, the commit was found. But it did not contain anything suspicious. Just a new unremarkable file called &lt;code&gt;ProjectTypeGuids.cs&lt;/code&gt; and the following file in &lt;code&gt;.csproj&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Compile Include=&amp;quot;ProjectTypeGuids.cs&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What can be possible wrong with such commit? Further investigation revealed the following non-obvious fact: Visual Studio can&#39;t load a project that contains the &lt;code&gt;ProjectTypeGuids.cs&lt;/code&gt;. I&#39;m serious. Try it yourself:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Open Visual Studio (2013 or 2015).&lt;/li&gt;
&lt;li&gt;Create a console application or a class library.&lt;/li&gt;
&lt;li&gt;Add new file: &lt;code&gt;ProjectTypeGuids.cs&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Save all.&lt;/li&gt;
&lt;li&gt;Close the solution.&lt;/li&gt;
&lt;li&gt;Try to open this solution.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;There is a corresponded bug on connect.microsoft.com: &lt;a href=&quot;http://connect.microsoft.com/VisualStudio/feedbackdetail/view/763638/visual-studio-project-load-bug&quot;&gt;Visual Studio Project Load bug&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a bug in Visual studio console project loader module.
Usually the project file for most applications (e.g. silverlight) has certain XML attributes like &amp;quot;ProjectTypeGuids&amp;quot; and &amp;quot;OutputType&amp;quot; among several others. Some don&#39;t have them e.g. console.
If i create a console project and add a file which is named similar (case sensitive) to one of the attributes (e.g. Add ProjectTypeGuids.cs to the console project), Unload it and then try to reload it; the project fails to load.
&amp;quot;The project type is not supported by this installation&amp;quot; is the error that is thrown.
If the case of file name is altered manually in csproj file, the correct file does get picked up and the project reloads succesfully.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unfortunately, the bug status is &amp;quot;Closed as Won&#39;t Fix&amp;quot;. So, we should just live with that. I just renamed this file in my project and now everything works fine.&lt;/p&gt;
&lt;p&gt;By the way, &lt;a href=&quot;https://blog.jetbrains.com/dotnet/2016/01/13/project-rider-a-csharp-ide/&quot;&gt;Rider&lt;/a&gt; open such projects very well. =)&lt;/p&gt;
&lt;h3 id=&quot;see-also&quot;&gt;See also&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/en/blog/dotnet/happy-monday/&quot;&gt;Happy Monday!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Visual Studio и ProjectTypeGuids.cs</title>
            <link>http://aakinshin.net/ru/posts/projecttypeguids/</link> 
            <pubDate>Sat, 27 Feb 2016 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/projecttypeguids/</guid>
            <description>&lt;p&gt;Это история о том, как я несколько часов пытался открыть проект в Visual Studio. Как-то раз я решил немножко поработать: стянул себе последние коммиты из репозитория, открыл Visual Studio и собрался программировать. Увы, один из моих проектов не открылся, а в окошке Output я увидел странное сообщение:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error  : The operation could not be completed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В Solution Explorer, рядом с названием проекта была надпись &lt;em&gt;&amp;quot;load failed&amp;quot;&lt;/em&gt;, а вместо файлов было написано следующее: &lt;em&gt;&amp;quot;The project requires user input. Reload the project for more information.&amp;quot;&lt;/em&gt; Хмм, ну ок, я попробовал перегрузить проект. Увы, не помогло, я получил ещё два уже знакомых сообщения об ошибке:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;error  : The operation could not be completed.
error  : The operation could not be completed.
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Не буду утомлять вас подробными рассказами о том, как я пытался понять происходящее. В числе прочего были сделаны следующие вещи:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;del /s *.suo *.user&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clean -xfd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutdown -r&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Увы, ничего не помогло. Тогда я стал искать коммит, после которого всё сломалось. Слава &lt;code&gt;git bisect&lt;/code&gt;, вскоре коммит был найден. Но вот только он не содержал ничего подозрительного. В коммите был добавлен непримечательный файл под названием &lt;code&gt;ProjectTypeGuids.cs&lt;/code&gt; и соответствующая строчка в &lt;code&gt;.csproj&lt;/code&gt;-файле:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Compile Include=&amp;quot;ProjectTypeGuids.cs&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Что может быть не так с подобным коммитом? Дальнейшее расследование выявило следюущий не особо очевидный факт: Visual Studio не может открыть проект, который содержит файл &lt;code&gt;ProjectTypeGuids.cs&lt;/code&gt;. Я сейчас абсолютно серьёзно. Попробуйте сами, воспроизвести проблему очень легко:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Открываем Visual Studio (2013 или 2015).&lt;/li&gt;
&lt;li&gt;Создаём новое консольное приложение или библиотеку.&lt;/li&gt;
&lt;li&gt;Добавляем новый файл: &lt;code&gt;ProjectTypeGuids.cs&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Сохраняем всё.&lt;/li&gt;
&lt;li&gt;Закрываем всё.&lt;/li&gt;
&lt;li&gt;Пытаемся снова открыть проект.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;На connect.microsoft.com есть соответствующий баг: &lt;a href=&quot;http://connect.microsoft.com/VisualStudio/feedbackdetail/view/763638/visual-studio-project-load-bug&quot;&gt;Visual Studio Project Load bug&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a bug in Visual studio console project loader module.
Usually the project file for most applications (e.g. silverlight) has certain XML attributes like &amp;quot;ProjectTypeGuids&amp;quot; and &amp;quot;OutputType&amp;quot; among several others. Some don&#39;t have them e.g. console.
If i create a console project and add a file which is named similar (case sensitive) to one of the attributes (e.g. Add ProjectTypeGuids.cs to the console project), Unload it and then try to reload it; the project fails to load.
&amp;quot;The project type is not supported by this installation&amp;quot; is the error that is thrown.
If the case of file name is altered manually in csproj file, the correct file does get picked up and the project reloads succesfully.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Увы, статус бага &amp;quot;Closed as Won&#39;t Fix&amp;quot;, так что исправлять его никто не будет, придётся с этим жить. В своём проекте я просто переименовал файл, теперь всё работает нормально.&lt;/p&gt;
&lt;p&gt;Кстати говоря, а вот &lt;a href=&quot;https://blog.jetbrains.com/dotnet/2016/01/13/project-rider-a-csharp-ide/&quot;&gt;Rider&lt;/a&gt; открывает такие проекты вообще без проблем. =)&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;См. также&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/en/blog/dotnet/happy-monday/&quot;&gt;Happy Monday!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Blittable types</title>
            <link>http://aakinshin.net/posts/blittable/</link> 
            <pubDate>Thu, 26 Nov 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/blittable/</guid>
            <description>&lt;p&gt;Challenge of the day: what will the following code display?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Explicit)]
public struct UInt128
{
    [FieldOffset(0)]
    public ulong Value1;
    [FieldOffset(8)]
    public ulong Value2;
}
[StructLayout(LayoutKind.Sequential)]
public struct MyStruct
{
    public UInt128 UInt128;
    public char Char;
}
class Program
{
    public static unsafe void Main()
    {
        var myStruct = new MyStruct();
        var baseAddress = (int)&amp;amp;myStruct;
        var uInt128Adress = (int)&amp;amp;myStruct.UInt128;
        Console.WriteLine(uInt128Adress - baseAddress);
        Console.WriteLine(Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A hint: two zeros or two another same values are wrong answers in the general case. The following table shows the console output on different runtimes:&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;MS.NET-x86&lt;/th&gt;&lt;th&gt;MS.NET-x64&lt;/th&gt;&lt;th&gt;Mono&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;uInt128Adress - baseAddress                  &lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Marshal.OffsetOf(typeof(MyStruct), &quot;UInt128&quot;)&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;If you want to know why it happens, you probably should learn some useful information about blittable types.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;theory&quot;&gt;Theory&lt;/h3&gt;
&lt;p&gt;There is a definition of &lt;a href=&quot;https://en.wikipedia.org/wiki/Blittable_types&quot;&gt;blittable types&lt;/a&gt; from Wikipedia:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blittable types are data types in software applications which have a unique characteristic. Data are often represented in memory differently in managed and unmanaged code in the Microsoft .NET framework. However, blittable types are defined as having an identical presentation in memory for both environments, and can be directly shared. Understanding the difference between blittable and non-blittable types can aid in using COM Interop or P/Invoke, two techniques for interoperability in .NET applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you want to marshall your structures, it is very important to know: is your type blittable or not. Indeed, marshalling will be easier, if your data in memory has a proper representation for marshalling. Furthermore, there are situations when you can use only blittable types. For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Structures that are returned from platform invoke calls must be blittable types.&lt;/li&gt;
&lt;li&gt;As an optimization, arrays of blittable types and classes that contain only blittable members are pinned instead of copied during marshaling.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&#39;s discuss it in detail: which types are blittable and what does it depend?&lt;/p&gt;
&lt;p&gt;First of all, we should know about the following attribute: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.structlayoutattribute.aspx&quot;&gt; System.Runtime.InteropServices.StructLayoutAttribute&lt;/a&gt;, it lets you control the physical layout of the data fields of a class or structure in memory. You can use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.layoutkind.aspx&quot;&gt;3 following values&lt;/a&gt; of &lt;code&gt;LayoutKind&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Auto&lt;/code&gt;: The runtime automatically chooses an appropriate layout for the members of an object in unmanaged memory. Objects defined with this enumeration member cannot be exposed outside of managed code. Attempting to do so generates an exception.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Explicit&lt;/code&gt;: The precise position of each member of an object in unmanaged memory is explicitly controlled, subject to the setting of the StructLayoutAttribute.Pack field. Each member must use the FieldOffsetAttribute to indicate the position of that field within the type.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sequential&lt;/code&gt;: The members of the object are laid out sequentially, in the order in which they appear when exported to unmanaged memory. The members are laid out according to the packing specified in StructLayoutAttribute.Pack, and can be noncontiguous.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Two last values (&lt;code&gt;Explicit&lt;/code&gt; and &lt;code&gt;Sequential&lt;/code&gt;) are also called Formatted because they define the fields order for marshalling. C# uses &lt;code&gt;Sequential&lt;/code&gt; as default.&lt;/p&gt;
&lt;h3 id=&quot;blittable-types&quot;&gt;Blittable types&lt;/h3&gt;
&lt;p&gt;It is very important to know, which types are blittable. We have the following groups of blittable types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some primitive types: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.byte.aspx&quot;&gt;System.Byte&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.sbyte.aspx&quot;&gt;System.SByte&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.int16.aspx&quot;&gt;System.Int16&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uint16.aspx&quot;&gt;System.UInt16&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.int32.aspx&quot;&gt;System.Int32&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uint32.aspx&quot;&gt;System.UInt32&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.int64.aspx&quot;&gt;System.Int64&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uint64.aspx&quot;&gt;System.UInt64&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.intptr.aspx&quot;&gt;System.IntPtr&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uintptr.aspx&quot;&gt;System.UIntPtr&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.single.aspx&quot;&gt;System.Single&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.double.aspx&quot;&gt;System.Double&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;One-dimensional arrays of blittable types, such as an array of integers. However, a type that contains a variable array of blittable types is not itself blittable.&lt;/li&gt;
&lt;li&gt;Formatted value types that contain only blittable types (and classes if they are marshaled as formatted types).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;non-blittable-types&quot;&gt;Non-Blittable Types&lt;/h3&gt;
&lt;p&gt;There are several non-blittable types which we should discussed in detail.&lt;/p&gt;
&lt;h4 id=&quot;decimal&quot;&gt;Decimal&lt;/h4&gt;
&lt;p&gt;Yep, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.decimal.aspx&quot;&gt;Decimal&lt;/a&gt; is not a blittable type. If you want to use it as a blittable, you probably should write a wrapper (based on the &lt;a href=&quot;http://stackoverflow.com/a/30217247/184842&quot;&gt;method&lt;/a&gt; by Hans Passant, see &lt;a href=&quot;http://stackoverflow.com/questions/30213132/why-is-decimal-data-type-non-blittable&quot;&gt;Why is “decimal” data type non-blittable?&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct BlittableDecimal
{
    private long longValue;

    public decimal Value
    {
        get { return decimal.FromOACurrency(longValue); }
        set { longValue = decimal.ToOACurrency(value); }
    }

    public static explicit operator BlittableDecimal(decimal value)
    {
        return new BlittableDecimal { Value = value };
    }

    public static implicit operator decimal (BlittableDecimal value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;datetime&quot;&gt;DateTime&lt;/h4&gt;
&lt;p&gt;An interesting fact: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.datetime.aspx&quot;&gt;DateTime&lt;/a&gt; contains a single  &lt;code&gt;UInt64&lt;/code&gt; field, but the LayoutKind &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/datetime.cs,55&quot;&gt;explicitly set&lt;/a&gt; to &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Auto)]
[Serializable]
public struct DateTime : 
  IComparable, IFormattable, IConvertible, ISerializable, IComparable&amp;lt;DateTime&amp;gt;,IEquatable&amp;lt;DateTime&amp;gt; {
    
    // ...
                    
    // The data is stored as an unsigned 64-bit integeter
    //   Bits 01-62: The value of 100-nanosecond ticks where 0 represents 1/1/0001 12:00am, up until the value
    //               12/31/9999 23:59:59.9999999
    //   Bits 63-64: A four-state value that describes the DateTimeKind value of the date time, with a 2nd
    //               value for the rare case where the date time is local, but is in an overlapped daylight
    //               savings time hour and it is in daylight savings time. This allows distinction of these
    //               otherwise ambiguous local times and prevents data loss when round tripping from Local to
    //               UTC time.
    private UInt64 dateData;
    
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It means that &lt;code&gt;DateTime&lt;/code&gt; is a non-blittable type. Thus, if you have a value type with a &lt;code&gt;DateTime&lt;/code&gt; field, your types will be also non-blittable. Such behaviour has historical causes and confuses some people, see: &lt;a href=&quot;http://stackoverflow.com/questions/21881554/why-does-the-system-datetime-struct-have-layout-kind-auto&quot;&gt;Why does the System.DateTime struct have layout kind Auto?&lt;/a&gt;, &lt;a href=&quot;http://stackoverflow.com/questions/4132533/why-does-layoutkind-sequential-work-differently-if-a-struct-contains-a-datetime&quot;&gt;Why does LayoutKind.Sequential work differently if a struct contains a DateTime field?&lt;/a&gt; (I recommend to read &lt;a href=&quot;http://stackoverflow.com/a/21883421/184842&quot;&gt;this answer&lt;/a&gt; by Hans Passant).&lt;/p&gt;
&lt;p&gt;Of course, you can write a blittable wrapper like follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct BlittableDateTime
{
    private long ticks;

    public DateTime Value
    {
        get { return new DateTime(ticks); }
        set { ticks = value.Ticks; }
    }

    public static explicit operator BlittableDateTime(DateTime value)
    {
        return new BlittableDateTime { Value = value };
    }

    public static implicit operator DateTime(BlittableDateTime value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;guid&quot;&gt;Guid&lt;/h4&gt;
&lt;p&gt;Of course, you know about the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.guid.aspx&quot;&gt;Guid&lt;/a&gt; type. But do you know about its internal representation? Let&#39;s look to &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/guid.cs,30&quot;&gt;the source code&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private int         _a;
private short       _b;
private short       _c;
private byte       _d;
private byte       _e;
private byte       _f;
private byte       _g;
private byte       _h;
private byte       _i;
private byte       _j;
private byte       _k;

// Creates a new guid from an array of bytes.
public Guid(byte[] b)
{
    // Some checks ...

    _a = ((int)b[3] &amp;lt;&amp;lt; 24) | ((int)b[2] &amp;lt;&amp;lt; 16) | ((int)b[1] &amp;lt;&amp;lt; 8) | b[0];
    _b = (short)(((int)b[5] &amp;lt;&amp;lt; 8) | b[4]);
    _c = (short)(((int)b[7] &amp;lt;&amp;lt; 8) | b[6]);
    _d = b[8];
    _e = b[9];
    _f = b[10];
    _g = b[11];
    _h = b[12];
    _i = b[13];
    _j = b[14];
    _k = b[15];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is interesting. If we open &lt;a href=&quot;https://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;wikipedia&lt;/a&gt;, we can find the following table:&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;Bits&lt;/th&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Endianness (Microsoft GUID Structure)&lt;/th&gt;&lt;th&gt;Endianness (RFC 4122)&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;Data1&lt;/td&gt;&lt;td&gt;Native&lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Data2&lt;/td&gt;&lt;td&gt;Native&lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Data3&lt;/td&gt;&lt;td&gt;Native&lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;Data4&lt;/td&gt;&lt;td&gt;Big   &lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;GUID has the following Type library representation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct tagGUID {
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[ 8 ];
} GUID;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is very important that internal representation of GUID is depend on platform. If you work with the little-endian architecture (you likely uses exactly little-endian, see &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;Endianness&lt;/a&gt;), the GUID representation will differ from RFC 4122. It can create some troubles during interop with another application (for example, &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/UUID.html&quot;&gt;Java UUID&lt;/a&gt; uses RFC 4122).&lt;/p&gt;
&lt;h4 id=&quot;char&quot;&gt;Char&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.char.aspx&quot;&gt;Char&lt;/a&gt; is also non-blittable type, it can be converted to &lt;code&gt;Unicode&lt;/code&gt; or &lt;code&gt;ANSI&lt;/code&gt; character. The marshalling type depends on &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.charset.aspx&quot;&gt;CharSet&lt;/a&gt; of &lt;code&gt;StructLayout&lt;/code&gt;, which can be equal to one of the following values: &lt;code&gt;Auto&lt;/code&gt;, &lt;code&gt;Ansi&lt;/code&gt;, &lt;code&gt;Unicode&lt;/code&gt;. On the modern versions of Windows, &lt;code&gt;Auto&lt;/code&gt; resolves to &lt;code&gt;Unicode&lt;/code&gt;, but on Windows 98 and Windows Me &lt;code&gt;Auto&lt;/code&gt; resolves to &lt;code&gt;Ansi&lt;/code&gt;. The C# compiler uses &lt;code&gt;Ansi&lt;/code&gt; as default that makes char a non-blittable type. However, we can write the following wrapper and solve the problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct BlittableChar
{
    public char Value;

    public static explicit operator BlittableChar(char value)
    {
        return new BlittableChar { Value = value };
    }

    public static implicit operator char (BlittableChar value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;boolean&quot;&gt;Boolean&lt;/h4&gt;
&lt;p&gt;MSDN &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/75dwhxf7.aspx&quot;&gt;says&lt;/a&gt; the following phrase about &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.boolean.aspx&quot;&gt;Boolean&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Converts to a 1, 2, or 4-byte value with true as 1 or -1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&#39;s write one more wrapper and make blittable bool:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct BlittableBoolean
{
    private byte byteValue;

    public bool Value
    {
        get { return Convert.ToBoolean(byteValue); }
        set { byteValue = Convert.ToByte(value); }
    }

    public static explicit operator BlittableBoolean(bool value)
    {
        return new BlittableBoolean { Value = value };
    }

    public static implicit operator bool (BlittableBoolean value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;blittable-or-non-blittable&quot;&gt;Blittable or Non-Blittable?&lt;/h3&gt;
&lt;p&gt;Sometimes it is useful to know, is your type blittable or not. How we can do it? Recall that we can&#39;t allocate pinned instances of non-blittable type. So, we can write the following helper class for our aim (based on the &lt;a href=&quot;http://stackoverflow.com/a/31485271/184842&quot;&gt;method by IllidanS4&lt;/a&gt;, see &lt;a href=&quot;http://stackoverflow.com/questions/10574645/the-fastest-way-to-check-if-a-type-is-blittable&quot;&gt;The fastest way to check if a type is blittable?&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static class BlittableHelper
{
    public static bool IsBlittable&amp;lt;T&amp;gt;()
    {
        return IsBlittableCache&amp;lt;T&amp;gt;.Value;
    }

    public static bool IsBlittable(this Type type)
    {
        if (type.IsArray)
        {
            var elem = type.GetElementType();
            return elem.IsValueType &amp;amp;&amp;amp; IsBlittable(elem);
        }
        try
        {
            object instance = FormatterServices.GetUninitializedObject(type);
            GCHandle.Alloc(instance, GCHandleType.Pinned).Free();
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static class IsBlittableCache&amp;lt;T&amp;gt;
    {
        public static readonly bool Value = IsBlittable(typeof(T));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, there is one type that broke our approach: decimal. Surprisingly, but you can allocate a pinned decimal. And you can&#39;t allocate a pinned instance of value types that contains decimal field (because decimal is non-blittable). I don&#39;t know other such types. So, we probably can write a hack in the &lt;code&gt;IsBlittable&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (type == typeof(decimal))
    return false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you know a general solution, I&#39;ll be glad to discuss it.&lt;/p&gt;
&lt;h3 id=&quot;coreclr-sources&quot;&gt;CoreCLR sources&lt;/h3&gt;
&lt;p&gt;Nowadays, we have open source CoreCLR. So, we can look inside the runtime and find something interesting. An interesting file is &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/vm/fieldmarshaler.cpp#L283-L318&quot;&gt;fieldmarshaler.cpp&lt;/a&gt;, it contains the following lines:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;if (!(*pfDisqualifyFromManagedSequential))
{
    // This type may qualify for ManagedSequential. Collect managed size and alignment info.
    if (CorTypeInfo::IsPrimitiveType(corElemType))
    {
        pfwalk-&amp;gt;m_managedSize = ((UINT32)CorTypeInfo::Size(corElemType)); // Safe cast - no primitive type is larger than 4gb!
        pfwalk-&amp;gt;m_managedAlignmentReq = pfwalk-&amp;gt;m_managedSize;
    }
    else if (corElemType == ELEMENT_TYPE_PTR)
    {
        pfwalk-&amp;gt;m_managedSize = sizeof(LPVOID);
        pfwalk-&amp;gt;m_managedAlignmentReq = sizeof(LPVOID);
    }
    else if (corElemType == ELEMENT_TYPE_VALUETYPE)
    {
        TypeHandle pNestedType = fsig.GetLastTypeHandleThrowing(ClassLoader::LoadTypes,
                                                                CLASS_LOAD_APPROXPARENTS,
                                                                TRUE);
        if (pNestedType.GetMethodTable()-&amp;gt;IsManagedSequential())
        {
            pfwalk-&amp;gt;m_managedSize = (pNestedType.GetMethodTable()-&amp;gt;GetNumInstanceFieldBytes());

            _ASSERTE(pNestedType.GetMethodTable()-&amp;gt;HasLayout()); // If it is ManagedSequential(), it also has Layout but doesn&#39;t hurt to check before we do a cast!
            pfwalk-&amp;gt;m_managedAlignmentReq = pNestedType.GetMethodTable()-&amp;gt;GetLayoutInfo()-&amp;gt;m_ManagedLargestAlignmentRequirementOfAllMembers;
        }
        else
        {
            *pfDisqualifyFromManagedSequential = TRUE;
        }
    }
    else
    {
        // No other type permitted for ManagedSequential.
        *pfDisqualifyFromManagedSequential = TRUE;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;explanation-of-the-example&quot;&gt;Explanation of the example&lt;/h3&gt;
&lt;p&gt;Let&#39;s back to the first example from this post. Now we can understand why MS.NET shows different results. &lt;code&gt;Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;)&lt;/code&gt; display &#171;honest&#187; marshalling offset (&lt;code&gt;0&lt;/code&gt;). However, CLR does not guarantee anything about memory representation of our value types because it is not a blittable type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(BlittableHelper.IsBlittable&amp;lt;MyStruct&amp;gt;()); // False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But now we know how to change the situation and make the result more predictable. Let&#39;s replace &lt;code&gt;char&lt;/code&gt; by our wrapper:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Sequential)]
public struct MyStruct
{
    public UInt128 UInt128;
    public BlittableChar Char;
}

Console.WriteLine(uInt128Adress - baseAddress); // 0
Console.WriteLine(Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;)); // 0
Console.WriteLine(BlittableHelper.IsBlittable&amp;lt;MyStruct&amp;gt;()); // True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I don&#39;t recommend try to predict memory representation of your non-blittable types, it depends on big amount of different conditions. For example, the following modification of the example shows that non-blittable types can be represented in memory without field reordering:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Sequential)]
public struct UInt128
{
    public ulong Value1;
    public ulong Value2;
}
[StructLayout(LayoutKind.Sequential)]
public struct MyStruct
{
    public UInt128 UInt128;
    public char Char;
}

Console.WriteLine(uInt128Adress - baseAddress); // 0
Console.WriteLine(Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;)); // 0
Console.WriteLine(BlittableHelper.IsBlittable&amp;lt;MyStruct&amp;gt;()); // False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;nuget-github&quot;&gt;NuGet &amp;amp; GitHub&lt;/h3&gt;
&lt;p&gt;I pushed my blittable wrappers to GitHub and publish a NuGet package:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AndreyAkinshin/BlittableStructs&quot;&gt;https://github.com/AndreyAkinshin/BlittableStructs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/BlittableStructs/&quot;&gt;https://www.nuget.org/packages/BlittableStructs/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope, it will be useful for someone. If you have any good ideas about blittable wrappers, PRs are welcome.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/75dwhxf7.aspx&quot;&gt;MSDN: Blittable and Non-Blittable Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/zah6xy75.aspx&quot;&gt;MSDN: Default Marshaling Behavior&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/s9ts558h.aspx&quot;&gt;MSDN: Default Marshaling for Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7b93s42f.aspx&quot;&gt;MSDN: Specifying a Character Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/cwe8bzh0.aspx&quot;&gt;MSDN: Unicode and MBCS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/23acw07k.aspx&quot;&gt;MSDN: Copying and Pinning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/y8ewk18b.aspx&quot;&gt;MSDN: Marshal.OffsetOf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.structlayoutattribute.aspx&quot;&gt;MSDN: System.Runtime.InteropServices.StructLayoutAttribute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.layoutkind.aspx&quot;&gt;MSDN: System.Runtime.InteropServices.LayoutKind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.structlayoutattribute.charset.aspx&quot;&gt;MSDN: System.Runtime.InteropServices.StructLayoutAttribute.CharSet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Wikipedia: Globally unique identifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia: Universally unique identifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;Wikipedia: Endianness&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10574645/the-fastest-way-to-check-if-a-type-is-blittable&quot;&gt;Stackoverflow: The fastest way to check if a type is blittable?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/11416433/marshalling-non-blittable-structs-from-c-sharp-to-c&quot;&gt;Stackoverflow: Marshalling non-Blittable Structs from C# to C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/30213132/why-is-decimal-data-type-non-blittable&quot;&gt;Stackoverflow: Why is “decimal” data type non-blittable?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/15544818/non-blitable-error-on-a-blitable-type&quot;&gt;Stackoverflow: Non-blitable error on a blitable type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/17510042/using-reflection-to-determine-how-a-net-type-is-layed-out-in-memory&quot;&gt;Stackoverflow: Using reflection to determine how a .Net type is layed out in memory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5584160/are-net-enums-blittable-types-marshalling&quot;&gt;Stackoverflow: Are .net Enums blittable types? (Marshalling)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/21881554/why-does-the-system-datetime-struct-have-layout-kind-auto&quot;&gt;Stackoverflow: Why does the System.DateTime struct have layout kind Auto?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4132533/why-does-layoutkind-sequential-work-differently-if-a-struct-contains-a-datetime&quot;&gt;Stackoverflow: Why does LayoutKind.Sequential work differently if a struct contains a DateTime field?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/16333511/layoutkind-sequential-not-followed-when-substruct-has-layoutkind-explicit&quot;&gt;Stackoverflow: LayoutKind.Sequential not followed when substruct has LayoutKind.Explicit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/246930/is-there-any-difference-between-a-guid-and-a-uuid&quot;&gt;Stackoverflow: Is there any difference between a GUID and a UUID?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/vm/fieldmarshaler.cpp&quot;&gt;GitHub CoreCLR:  coreclr/src/vm/fieldmarshaler.cpp
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/guid.cs&quot;&gt;Microsoft Reference Source: GUID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/datetime.cs&quot;&gt;Microsoft Reference Source: DateTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/UUID.html&quot;&gt;Java UUID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.stephencleary.com/2010/11/few-words-on-guids.html&quot;&gt;Stephen Cleary: A Few Words on GUIDs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Blittable-типы</title>
            <link>http://aakinshin.net/ru/posts/blittable/</link> 
            <pubDate>Thu, 26 Nov 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/blittable/</guid>
            <description>&lt;p&gt;Вопрос дня: что выведет нижеприведённый код?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Explicit)]
public struct UInt128
{
    [FieldOffset(0)]
    public ulong Value1;
    [FieldOffset(8)]
    public ulong Value2;
}
[StructLayout(LayoutKind.Sequential)]
public struct MyStruct
{
    public UInt128 UInt128;
    public char Char;
}
class Program
{
    public static unsafe void Main()
    {
        var myStruct = new MyStruct();
        var baseAddress = (int)&amp;amp;myStruct;
        var uInt128Adress = (int)&amp;amp;myStruct.UInt128;
        Console.WriteLine(uInt128Adress - baseAddress);
        Console.WriteLine(Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы подумали, что в консоли напечатается два нуля (или просто два одинаковых значения), то вам нужно узнать больше про внутреннее устройство структур в .NET. Ниже представлены результаты выполнения кода в зависимости от рантайма:&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;MS.NET-x86&lt;/th&gt;&lt;th&gt;MS.NET-x64&lt;/th&gt;&lt;th&gt;Mono&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;uInt128Adress - baseAddress                  &lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;Marshal.OffsetOf(typeof(MyStruct), &quot;UInt128&quot;)&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Чтобы разобраться с ситуацией, нам необходимо узнать больше про blittable-типы.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Теория&lt;/h3&gt;
&lt;p&gt;Википедия &lt;a href=&quot;https://en.wikipedia.org/wiki/Blittable_types&quot;&gt;даёт&lt;/a&gt; следующее определение blittable-типов:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Blittable types are data types in software applications which have a unique characteristic. Data are often represented in memory differently in managed and unmanaged code in the Microsoft .NET framework. However, blittable types are defined as having an identical presentation in memory for both environments, and can be directly shared. Understanding the difference between blittable and non-blittable types can aid in using COM Interop or P/Invoke, two techniques for interoperability in .NET applications.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Другими словами, это такие типы, которые представлены одинаково в управляемой или неуправляемой памяти. Данная характеристика очень важна, если вы собираетесь маршалить ваши структуры. Согласитесь, было бы очень здорово, если бы поля структуры уже лежали бы в памяти именно в том порядке, в котором вы собираетесь их куда-то передавать. Кроме того, имеется ряд ситуаций, в которых вы можете использовать только blittable-типы. Примеры:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Типы, которые возвращаются через P/Invoke.&lt;/li&gt;
&lt;li&gt;Типы, которые вы можете сделать &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/23acw07k.aspx&quot;&gt;pinned&lt;/a&gt; (Есть оптимизация, благодаря которой при маршалинге такие типы делаются pinned, а не копируются явно).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Давайте разберёмся в этой теме подробней: какие же типы являются blittable и что на это влияет?&lt;/p&gt;
&lt;p&gt;Для понимания дальнейшего материала также полезно знать про атрибут &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.structlayoutattribute.aspx&quot;&gt; System.Runtime.InteropServices.StructLayoutAttribute&lt;/a&gt;, с помощью которого можно контролировать метод физической организации данных структуры при экспорте в неуправляемый код. С помощью параметра &lt;code&gt;LayoutKind&lt;/code&gt; можно задать &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.layoutkind.aspx&quot;&gt;один из трёх режимов&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Auto&lt;/code&gt;: Среда CLR автоматически выбирает соответствующее размещение для членов объекта в неуправляемой памяти. Доступ к объектам, определенным при помощи этого члена перечисления, не может быть предоставлен вне управляемого кода. Попытка выполнить такую операцию вызовет исключение.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Explicit&lt;/code&gt;: Точное положение каждого члена объекта в неуправляемой памяти управляется явно в соответствии с настройкой поля StructLayoutAttribute.Pack. Каждый член должен использовать атрибут FieldOffsetAttribute для указания положения этого поля внутри типа.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sequential&lt;/code&gt;: Члены объекта располагаются последовательно, в порядке своего появления при экспортировании в неуправляемую память. Члены располагаются в соответствии с компоновкой, заданной в StructLayoutAttribute.Pack, и могут быть несмежными.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Два последних значения (&lt;code&gt;Explicit&lt;/code&gt; и &lt;code&gt;Sequential&lt;/code&gt;) также называются Formatted, т.к. явно задают порядок полей. C# использует &lt;code&gt;Sequential&lt;/code&gt; в качестве значения по умолчанию.&lt;/p&gt;
&lt;h3 id=&quot;blittable-types&quot;&gt;Blittable types&lt;/h3&gt;
&lt;p&gt;Очень важно понимать, какие именно типы являются blittable. Итак, Blittable-типами являются:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Следующие примитивные типы: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.byte.aspx&quot;&gt;System.Byte&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.sbyte.aspx&quot;&gt;System.SByte&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.int16.aspx&quot;&gt;System.Int16&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uint16.aspx&quot;&gt;System.UInt16&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.int32.aspx&quot;&gt;System.Int32&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uint32.aspx&quot;&gt;System.UInt32&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.int64.aspx&quot;&gt;System.Int64&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uint64.aspx&quot;&gt;System.UInt64&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.intptr.aspx&quot;&gt;System.IntPtr&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uintptr.aspx&quot;&gt;System.UIntPtr&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.single.aspx&quot;&gt;System.Single&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.double.aspx&quot;&gt;System.Double&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Одномерные массивы blittable-типов.&lt;/li&gt;
&lt;li&gt;Formatted (Explicit или Sequential) value types, которые в качестве полей содержат исключительно blittable-структуры.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;non-blittable-types&quot;&gt;Non-Blittable Types&lt;/h3&gt;
&lt;p&gt;Есть несколько non-blittable-типов, о которых хотелось бы поговорить подробней.&lt;/p&gt;
&lt;h4 id=&quot;decimal&quot;&gt;Decimal&lt;/h4&gt;
&lt;p&gt;Да, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.decimal.aspx&quot;&gt;Decimal&lt;/a&gt; не является blittable-типом. Если вам нужно использовать его для blittable-целей, то придётся написать обёртку вида (основано на &lt;a href=&quot;http://stackoverflow.com/a/30217247/184842&quot;&gt;методе&lt;/a&gt; от Hans Passant, см. &lt;a href=&quot;http://stackoverflow.com/questions/30213132/why-is-decimal-data-type-non-blittable&quot;&gt;Why is “decimal” data type non-blittable?&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct BlittableDecimal
{
    private long longValue;

    public decimal Value
    {
        get { return decimal.FromOACurrency(longValue); }
        set { longValue = decimal.ToOACurrency(value); }
    }

    public static explicit operator BlittableDecimal(decimal value)
    {
        return new BlittableDecimal { Value = value };
    }

    public static implicit operator decimal (BlittableDecimal value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;datetime&quot;&gt;DateTime&lt;/h4&gt;
&lt;p&gt;Занимательный факт: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.datetime.aspx&quot;&gt;DateTime&lt;/a&gt; содержит единственное &lt;code&gt;UInt64&lt;/code&gt; поле, но LayoutKind &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/datetime.cs,55&quot;&gt;явно выставлен&lt;/a&gt; в &lt;code&gt;Auto&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Auto)]
[Serializable]
public struct DateTime : 
  IComparable, IFormattable, IConvertible, ISerializable, IComparable&amp;lt;DateTime&amp;gt;,IEquatable&amp;lt;DateTime&amp;gt; {
    
    // ...
                    
    // The data is stored as an unsigned 64-bit integeter
    //   Bits 01-62: The value of 100-nanosecond ticks where 0 represents 1/1/0001 12:00am, up until the value
    //               12/31/9999 23:59:59.9999999
    //   Bits 63-64: A four-state value that describes the DateTimeKind value of the date time, with a 2nd
    //               value for the rare case where the date time is local, but is in an overlapped daylight
    //               savings time hour and it is in daylight savings time. This allows distinction of these
    //               otherwise ambiguous local times and prevents data loss when round tripping from Local to
    //               UTC time.
    private UInt64 dateData;
    
    // ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Это означает, что &lt;code&gt;DateTime&lt;/code&gt; не является blittable-типом. Значит, если ваша структура содержит DateTime-поле, то она также будет non-blittable. Данный факт имеет исторические причины и вызывает массу недоумения у людей, см: &lt;a href=&quot;http://stackoverflow.com/questions/21881554/why-does-the-system-datetime-struct-have-layout-kind-auto&quot;&gt;Why does the System.DateTime struct have layout kind Auto?&lt;/a&gt;, &lt;a href=&quot;http://stackoverflow.com/questions/4132533/why-does-layoutkind-sequential-work-differently-if-a-struct-contains-a-datetime&quot;&gt;Why does LayoutKind.Sequential work differently if a struct contains a DateTime field?&lt;/a&gt; (для понимания происходящего рекомендую прочитать &lt;a href=&quot;http://stackoverflow.com/a/21883421/184842&quot;&gt;вот этот ответ&lt;/a&gt; от Hans Passant).&lt;/p&gt;
&lt;p&gt;Для DateTime можно написать blittable-обёртку:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct BlittableDateTime
{
    private long ticks;

    public DateTime Value
    {
        get { return new DateTime(ticks); }
        set { ticks = value.Ticks; }
    }

    public static explicit operator BlittableDateTime(DateTime value)
    {
        return new BlittableDateTime { Value = value };
    }

    public static implicit operator DateTime(BlittableDateTime value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;guid&quot;&gt;Guid&lt;/h4&gt;
&lt;p&gt;Вы наверняка знаете про тип &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.guid.aspx&quot;&gt;Guid&lt;/a&gt;, но знаете ли вы то, как он устроен внутри? Давайте взглянем на &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/guid.cs,30&quot;&gt;исходный код&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private int         _a;
private short       _b;
private short       _c;
private byte       _d;
private byte       _e;
private byte       _f;
private byte       _g;
private byte       _h;
private byte       _i;
private byte       _j;
private byte       _k;

// Creates a new guid from an array of bytes.
public Guid(byte[] b)
{
    // Some checks ...

    _a = ((int)b[3] &amp;lt;&amp;lt; 24) | ((int)b[2] &amp;lt;&amp;lt; 16) | ((int)b[1] &amp;lt;&amp;lt; 8) | b[0];
    _b = (short)(((int)b[5] &amp;lt;&amp;lt; 8) | b[4]);
    _c = (short)(((int)b[7] &amp;lt;&amp;lt; 8) | b[6]);
    _d = b[8];
    _e = b[9];
    _f = b[10];
    _g = b[11];
    _h = b[12];
    _i = b[13];
    _j = b[14];
    _k = b[15];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Интересненько, не правда ли? Если мы &lt;a href=&quot;https://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;почитаем википедию&lt;/a&gt;, то найдём там следующую табличку:&lt;/p&gt;
&lt;table&gt;
&lt;tr&gt;&lt;th&gt;Bits&lt;/th&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Endianness (Microsoft GUID Structure)&lt;/th&gt;&lt;th&gt;Endianness (RFC 4122)&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;Data1&lt;/td&gt;&lt;td&gt;Native&lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Data2&lt;/td&gt;&lt;td&gt;Native&lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;Data3&lt;/td&gt;&lt;td&gt;Native&lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;Data4&lt;/td&gt;&lt;td&gt;Big   &lt;/td&gt;&lt;td&gt;Big&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;GUID имеет следующий Type library representation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;typedef struct tagGUID {
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[ 8 ];
} GUID;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Важным является тот факт, что представление GUID в памяти является платформозависимым. Если вы работаете с little-endian-архитектурой (а это скорее всего так, см. &lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;Endianness&lt;/a&gt;), то представление Guid будет отличаться от RFC 4122, что может создать некоторые проблемы при взаимодействии .NET с другими системами (например, &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/UUID.html&quot;&gt;Java UUID&lt;/a&gt; использует RFC 4122).&lt;/p&gt;
&lt;h4 id=&quot;char&quot;&gt;Char&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.char.aspx&quot;&gt;Char&lt;/a&gt; также является non-blittable-типом, при маршалинге он может конвертироваться в &lt;code&gt;Unicode&lt;/code&gt; или &lt;code&gt;ANSI&lt;/code&gt; символ. За тип маршалинга отвечает &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.charset.aspx&quot;&gt;CharSet&lt;/a&gt; атрибута &lt;code&gt;StructLayout&lt;/code&gt;, который может принимать значения: &lt;code&gt;Auto&lt;/code&gt;, &lt;code&gt;Ansi&lt;/code&gt;, &lt;code&gt;Unicode&lt;/code&gt;. На современных версиях Windows &lt;code&gt;Auto&lt;/code&gt; превращается в &lt;code&gt;Unicode&lt;/code&gt;, но во времена Windows 98 и Windows Me &lt;code&gt;Auto&lt;/code&gt; превращался в &lt;code&gt;Ansi&lt;/code&gt;. C# компилятор использует значение &lt;code&gt;Ansi&lt;/code&gt; по умолчанию, что делает char не blittable-типом. Однако, мы можем написать следующую обёртку, чтобы победить проблему:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
public struct BlittableChar
{
    public char Value;

    public static explicit operator BlittableChar(char value)
    {
        return new BlittableChar { Value = value };
    }

    public static implicit operator char (BlittableChar value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;boolean&quot;&gt;Boolean&lt;/h4&gt;
&lt;p&gt;MSDN &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/75dwhxf7.aspx&quot;&gt;говорит&lt;/a&gt; нам следующую вещь про &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.boolean.aspx&quot;&gt;Boolean&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Converts to a 1, 2, or 4-byte value with true as 1 or -1.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Давайте напишем ещё одну обёртку, чтобы решить проблему:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct BlittableBoolean
{
    private byte byteValue;

    public bool Value
    {
        get { return Convert.ToBoolean(byteValue); }
        set { byteValue = Convert.ToByte(value); }
    }

    public static explicit operator BlittableBoolean(bool value)
    {
        return new BlittableBoolean { Value = value };
    }

    public static implicit operator bool (BlittableBoolean value)
    {
        return value.Value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;blittable-non-blittable&quot;&gt;Blittable или Non-Blittable?&lt;/h3&gt;
&lt;p&gt;Порой очень полезно понять, является ли наш тип Blittable. Как это сделать? Нам поможет знание о том, что мы не можем аллоцировать pinned-версию экземпляра такого типа. Для удобства мы можем написать следующий helper-класс (основано на &lt;a href=&quot;http://stackoverflow.com/a/31485271/184842&quot;&gt;методе IllidanS4&lt;/a&gt;, см. &lt;a href=&quot;http://stackoverflow.com/questions/10574645/the-fastest-way-to-check-if-a-type-is-blittable&quot;&gt;The fastest way to check if a type is blittable?&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static class BlittableHelper
{
    public static bool IsBlittable&amp;lt;T&amp;gt;()
    {
        return IsBlittableCache&amp;lt;T&amp;gt;.Value;
    }

    public static bool IsBlittable(this Type type)
    {
        if (type.IsArray)
        {
            var elem = type.GetElementType();
            return elem.IsValueType &amp;amp;&amp;amp; IsBlittable(elem);
        }
        try
        {
            object instance = FormatterServices.GetUninitializedObject(type);
            GCHandle.Alloc(instance, GCHandleType.Pinned).Free();
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static class IsBlittableCache&amp;lt;T&amp;gt;
    {
        public static readonly bool Value = IsBlittable(typeof(T));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но есть один особый тип, для которого приведённый helper будет работать неправильно: decimal. Удивительно, но вы можете сделать pinned alloc для decimal-а! Впрочем, pinned alloc для структуры, которая содержит decimal, работать не будет, т.к. decimal всё-таки не является blittable-типом. Я не знаю других типов, с которыми возникает подобная проблема, поэтому можно позволить себе немного похакать и добавить в начало метода &lt;code&gt;IsBlittable&lt;/code&gt; вот такие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (type == typeof(decimal))
    return false;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы знаете более элегантное решение, то буду рад комментариям.&lt;/p&gt;
&lt;h3 id=&quot;coreclr&quot;&gt;CoreCLR-исходники&lt;/h3&gt;
&lt;p&gt;CoreCLR нынче имеет открытый исходный код, так что можно посмотреть, как же там всё устроено внутри. Сегодня нас больше всего будет интересовать файл &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/vm/fieldmarshaler.cpp#L283-L318&quot;&gt;fieldmarshaler.cpp&lt;/a&gt;, там можно найти следующие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;if (!(*pfDisqualifyFromManagedSequential))
{
    // This type may qualify for ManagedSequential. Collect managed size and alignment info.
    if (CorTypeInfo::IsPrimitiveType(corElemType))
    {
        pfwalk-&amp;gt;m_managedSize = ((UINT32)CorTypeInfo::Size(corElemType)); // Safe cast - no primitive type is larger than 4gb!
        pfwalk-&amp;gt;m_managedAlignmentReq = pfwalk-&amp;gt;m_managedSize;
    }
    else if (corElemType == ELEMENT_TYPE_PTR)
    {
        pfwalk-&amp;gt;m_managedSize = sizeof(LPVOID);
        pfwalk-&amp;gt;m_managedAlignmentReq = sizeof(LPVOID);
    }
    else if (corElemType == ELEMENT_TYPE_VALUETYPE)
    {
        TypeHandle pNestedType = fsig.GetLastTypeHandleThrowing(ClassLoader::LoadTypes,
                                                                CLASS_LOAD_APPROXPARENTS,
                                                                TRUE);
        if (pNestedType.GetMethodTable()-&amp;gt;IsManagedSequential())
        {
            pfwalk-&amp;gt;m_managedSize = (pNestedType.GetMethodTable()-&amp;gt;GetNumInstanceFieldBytes());

            _ASSERTE(pNestedType.GetMethodTable()-&amp;gt;HasLayout()); // If it is ManagedSequential(), it also has Layout but doesn&#39;t hurt to check before we do a cast!
            pfwalk-&amp;gt;m_managedAlignmentReq = pNestedType.GetMethodTable()-&amp;gt;GetLayoutInfo()-&amp;gt;m_ManagedLargestAlignmentRequirementOfAllMembers;
        }
        else
        {
            *pfDisqualifyFromManagedSequential = TRUE;
        }
    }
    else
    {
        // No other type permitted for ManagedSequential.
        *pfDisqualifyFromManagedSequential = TRUE;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Разбор примера&lt;/h3&gt;
&lt;p&gt;Давайте вернёмся к примеру из начала поста. Теперь понятно, почему под MS.NET мы можем наблюдать разницу. &lt;code&gt;Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;)&lt;/code&gt; выдаёт нам &#171;честный&#187; offset, который получается при маршалинге, он равен &lt;code&gt;0&lt;/code&gt;. А вот про внутреннее устройство структуры никаких гарантий CLR не даёт, ведь наша структура не является blittable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(BlittableHelper.IsBlittable&amp;lt;MyStruct&amp;gt;()); // False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но теперь мы знаем, как исправить ситуацию и сделать код более предсказуемым: заменим &lt;code&gt;char&lt;/code&gt; на нашу обёртку &lt;code&gt;blittableChar&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Sequential)]
public struct MyStruct
{
    public UInt128 UInt128;
    public BlittableChar Char;
}

Console.WriteLine(uInt128Adress - baseAddress); // 0
Console.WriteLine(Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;)); // 0
Console.WriteLine(BlittableHelper.IsBlittable&amp;lt;MyStruct&amp;gt;()); // True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Не советую закладываться на то, что вы можете предсказать устройство non-blittable-типов в памяти, оно зависит от многих факторов. Следующая модификация примера показывает, что non-blittable-типы также могут быть представлены в памяти без переставления полей:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[StructLayout(LayoutKind.Sequential)]
public struct UInt128
{
    public ulong Value1;
    public ulong Value2;
}
[StructLayout(LayoutKind.Sequential)]
public struct MyStruct
{
    public UInt128 UInt128;
    public char Char;
}

Console.WriteLine(uInt128Adress - baseAddress); // 0
Console.WriteLine(Marshal.OffsetOf(typeof(MyStruct), &amp;quot;UInt128&amp;quot;)); // 0
Console.WriteLine(BlittableHelper.IsBlittable&amp;lt;MyStruct&amp;gt;()); // False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;nuget-github&quot;&gt;NuGet &amp;amp; GitHub&lt;/h3&gt;
&lt;p&gt;Приведённые в посте обёртки я выложил на GitHub и оформил в виде NuGet-пакета:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AndreyAkinshin/BlittableStructs&quot;&gt;https://github.com/AndreyAkinshin/BlittableStructs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.nuget.org/packages/BlittableStructs/&quot;&gt;https://www.nuget.org/packages/BlittableStructs/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Надеюсь, кому-нибудь это будет полезно. Если у вас есть что добавить, то пул-реквесты приветствуются.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/75dwhxf7.aspx&quot;&gt;MSDN: Blittable and Non-Blittable Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/zah6xy75.aspx&quot;&gt;MSDN: Default Marshaling Behavior&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/s9ts558h.aspx&quot;&gt;MSDN: Default Marshaling for Strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7b93s42f.aspx&quot;&gt;MSDN: Specifying a Character Set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/cwe8bzh0.aspx&quot;&gt;MSDN: Unicode and MBCS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/23acw07k.aspx&quot;&gt;MSDN: Copying and Pinning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/y8ewk18b.aspx&quot;&gt;MSDN: Marshal.OffsetOf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.structlayoutattribute.aspx&quot;&gt;MSDN: System.Runtime.InteropServices.StructLayoutAttribute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.layoutkind.aspx&quot;&gt;MSDN: System.Runtime.InteropServices.LayoutKind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.runtime.interopservices.structlayoutattribute.charset.aspx&quot;&gt;MSDN: System.Runtime.InteropServices.StructLayoutAttribute.CharSet&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Globally_unique_identifier&quot;&gt;Wikipedia: Globally unique identifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Universally_unique_identifier&quot;&gt;Wikipedia: Universally unique identifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Endianness&quot;&gt;Wikipedia: Endianness&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10574645/the-fastest-way-to-check-if-a-type-is-blittable&quot;&gt;Stackoverflow: The fastest way to check if a type is blittable?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/11416433/marshalling-non-blittable-structs-from-c-sharp-to-c&quot;&gt;Stackoverflow: Marshalling non-Blittable Structs from C# to C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/30213132/why-is-decimal-data-type-non-blittable&quot;&gt;Stackoverflow: Why is “decimal” data type non-blittable?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/15544818/non-blitable-error-on-a-blitable-type&quot;&gt;Stackoverflow: Non-blitable error on a blitable type&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/17510042/using-reflection-to-determine-how-a-net-type-is-layed-out-in-memory&quot;&gt;Stackoverflow: Using reflection to determine how a .Net type is layed out in memory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5584160/are-net-enums-blittable-types-marshalling&quot;&gt;Stackoverflow: Are .net Enums blittable types? (Marshalling)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/21881554/why-does-the-system-datetime-struct-have-layout-kind-auto&quot;&gt;Stackoverflow: Why does the System.DateTime struct have layout kind Auto?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/4132533/why-does-layoutkind-sequential-work-differently-if-a-struct-contains-a-datetime&quot;&gt;Stackoverflow: Why does LayoutKind.Sequential work differently if a struct contains a DateTime field?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/16333511/layoutkind-sequential-not-followed-when-substruct-has-layoutkind-explicit&quot;&gt;Stackoverflow: LayoutKind.Sequential not followed when substruct has LayoutKind.Explicit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/246930/is-there-any-difference-between-a-guid-and-a-uuid&quot;&gt;Stackoverflow: Is there any difference between a GUID and a UUID?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/vm/fieldmarshaler.cpp&quot;&gt;GitHub CoreCLR:  coreclr/src/vm/fieldmarshaler.cpp
&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/guid.cs&quot;&gt;Microsoft Reference Source: GUID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/datetime.cs&quot;&gt;Microsoft Reference Source: DateTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/UUID.html&quot;&gt;Java UUID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.stephencleary.com/2010/11/few-words-on-guids.html&quot;&gt;Stephen Cleary: A Few Words on GUIDs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>RyuJIT RC and constant folding</title>
            <link>http://aakinshin.net/posts/ryujit-rc-and-constant-folding/</link> 
            <pubDate>Tue, 12 May 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/ryujit-rc-and-constant-folding/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; The below results are valid for the release version of RyuJIT in .NET Framework 4.6 without updates.&lt;/p&gt;
&lt;p&gt;The challenge of the day: which method is faster?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public double Sqrt13()
{
    return Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
           Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
           Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13);
}
public double Sqrt14()
{
    return Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
           Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
           Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13) + Math.Sqrt(14);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have measured the methods performance with help of &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; for RyuJIT RC (a part of .NET Framework 4.6 RC) and received the following results:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// BenchmarkDotNet=v0.7.4.0
// OS=Microsoft Windows NT 6.2.9200.0
// Processor=Intel(R) Core(TM) i7-4702MQ CPU ＠ 2.20GHz, ProcessorCount=8
// CLR=MS.NET 4.0.30319.0, Arch=64-bit  [RyuJIT]
Common:  Type=Math_DoubleSqrtAvx  Mode=Throughput  Platform=X64  Jit=RyuJit  .NET=Current  

 Method |  AvrTime |    StdDev |         op/s |
------- |--------- |---------- |------------- |
 Sqrt13 | 55.40 ns |  0.571 ns |  18050993.06 |
 Sqrt14 |  1.43 ns | 0.0224 ns | 697125029.18 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How so? If I add one more &lt;code&gt;Math.Sqrt&lt;/code&gt; to the expression, the method starts work 40 times faster! Let&#39;s examine the situation..&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;First of all, open in VisualStudio generated ASM code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Sqrt13
vsqrtsd     xmm0,xmm0,mmword ptr [7FF94F9E4D28h]  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D30h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D38h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D40h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D48h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D50h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D58h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D60h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D68h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D70h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D78h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D80h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D88h]  
vaddsd      xmm0,xmm0,xmm1  
ret

; Sqrt14
vmovsd      xmm0,qword ptr [7FF94F9C4C80h]  
ret    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How so? It seems that an expression with 13 of &lt;code&gt;Math.Sqrt&lt;/code&gt; calculates honestly and an expression with 14 of &lt;code&gt;Math.Sqrt&lt;/code&gt; uses constant folding for result precalculation.&lt;/p&gt;
&lt;p&gt;Next, let&#39;s build own version of CoreCLR. I will work with the actual version for today (&lt;a href=&quot;https://github.com/dotnet/coreclr/commit/0e6021bb96eaee9ac94e5f0095cbe4e846cdb6af&quot;&gt;0e6021bb&lt;/a&gt;).
&lt;code&gt;COMPLUS_JitDisasm&lt;/code&gt; can help us to print generated ASM code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Sqrt13
sqrtsd   xmm0, qword ptr [＠RWD00]
sqrtsd   xmm1, qword ptr [＠RWD08]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD16]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD24]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD32]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD40]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD48]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD56]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD64]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD72]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD80]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD88]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD96]
addsd    xmm0, xmm1
ret

; Sqrt14
movsd    xmm0, qword ptr [＠RWD00]
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that CoreCLR uses the &lt;code&gt;sqrtsd&lt;/code&gt; instruction (SSE2) instead of &lt;code&gt;vsqrtsd&lt;/code&gt; (AVX). It is not important for now. We can create an issue on GitHib (&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/977&quot;&gt;coreclr/issues/977&lt;/a&gt;) and continue (now there is a fix for the problem: &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/981&quot;&gt;coreclr/pull/981&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Now let&#39;s enable &lt;code&gt;COMPLUS_JitDump&lt;/code&gt; and print the full dump. We can see that RyuJIT build the following tree for &lt;code&gt;Sqrt13&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*  stmtExpr  void  (top level) (IL 0x000...  ???)
|     /--*  mathFN    double sqrt
|     |  \--*  dconst    double 13.000000000000000
|  /--*  +         double
|  |  |  /--*  mathFN    double sqrt
|  |  |  |  \--*  dconst    double 12.000000000000000
|  |  \--*  +         double
|  |     |  /--*  mathFN    double sqrt
|  |     |  |  \--*  dconst    double 11.000000000000000
|  |     \--*  +         double
|  |        |  /--*  mathFN    double sqrt
|  |        |  |  \--*  dconst    double 10.000000000000000
|  |        \--*  +         double
|  |           |  /--*  mathFN    double sqrt
|  |           |  |  \--*  dconst    double 9.0000000000000000
|  |           \--*  +         double
|  |              |  /--*  mathFN    double sqrt
|  |              |  |  \--*  dconst    double 8.0000000000000000
|  |              \--*  +         double
|  |                 |  /--*  mathFN    double sqrt
|  |                 |  |  \--*  dconst    double 7.0000000000000000
|  |                 \--*  +         double
|  |                    |  /--*  mathFN    double sqrt
|  |                    |  |  \--*  dconst    double 6.0000000000000000
|  |                    \--*  +         double
|  |                       |  /--*  mathFN    double sqrt
|  |                       |  |  \--*  dconst    double 5.0000000000000000
|  |                       \--*  +         double
|  |                          |  /--*  mathFN    double sqrt
|  |                          |  |  \--*  dconst    double 4.0000000000000000
|  |                          \--*  +         double
|  |                             |  /--*  mathFN    double sqrt
|  |                             |  |  \--*  dconst    double 3.0000000000000000
|  |                             \--*  +         double
|  |                                |  /--*  mathFN    double sqrt
|  |                                |  |  \--*  dconst    double 2.0000000000000000
|  |                                \--*  +         double
|  |                                   \--*  mathFN    double sqrt
|  |                                      \--*  dconst    double 1.0000000000000000
\--*  =         double
   \--*  lclVar    double V01 tmp0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RyuJIT marks the expression in &lt;code&gt;Sqrt13&lt;/code&gt; as not too big and don&#39;t apply any optimization in this case. However, RyuJIT mark the expression in &lt;code&gt;Sqrt14&lt;/code&gt; as too big, save in a temp variable, and apply &lt;a href=&quot;http://en.wikipedia.org/wiki/Constant_folding&quot;&gt;constant folding&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;N001 [000001]   dconst    1.0000000000000000 =&amp;gt; $c0 {DblCns[1.000000]}
N002 [000002]   mathFN    =&amp;gt; $c0 {DblCns[1.000000]}
N003 [000003]   dconst    2.0000000000000000 =&amp;gt; $c1 {DblCns[2.000000]}
N004 [000004]   mathFN    =&amp;gt; $c2 {DblCns[1.414214]}
N005 [000005]   +         =&amp;gt; $c3 {DblCns[2.414214]}
N006 [000006]   dconst    3.0000000000000000 =&amp;gt; $c4 {DblCns[3.000000]}
N007 [000007]   mathFN    =&amp;gt; $c5 {DblCns[1.732051]}
N008 [000008]   +         =&amp;gt; $c6 {DblCns[4.146264]}
N009 [000009]   dconst    4.0000000000000000 =&amp;gt; $c7 {DblCns[4.000000]}
N010 [000010]   mathFN    =&amp;gt; $c1 {DblCns[2.000000]}
N011 [000011]   +         =&amp;gt; $c8 {DblCns[6.146264]}
N012 [000012]   dconst    5.0000000000000000 =&amp;gt; $c9 {DblCns[5.000000]}
N013 [000013]   mathFN    =&amp;gt; $ca {DblCns[2.236068]}
N014 [000014]   +         =&amp;gt; $cb {DblCns[8.382332]}
N015 [000015]   dconst    6.0000000000000000 =&amp;gt; $cc {DblCns[6.000000]}
N016 [000016]   mathFN    =&amp;gt; $cd {DblCns[2.449490]}
N017 [000017]   +         =&amp;gt; $ce {DblCns[10.831822]}
N018 [000018]   dconst    7.0000000000000000 =&amp;gt; $cf {DblCns[7.000000]}
N019 [000019]   mathFN    =&amp;gt; $d0 {DblCns[2.645751]}
N020 [000020]   +         =&amp;gt; $d1 {DblCns[13.477573]}
N021 [000021]   dconst    8.0000000000000000 =&amp;gt; $d2 {DblCns[8.000000]}
N022 [000022]   mathFN    =&amp;gt; $d3 {DblCns[2.828427]}
N023 [000023]   +         =&amp;gt; $d4 {DblCns[16.306001]}
N024 [000024]   dconst    9.0000000000000000 =&amp;gt; $d5 {DblCns[9.000000]}
N025 [000025]   mathFN    =&amp;gt; $c4 {DblCns[3.000000]}
N026 [000026]   +         =&amp;gt; $d6 {DblCns[19.306001]}
N027 [000027]   dconst    10.000000000000000 =&amp;gt; $d7 {DblCns[10.000000]}
N028 [000028]   mathFN    =&amp;gt; $d8 {DblCns[3.162278]}
N029 [000029]   +         =&amp;gt; $d9 {DblCns[22.468278]}
N030 [000030]   dconst    11.000000000000000 =&amp;gt; $da {DblCns[11.000000]}
N031 [000031]   mathFN    =&amp;gt; $db {DblCns[3.316625]}
N032 [000032]   +         =&amp;gt; $dc {DblCns[25.784903]}
N033 [000033]   dconst    12.000000000000000 =&amp;gt; $dd {DblCns[12.000000]}
N034 [000034]   mathFN    =&amp;gt; $de {DblCns[3.464102]}
N035 [000035]   +         =&amp;gt; $df {DblCns[29.249005]}
N036 [000036]   dconst    13.000000000000000 =&amp;gt; $e0 {DblCns[13.000000]}
N037 [000037]   mathFN    =&amp;gt; $e1 {DblCns[3.605551]}
N038 [000038]   +         =&amp;gt; $e2 {DblCns[32.854556]}
N039 [000041]   lclVar    V01 tmp0         d:2 =&amp;gt; $e2 {DblCns[32.854556]}
N040 [000042]   =         =&amp;gt; $e2 {DblCns[32.854556]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is very strange situation. I want to see RyuJIT could apply such optimization even for small expression. So, go to GitHub and create another issue: &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/978&quot;&gt;coreclr/issues/978&lt;/a&gt;. We can learn some new fact from the discussion: if we manually save the result of expression in a temp variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static double Sqrt13B()
{
    double res = Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
                 Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
                 Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13);
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then RyuJIT applies constant folding, the expression will be precalculated. As a result of the discussion, it was decided: RyuJIT shouldn&#39;t behave like this. So, another ticked was created: &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/987&quot;&gt;coreclr/issues/987&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/977&quot;&gt;coreclr/issues/977&lt;/a&gt;: How to run CoreCLR with the AVX support?&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/978&quot;&gt;coreclr/issues/978&lt;/a&gt;: Is it possible to make &amp;quot;force optimization mode&amp;quot; for RyuJIT?&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/981&quot;&gt;coreclr/pull/981&lt;/a&gt;: Enable FEATURE_SIMD and FEATURE_AVX_SUPPORT in the JIT&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/987&quot;&gt;coreclr/issues/987&lt;/a&gt;: JIT optimization - Perform additional constant propagation for expressions&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>RyuJIT RC и свёртка констант</title>
            <link>http://aakinshin.net/ru/posts/ryujit-rc-and-constant-folding/</link> 
            <pubDate>Tue, 12 May 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/ryujit-rc-and-constant-folding/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; Нижеприведённый материал справедлив для релизной версии RyuJIT (часть .NET Framework 4.6).&lt;/p&gt;
&lt;p&gt;Задачка дня: какой из методов быстрее?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public double Sqrt13()
{
    return Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
           Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
           Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13);
}
public double Sqrt14()
{
    return Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
           Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
           Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13) + Math.Sqrt(14);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Я померил скорость работы с помощью &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; для RyuJIT RC (часть .NET Framework 4.6 RC) получил следующие результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// BenchmarkDotNet=v0.7.4.0
// OS=Microsoft Windows NT 6.2.9200.0
// Processor=Intel(R) Core(TM) i7-4702MQ CPU ＠ 2.20GHz, ProcessorCount=8
// CLR=MS.NET 4.0.30319.0, Arch=64-bit  [RyuJIT]
Common:  Type=Math_DoubleSqrtAvx  Mode=Throughput  Platform=X64  Jit=RyuJit  .NET=Current  

 Method |  AvrTime |    StdDev |         op/s |
------- |--------- |---------- |------------- |
 Sqrt13 | 55.40 ns |  0.571 ns |  18050993.06 |
 Sqrt14 |  1.43 ns | 0.0224 ns | 697125029.18 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как же так? Добавление в выражение одно дополнительного &lt;code&gt;Math.Sqrt&lt;/code&gt; ускорило метод в 40 раз! Давайте разберёмся.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Прежде всего посмотрим на генерируемый ASM-код, который любезно предоставляет нам VisualStudio:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Sqrt13
vsqrtsd     xmm0,xmm0,mmword ptr [7FF94F9E4D28h]  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D30h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D38h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D40h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D48h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D50h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D58h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D60h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D68h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D70h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D78h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D80h]  
vaddsd      xmm0,xmm0,xmm1  
vsqrtsd     xmm1,xmm0,mmword ptr [7FF94F9E4D88h]  
vaddsd      xmm0,xmm0,xmm1  
ret

; Sqrt14
vmovsd      xmm0,qword ptr [7FF94F9C4C80h]  
ret    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот это поворот! Выглядит всё так, что если в выражении присутствуют 13 квадратных корней, то они честно считаются каждый раз, а если 14, то применяется свёртка констант и всё выражение превращается в подгрузку предподсчитанного значения. Продолжим разбираться в ситуации.&lt;/p&gt;
&lt;p&gt;Соберём собственную версию CoreCLR. Я буду работать с актуальной на данный момент &lt;a href=&quot;https://github.com/dotnet/coreclr/commit/0e6021bb96eaee9ac94e5f0095cbe4e846cdb6af&quot;&gt;0e6021bb&lt;/a&gt;. Воспользуемся силой &lt;code&gt;COMPLUS_JitDisasm&lt;/code&gt;, чтобы посмотреть генерируемый ASM-код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-nasm&quot;&gt;; Sqrt13
sqrtsd   xmm0, qword ptr [＠RWD00]
sqrtsd   xmm1, qword ptr [＠RWD08]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD16]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD24]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD32]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD40]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD48]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD56]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD64]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD72]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD80]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD88]
addsd    xmm0, xmm1
sqrtsd   xmm1, qword ptr [＠RWD96]
addsd    xmm0, xmm1
ret

; Sqrt14
movsd    xmm0, qword ptr [＠RWD00]
ret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сразу бросается в глаза, что место AVX-инструкции &lt;code&gt;vsqrtsd&lt;/code&gt; для квадратного корня используется SSE2-инструкция &lt;code&gt;sqrtsd&lt;/code&gt;. Для нас это сейчас не принципиально, поэтому жалуемся о проблеме на GitHub (&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/977&quot;&gt;coreclr/issues/977&lt;/a&gt;) и идём дальше (исправление проблемы уже готово: &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/981&quot;&gt;coreclr/pull/981&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Теперь включим &lt;code&gt;COMPLUS_JitDump&lt;/code&gt; и посмотрим на полный дамп. Увидим, что для первых 13-ти квадратных корней строится дерево следующего вида:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*  stmtExpr  void  (top level) (IL 0x000...  ???)
|     /--*  mathFN    double sqrt
|     |  \--*  dconst    double 13.000000000000000
|  /--*  +         double
|  |  |  /--*  mathFN    double sqrt
|  |  |  |  \--*  dconst    double 12.000000000000000
|  |  \--*  +         double
|  |     |  /--*  mathFN    double sqrt
|  |     |  |  \--*  dconst    double 11.000000000000000
|  |     \--*  +         double
|  |        |  /--*  mathFN    double sqrt
|  |        |  |  \--*  dconst    double 10.000000000000000
|  |        \--*  +         double
|  |           |  /--*  mathFN    double sqrt
|  |           |  |  \--*  dconst    double 9.0000000000000000
|  |           \--*  +         double
|  |              |  /--*  mathFN    double sqrt
|  |              |  |  \--*  dconst    double 8.0000000000000000
|  |              \--*  +         double
|  |                 |  /--*  mathFN    double sqrt
|  |                 |  |  \--*  dconst    double 7.0000000000000000
|  |                 \--*  +         double
|  |                    |  /--*  mathFN    double sqrt
|  |                    |  |  \--*  dconst    double 6.0000000000000000
|  |                    \--*  +         double
|  |                       |  /--*  mathFN    double sqrt
|  |                       |  |  \--*  dconst    double 5.0000000000000000
|  |                       \--*  +         double
|  |                          |  /--*  mathFN    double sqrt
|  |                          |  |  \--*  dconst    double 4.0000000000000000
|  |                          \--*  +         double
|  |                             |  /--*  mathFN    double sqrt
|  |                             |  |  \--*  dconst    double 3.0000000000000000
|  |                             \--*  +         double
|  |                                |  /--*  mathFN    double sqrt
|  |                                |  |  \--*  dconst    double 2.0000000000000000
|  |                                \--*  +         double
|  |                                   \--*  mathFN    double sqrt
|  |                                      \--*  dconst    double 1.0000000000000000
\--*  =         double
   \--*  lclVar    double V01 tmp0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для &lt;code&gt;Sqrt13&lt;/code&gt; выражение считается не очень большим, никакие оптимизации к нему не применяются. Начиная с &lt;code&gt;Sqrt14&lt;/code&gt; выражение считается слишком большим, оно сохраняется во временную переменную, к вычислению которой применяется &lt;a href=&quot;http://en.wikipedia.org/wiki/Constant_folding&quot;&gt;свёртка констант&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;N001 [000001]   dconst    1.0000000000000000 =&amp;gt; $c0 {DblCns[1.000000]}
N002 [000002]   mathFN    =&amp;gt; $c0 {DblCns[1.000000]}
N003 [000003]   dconst    2.0000000000000000 =&amp;gt; $c1 {DblCns[2.000000]}
N004 [000004]   mathFN    =&amp;gt; $c2 {DblCns[1.414214]}
N005 [000005]   +         =&amp;gt; $c3 {DblCns[2.414214]}
N006 [000006]   dconst    3.0000000000000000 =&amp;gt; $c4 {DblCns[3.000000]}
N007 [000007]   mathFN    =&amp;gt; $c5 {DblCns[1.732051]}
N008 [000008]   +         =&amp;gt; $c6 {DblCns[4.146264]}
N009 [000009]   dconst    4.0000000000000000 =&amp;gt; $c7 {DblCns[4.000000]}
N010 [000010]   mathFN    =&amp;gt; $c1 {DblCns[2.000000]}
N011 [000011]   +         =&amp;gt; $c8 {DblCns[6.146264]}
N012 [000012]   dconst    5.0000000000000000 =&amp;gt; $c9 {DblCns[5.000000]}
N013 [000013]   mathFN    =&amp;gt; $ca {DblCns[2.236068]}
N014 [000014]   +         =&amp;gt; $cb {DblCns[8.382332]}
N015 [000015]   dconst    6.0000000000000000 =&amp;gt; $cc {DblCns[6.000000]}
N016 [000016]   mathFN    =&amp;gt; $cd {DblCns[2.449490]}
N017 [000017]   +         =&amp;gt; $ce {DblCns[10.831822]}
N018 [000018]   dconst    7.0000000000000000 =&amp;gt; $cf {DblCns[7.000000]}
N019 [000019]   mathFN    =&amp;gt; $d0 {DblCns[2.645751]}
N020 [000020]   +         =&amp;gt; $d1 {DblCns[13.477573]}
N021 [000021]   dconst    8.0000000000000000 =&amp;gt; $d2 {DblCns[8.000000]}
N022 [000022]   mathFN    =&amp;gt; $d3 {DblCns[2.828427]}
N023 [000023]   +         =&amp;gt; $d4 {DblCns[16.306001]}
N024 [000024]   dconst    9.0000000000000000 =&amp;gt; $d5 {DblCns[9.000000]}
N025 [000025]   mathFN    =&amp;gt; $c4 {DblCns[3.000000]}
N026 [000026]   +         =&amp;gt; $d6 {DblCns[19.306001]}
N027 [000027]   dconst    10.000000000000000 =&amp;gt; $d7 {DblCns[10.000000]}
N028 [000028]   mathFN    =&amp;gt; $d8 {DblCns[3.162278]}
N029 [000029]   +         =&amp;gt; $d9 {DblCns[22.468278]}
N030 [000030]   dconst    11.000000000000000 =&amp;gt; $da {DblCns[11.000000]}
N031 [000031]   mathFN    =&amp;gt; $db {DblCns[3.316625]}
N032 [000032]   +         =&amp;gt; $dc {DblCns[25.784903]}
N033 [000033]   dconst    12.000000000000000 =&amp;gt; $dd {DblCns[12.000000]}
N034 [000034]   mathFN    =&amp;gt; $de {DblCns[3.464102]}
N035 [000035]   +         =&amp;gt; $df {DblCns[29.249005]}
N036 [000036]   dconst    13.000000000000000 =&amp;gt; $e0 {DblCns[13.000000]}
N037 [000037]   mathFN    =&amp;gt; $e1 {DblCns[3.605551]}
N038 [000038]   +         =&amp;gt; $e2 {DblCns[32.854556]}
N039 [000041]   lclVar    V01 tmp0         d:2 =&amp;gt; $e2 {DblCns[32.854556]}
N040 [000042]   =         =&amp;gt; $e2 {DblCns[32.854556]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ситуация очень странная, не должно так быть. Хочется, чтобы к небольшим выражением также можно было применить волшебные оптимизации. Поэтому идём на GitHub и заводим ещё один тикет: &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/978&quot;&gt;coreclr/issues/978&lt;/a&gt;. Из общения с разработчиками узнаём дополнительные подробности: если наше сложное выражение запихать руками во временную переменную&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static double Sqrt13B()
{
    double res = Math.Sqrt(1) + Math.Sqrt(2) + Math.Sqrt(3) + Math.Sqrt(4) + Math.Sqrt(5) + 
                 Math.Sqrt(6) + Math.Sqrt(7) + Math.Sqrt(8) + Math.Sqrt(9) + Math.Sqrt(10) + 
                 Math.Sqrt(11) + Math.Sqrt(12) + Math.Sqrt(13);
    return res;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;то свёртка констант также сработает, выражение будет предподсчитано. Обсуждение привело к тому, что RyuJIT не должен так делать. Поэтому появился ещё один тикет по исправлению данной проблемы: &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/987&quot;&gt;coreclr/issues/987&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/977&quot;&gt;coreclr/issues/977&lt;/a&gt;: How to run CoreCLR with the AVX support?&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/978&quot;&gt;coreclr/issues/978&lt;/a&gt;: Is it possible to make &amp;quot;force optimization mode&amp;quot; for RyuJIT?&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/981&quot;&gt;coreclr/pull/981&lt;/a&gt;: Enable FEATURE_SIMD and FEATURE_AVX_SUPPORT in the JIT&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/issues/987&quot;&gt;coreclr/issues/987&lt;/a&gt;: JIT optimization - Perform additional constant propagation for expressions&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Unrolling of small loops in different JIT versions</title>
            <link>http://aakinshin.net/posts/unrolling-of-small-loops-in-different-jit-versions/</link> 
            <pubDate>Mon, 02 Mar 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/unrolling-of-small-loops-in-different-jit-versions/</guid>
            <description>&lt;p&gt;Challenge of the day: what will the following code display?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;struct Point
{
    public int X;
    public int Y;
}
static void Print(Point p)
{
    Console.WriteLine(p.X + &amp;quot; &amp;quot; + p.Y);
}
static void Main()
{
    var p = new Point();
    for (p.X = 0; p.X &amp;lt; 2; p.X++)
        Print(p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The right answer: it depends. There is a bug in CLR2 JIT-x86 which spoil this wonderful program. This story is about optimization that called unrolling of small loops. This is a very interesting theme, let&#39;s discuss it in detail.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;experiment-1-sum&quot;&gt;Experiment 1 (Sum)&lt;/h3&gt;
&lt;p&gt;In the &lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/ryujit-ctp5-and-loop-unrolling/&quot;&gt;previous post&lt;/a&gt;, I told how loop unrolling works. There is a special case of this optimization: unrolling of small loops: if you have small amount of iterations, JIT can completely eliminate the loop by repeating its body several times. Let&#39;s discuss it with the following simple code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int sum = 0;
for (int i = 0; i &amp;lt; 4; i++)
    sum += i;
Console.WriteLine(sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;jit-x86&quot;&gt;JIT-x86&lt;/h4&gt;
&lt;p&gt;Let&#39;s run the code with CLR4 + JIT-x86:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                           
0125291A  in          al,dx                    
0125291B  push        esi                      
0125291C  xor         esi,esi                  
            sum += i;                          
0125291E  inc         esi                      ; sum += 1
0125291F  inc         esi                      ; sum += 2 (Part 1)
01252920  inc         esi                      ; sum += 2 (Part 2)
01252921  add         esi,3                    ; sum += 3
        Console.WriteLine(sum);                
01252924  call        72EE0258                 
01252929  mov         ecx,eax                  
0125292B  mov         edx,esi                  
0125292D  mov         eax,dword ptr [ecx]      
0125292F  mov         eax,dword ptr [eax+38h]  
01252932  call        dword ptr [eax+14h]      
01252935  pop         esi                      
01252936  pop         ebp                      
01252937  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, there are no branches in the program, the loop was completely eliminate. Instead of the loop, we have special instructions that calculate a value of the &lt;code&gt;sum&lt;/code&gt; variable in the &lt;code&gt;esi&lt;/code&gt; register.&lt;/p&gt;
&lt;h4 id=&quot;jit-x64&quot;&gt;JIT-x64&lt;/h4&gt;
&lt;p&gt;Next, CLR4 + JIT-x64:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                            
00007FFCC86F3EC0  sub         rsp,28h           
        Console.WriteLine(sum);                 
00007FFCC86F3EC4  mov         ecx,6             ; sum = 6
00007FFCC86F3EC9  call        00007FFD273DCF10  
00007FFCC86F3ECE  nop                           
00007FFCC86F3ECF  add         rsp,28h           
00007FFCC86F3ED3  ret                           
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JIT-x64 have done wonderful job:: he guessed that &lt;code&gt;0+1+2+3=6&lt;/code&gt;. As a result, &lt;code&gt;6&lt;/code&gt; displays without any arithmetic operations for its calculation.&lt;/p&gt;
&lt;h4 id=&quot;ryujit-ctp5&quot;&gt;RyuJIT CTP5&lt;/h4&gt;
&lt;p&gt;Next, CLR4 + RyuJIT CTP5:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;
00007FFCC8713A02  sub         esp,20h  
00007FFCC8713A05  xor         esi,esi  
        for (int i = 0; i &amp;lt; 4; i++)
00007FFCC8713A07  xor         eax,eax  
            sum += i;
00007FFCC8713A09  add         esi,eax  
        for (int i = 0; i &amp;lt; 4; i++)
00007FFCC8713A0B  inc         eax  
00007FFCC8713A0D  cmp         eax,4  
00007FFCC8713A10  jl          00007FFCC8713A09  
        Console.WriteLine(sum);
00007FFCC8713A12  call        00007FFD26C0AFA0  
00007FFCC8713A17  mov         rcx,rax  
00007FFCC8713A1A  mov         edx,esi  
00007FFCC8713A1C  mov         rax,qword ptr [rax]  
00007FFCC8713A1F  mov         rax,qword ptr [rax+60h]  
00007FFCC8713A23  call        qword ptr [rax+28h]  
00007FFCC8713A26  nop  
00007FFCC8713A27  add         rsp,20h  
00007FFCC8713A2B  pop         rsi  
00007FFCC8713A2C  ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hey, RyuJIT, what is wrong with you? The optimization looks very simple, but you did not it! Well, we hope that you will learn it in the final release.&lt;/p&gt;
&lt;h3 id=&quot;experiment-2-point&quot;&gt;Experiment 2 (Point)&lt;/h3&gt;
&lt;p&gt;Now, let&#39;s back to the first code snippet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;struct Point
{
    public int X;
    public int Y;
}

static void Print(Point p)
{
    Console.WriteLine(p.X + &amp;quot; &amp;quot; + p.Y);
}

static void Main()
{
    var p = new Point();
    for (p.X = 0; p.X &amp;lt; 2; p.X++)
        Print(p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Logic suggests us that the following output will be display:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 0
1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#39;s check it!&lt;/p&gt;
&lt;h4 id=&quot;clr2-jit-x86&quot;&gt;CLR2 + JIT-x86&lt;/h4&gt;
&lt;p&gt;Let&#39;s start with the configuration in which there is a bug: CLR2 + JIT-x86. In this case, the following output will be display:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 0
2 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open the assembler code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();                  
05C5178C  push        esi                     
05C5178D  xor         esi,esi                 ; p.Y = 0
        for (p.X = 0; p.X &amp;lt; 2; p.X++)         
05C5178F  lea         edi,[esi+2]             ; p.X = 2
            Print(p);                         
05C51792  push        esi                     ; push p.Y
05C51793  push        edi                     ; push p.X
05C51794  call        dword ptr ds:[54607F4h] ; Print(p)
05C5179A  push        esi                     ; push p.Y
05C5179B  push        edi                     ; push p.X
05C5179C  call        dword ptr ds:[54607F4h] ; Print(p)
05C517A2  pop         esi                     
05C517A3  pop         edi                     
05C517A4  pop         ebp                     
05C517A5  ret                                 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, loop unrolling have been performed, but the optimization has an error: variable &lt;code&gt;x&lt;/code&gt; immediately takes the value&lt;code&gt;2&lt;/code&gt; and never changing. This bug has long been known, it have been discussed in the question on StackOverflow [.NET JIT potential error?] (Http://stackoverflow.com/q/2056948/184842).&lt;/p&gt;
&lt;p&gt;Let&#39;s check other JIT versions.&lt;/p&gt;
&lt;h4 id=&quot;clr4-jit-x86&quot;&gt;CLR4 + JIT-x86&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();                   
01392620  push        ebp                      
01392621  mov         ebp,esp                  
01392623  push        edi                      
01392624  push        esi                      
01392625  xor         edi,edi                  ; p.Y = 0
        for (p.X = 0; p.X &amp;lt; 2; p.X++)          
01392627  xor         esi,esi                  ; p.X = 0
            Print(p);                          
01392629  push        edi                      ; push p.Y
0139262A  push        esi                      ; push p.X
0139262B  call        dword ptr ds:[2DB2108h]  ; Print(p)
        for (p.X = 0; p.X &amp;lt; 2; p.X++)          
01392631  inc         esi                      ; p.X++
01392632  cmp         esi,2                    
01392635  jl          01392629                 
01392637  pop         esi                      
01392638  pop         edi                      
01392639  pop         ebp                      
0139263A  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Microsoft has fixed the bug in CLR4. Unfortunately we don&#39;t have loop unrolling in the new version of the code. It works correctly, though not so fast.&lt;/p&gt;
&lt;h4 id=&quot;clr2-jit-x64&quot;&gt;CLR2 + JIT-x64&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();
00007FFCB94A3502  in          al,dx  
00007FFCB94A3503  cmp         byte ptr [rbx],dh  
00007FFCB94A3505  ror         byte ptr [rax-77h],44h  
00007FFCB94A3509  and         al,20h  
00007FFCB94A350B  xor         eax,eax  
00007FFCB94A350D  mov         qword ptr [rsp+20h],rax  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCB94A3512  mov         dword ptr [rsp+20h],0  
00007FFCB94A351A  mov         eax,dword ptr [rsp+20h]  
00007FFCB94A351E  cmp         eax,2  
00007FFCB94A3521  jge         00007FFCB94A3544  
            Print(p);
00007FFCB94A3523  mov         rcx,qword ptr [rsp+20h]  
00007FFCB94A3528  call        00007FFCB936C868  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCB94A352D  mov         r11d,dword ptr [rsp+20h]  
00007FFCB94A3532  add         r11d,1  
00007FFCB94A3536  mov         dword ptr [rsp+20h],r11d  
00007FFCB94A353B  mov         eax,dword ptr [rsp+20h]  
00007FFCB94A353F  cmp         eax,2  
00007FFCB94A3542  jl          00007FFCB94A3523  
00007FFCB94A3544  add         rsp,38h  
00007FFCB94A3548  rep ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although this code works correctly, but it is very bad: loop unrolling haven&#39;t been applying, and we have big amount of unnecessary instruction with sending values between stack and registers. Let&#39;s see what has changed in CLR4.&lt;/p&gt;
&lt;h4 id=&quot;clr4-jit-x64&quot;&gt;CLR4 + JIT-x64&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();                           
00007FFCC8703EC2  sub         esp,30h                  
00007FFCC8703EC5  mov         qword ptr [rsp+20h],0    
        for (p.X = 0; p.X &amp;lt; 2; p.X++)                  
00007FFCC8703ECE  xor         ebx,ebx                  
00007FFCC8703ED0  mov         dword ptr [rsp+20h],ebx  
00007FFCC8703ED4  cmp         ebx,2                    
00007FFCC8703ED7  jge         00007FFCC8703EF5         
00007FFCC8703ED9  nop         dword ptr [rax]          
            Print(p);                                  
00007FFCC8703EE0  mov         rcx,qword ptr [rsp+20h]  
00007FFCC8703EE5  call        00007FFCC85EC8E0         
        for (p.X = 0; p.X &amp;lt; 2; p.X++)                  
00007FFCC8703EEA  inc         ebx                      
00007FFCC8703EEC  mov         dword ptr [rsp+20h],ebx  
00007FFCC8703EF0  cmp         ebx,2                    
00007FFCC8703EF3  jl          00007FFCC8703EE0         
00007FFCC8703EF5  add         rsp,30h                  
00007FFCC8703EF9  pop         rbx                      
00007FFCC8703EFA  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We still don&#39;t have loop unrolling. However, code has become much better in comparison with CLR2 + JIT-x64. Note, the sending the &lt;code&gt;Point&lt;/code&gt; structure to the &lt;code&gt;Print&lt;/code&gt; method implements via 64-bit register instead of two 32-bit values on the stack in JIT-x86.&lt;/p&gt;
&lt;h4 id=&quot;clr4-ryujit-ctp5&quot;&gt;CLR4 + RyuJIT CTP5&lt;/h4&gt;
&lt;p&gt;Next, let&#39;s try RyuJIT CTP5:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();
00007FFCC8723A02  sub         rsp,28h  
00007FFCC8723A06  xor         esi,esi  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCC8723A08  xor         edi,edi  
            Print(p);
00007FFCC8723A0A  lea         rcx,[rsp+20h]  
00007FFCC8723A0F  mov         dword ptr [rcx],edi  
00007FFCC8723A11  mov         dword ptr [rcx+4],esi  
00007FFCC8723A14  mov         rcx,qword ptr [rsp+20h]  
00007FFCC8723A19  call        00007FFCC860C8E0  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCC8723A1E  inc         edi  
00007FFCC8723A20  cmp         edi,2  
00007FFCC8723A23  jl          00007FFCC8723A0A  
00007FFCC8723A25  add         rsp,28h  
00007FFCC8723A29  pop         rsi  
00007FFCC8723A2A  pop         rdi  
00007FFCC8723A2B  ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We don&#39;t have loop unrolling. However, code looks a little cleaner with comparison with CLR4 + JIT-x64.&lt;/p&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;We show the results of the experiments in the following table:&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt; &lt;th&gt;Experiment&lt;/th&gt;  &lt;th&gt;CLR&lt;/th&gt; &lt;th&gt;JIT&lt;/th&gt;    &lt;th&gt;Results&lt;/th&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt;         &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x86&lt;/td&gt;    &lt;td&gt;Loop unrolling&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt;         &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x64&lt;/td&gt;    &lt;td&gt;Value precalculation&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt;         &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;RuyJIT&lt;/td&gt; &lt;td&gt;Loop unrolling is absence&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;2&lt;/td&gt;   &lt;td&gt;x86&lt;/td&gt;    &lt;td&gt;Loop unrolling with the bug&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x86&lt;/td&gt;    &lt;td&gt;Loop unrolling is absence&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;2&lt;/td&gt;   &lt;td&gt;x64&lt;/td&gt;    &lt;td&gt;Loop unrolling is absence, poor code quality&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x64&lt;/td&gt;    &lt;td&gt;Loop unrolling is absence, medium code quality&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;RyuJIT&lt;/td&gt; &lt;td&gt;Loop unrolling is absence, good code quality&lt;/td&gt; &lt;/tr&gt;
&lt;/table&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/ryujit-ctp5-and-loop-unrolling/&quot;&gt;RyuJIT CTP5 and loop unrolling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/2056948/184842&quot;&gt;StackOverflow: .NET JIT potential error?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Размотка маленьких циклов в разных версиях JIT</title>
            <link>http://aakinshin.net/ru/posts/unrolling-of-small-loops-in-different-jit-versions/</link> 
            <pubDate>Mon, 02 Mar 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/unrolling-of-small-loops-in-different-jit-versions/</guid>
            <description>&lt;p&gt;Вопрос дня: что выведет нижеприведённый код?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;struct Point
{
    public int X;
    public int Y;
}
static void Print(Point p)
{
    Console.WriteLine(p.X + &amp;quot; &amp;quot; + p.Y);
}
static void Main()
{
    var p = new Point();
    for (p.X = 0; p.X &amp;lt; 2; p.X++)
        Print(p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Правильный ответ: зависит. В JIT-x86 под CLR2 был баг, который портил эту замечательную программу. А проблема кроется в оптимизации, которая назвается раскрутка маленького цикла. Тема интересная, давайте обсудим её подробно.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;sum&quot;&gt;Эксперимент 1 (Sum)&lt;/h3&gt;
&lt;p&gt;В &lt;a href=&quot;http://aakinshin.net/ru/blog/dotnet/ryujit-ctp5-and-loop-unrolling/&quot;&gt;предыдущем посте&lt;/a&gt; я рассказывал, как происходит раскрутка циклов. Существует частный случай этой оптимизации: если количество итераций мало, то JIT может полностью избавиться от цикла, повторив его тело указанное число раз. Давайте разберёмся в этом чуть подробней на простом примере:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int sum = 0;
for (int i = 0; i &amp;lt; 4; i++)
    sum += i;
Console.WriteLine(sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;jit-x86&quot;&gt;JIT-x86&lt;/h4&gt;
&lt;p&gt;Запустим программу под CLR4 + JIT-x86:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                           
0125291A  in          al,dx                    
0125291B  push        esi                      
0125291C  xor         esi,esi                  
            sum += i;                          
0125291E  inc         esi                      ; sum += 1
0125291F  inc         esi                      ; sum += 2 (Part 1)
01252920  inc         esi                      ; sum += 2 (Part 2)
01252921  add         esi,3                    ; sum += 3
        Console.WriteLine(sum);                
01252924  call        72EE0258                 
01252929  mov         ecx,eax                  
0125292B  mov         edx,esi                  
0125292D  mov         eax,dword ptr [ecx]      
0125292F  mov         eax,dword ptr [eax+38h]  
01252932  call        dword ptr [eax+14h]      
01252935  pop         esi                      
01252936  pop         ebp                      
01252937  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как мы видим, условных переходов в этой программе нет, цикл был полностью уничтожен. Вместо него появились команды, которые высчитывают значение переменно &lt;code&gt;sum&lt;/code&gt; в регистре &lt;code&gt;esi&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&quot;jit-x64&quot;&gt;JIT-x64&lt;/h4&gt;
&lt;p&gt;Следующий эксперимент: CLR4 + JIT-x64:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                            
00007FFCC86F3EC0  sub         rsp,28h           
        Console.WriteLine(sum);                 
00007FFCC86F3EC4  mov         ecx,6             ; sum = 6
00007FFCC86F3EC9  call        00007FFD273DCF10  
00007FFCC86F3ECE  nop                           
00007FFCC86F3ECF  add         rsp,28h           
00007FFCC86F3ED3  ret                           
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JIT-x64 нас приятно радует: он догадался, что &lt;code&gt;0+1+2+3=6&lt;/code&gt;. В результате на консоль выводится &lt;code&gt;6&lt;/code&gt; без каких-либо арифметических операций для её расчёта.&lt;/p&gt;
&lt;h4 id=&quot;ryujit-ctp5&quot;&gt;RyuJIT CTP5&lt;/h4&gt;
&lt;p&gt;А теперь запускаем CLR4 + RyuJIT CTP5:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;
00007FFCC8713A02  sub         esp,20h  
00007FFCC8713A05  xor         esi,esi  
        for (int i = 0; i &amp;lt; 4; i++)
00007FFCC8713A07  xor         eax,eax  
            sum += i;
00007FFCC8713A09  add         esi,eax  
        for (int i = 0; i &amp;lt; 4; i++)
00007FFCC8713A0B  inc         eax  
00007FFCC8713A0D  cmp         eax,4  
00007FFCC8713A10  jl          00007FFCC8713A09  
        Console.WriteLine(sum);
00007FFCC8713A12  call        00007FFD26C0AFA0  
00007FFCC8713A17  mov         rcx,rax  
00007FFCC8713A1A  mov         edx,esi  
00007FFCC8713A1C  mov         rax,qword ptr [rax]  
00007FFCC8713A1F  mov         rax,qword ptr [rax+60h]  
00007FFCC8713A23  call        qword ptr [rax+28h]  
00007FFCC8713A26  nop  
00007FFCC8713A27  add         rsp,20h  
00007FFCC8713A2B  pop         rsi  
00007FFCC8713A2C  ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Эй, RyuJIT, ну что же ты? Вроде бы такая простая оптимизация, а ты её не сделал! Ну, будем надеяться, что в релизе ты научишься такие вещи делать.&lt;/p&gt;
&lt;h3 id=&quot;point&quot;&gt;Эксперимент 2 (Point)&lt;/h3&gt;
&lt;p&gt;А теперь вернёмся к коду из начала статьи:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;struct Point
{
    public int X;
    public int Y;
}

static void Print(Point p)
{
    Console.WriteLine(p.X + &amp;quot; &amp;quot; + p.Y);
}

static void Main()
{
    var p = new Point();
    for (p.X = 0; p.X &amp;lt; 2; p.X++)
        Print(p);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Логика подсказывает нам, что на консоль будет выведено:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 0
1 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Давайте проверим!&lt;/p&gt;
&lt;h4 id=&quot;clr2-jit-x86&quot;&gt;CLR2 + JIT-x86&lt;/h4&gt;
&lt;p&gt;Начнём с конфигурации, в которой возникает бага: CLR2 + JIT-x86. В этом случае на консоль будет выведено:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2 0
2 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Взглянем на ассемблерный код, чтобы разобраться в ситуации:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();                  
05C5178C  push        esi                     
05C5178D  xor         esi,esi                 ; p.Y = 0
        for (p.X = 0; p.X &amp;lt; 2; p.X++)         
05C5178F  lea         edi,[esi+2]             ; p.X = 2
            Print(p);                         
05C51792  push        esi                     ; push p.Y
05C51793  push        edi                     ; push p.X
05C51794  call        dword ptr ds:[54607F4h] ; Print(p)
05C5179A  push        esi                     ; push p.Y
05C5179B  push        edi                     ; push p.X
05C5179C  call        dword ptr ds:[54607F4h] ; Print(p)
05C517A2  pop         esi                     
05C517A3  pop         edi                     
05C517A4  pop         ebp                     
05C517A5  ret                                 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы видим, что размотка цикла была произведена, но в оптимизацию вкралась ошибка: переменная &lt;code&gt;x&lt;/code&gt; сразу принимает значение &lt;code&gt;2&lt;/code&gt; и больше не меняется. Данная бага известна давно, она обсуждалась на StackOverflow в вопросе &lt;a href=&quot;http://stackoverflow.com/q/2056948/184842&quot;&gt;.NET JIT potential error?&lt;/a&gt;. Там приведён более сложный пример кода, но в рамках данного поста я его упростил, чтобы было проще разобраться в проблеме.&lt;/p&gt;
&lt;p&gt;Для полноты эксперимента взглянем на работу остальных версий JIT.&lt;/p&gt;
&lt;h4 id=&quot;clr4-jit-x86&quot;&gt;CLR4 + JIT-x86&lt;/h4&gt;
&lt;p&gt;Для версии CLR4 имеем следующий листинг:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();                   
01392620  push        ebp                      
01392621  mov         ebp,esp                  
01392623  push        edi                      
01392624  push        esi                      
01392625  xor         edi,edi                  ; p.Y = 0
        for (p.X = 0; p.X &amp;lt; 2; p.X++)          
01392627  xor         esi,esi                  ; p.X = 0
            Print(p);                          
01392629  push        edi                      ; push p.Y
0139262A  push        esi                      ; push p.X
0139262B  call        dword ptr ds:[2DB2108h]  ; Print(p)
        for (p.X = 0; p.X &amp;lt; 2; p.X++)          
01392631  inc         esi                      ; p.X++
01392632  cmp         esi,2                    
01392635  jl          01392629                 
01392637  pop         esi                      
01392638  pop         edi                      
01392639  pop         ebp                      
0139263A  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Microsoft пофиксили багу в CLR4. Увы, сделали они это за счёт выключения размотки. Код теперь работает правильно, хоть и не так быстро.&lt;/p&gt;
&lt;h4 id=&quot;clr2-jit-x64&quot;&gt;CLR2 + JIT-x64&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();
00007FFCB94A3502  in          al,dx  
00007FFCB94A3503  cmp         byte ptr [rbx],dh  
00007FFCB94A3505  ror         byte ptr [rax-77h],44h  
00007FFCB94A3509  and         al,20h  
00007FFCB94A350B  xor         eax,eax  
00007FFCB94A350D  mov         qword ptr [rsp+20h],rax  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCB94A3512  mov         dword ptr [rsp+20h],0  
00007FFCB94A351A  mov         eax,dword ptr [rsp+20h]  
00007FFCB94A351E  cmp         eax,2  
00007FFCB94A3521  jge         00007FFCB94A3544  
            Print(p);
00007FFCB94A3523  mov         rcx,qword ptr [rsp+20h]  
00007FFCB94A3528  call        00007FFCB936C868  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCB94A352D  mov         r11d,dword ptr [rsp+20h]  
00007FFCB94A3532  add         r11d,1  
00007FFCB94A3536  mov         dword ptr [rsp+20h],r11d  
00007FFCB94A353B  mov         eax,dword ptr [rsp+20h]  
00007FFCB94A353F  cmp         eax,2  
00007FFCB94A3542  jl          00007FFCB94A3523  
00007FFCB94A3544  add         rsp,38h  
00007FFCB94A3548  rep ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хоть этот код работает и правильно, но он очень плох: мало того, что размотка цикла не выполнилась, так ещё и добавилось много лишних операций по перекидыванию значений из регистра в стек и обратно. Ай-яй-яй! Посмотрим, что изменилось в CLR4.&lt;/p&gt;
&lt;h4 id=&quot;clr4-jit-x64&quot;&gt;CLR4 + JIT-x64&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();                           
00007FFCC8703EC2  sub         esp,30h                  
00007FFCC8703EC5  mov         qword ptr [rsp+20h],0    
        for (p.X = 0; p.X &amp;lt; 2; p.X++)                  
00007FFCC8703ECE  xor         ebx,ebx                  
00007FFCC8703ED0  mov         dword ptr [rsp+20h],ebx  
00007FFCC8703ED4  cmp         ebx,2                    
00007FFCC8703ED7  jge         00007FFCC8703EF5         
00007FFCC8703ED9  nop         dword ptr [rax]          
            Print(p);                                  
00007FFCC8703EE0  mov         rcx,qword ptr [rsp+20h]  
00007FFCC8703EE5  call        00007FFCC85EC8E0         
        for (p.X = 0; p.X &amp;lt; 2; p.X++)                  
00007FFCC8703EEA  inc         ebx                      
00007FFCC8703EEC  mov         dword ptr [rsp+20h],ebx  
00007FFCC8703EF0  cmp         ebx,2                    
00007FFCC8703EF3  jl          00007FFCC8703EE0         
00007FFCC8703EF5  add         rsp,30h                  
00007FFCC8703EF9  pop         rbx                      
00007FFCC8703EFA  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Размотки цикла по-прежнему нет, но зато код стал заметно лучше по сравнению с CLR2 + JIT-x64. Обратите внимание, что по сравнению с JIT-x86 мы пересылаем структуру &lt;code&gt;Point&lt;/code&gt; в метод &lt;code&gt;Print&lt;/code&gt; через один 64-битный регистр вместо двух 32-битных значений на стеке.&lt;/p&gt;
&lt;h4 id=&quot;clr4-ryujit-ctp5&quot;&gt;CLR4 + RyuJIT CTP5&lt;/h4&gt;
&lt;p&gt;Теперь попробуем запустить RyuJIT CTP5:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        var p = new Point();
00007FFCC8723A02  sub         rsp,28h  
00007FFCC8723A06  xor         esi,esi  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCC8723A08  xor         edi,edi  
            Print(p);
00007FFCC8723A0A  lea         rcx,[rsp+20h]  
00007FFCC8723A0F  mov         dword ptr [rcx],edi  
00007FFCC8723A11  mov         dword ptr [rcx+4],esi  
00007FFCC8723A14  mov         rcx,qword ptr [rsp+20h]  
00007FFCC8723A19  call        00007FFCC860C8E0  
        for (p.X = 0; p.X &amp;lt; 2; p.X++)
00007FFCC8723A1E  inc         edi  
00007FFCC8723A20  cmp         edi,2  
00007FFCC8723A23  jl          00007FFCC8723A0A  
00007FFCC8723A25  add         rsp,28h  
00007FFCC8723A29  pop         rsi  
00007FFCC8723A2A  pop         rdi  
00007FFCC8723A2B  ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Размотки цикла нет, то зато код выглядит немного чище по сравнению с CLR4 + JIT-x64.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Проиллюстрируем результаты экспериментов в виде таблицы:&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt; &lt;th&gt;Эксперимент&lt;/th&gt; &lt;th&gt;CLR&lt;/th&gt; &lt;th&gt;JIT&lt;/th&gt;    &lt;th&gt;Результаты&lt;/th&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt;         &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x86&lt;/td&gt;    &lt;td&gt;Размотка цикла&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt;         &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x64&lt;/td&gt;    &lt;td&gt;Предподсчёт значения&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Sum&lt;/td&gt;         &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;RuyJIT&lt;/td&gt; &lt;td&gt;Размотки цикла нет&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;2&lt;/td&gt;   &lt;td&gt;x86&lt;/td&gt;    &lt;td&gt;Размотка цикла с багом&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x86&lt;/td&gt;    &lt;td&gt;Размотки цикла нет&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;2&lt;/td&gt;   &lt;td&gt;x64&lt;/td&gt;    &lt;td&gt;Размотки цикла нет, плохой код&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;x64&lt;/td&gt;    &lt;td&gt;Размотки цикла нет, код среднего качество&lt;/td&gt; &lt;/tr&gt;
  &lt;tr&gt; &lt;td&gt;Point&lt;/td&gt;       &lt;td&gt;4&lt;/td&gt;   &lt;td&gt;RyuJIT&lt;/td&gt; &lt;td&gt;Размотки цикла нет, код хорошего качества&lt;/td&gt; &lt;/tr&gt;
&lt;/table&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aakinshin.net/ru/blog/dotnet/ryujit-ctp5-and-loop-unrolling/&quot;&gt;RyuJIT CTP5 и размотка циклов&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/2056948/184842&quot;&gt;StackOverflow: .NET JIT potential error?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>RyuJIT CTP5 and loop unrolling</title>
            <link>http://aakinshin.net/posts/ryujit-ctp5-and-loop-unrolling/</link> 
            <pubDate>Sun, 01 Mar 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/ryujit-ctp5-and-loop-unrolling/</guid>
            <description>&lt;p&gt;RyuJIT will be available soon. It is a next generation JIT-compiler for .NET-applications. Microsoft likes to tell us about the benefits of SIMD using and JIT-compilation time reducing. But what about basic code optimization which is usually applying by a compiler? Today we talk about the loop unrolling (unwinding) optimization. In general, in this type of code optimization, the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 1024; i++)
    Foo(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;transforms to&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 1024; i += 4)
{
    Foo(i);
    Foo(i + 1);
    Foo(i + 2);
    Foo(i + 3);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Such approach can significantly increase performance of your code. So, what&#39;s about loop unrolling in .NET?&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;common-theory&quot;&gt;Common theory&lt;/h3&gt;
&lt;p&gt;First of all, let&#39;s talk about how loop unrolling affects to our applications.&lt;/p&gt;
&lt;h4 id=&quot;advantages&quot;&gt;Advantages&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;We are reducing the number of machine commands (iterator increments).&lt;/li&gt;
&lt;li&gt;Reduced overheads of &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch prediction&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;We increase the possibility of using &lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction-level_parallelism&quot;&gt;instruction-level parallelism&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;We can apply additional code improvements in conjunction with other optimizations (e. g. , &lt;a href=&quot;http://en.wikipedia.org/wiki/Inline_expansion&quot;&gt;inlining&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;disadvantages&quot;&gt;Disadvantages&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;The source code size increased.&lt;/li&gt;
&lt;li&gt;Sometimes, due to the increasing size of the instruction amount, it is impossible to simultaneously apply loop unrolling and inlining.&lt;/li&gt;
&lt;li&gt;Possible &lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Cache_miss&quot;&gt;cache misses&lt;/a&gt; in the commands cache.&lt;/li&gt;
&lt;li&gt;Possible increased register usage in a single iteration (we may not have enough registers, other optimizations can not apply because of registers deficit).&lt;/li&gt;
&lt;li&gt;If there is branching in the iteration, loop unrolling can adversely affect to other optimizations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h4&gt;
&lt;p&gt;Loop unrolling is a very powerful tool for optimization, but only if we use it wisely. I don&#39;t recommended apply it yourself: it will reduce the readability of the source code and it can adversely affect to use other optimizations. It is best to leave this approach to the compiler. It is important that your compiler could do loop unrolling competently.&lt;/p&gt;
&lt;h3 id=&quot;experiments&quot;&gt;Experiments&lt;/h3&gt;
&lt;h4 id=&quot;source-code&quot;&gt;Source code&lt;/h4&gt;
&lt;p&gt;We will work with a very simple loop which is very easy to unroll:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int sum = 0;
for (int i = 0; i &amp;lt; 1024; i++)
    sum += i;
Console.WriteLine(sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note, the amount of iterations is known beforehand and it is equal to 2&lt;sup&gt;10&lt;/sup&gt;. It is very important because it greatly simplifies usage of the considered optimization.&lt;/p&gt;
&lt;h4 id=&quot;jit-x86&quot;&gt;JIT-x86&lt;/h4&gt;
&lt;p&gt;Let&#39;s run the code with JIT-x86 and look to the assembler code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                    
00EE0052  in          al,dx             
00EE0053  push        esi               
00EE0054  xor         esi,esi           
        for (int i = 0; i &amp;lt; 1024; i++)  
00EE0056  xor         eax,eax           
            sum += i;                   
00EE0058  add         esi,eax           ; sum += i
        for (int i = 0; i &amp;lt; 1024; i++)  
00EE005A  inc         eax               ; i++
00EE005B  cmp         eax,400h          
00EE0060  jl          00EE0058          
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, JIT-x86 didn&#39;t apply loop unrolling. You should understood, the 32-bit version of JIT-compiler is quite primitive. JIT-x86 apply loop unrolling rarely, only if specific conditions are satisfied.&lt;/p&gt;
&lt;h4 id=&quot;jit-x64&quot;&gt;JIT-x64&lt;/h4&gt;
&lt;p&gt;Next, try the experiment with the 64-bit version of JIT-compiler:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                               
00007FFCC8710090  sub         rsp,28h              
        for (int i = 0; i &amp;lt; 1024; i++)             
00007FFCC8710094  xor         ecx,ecx              
00007FFCC8710096  mov         edx,1                ; edx = i + 1
00007FFCC871009B  nop         dword ptr [rax+rax]  
00007FFCC87100A0  lea         eax,[rdx-1]          ; eax = i
            sum += i;                              
00007FFCC87100A3  add         ecx,eax              ; sum += i
00007FFCC87100A5  add         ecx,edx              ; sum += i + 1
00007FFCC87100A7  lea         eax,[rdx+1]          ; eax = i + 2
00007FFCC87100AA  add         ecx,eax              ; sum += i + 2;
00007FFCC87100AC  lea         eax,[rdx+2]          ; eax = i + 3
00007FFCC87100AF  add         ecx,eax              ; sum += i + 3;
00007FFCC87100B1  add         edx,4                ; i += 4
        for (int i = 0; i &amp;lt; 1024; i++)             
00007FFCC87100B4  cmp         edx,401h             
00007FFCC87100BA  jl          00007FFCC87100A0     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, loop unrolling have been applied, the loop body repeated 4 times. JIT-x64 is able to repeat the loop body 2, 3 or 4 times (it depends on the amount of iterations). Unfortunately, if there are no 2, 3, 4 in the set of iterations amount divisors, loop unrolling will not be applied.&lt;/p&gt;
&lt;h4 id=&quot;ryujit&quot;&gt;RyuJIT&lt;/h4&gt;
&lt;p&gt;What&#39;s about new RyuJIT? Let&#39;s look to the assembler code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                            
00007FFCC86E0091  sub         rsp,20h           
00007FFCC86E0095  xor         esi,esi           
        for (int i = 0; i &amp;lt; 1024; i++)          
00007FFCC86E0097  xor         eax,eax           
            sum += i;                           
00007FFCC86E0099  add         esi,eax           ; sum += i
        for (int i = 0; i &amp;lt; 1024; i++)          
00007FFCC86E009B  inc         eax               ; i++
00007FFCC86E009D  cmp         eax,400h          
00007FFCC86E00A2  jl          00007FFCC86E0099  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A sad situation: RyuJIT can&#39;t unroll even the simplest loop. The cause is the following: RyuJIT is based off of the same codebase as JIT-x86 (see: &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx&quot;&gt;RyuJIT: The next-generation JIT compiler for .NET&lt;/a&gt;).&lt;/p&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;RyuJIT allows us to use SIMD-instructions and reduces the JIT compilation time. Unfortunately, the performance of the resulted code with the transition to the new JIT can reduce. Note, there is no the final RuyJIT, the experiment was conducted for CTP5. Let&#39;s hope that the RyuJIT release will include smart code optimizations.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/unrolling-of-small-loops-in-different-jit-versions/&quot;&gt;Unrolling of small loops in different JIT versions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unrolling&quot;&gt;Wikipedia: Loop unrolling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/publication/2449271_Generalized_Loop-Unrolling_a_Method_for_Program_Speed-Up&quot;&gt;J. C. Huang, T. Leng, Generalized Loop-Unrolling: a Method for Program Speed-Up (1998)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Wikipedia: Branch prediction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Instruction-level_parallelism&quot;&gt;Wikipedia: Instruction-level parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inline_expansion&quot;&gt;Wikipedia: Inline expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Cache_miss&quot;&gt;Wikipedia: Cache miss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful&quot;&gt;StackOverflow: http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx&quot;&gt;Blogs.Msdn: RyuJIT: The next-generation JIT compiler for .NET&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>RyuJIT CTP5 и размотка циклов</title>
            <link>http://aakinshin.net/ru/posts/ryujit-ctp5-and-loop-unrolling/</link> 
            <pubDate>Sun, 01 Mar 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/ryujit-ctp5-and-loop-unrolling/</guid>
            <description>&lt;p&gt;Уже скоро нам будет доступен RyuJIT, JIT-компилятор следующего поколения для .NET-приложений. Microsoft любит рассказывать нам о преимуществах использования SIMD и сокращением времени JIT-компиляции. Но что можно сказать о базовых оптимизациях кода, за которые обычно отвечает компилятор? Сегодня мы поговорим о такой оптимизации как размотка (раскрутка) цикла. Если кратко, то это оптимизации кода вида&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 1024; i++)
    Foo(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;превращается в&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;for (int i = 0; i &amp;lt; 1024; i += 4)
{
    Foo(i);
    Foo(i + 1);
    Foo(i + 2);
    Foo(i + 3);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Подобный подход может заметно увеличить производительность вашего кода. Итак, как же обстоят дела с раскруткой цикла в .NET?&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;section&quot;&gt;Общая теория&lt;/h3&gt;
&lt;p&gt;Сперва поговорим о том, как размотка циклов влияет на наше приложение.&lt;/p&gt;
&lt;h4 id=&quot;section-1&quot;&gt;Достоинства&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Мы немного экономим на сокращении количества инкрементов переменной цикла.&lt;/li&gt;
&lt;li&gt;Сокращаются накладные расходы на &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%BE%D0%B2&quot;&gt;предсказывание переходов (branch prediction)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Повышаются возможности применения &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B7%D0%BC_%D0%BD%D0%B0_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4&quot;&gt;параллелизма уровня команд (instruction-level parallelism)&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Позволяет выполнить дополнительные улучшения кода в связке с другими оптимизациями (например, &lt;a href=&quot;http://en.wikipedia.org/wiki/Inline_expansion&quot;&gt;инлайнинг&lt;/a&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;section-2&quot;&gt;Недостатки&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Увеличивается размер исходного кода, что негативно сказывается на размере программы.&lt;/li&gt;
&lt;li&gt;Из-за растущего размера количества инструкций иногда невозможно одновременно применить размотку цикла и инлайнинг.&lt;/li&gt;
&lt;li&gt;Возможные &lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Cache_miss&quot;&gt;промахи&lt;/a&gt; в кеше команд.&lt;/li&gt;
&lt;li&gt;Возрастает нагрузка на регистры в рамках итерации (нам может не хватить регистров, другие оптимизации могут не примениться из-за их нехватки).&lt;/li&gt;
&lt;li&gt;Если внутри итерации есть ветвление, то размотка может отрицательно повлиять на другие оптимизации.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;section-3&quot;&gt;Выводы&lt;/h4&gt;
&lt;p&gt;Размотка циклов — очень мощный инструмент для оптимизации, но только если применять её с умом. Не рекомендуется делать размотку самостоятельно: это понизит читаемость кода и может затруднить применение других оптимизаций. Лучше всего оставить этот подход компилятору. Очень важно, чтобы ваш компилятор умел делать размотку циклов грамотно.&lt;/p&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Эксперименты&lt;/h3&gt;
&lt;h4 id=&quot;section-5&quot;&gt;Исходный код&lt;/h4&gt;
&lt;p&gt;Мы будем работать с очень простым циклом, который просто грех не размотать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int sum = 0;
for (int i = 0; i &amp;lt; 1024; i++)
    sum += i;
Console.WriteLine(sum);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратите внимание, что количество итераций известно заранее и равно 2&lt;sup&gt;10&lt;/sup&gt;. Это очень важно, т. к. существенно упрощает применение рассматриваемой оптимизации.&lt;/p&gt;
&lt;h4 id=&quot;jit-x86&quot;&gt;JIT-x86&lt;/h4&gt;
&lt;p&gt;Запустим данный код под x86 и взглянем на ассемблерный код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                    
00EE0052  in          al,dx             
00EE0053  push        esi               
00EE0054  xor         esi,esi           
        for (int i = 0; i &amp;lt; 1024; i++)  
00EE0056  xor         eax,eax           
            sum += i;                   
00EE0058  add         esi,eax           ; sum += i
        for (int i = 0; i &amp;lt; 1024; i++)  
00EE005A  inc         eax               ; i++
00EE005B  cmp         eax,400h          
00EE0060  jl          00EE0058          
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как видно, JIT-x86 размотку не выполнил. Нужно понимать, что 32-битная версия JIT-компилятора достаточно примитивна, от неё не часто можно увидеть хорошие оптимизации. Размотка цикла в JIT-x86 выполняется крайне редко, если выполняются специфические условия.&lt;/p&gt;
&lt;h4 id=&quot;jit-x64&quot;&gt;JIT-x64&lt;/h4&gt;
&lt;p&gt;Теперь перейдём к 64-битной версии JIT-компилятора:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                               
00007FFCC8710090  sub         rsp,28h              
        for (int i = 0; i &amp;lt; 1024; i++)             
00007FFCC8710094  xor         ecx,ecx              
00007FFCC8710096  mov         edx,1                ; edx = i + 1
00007FFCC871009B  nop         dword ptr [rax+rax]  
00007FFCC87100A0  lea         eax,[rdx-1]          ; eax = i
            sum += i;                              
00007FFCC87100A3  add         ecx,eax              ; sum += i
00007FFCC87100A5  add         ecx,edx              ; sum += i + 1
00007FFCC87100A7  lea         eax,[rdx+1]          ; eax = i + 2
00007FFCC87100AA  add         ecx,eax              ; sum += i + 2;
00007FFCC87100AC  lea         eax,[rdx+2]          ; eax = i + 3
00007FFCC87100AF  add         ecx,eax              ; sum += i + 3;
00007FFCC87100B1  add         edx,4                ; i += 4
        for (int i = 0; i &amp;lt; 1024; i++)             
00007FFCC87100B4  cmp         edx,401h             
00007FFCC87100BA  jl          00007FFCC87100A0     
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вы можете видеть, что размотка циклов была выполнена: тело цикла было повторено 4 раза. JIT-x64 умеет повторять тело цикла 2, 3 или 4 раза (в зависимости от количества итераций). Увы, если среди делителей количества итераций чисел 2, 3, 4 нет, то размотка произведена не будет.&lt;/p&gt;
&lt;h4 id=&quot;ryujit&quot;&gt;RyuJIT&lt;/h4&gt;
&lt;p&gt;Что же произойдёт в новом RyuJIT? Взглянем на ассемблерный код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        int sum = 0;                            
00007FFCC86E0091  sub         rsp,20h           
00007FFCC86E0095  xor         esi,esi           
        for (int i = 0; i &amp;lt; 1024; i++)          
00007FFCC86E0097  xor         eax,eax           
            sum += i;                           
00007FFCC86E0099  add         esi,eax           ; sum += i
        for (int i = 0; i &amp;lt; 1024; i++)          
00007FFCC86E009B  inc         eax               ; i++
00007FFCC86E009D  cmp         eax,400h          
00007FFCC86E00A2  jl          00007FFCC86E0099  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Печальная картина: RyuJIT не может размотать даже простейший цикл. Объяснение следующее: RyuJIT базируется на той же кодовой базе, что и JIT-x86 (см. &lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx&quot;&gt;RyuJIT: The next-generation JIT compiler for .NET&lt;/a&gt;).&lt;/p&gt;
&lt;h3 id=&quot;section-6&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;RyuJIT позволяет нам использовать SIMD-инструкции и сокращает время JIT-компиляции. Увы, производительность самого кода с переходом на новый JIT временами начинает страдать. Стоит отметить, что финальной версии RyuJIT ещё не вышло, эксперимент был проведён для CTP5. Надеемся, что ближе к релизу интеллектуальные оптимизации кода всё-таки появятся.&lt;/p&gt;
&lt;h3 id=&quot;section-7&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aakinshin.net/ru/blog/dotnet/unrolling-of-small-loops-in-different-jit-versions/&quot;&gt;Размотка маленьких циклов в разных версиях JIT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%BC%D0%BE%D1%82%D0%BA%D0%B0_%D1%86%D0%B8%D0%BA%D0%BB%D0%B0&quot;&gt;Википедия: Размотка цикла&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unrolling&quot;&gt;Wikipedia: Loop unrolling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.researchgate.net/publication/2449271_Generalized_Loop-Unrolling_a_Method_for_Program_Speed-Up&quot;&gt;J. C. Huang, T. Leng, Generalized Loop-Unrolling: a Method for Program Speed-Up (1998)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%BE%D0%B2&quot;&gt;Википедия: Предсказывание переходов (branch prediction)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9F%D0%B0%D1%80%D0%B0%D0%BB%D0%BB%D0%B5%D0%BB%D0%B8%D0%B7%D0%BC_%D0%BD%D0%B0_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5_%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4&quot;&gt;Википедия: Параллелизма уровня команд (instruction-level parallelism)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inline_expansion&quot;&gt;Wikipedia: Inline expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Cache_miss&quot;&gt;Wikipedia: Cache miss&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful&quot;&gt;StackOverflow: http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx&quot;&gt;Blogs.Msdn: RyuJIT: The next-generation JIT compiler for .NET&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>JIT version determining in runtime</title>
            <link>http://aakinshin.net/posts/jit-version-determining-in-runtime/</link> 
            <pubDate>Sat, 28 Feb 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/jit-version-determining-in-runtime/</guid>
            <description>&lt;p&gt;Sometimes I want to know used JIT compiler version in my little C# experiments. It is clear that it is possible to determine the version in advance based on the environment. However, sometimes I want to know it in runtime to perform specific code for the current JIT compiler. More formally, I want to get the value from the following enum:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public enum JitVersion
{
    Mono, MsX86, MsX64, RyuJit
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is easy to detect Mono by existing of the &lt;code&gt;Mono.Runtime&lt;/code&gt; class. Otherwise, we can assume that we work with Microsoft JIT implementation. It is easy to detect JIT-x86 with help of &lt;code&gt;IntPtr.Size == 4&lt;/code&gt;. The challenge is to distinguish JIT-x64 and RyuJIT. Next, I will show how you can do it with help of the bug from my &lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;previous post&lt;/a&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;First of all, I show a trivial code that helps us to detect the &lt;code&gt;JitVersion.Mono&lt;/code&gt; and &lt;code&gt;JitVersion.MsX86&lt;/code&gt; versions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static bool IsMono()
{
    return Type.GetType(&amp;quot;Mono.Runtime&amp;quot;) != null;
}

public static bool IsMsX86()
{
    return !IsMono() &amp;amp;&amp;amp; IntPtr.Size == 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we will learn to detect &lt;code&gt;JitVersion.MsX64&lt;/code&gt;. We will use &lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;the JIT-x64 sub-expression elimination optimizer bug&lt;/a&gt; for this purpose. Note, that you should compile the program with enabled optimizations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private int bar;

private bool IsMsX64(int step = 1)
{
    var value = 0;
    for (int i = 0; i &amp;lt; step; i++)
    {
        bar = i + 10;
        for (int j = 0; j &amp;lt; 2 * step; j += step)
            value = j + 10;
    }
    return value == 20 + step;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this post, we work with a limited set of JIT-compiler. Therefore RyuJIT can be identified by the elimination method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public JitVersion GetJitVersion()
{
    if (IsMono())
        return JitVersion.Mono;
    if (IsMsX86())
        return JitVersion.MsX86;
    if (IsMsX64())
        return JitVersion.MsX64;
    return JitVersion.RyuJit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything is ready! Let&#39;s write a simple program, which determine the JIT version in runtime:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;

class Program
{
    public enum JitVersion
    {
        Mono, MsX86, MsX64, RyuJit
    }

    public class JitVersionInfo
    {
        public JitVersion GetJitVersion()
        {
            if (IsMono())
                return JitVersion.Mono;
            if (IsMsX86())
                return JitVersion.MsX86;
            if (IsMsX64())
                return JitVersion.MsX64;
            return JitVersion.RyuJit;
        }

        private int bar;

        private bool IsMsX64(int step = 1)
        {
            var value = 0;
            for (int i = 0; i &amp;lt; step; i++)
            {
                bar = i + 10;
                for (int j = 0; j &amp;lt; 2 * step; j += step)
                    value = j + 10;
            }
            return value == 20 + step;
        }

        public static bool IsMono()
        {
            return Type.GetType(&amp;quot;Mono.Runtime&amp;quot;) != null;
        }

        public static bool IsMsX86()
        {
            return !IsMono() &amp;amp;&amp;amp; IntPtr.Size == 4;
        }
    }

    static void Main()
    {
        Console.WriteLine(&amp;quot;Current JIT version: &amp;quot; + new JitVersionInfo().GetJitVersion());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The class is ready to use! The complete code is also available on Gist: &lt;a href=&quot;https://gist.github.com/AndreyAkinshin/0506ad10faf0c2a7b1cb&quot;&gt;JitVersionInfo.cs&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;notes&quot;&gt;Notes&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Method of distinguish MsX64 and RyuJIT works only with enabled optimizations.&lt;/li&gt;
&lt;li&gt;The approach works with a limited set of JIT versions, you can have troubles with non-standard .NET versions.&lt;/li&gt;
&lt;li&gt;Miguel have promised that Mono 4 will work on CoreCLR which means RyuJIT.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aakinshin.net/en/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;A bug story about JIT-x64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/721161/184842&quot;&gt;StackOverflow: How to detect which .NET runtime is being used (MS vs. Mono)?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/22422021/184842&quot;&gt;StackOverflow: How do I verify that ryujit is jitting my app?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Определение версии JIT в рантайме</title>
            <link>http://aakinshin.net/ru/posts/jit-version-determining-in-runtime/</link> 
            <pubDate>Sat, 28 Feb 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/jit-version-determining-in-runtime/</guid>
            <description>&lt;p&gt;Иногда мне в моих маленьких C#-экспериментах нужно определять версию используемого JIT-компилятора. Понятно, что её можно определить заранее исходя из окружения. Но порой мне хочется знать её в рантайме, чтобы выполнять специфичный код для текущего JIT-компилятора. Строго говоря, я хочу получать значение из следующего перечисления:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public enum JitVersion
{
    Mono, MsX86, MsX64, RyuJit
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Я могу легко определить, что работаю под Mono, по наличию класса &lt;code&gt;Mono.Runtime&lt;/code&gt;. Если это не так, то можно считать, что мы работаем с JIT от Microsoft. JIT-x86 легко узнать с помощью &lt;code&gt;IntPtr.Size == 4&lt;/code&gt;. А вот чтобы отличить старый JIT-x64 от нового RyuJIT необходимо немного призадуматься. Далее я покажу, как это можно сделать с помощью бага JIT-x64, который я описывал в &lt;a href=&quot;http://aakinshin.net/ru/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;предыдущем посте&lt;/a&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Сначала приведу тривиальный код, который поможет нам опознать версии &lt;code&gt;JitVersion.Mono&lt;/code&gt; и &lt;code&gt;JitVersion.MsX86&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static bool IsMono()
{
    return Type.GetType(&amp;quot;Mono.Runtime&amp;quot;) != null;
}

public static bool IsMsX86()
{
    return !IsMono() &amp;amp;&amp;amp; IntPtr.Size == 4;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь научимся определять &lt;code&gt;JitVersion.MsX64&lt;/code&gt;. Для этого проверим наличие &lt;a href=&quot;http://aakinshin.net/ru/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;JIT-x64 sub-expression elimination optimizer bug&lt;/a&gt;. Обратите внимание, что программа должна быть скомпилирована с включёнными оптимизациями.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private int bar;

private bool IsMsX64(int step = 1)
{
    var value = 0;
    for (int i = 0; i &amp;lt; step; i++)
    {
        bar = i + 10;
        for (int j = 0; j &amp;lt; 2 * step; j += step)
            value = j + 10;
    }
    return value == 20 + step;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В рамках данной задачи мы работаем с ограниченным набором JIT-компиляторов. Поэтому RyuJIT можно опознать методом исключения:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public JitVersion GetJitVersion()
{
    if (IsMono())
        return JitVersion.Mono;
    if (IsMsX86())
        return JitVersion.MsX86;
    if (IsMsX64())
        return JitVersion.MsX64;
    return JitVersion.RyuJit;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё готово! Напишем простую программу, в которой определим версию JIT:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;

class Program
{
    public enum JitVersion
    {
        Mono, MsX86, MsX64, RyuJit
    }

    public class JitVersionInfo
    {
        public JitVersion GetJitVersion()
        {
            if (IsMono())
                return JitVersion.Mono;
            if (IsMsX86())
                return JitVersion.MsX86;
            if (IsMsX64())
                return JitVersion.MsX64;
            return JitVersion.RyuJit;
        }

        private int bar;

        private bool IsMsX64(int step = 1)
        {
            var value = 0;
            for (int i = 0; i &amp;lt; step; i++)
            {
                bar = i + 10;
                for (int j = 0; j &amp;lt; 2 * step; j += step)
                    value = j + 10;
            }
            return value == 20 + step;
        }

        public static bool IsMono()
        {
            return Type.GetType(&amp;quot;Mono.Runtime&amp;quot;) != null;
        }

        public static bool IsMsX86()
        {
            return !IsMono() &amp;amp;&amp;amp; IntPtr.Size == 4;
        }
    }

    static void Main()
    {
        Console.WriteLine(&amp;quot;Current JIT version: &amp;quot; + new JitVersionInfo().GetJitVersion());
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отлично, класс готов к использованию! Полный код также доступен на Gist: &lt;a href=&quot;https://gist.github.com/AndreyAkinshin/0506ad10faf0c2a7b1cb&quot;&gt;JitVersionInfo.cs&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Замечания&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Метод определения MsX64 vs RyuJIT работает только с включёнными оптимизациями.&lt;/li&gt;
&lt;li&gt;Данная программа работает с ограниченными набором версий JIT, могут быть проблемы на нестандартных версиях .NET.&lt;/li&gt;
&lt;li&gt;Мигель обещал, что Mono 4 будет работать на CoreCLR, что означает использование RyuJIT.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://aakinshin.net/ru/blog/dotnet/subexpression-elimination-bug-in-jit-x64/&quot;&gt;История про баг в JIT-x64&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/721161/184842&quot;&gt;StackOverflow: How to detect which .NET runtime is being used (MS vs. Mono)?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/22422021/184842&quot;&gt;StackOverflow: How do I verify that ryujit is jitting my app?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>A bug story about JIT-x64</title>
            <link>http://aakinshin.net/posts/subexpression-elimination-bug-in-jit-x64/</link> 
            <pubDate>Fri, 27 Feb 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/subexpression-elimination-bug-in-jit-x64/</guid>
            <description>&lt;p&gt;Can you say, what will the following code display for &lt;code&gt;step=1&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Foo(int step)
{
    for (int i = 0; i &amp;lt; step; i++)
    {
        bar = i + 10;
        for (int j = 0; j &amp;lt; 2 * step; j += step)
            Console.WriteLine(j + 10);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you think about specific numbers, you are wrong. The right answer: it depends. The post title suggests to us, the program can has a strange behavior for x64.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-problem-statement&quot;&gt;The problem statement&lt;/h3&gt;
&lt;p&gt;The bug isn&#39;t a new one, it has been discussed a year ago on StackOverflow: &lt;a href=&quot;http://stackoverflow.com/questions/20701701/jit-net-compiler-bug&quot;&gt;“JIT .Net compiler bug?”&lt;/a&gt;. However, the code from the question is too complicated for an analysis. I have tried to minimize it for the future examination. Let&#39;s consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        new Program().Run();
    }

    private void Run()
    {
        Console.WriteLine(&amp;quot;Optimization:&amp;quot;);
        Optimization(1);
        Console.WriteLine(&amp;quot;NoOptimization:&amp;quot;);
        NoOptimization(1);
    }

    int bar;

    public void Optimization(int step)
    {
        for (int i = 0; i &amp;lt; step; i++)
        {
            bar = i + 10;
            for (int j = 0; j &amp;lt; 2 * step; j += step)
                Console.WriteLine(j + 10);
        }
    }

    [MethodImpl(MethodImplOptions.NoOptimization)]
    public void NoOptimization(int step)
    {
        for (int i = 0; i &amp;lt; step; i++)
        {
            bar = i + 10;
            for (int j = 0; j &amp;lt; 2 * step; j += step)
                Console.WriteLine(j + 10);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you compile the code in the Release-x64 mode and run it with JIT-x64, you see the following result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimization:
10
21
NoOptimization:
10
11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unexpectedly, is not it? JIT-x64 has played a dirty trick on us and spent optimizing crooked. Some important facts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;step&lt;/code&gt; is a method argument.&lt;/li&gt;
&lt;li&gt;Both of the loops start with zero and have the &lt;code&gt;step&lt;/code&gt; increment..&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j+10&lt;/code&gt; prints on the Console, &lt;code&gt;i+10&lt;/code&gt; stores in a local variable per each first loop iteration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These conditions (and several tricky additional conditions) allows JIT-x64 to perform an sub-expression elimination optimization. Unfortunately he does it wrong.&lt;/p&gt;
&lt;h3 id=&quot;jit-x86&quot;&gt;JIT-x86&lt;/h3&gt;
&lt;p&gt;At first, we will look to the assembler code for JIT-x86. We want to make sure that it is a code without any troubles.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Optimization, JIT-x86
        for (int i = 0; i &amp;lt; step; i++)                
008400DA  in          al,dx                           
008400DB  push        edi                             
008400DC  push        esi                             
008400DD  push        ebx                             
008400DE  sub         esp,8                           
008400E1  mov         dword ptr [ebp-14h],ecx         
008400E4  mov         edi,edx                         ; edi=edx (edi=step)
008400E6  xor         edx,edx                         ; edx=0
008400E8  mov         dword ptr [ebp-10h],edx         ; [ebp-10h]=edx (i=0)
008400EB  test        edi,edi                         
008400ED  jle         00840125                        
        {                                             
            bar = i + 10;                             
008400EF  mov         eax,dword ptr [ebp-10h]         ; eax=[ebp-10h] (eax=i)
008400F2  add         eax,0Ah                         ; eax+=0Ah (eax=i+10)
008400F5  mov         edx,dword ptr [ebp-14h]         ; edx=&amp;amp;this
008400F8  mov         dword ptr [edx+4],eax           ; [edx+4]=eax (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
008400FB  xor         esi,esi                         ; esi=0 (j=0)
008400FD  mov         ebx,edi                         ; ebx=edi (ebx=step)
008400FF  add         ebx,ebx                         ; ebx+=edx (ebx=2*step)
00840101  test        ebx,ebx                         
00840103  jle         0084011D                        
                Console.WriteLine(j + 10);            
00840105  call        72EE0258                        
0084010A  mov         ecx,eax                         
0084010C  lea         edx,[esi+0Ah]                   ; edx=[esi+0Ah] (edx=j+10)
0084010F  mov         eax,dword ptr [ecx]             
00840111  mov         eax,dword ptr [eax+38h]         
00840114  call        dword ptr [eax+14h]             ; Console.WriteLine(edx)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00840117  add         esi,edi                         ; esi+=edi (j+=step)
00840119  cmp         esi,ebx                         ; if esi&amp;lt;ebx (j&amp;lt;2*step)
0084011B  jl          00840105                        ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                
0084011D  inc         dword ptr [ebp-10h]             ; [ebp-10h]++ (i++)
00840120  cmp         dword ptr [ebp-10h],edi         ; if [ebp-10h]&amp;lt;edi (i&amp;lt;step)
00840123  jl          008400EF                        ; jump to loop start (i)
00840125  lea         esp,[ebp-0Ch]                   
00840128  pop         ebx                             
00840129  pop         esi                             
0084012A  pop         edi                             
0084012B  pop         ebp                             
0084012C  ret                                         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is right, we can see the expected result on the Console:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimization:
10
11
NoOptimization:
10
11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;jit-x64&quot;&gt;JIT-x64&lt;/h3&gt;
&lt;p&gt;Now, we will take the JIT-x64 assembler code and start with the &lt;code&gt;NoOptimization&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; NoOptimization, JIT-x64
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC87202A5  mov         dword ptr [rsp+8],ecx    
00007FFCC87202A9  sub         rsp,38h                  
00007FFCC87202AD  mov         dword ptr [rsp+20h],0    ; [rsp+20h]=0 (i=0)
00007FFCC87202B5  mov         dword ptr [rsp+24h],0    ; [rsp+24h]=0 (j=0)
00007FFCC87202BD  mov         dword ptr [rsp+20h],0    ; [rsp+20h]=0 (i=0)
00007FFCC87202C5  jmp         00007FFCC8720316         
        {                                              
            bar = i + 10;                              
00007FFCC87202C7  mov         ecx,dword ptr [rsp+20h]  ; ecx=[rsp+20h] (ecx=i)
00007FFCC87202CB  add         ecx,0Ah                  ; ecx+=10 (ecx=i+10)
00007FFCC87202CE  mov         rax,qword ptr [rsp+40h]  ; rax=&amp;amp;this
00007FFCC87202D3  mov         dword ptr [rax+8],ecx    ; [rax+8]=ecx (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC87202D6  mov         dword ptr [rsp+24h],0    ; [rsp+24h]=0 (j)
00007FFCC87202DE  jmp         00007FFCC87202FC         
                Console.WriteLine(j + 10);             
00007FFCC87202E0  mov         ecx,dword ptr [rsp+24h]  ; ecx=[rsp+24h] (ecx=j)
00007FFCC87202E4  add         ecx,0Ah                  ; ecx+=10
00007FFCC87202E7  call        00007FFD273DCF10         ; Console.WriteLine(j+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC87202EC  mov         r11d,dword ptr [rsp+48h] ; r11d=[rsp+48h] (r11d=step)
00007FFCC87202F1  mov         eax,dword ptr [rsp+24h]  ; eax=[rsp+24h] (eax=j)
00007FFCC87202F5  add         eax,r11d                 ; eax+=r11d (eax=j+step)
00007FFCC87202F8  mov         dword ptr [rsp+24h],eax  ; [rsp+24h]=eax (j=j+step)
00007FFCC87202FC  mov         eax,2                    ; eax=2
00007FFCC8720301  imul        eax,dword ptr [rsp+48h]  ; eax*=[rsp+48h] (eax=2*step)
00007FFCC8720306  cmp         dword ptr [rsp+24h],eax  ; if [resp+24h]&amp;lt;eax (j&amp;lt;2*step)
00007FFCC872030A  jl          00007FFCC87202E0         ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC872030C  mov         eax,dword ptr [rsp+20h]  ; eax=[rsp+20h] (i)
00007FFCC8720310  inc         eax                      ; eax++ (eax=i+1)
00007FFCC8720312  mov         dword ptr [rsp+20h],eax  ; [rsp+20h]=eax (i=i+1)
00007FFCC8720316  mov         eax,dword ptr [rsp+48h]  ; eax=[rsp+48h] (eax=step)
00007FFCC872031A  cmp         dword ptr [rsp+20h],eax  ; if [rsp+20h]&amp;lt;eax (i&amp;lt;step)
00007FFCC872031E  jl          00007FFCC87202C7         ; jump to loop start (i)
        }                                              
    }                                                  
00007FFCC8720320  jmp         00007FFCC8720322         
00007FFCC8720322  nop                                  
00007FFCC8720323  add         rsp,38h                  
00007FFCC8720327  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, it is fine, go to the opimized method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Optimization, JIT-x64
       for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC87201C2  push        rsi                     
00007FFCC87201C3  push        rdi                     
00007FFCC87201C4  push        r12                     
00007FFCC87201C6  push        r13                     
00007FFCC87201C8  push        r14                     
00007FFCC87201CA  push        r15                     
00007FFCC87201CC  sub         rsp,28h                 
00007FFCC87201D0  mov         ebx,edx                 ; ebx=step
00007FFCC87201D2  mov         r12,rcx                 ; r12=&amp;amp;this
00007FFCC87201D5  lea         r15d,[rbx+0Ah]          ; r15d=rbx+10 (r15d=step+10)
00007FFCC87201D9  test        ebx,ebx                 
00007FFCC87201DB  jle         00007FFCC8720260        
00007FFCC87201E1  xor         esi,esi                 ; esi=0 (i=0)
00007FFCC87201E3  mov         edi,0Ah                 ; edi=10 ((i+10)=10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00007FFCC87201E8  mov         ebp,2                   ; ebp=2
00007FFCC87201ED  imul        ebp,ebx                 ; ebp*=ebx (ebp=2*step)
        {                                             
            bar = i + 10;                             
00007FFCC87201F0  mov         dword ptr [r12+8],edi   ; bar=edi
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00007FFCC87201F5  test        ebp,ebp                 
00007FFCC87201F7  jle         00007FFCC8720256        
00007FFCC87201F9  xor         r13d,r13d               ; r13d=0 (j=0)
00007FFCC87201FC  mov         r14d,0Ah                ; r14d=10                     // !!!
00007FFCC8720202  nop         word ptr [rax+rax]      
00007FFCC8720210  mov         rax,0FC2B841138h        
00007FFCC872021A  mov         rax,qword ptr [rax]     
00007FFCC872021D  test        rax,rax                 
00007FFCC8720220  jne         00007FFCC8720230        
00007FFCC8720222  mov         cl,1                    
00007FFCC8720224  call        00007FFD26C0D960        
00007FFCC8720229  nop         dword ptr [rax]         
00007FFCC8720230  mov         rcx,0FC2B841138h        
00007FFCC872023A  mov         rcx,qword ptr [rcx]     
00007FFCC872023D  mov         rax,qword ptr [rcx]     
00007FFCC8720240  mov         r8,qword ptr [rax+60h]  
00007FFCC8720244  mov         edx,r14d                ; edx=r14d                     // !!!
00007FFCC8720247  call        qword ptr [r8+28h]      ; Console.WriteLine(edx)       // !!!
00007FFCC872024B  add         r13d,ebx                ; r13d+=ebx (j+=step)
00007FFCC872024E  add         r14d,r15d               ; r14d+=r15d (r14d+=(step+10)) // !!!
00007FFCC8720251  cmp         r13d,ebp                ; if r13d&amp;lt;ebp (j&amp;lt;2*step)
00007FFCC8720254  jl          00007FFCC8720210        ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                
00007FFCC8720256  inc         esi                     ; esi++ (i++)
00007FFCC8720258  inc         edi                     ; edi++ ((i+10)++)
00007FFCC872025A  cmp         esi,ebx                 ; if esi&amp;lt;ebx (i&amp;lt;step)
00007FFCC872025C  jl          00007FFCC87201F0        ; jump to loop start (i)
00007FFCC872025E  xchg        ax,ax                   
00007FFCC8720260  add         rsp,28h                 
00007FFCC8720264  pop         r15                     
00007FFCC8720266  pop         r14                     
00007FFCC8720268  pop         r13                     
00007FFCC872026A  pop         r12                     
00007FFCC872026C  pop         rdi                     
00007FFCC872026D  pop         rsi                     
00007FFCC872026E  pop         rbp                     
00007FFCC872026F  pop         rbx                     
00007FFCC8720270  ret                                 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have some time to explore the above listing, you&#39;ll see that the problem is related with the &lt;code&gt;r14d&lt;/code&gt; register which is used for output. At the beginning of the nested loop, it is initialized by &lt;code&gt;10&lt;/code&gt;. Next, it increases by &lt;code&gt;step + 10&lt;/code&gt; on each iteration (although the increment should be equal to &lt;code&gt;step&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;There is a &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/812093/&quot;&gt;bug report&lt;/a&gt; in MS Connect about the issue. Unfortunately, the bug status is sad:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Status: Closed as Won&#39;t Fix Won&#39;t Fix. Due to several factors the product team decided to focus its efforts on other items.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ryujit&quot;&gt;RyuJIT&lt;/h3&gt;
&lt;p&gt;Let&#39;s download and install RyuJIT CTP5, set the &lt;code&gt;HKLM\SOFTWARE\Microsoft\.NETFramework\AltJit=&#39;*&#39;&lt;/code&gt; key in the regedit, and look to the x64 assembler code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-x86asm&quot;&gt;; Optimization, RyuJIT
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC86F0160  push        r14                      
00007FFCC86F0162  push        rdi                      
00007FFCC86F0163  push        rsi                      
00007FFCC86F0164  push        rbp                      
00007FFCC86F0165  push        rbx                      
00007FFCC86F0166  sub         rsp,20h                  
00007FFCC86F016A  mov         rdi,rcx                  ; rdi=&amp;amp;this
00007FFCC86F016D  mov         esi,edx                  ; esi=edx (esi=step)
00007FFCC86F016F  xor         ebx,ebx                  ; ebx=0 (i=0)
00007FFCC86F0171  test        esi,esi                  
00007FFCC86F0173  jle         00007FFCC86F01AA         
00007FFCC86F0175  mov         ebp,esi                  ; ebp=esi (ebp=step)
00007FFCC86F0177  shl         ebp,1                    ; ebp*=2 (ebp=2*step)
        {                                              
            bar = i + 10;                              
00007FFCC86F0179  lea         eax,[rbx+0Ah]            ; eax=[rbx+0Ah] (eax=i+10)
00007FFCC86F017C  mov         dword ptr [rdi+8],eax    ; [rdi+8]=eax (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC86F017F  xor         r14d,r14d                ; r14d=0 (j=0)
00007FFCC86F0182  test        ebp,ebp                  
00007FFCC86F0184  jle         00007FFCC86F01A4         
                Console.WriteLine(j + 10);             
00007FFCC86F0186  call        00007FFD26C0AFA0         
00007FFCC86F018B  mov         rcx,rax                  
00007FFCC86F018E  lea         edx,[r14+0Ah]            ; edx=r14+0Ah (edx=j+10)
00007FFCC86F0192  mov         rax,qword ptr [rax]      
00007FFCC86F0195  mov         rax,qword ptr [rax+60h]  
00007FFCC86F0199  call        qword ptr [rax+28h]      ; Console.WriteLine(edx)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC86F019C  add         r14d,esi                 ; r14d+=esi (j+=step)
00007FFCC86F019F  cmp         r14d,ebp                 ; if (r14d&amp;lt;ebp) (j&amp;lt;2*step)
00007FFCC86F01A2  jl          00007FFCC86F0186         ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC86F01A4  inc         ebx                      ; ebx++ (i++)
00007FFCC86F01A6  cmp         ebx,esi                  ; if ebx&amp;lt;esi (i&amp;lt;step)
00007FFCC86F01A8  jl          00007FFCC86F0179         ; jump to loop start (i)
00007FFCC86F01AA  add         rsp,20h                  
00007FFCC86F01AE  pop         rbx                      
00007FFCC86F01AF  pop         rbp                      
00007FFCC86F01B0  pop         rsi                      
00007FFCC86F01B1  pop         rdi                      
00007FFCC86F01B2  pop         r14                      
00007FFCC86F01B4  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything is fine: clever optimization are absent, the code works correctly.&lt;/p&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;The JIT-x86 and RyuJIT CTP5 don&#39;t have the described bug. However, it is exist in JIT-x64. Most likely, it will not going anywhere.&lt;/p&gt;
&lt;p&gt;You should understand, there is no perfect software. .NET is not an exception. Bugs in the JIT are extremely rare, but it is useful to bear in mind that thay may exist.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/20701701/jit-net-compiler-bug&quot;&gt;StackOverflow: JIT .Net compiler bug?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/812093/x64-jitter-sub-expression-elimination-optimizer-bug&quot;&gt;MS Connect: x64 jitter sub-expression elimination optimizer bug&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>История про баг в JIT-x64</title>
            <link>http://aakinshin.net/ru/posts/subexpression-elimination-bug-in-jit-x64/</link> 
            <pubDate>Fri, 27 Feb 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/subexpression-elimination-bug-in-jit-x64/</guid>
            <description>&lt;p&gt;Можете ли вы сказать, что выведет следующий код для &lt;code&gt;step=1&lt;/code&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Foo(int step)
{
    for (int i = 0; i &amp;lt; step; i++)
    {
        bar = i + 10;
        for (int j = 0; j &amp;lt; 2 * step; j += step)
            Console.WriteLine(j + 10);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы назвали конкретные числа, то ошиблись. Правильный ответ: зависит. Заголовок подсказывает нам, что под x64 программа может вести себя не так, как мы от неё ожидаем.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Постановка задачи&lt;/h3&gt;
&lt;p&gt;Баг не является новым, его обсуждали чуть больше года назад на StackOverflow: &lt;a href=&quot;http://stackoverflow.com/questions/20701701/jit-net-compiler-bug&quot;&gt;&#171;JIT .Net compiler bug?&#187;&lt;/a&gt;. Однако, приведённый в вопросе пример кода достаточно сложен для анализа. Я его постарался максимально ужать, чтобы можно было изучить поведение подробней. Итак, код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        new Program().Run();
    }

    private void Run()
    {
        Console.WriteLine(&amp;quot;Optimization:&amp;quot;);
        Optimization(1);
        Console.WriteLine(&amp;quot;NoOptimization:&amp;quot;);
        NoOptimization(1);
    }

    int bar;

    public void Optimization(int step)
    {
        for (int i = 0; i &amp;lt; step; i++)
        {
            bar = i + 10;
            for (int j = 0; j &amp;lt; 2 * step; j += step)
                Console.WriteLine(j + 10);
        }
    }

    [MethodImpl(MethodImplOptions.NoOptimization)]
    public void NoOptimization(int step)
    {
        for (int i = 0; i &amp;lt; step; i++)
        {
            bar = i + 10;
            for (int j = 0; j &amp;lt; 2 * step; j += step)
                Console.WriteLine(j + 10);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы скомпилируете его в Release под x64, а потом запустите под JIT-x64, то увидите следующий результат:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimization:
10
21
NoOptimization:
10
11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Неожиданно, не так ли? JIT-x64 сыграл с нами злую шутку и провёл оптимизацию криво. Важными являются следующие факты:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;step&lt;/code&gt; является параметром метода.&lt;/li&gt;
&lt;li&gt;Оба цикла начинаются от нуля идут с шагом &lt;code&gt;step&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;На консоль выводится &lt;code&gt;j + 10&lt;/code&gt;, а выражение &lt;code&gt;i + 10&lt;/code&gt; на каждой итерации первого цикла сохраняется в нестатичную переменную.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти условия (а также несколько дополнительных и более хитрых) позволяют JIT-x64 запустить оптимизацию по удалению подвыражения в вычислениях. Увы, делает он это неправильно.&lt;/p&gt;
&lt;h3 id=&quot;jit-x86&quot;&gt;JIT-x86&lt;/h3&gt;
&lt;p&gt;Сперва взглянем на версию с использованием JIT-x86. Убедимся, что в ней всё хорошо.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; Optimization, JIT-x86
        for (int i = 0; i &amp;lt; step; i++)                
008400DA  in          al,dx                           
008400DB  push        edi                             
008400DC  push        esi                             
008400DD  push        ebx                             
008400DE  sub         esp,8                           
008400E1  mov         dword ptr [ebp-14h],ecx         
008400E4  mov         edi,edx                         ; edi=edx (edi=step)
008400E6  xor         edx,edx                         ; edx=0
008400E8  mov         dword ptr [ebp-10h],edx         ; [ebp-10h]=edx (i=0)
008400EB  test        edi,edi                         
008400ED  jle         00840125                        
        {                                             
            bar = i + 10;                             
008400EF  mov         eax,dword ptr [ebp-10h]         ; eax=[ebp-10h] (eax=i)
008400F2  add         eax,0Ah                         ; eax+=0Ah (eax=i+10)
008400F5  mov         edx,dword ptr [ebp-14h]         ; edx=&amp;amp;this
008400F8  mov         dword ptr [edx+4],eax           ; [edx+4]=eax (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
008400FB  xor         esi,esi                         ; esi=0 (j=0)
008400FD  mov         ebx,edi                         ; ebx=edi (ebx=step)
008400FF  add         ebx,ebx                         ; ebx+=edx (ebx=2*step)
00840101  test        ebx,ebx                         
00840103  jle         0084011D                        
                Console.WriteLine(j + 10);            
00840105  call        72EE0258                        
0084010A  mov         ecx,eax                         
0084010C  lea         edx,[esi+0Ah]                   ; edx=[esi+0Ah] (edx=j+10)
0084010F  mov         eax,dword ptr [ecx]             
00840111  mov         eax,dword ptr [eax+38h]         
00840114  call        dword ptr [eax+14h]             ; Console.WriteLine(edx)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00840117  add         esi,edi                         ; esi+=edi (j+=step)
00840119  cmp         esi,ebx                         ; if esi&amp;lt;ebx (j&amp;lt;2*step)
0084011B  jl          00840105                        ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                
0084011D  inc         dword ptr [ebp-10h]             ; [ebp-10h]++ (i++)
00840120  cmp         dword ptr [ebp-10h],edi         ; if [ebp-10h]&amp;lt;edi (i&amp;lt;step)
00840123  jl          008400EF                        ; jump to loop start (i)
00840125  lea         esp,[ebp-0Ch]                   
00840128  pop         ebx                             
00840129  pop         esi                             
0084012A  pop         edi                             
0084012B  pop         ebp                             
0084012C  ret                                         
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Код сгенерировался абсолютно правильно, на консоли видим ожидаемое:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Optimization:
10
11
NoOptimization:
10
11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;jit-x64&quot;&gt;JIT-x64&lt;/h3&gt;
&lt;p&gt;Теперь посмотрим версию ассемблерного кода для JIT-x64. Начнём с метода без оптимизации &lt;code&gt;NoOptimization&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; NoOptimization, JIT-x64
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC87202A5  mov         dword ptr [rsp+8],ecx    
00007FFCC87202A9  sub         rsp,38h                  
00007FFCC87202AD  mov         dword ptr [rsp+20h],0    ; [rsp+20h]=0 (i=0)
00007FFCC87202B5  mov         dword ptr [rsp+24h],0    ; [rsp+24h]=0 (j=0)
00007FFCC87202BD  mov         dword ptr [rsp+20h],0    ; [rsp+20h]=0 (i=0)
00007FFCC87202C5  jmp         00007FFCC8720316         
        {                                              
            bar = i + 10;                              
00007FFCC87202C7  mov         ecx,dword ptr [rsp+20h]  ; ecx=[rsp+20h] (ecx=i)
00007FFCC87202CB  add         ecx,0Ah                  ; ecx+=10 (ecx=i+10)
00007FFCC87202CE  mov         rax,qword ptr [rsp+40h]  ; rax=&amp;amp;this
00007FFCC87202D3  mov         dword ptr [rax+8],ecx    ; [rax+8]=ecx (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC87202D6  mov         dword ptr [rsp+24h],0    ; [rsp+24h]=0 (j)
00007FFCC87202DE  jmp         00007FFCC87202FC         
                Console.WriteLine(j + 10);             
00007FFCC87202E0  mov         ecx,dword ptr [rsp+24h]  ; ecx=[rsp+24h] (ecx=j)
00007FFCC87202E4  add         ecx,0Ah                  ; ecx+=10
00007FFCC87202E7  call        00007FFD273DCF10         ; Console.WriteLine(j+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC87202EC  mov         r11d,dword ptr [rsp+48h] ; r11d=[rsp+48h] (r11d=step)
00007FFCC87202F1  mov         eax,dword ptr [rsp+24h]  ; eax=[rsp+24h] (eax=j)
00007FFCC87202F5  add         eax,r11d                 ; eax+=r11d (eax=j+step)
00007FFCC87202F8  mov         dword ptr [rsp+24h],eax  ; [rsp+24h]=eax (j=j+step)
00007FFCC87202FC  mov         eax,2                    ; eax=2
00007FFCC8720301  imul        eax,dword ptr [rsp+48h]  ; eax*=[rsp+48h] (eax=2*step)
00007FFCC8720306  cmp         dword ptr [rsp+24h],eax  ; if [resp+24h]&amp;lt;eax (j&amp;lt;2*step)
00007FFCC872030A  jl          00007FFCC87202E0         ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC872030C  mov         eax,dword ptr [rsp+20h]  ; eax=[rsp+20h] (i)
00007FFCC8720310  inc         eax                      ; eax++ (eax=i+1)
00007FFCC8720312  mov         dword ptr [rsp+20h],eax  ; [rsp+20h]=eax (i=i+1)
00007FFCC8720316  mov         eax,dword ptr [rsp+48h]  ; eax=[rsp+48h] (eax=step)
00007FFCC872031A  cmp         dword ptr [rsp+20h],eax  ; if [rsp+20h]&amp;lt;eax (i&amp;lt;step)
00007FFCC872031E  jl          00007FFCC87202C7         ; jump to loop start (i)
        }                                              
    }                                                  
00007FFCC8720320  jmp         00007FFCC8720322         
00007FFCC8720322  nop                                  
00007FFCC8720323  add         rsp,38h                  
00007FFCC8720327  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут всё хорошо, компиляция прошла максимально просто. А теперь взглянем на оптимизированную версию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; Optimization, JIT-x64
       for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC87201C2  push        rsi                     
00007FFCC87201C3  push        rdi                     
00007FFCC87201C4  push        r12                     
00007FFCC87201C6  push        r13                     
00007FFCC87201C8  push        r14                     
00007FFCC87201CA  push        r15                     
00007FFCC87201CC  sub         rsp,28h                 
00007FFCC87201D0  mov         ebx,edx                 ; ebx=step
00007FFCC87201D2  mov         r12,rcx                 ; r12=&amp;amp;this
00007FFCC87201D5  lea         r15d,[rbx+0Ah]          ; r15d=rbx+10 (r15d=step+10)
00007FFCC87201D9  test        ebx,ebx                 
00007FFCC87201DB  jle         00007FFCC8720260        
00007FFCC87201E1  xor         esi,esi                 ; esi=0 (i=0)
00007FFCC87201E3  mov         edi,0Ah                 ; edi=10 ((i+10)=10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00007FFCC87201E8  mov         ebp,2                   ; ebp=2
00007FFCC87201ED  imul        ebp,ebx                 ; ebp*=ebx (ebp=2*step)
        {                                             
            bar = i + 10;                             
00007FFCC87201F0  mov         dword ptr [r12+8],edi   ; bar=edi
            for (int j = 0; j &amp;lt; 2 * step; j += step)  
00007FFCC87201F5  test        ebp,ebp                 
00007FFCC87201F7  jle         00007FFCC8720256        
00007FFCC87201F9  xor         r13d,r13d               ; r13d=0 (j=0)
00007FFCC87201FC  mov         r14d,0Ah                ; r14d=10                     // !!!
00007FFCC8720202  nop         word ptr [rax+rax]      
00007FFCC8720210  mov         rax,0FC2B841138h        
00007FFCC872021A  mov         rax,qword ptr [rax]     
00007FFCC872021D  test        rax,rax                 
00007FFCC8720220  jne         00007FFCC8720230        
00007FFCC8720222  mov         cl,1                    
00007FFCC8720224  call        00007FFD26C0D960        
00007FFCC8720229  nop         dword ptr [rax]         
00007FFCC8720230  mov         rcx,0FC2B841138h        
00007FFCC872023A  mov         rcx,qword ptr [rcx]     
00007FFCC872023D  mov         rax,qword ptr [rcx]     
00007FFCC8720240  mov         r8,qword ptr [rax+60h]  
00007FFCC8720244  mov         edx,r14d                ; edx=r14d                     // !!!
00007FFCC8720247  call        qword ptr [r8+28h]      ; Console.WriteLine(edx)       // !!!
00007FFCC872024B  add         r13d,ebx                ; r13d+=ebx (j+=step)
00007FFCC872024E  add         r14d,r15d               ; r14d+=r15d (r14d+=(step+10)) // !!!
00007FFCC8720251  cmp         r13d,ebp                ; if r13d&amp;lt;ebp (j&amp;lt;2*step)
00007FFCC8720254  jl          00007FFCC8720210        ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                
00007FFCC8720256  inc         esi                     ; esi++ (i++)
00007FFCC8720258  inc         edi                     ; edi++ ((i+10)++)
00007FFCC872025A  cmp         esi,ebx                 ; if esi&amp;lt;ebx (i&amp;lt;step)
00007FFCC872025C  jl          00007FFCC87201F0        ; jump to loop start (i)
00007FFCC872025E  xchg        ax,ax                   
00007FFCC8720260  add         rsp,28h                 
00007FFCC8720264  pop         r15                     
00007FFCC8720266  pop         r14                     
00007FFCC8720268  pop         r13                     
00007FFCC872026A  pop         r12                     
00007FFCC872026C  pop         rdi                     
00007FFCC872026D  pop         rsi                     
00007FFCC872026E  pop         rbp                     
00007FFCC872026F  pop         rbx                     
00007FFCC8720270  ret                                 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы какое-то время поизучаете приведённый листинг, то увидите, что проблема кроется в регистре &lt;code&gt;r14d&lt;/code&gt;, который используется для вывода. В начале вложенного цикла он инициализируется значением &lt;code&gt;10&lt;/code&gt;, а на каждой итерации увеличивается на &lt;code&gt;step+10&lt;/code&gt; (хотя должен просто на &lt;code&gt;step&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;В MS Connect заведён &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/812093/&quot;&gt;баг-репорт&lt;/a&gt; по этому поводу. Увы, статус бага не радует:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Status: Closed as Won&#39;t Fix Won&#39;t Fix. Due to several factors the product team decided to focus its efforts on other items.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;ryujit&quot;&gt;RyuJIT&lt;/h3&gt;
&lt;p&gt;Скачаем и установим RyuJIT CTP5, поставим волшебный ключ в реестре &lt;code&gt;HKLM\SOFTWARE\Microsoft\.NETFramework\AltJit=&#39;*&#39;&lt;/code&gt; и вновь взглянем на ассемблер под x64:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;; Optimization, RyuJIT
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC86F0160  push        r14                      
00007FFCC86F0162  push        rdi                      
00007FFCC86F0163  push        rsi                      
00007FFCC86F0164  push        rbp                      
00007FFCC86F0165  push        rbx                      
00007FFCC86F0166  sub         rsp,20h                  
00007FFCC86F016A  mov         rdi,rcx                  ; rdi=&amp;amp;this
00007FFCC86F016D  mov         esi,edx                  ; esi=edx (esi=step)
00007FFCC86F016F  xor         ebx,ebx                  ; ebx=0 (i=0)
00007FFCC86F0171  test        esi,esi                  
00007FFCC86F0173  jle         00007FFCC86F01AA         
00007FFCC86F0175  mov         ebp,esi                  ; ebp=esi (ebp=step)
00007FFCC86F0177  shl         ebp,1                    ; ebp*=2 (ebp=2*step)
        {                                              
            bar = i + 10;                              
00007FFCC86F0179  lea         eax,[rbx+0Ah]            ; eax=[rbx+0Ah] (eax=i+10)
00007FFCC86F017C  mov         dword ptr [rdi+8],eax    ; [rdi+8]=eax (bar=i+10)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC86F017F  xor         r14d,r14d                ; r14d=0 (j=0)
00007FFCC86F0182  test        ebp,ebp                  
00007FFCC86F0184  jle         00007FFCC86F01A4         
                Console.WriteLine(j + 10);             
00007FFCC86F0186  call        00007FFD26C0AFA0         
00007FFCC86F018B  mov         rcx,rax                  
00007FFCC86F018E  lea         edx,[r14+0Ah]            ; edx=r14+0Ah (edx=j+10)
00007FFCC86F0192  mov         rax,qword ptr [rax]      
00007FFCC86F0195  mov         rax,qword ptr [rax+60h]  
00007FFCC86F0199  call        qword ptr [rax+28h]      ; Console.WriteLine(edx)
            for (int j = 0; j &amp;lt; 2 * step; j += step)   
00007FFCC86F019C  add         r14d,esi                 ; r14d+=esi (j+=step)
00007FFCC86F019F  cmp         r14d,ebp                 ; if (r14d&amp;lt;ebp) (j&amp;lt;2*step)
00007FFCC86F01A2  jl          00007FFCC86F0186         ; jump to loop start (j)
        for (int i = 0; i &amp;lt; step; i++)                 
00007FFCC86F01A4  inc         ebx                      ; ebx++ (i++)
00007FFCC86F01A6  cmp         ebx,esi                  ; if ebx&amp;lt;esi (i&amp;lt;step)
00007FFCC86F01A8  jl          00007FFCC86F0179         ; jump to loop start (i)
00007FFCC86F01AA  add         rsp,20h                  
00007FFCC86F01AE  pop         rbx                      
00007FFCC86F01AF  pop         rbp                      
00007FFCC86F01B0  pop         rsi                      
00007FFCC86F01B1  pop         rdi                      
00007FFCC86F01B2  pop         r14                      
00007FFCC86F01B4  ret                                  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё хорошо: никаких хитрых оптимизаций нет, код работает корректно.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;В JIT-x86 описываемого бага не было, в RyuJIT CTP5 всё также работает нормально. А вот в JIT-x64 проблема есть. Скорее всего, она уже никуда не денется.&lt;/p&gt;
&lt;p&gt;Нужно понимать, что нет совершенных программных продуктов. .NET не исключение. Баги в JIT встречаются крайне редко, но полезно иметь в виду их потенциальную возможность.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/20701701/jit-net-compiler-bug&quot;&gt;StackOverflow: JIT .Net compiler bug?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/812093/x64-jitter-sub-expression-elimination-optimizer-bug&quot;&gt;MS Connect: x64 jitter sub-expression elimination optimizer bug&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>A story about JIT-x86 inlining and starg</title>
            <link>http://aakinshin.net/posts/inlining-and-starg/</link> 
            <pubDate>Thu, 26 Feb 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/inlining-and-starg/</guid>
            <description>&lt;p&gt;Sometimes you can learn a lot during reading source .NET. Let&#39;s open the source code of a &lt;code&gt;Decimal&lt;/code&gt; constructor from .NET Reference Source (&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;mscorlib/system/decimal.cs,158&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Constructs a Decimal from an integer value.
//
public Decimal(int value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    int value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = value_copy;
    mid = 0;
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The comment states that JIT-x86 can&#39;t apply the inlining optimization for a method that contains the &lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;starg&lt;/a&gt; IL-opcode. Curious, is not it? &lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;the-jit-sources&quot;&gt;The JIT sources&lt;/h3&gt;
&lt;p&gt;Let&#39;s examine the situation and open the JIT source codes from CoreCLR. The fragment of &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;flowgraph.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// NetCF had some strict restrictions on inlining.  Specifically they
// would only inline methods that fit a specific pattern of loading
// arguments inorder, starting with zero, with no skipping, but not
// needing to load all of them.  Then a &#39;body&#39; section that could do
// anything besides control flow.  And a final ending ret opcode.
// Lastly they did not allow starg or ldarga.
// These simplifications allowed them to skip past the ldargs, when
// inlining, and just use the caller&#39;s EE stack as the callee&#39;s EE
// stack, after optionally popping a few &#39;arguments&#39; from the end.
//
// stateNetCFQuirks is a simple state machine to track that state
// and allow us to match those restrictions.
// State -1 means we&#39;re not tracking (no quirks mode)
// State 0 though 0x0000FFFF tracks what the *next* ldarg should be
//    to match the pattern
// State 0x00010000 and above means we are in the &#39;body&#39; section and
//    thus no more ldarg&#39;s are allowed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It states that inlining can&#39;t be applied for a method with opcodes &lt;code&gt;starg&lt;/code&gt; or &lt;code&gt;ldarga&lt;/code&gt;. Let&#39;s read the below code and make sure that this is true:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;switch (opcode)

// ...

    case CEE_STARG:
    case CEE_STARG_S:     goto ARG_WRITE;

    case CEE_LDARGA:
    case CEE_LDARGA_S:
    case CEE_LDLOCA:
    case CEE_LDLOCA_S:    goto ADDR_TAKEN;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;starg&lt;/code&gt; case is the simplest, let&#39;s look to the corresponding code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ARG_WRITE:
            if (compIsForInlining())
            {

#ifdef DEBUG
                if (verbose)
                {
                    printf(&amp;quot;\n\nInline expansion aborted due to opcode at offset [%02u] which writes to an argument\n&amp;quot;,
                           codeAddr-codeBegp-1);
                }
#endif

                /* The inliner keeps the args as trees and clones them.  Storing the arguments breaks that
                 * simplification.  To allow this, flag the argument as written to and spill it before
                 * inlining.  That way the STARG in the inlinee is trivial. */
                inlineFailReason = &amp;quot;Inlinee writes to an argument.&amp;quot;;
                goto InlineNever;
            }
            else
            {
                noway_assert(sz == sizeof(BYTE) || sz == sizeof(WORD));
                if (codeAddr &amp;gt; codeEndp - sz)
                goto TOO_FAR;
                varNum = (sz == sizeof(BYTE)) ? getU1LittleEndian(codeAddr)
                                              : getU2LittleEndian(codeAddr);
                varNum = compMapILargNum(varNum); // account for possible hidden param

                // This check is only intended to prevent an AV.  Bad varNum values will later
                // be handled properly by the verifier.
                if (varNum &amp;lt; lvaTableCnt)
                    lvaTable[varNum].lvArgWrite = 1;
            }
            break;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, for the &lt;code&gt;starg&lt;/code&gt; case, &lt;code&gt;goto InlineNever&lt;/code&gt; will be executed. In the &lt;code&gt;Debug&lt;/code&gt; moode, you also receive a message about aborted inlining.&lt;/p&gt;
&lt;p&gt;This “feature” uses in other JIT source files. Let&#39;s open the following fragment from &lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;importer.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;/******************************************************************************
 Is this the original &amp;quot;this&amp;quot; argument to the call being inlined?
 
 Note that we do not inline methods with &amp;quot;starg 0&amp;quot;, and so we do not need to
 worry about it.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;look-to-the-decimal&quot;&gt;Look to the  Decimal&lt;/h3&gt;
&lt;p&gt;Let&#39;s go back to the &lt;code&gt;Decimal&lt;/code&gt; constructor and make sure that coping the &lt;code&gt;value&lt;/code&gt; argument to a local variable really helps. We will use &lt;a href=&quot;http://ilspy.net/&quot;&gt;ILSpy&lt;/a&gt; for examination of the source constructor IL code:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Methods
.method public hidebysig specialname rtspecialname 
  instance void .ctor (
    int32 &#39;value&#39;
  ) cil managed 
{
  .custom instance void __DynamicallyInvokableAttribute::.ctor() = (
    01 00 00 00
  )
  // Method begins at RVA 0x222e8
  // Code size 51 (0x33)
  .maxstack 2
  .locals init (
    [0] int32
  )

  IL_0000: ldarg.1
  IL_0001: stloc.0
  IL_0002: ldloc.0
  IL_0003: ldc.i4.0
  IL_0004: blt.s IL_000f

  IL_0006: ldarg.0
  IL_0007: ldc.i4.0
  IL_0008: stfld int32 System.Decimal::&#39;flags&#39;
  IL_000d: br.s IL_001d

  IL_000f: ldarg.0
  IL_0010: ldc.i4 -2147483648
  IL_0015: stfld int32 System.Decimal::&#39;flags&#39;
  IL_001a: ldloc.0
  IL_001b: neg
  IL_001c: stloc.0

  IL_001d: ldarg.0
  IL_001e: ldloc.0
  IL_001f: stfld int32 System.Decimal::lo
  IL_0024: ldarg.0
  IL_0025: ldc.i4.0
  IL_0026: stfld int32 System.Decimal::mid
  IL_002b: ldarg.0
  IL_002c: ldc.i4.0
  IL_002d: stfld int32 System.Decimal::hi
  IL_0032: ret
} // end of method Decimal::.ctor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What would have happened if we had not copied the &lt;code&gt;value&lt;/code&gt; in a local variable? Let&#39;s check. Write a simple code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class MyDecimal
{
  private const int SignMask  = unchecked((int)0x80000000);
  private int flags, hi, lo, mid;

  public MyDecimal(int value)
  {
    if (value &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value = -value;
    }
    lo = value;
    mid = 0;
    hi = 0;
  }
}
class Program
{
  static void Main()
  {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compilation:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;csc Program.cs /optimize
Microsoft (R) Visual C# Compiler version 4.0.30319.33440
for Microsoft (R) .NET Framework 4.5
Copyright (C) Microsoft Corporation. All rights reserved.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The resulted IL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class private auto ansi beforefieldinit MyDecimal
  extends [mscorlib]System.Object
{
  // Fields
  .field private static literal int32 SignMask = int32(-2147483648)
  .field private int32 &#39;flags&#39;
  .field private int32 hi
  .field private int32 lo
  .field private int32 mid

  // Methods
  .method public hidebysig specialname rtspecialname 
    instance void .ctor (
      int32 &#39;value&#39;
    ) cil managed 
  {
    // Method begins at RVA 0x2050
    // Code size 56 (0x38)
    .maxstack 8

    IL_0000: ldarg.0
    IL_0001: call instance void [mscorlib]System.Object::.ctor()
    IL_0006: ldarg.1
    IL_0007: ldc.i4.0
    IL_0008: blt.s IL_0013

    IL_000a: ldarg.0
    IL_000b: ldc.i4.0
    IL_000c: stfld int32 MyDecimal::&#39;flags&#39;
    IL_0011: br.s IL_0022

    IL_0013: ldarg.0
    IL_0014: ldc.i4 -2147483648
    IL_0019: stfld int32 MyDecimal::&#39;flags&#39;
    IL_001e: ldarg.1
    IL_001f: neg
    IL_0020: starg.s &#39;value&#39;

    IL_0022: ldarg.0
    IL_0023: ldarg.1
    IL_0024: stfld int32 MyDecimal::lo
    IL_0029: ldarg.0
    IL_002a: ldc.i4.0
    IL_002b: stfld int32 MyDecimal::mid
    IL_0030: ldarg.0
    IL_0031: ldc.i4.0
    IL_0032: stfld int32 MyDecimal::hi
    IL_0037: ret
  } // end of method MyDecimal::.ctor

} // end of class MyDecimal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, in the line &lt;code&gt;IL_0020&lt;/code&gt;, the &lt;code&gt;starg.a&lt;/code&gt; opcode appears. Authors of the .NET framework use the same approach for the &lt;code&gt;Decimal&lt;/code&gt; constructor with the &lt;code&gt;long&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Constructs a Decimal from a long value.
//
public Decimal(long value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    long value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = (int)value_copy;
    mid = (int)(value_copy &amp;gt;&amp;gt; 32);
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;check-the-jit-possibilities&quot;&gt;Check the JIT possibilities&lt;/h3&gt;
&lt;p&gt;Now, we want to make sure that JIT really have the described behavior. Let&#39;s write the simple code for checking:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        var value = 0;
        value += SimpleMethod(0x11);
        value += MethodWithStarg(0x12);
        value += MethodWithStargAggressive(0x13);
        Console.WriteLine(value);
    }

    static int SimpleMethod(int value)
    {
        return value;
    }

    static int MethodWithStarg(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static int MethodWithStargAggressive(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;SimpleMethod&lt;/code&gt; method is very small, it will be inlined. The &lt;code&gt;MethodWithStarg&lt;/code&gt; method has the following IL-representation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;.method private hidebysig static 
  int32 MethodWithStarg (
    int32 &#39;value&#39;
  ) cil managed 
{
  // Method begins at RVA 0x2086
  // Code size 10 (0xa)
  .maxstack 8

  IL_0000: ldarg.0
  IL_0001: ldc.i4.0
  IL_0002: bge.s IL_0008

  IL_0004: ldarg.0
  IL_0005: neg
  IL_0006: starg.s &#39;value&#39;

  IL_0008: ldarg.0
  IL_0009: ret
} // end of method Program::MethodWithStarg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the &lt;code&gt;IL_0006&lt;/code&gt; line, this code contains the target &lt;code&gt;starg.s&lt;/code&gt; opcode. The &lt;code&gt;MethodWithStargAggressive&lt;/code&gt; method have the same body, but it also has the &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt; attribute. Let&#39;s look to the assembler code for x86:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;008A0050  push        ebp  
008A0051  mov         ebp,esp  
008A0053  push        esi  
008A0054  mov         ecx,12h  
008A0059  call        dword ptr ds:[7237BCh]  // MethodWithStarg
008A005F  add         eax,11h  
008A0062  mov         esi,eax  
008A0064  mov         ecx,13h  
008A0069  call        dword ptr ds:[7237C8h]  // MethodWithStargAggressive
008A006F  add         esi,eax  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The experiment was a success. &lt;code&gt;SimpleMethod&lt;/code&gt; was inlined as we expected. &lt;code&gt;MethodWithStarg&lt;/code&gt; wasn&#39;t be inlined because it contains the &lt;code&gt;starg.s&lt;/code&gt; opcode. Note, &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt; didn&#39;t help to &lt;code&gt;MethodWithStargAggressive&lt;/code&gt; inlining.&lt;/p&gt;
&lt;p&gt;Now we will look to the assembler code for x64:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00007FFCC8720094  mov         ecx,36h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, JIT has successfully performed inlining for all method and precalculated the result.&lt;/p&gt;
&lt;h3 id=&quot;summary&quot;&gt;Summary&lt;/h3&gt;
&lt;p&gt;Specific condition should be satisfied for successfully inlining. JIT-x86 can&#39;t apply the inlining optimization for method that contain the &lt;code&gt;starg&lt;/code&gt; or&lt;code&gt;ldarga&lt;/code&gt; opcodes regardless the &lt;code&gt;MethodImpl&lt;/code&gt; attribute. Sometimes, if you really need inlining of some method, you have to make some hacks like we can observe in the &lt;code&gt;Decimal&lt;/code&gt; constructors.&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;Links&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;.NET Reference Source: Constructs a Decimal from an integer value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;CoreCLR, JIT sources: flowgraph.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;CoreCLR, JIT sources: importer.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;MSDN: starg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.ldarga.aspx&quot;&gt;MSDN: ldarga&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/26369163/net-local-variable-optimization&quot;&gt;Stackoverflow: .NET local variable optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>История про инлайнинг под JIT-x86 и starg</title>
            <link>http://aakinshin.net/ru/posts/inlining-and-starg/</link> 
            <pubDate>Thu, 26 Feb 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/inlining-and-starg/</guid>
            <description>&lt;p&gt;Порой можно узнать много интересного во время чтения исходников .NET. Взглянем на конструктор типа &lt;code&gt;Decimal&lt;/code&gt; из .NET Reference Source (&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;mscorlib/system/decimal.cs,158&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Constructs a Decimal from an integer value.
//
public Decimal(int value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    int value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = value_copy;
    mid = 0;
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В комментарии сказано, что если метод содержит IL-опкод &lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;starg&lt;/a&gt;, то он не может быть заинлайнен под x86. Любопытно, не правда ли?&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;jit&quot;&gt;Исходники JIT&lt;/h3&gt;
&lt;p&gt;Давайте разберёмся в ситуации. Заглянем в исходники JIT из CoreCLR. Фрагмент файла &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;flowgraph.cpp&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// NetCF had some strict restrictions on inlining.  Specifically they
// would only inline methods that fit a specific pattern of loading
// arguments inorder, starting with zero, with no skipping, but not
// needing to load all of them.  Then a &#39;body&#39; section that could do
// anything besides control flow.  And a final ending ret opcode.
// Lastly they did not allow starg or ldarga.
// These simplifications allowed them to skip past the ldargs, when
// inlining, and just use the caller&#39;s EE stack as the callee&#39;s EE
// stack, after optionally popping a few &#39;arguments&#39; from the end.
//
// stateNetCFQuirks is a simple state machine to track that state
// and allow us to match those restrictions.
// State -1 means we&#39;re not tracking (no quirks mode)
// State 0 though 0x0000FFFF tracks what the *next* ldarg should be
//    to match the pattern
// State 0x00010000 and above means we are in the &#39;body&#39; section and
//    thus no more ldarg&#39;s are allowed.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Комментарий гласит, что если метод содержит IL-команду &lt;code&gt;starg&lt;/code&gt; или &lt;code&gt;ldarga&lt;/code&gt;, то инлайнинг не выполнится. Почитаем код и убедимся, что это действительно так. Вскоре после комментария происходит выбор опкода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;switch (opcode)

// ...

    case CEE_STARG:
    case CEE_STARG_S:     goto ARG_WRITE;

    case CEE_LDARGA:
    case CEE_LDARGA_S:
    case CEE_LDLOCA:
    case CEE_LDLOCA_S:    goto ADDR_TAKEN;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Случай с командой &lt;code&gt;starg&lt;/code&gt; попроще, взглянем на него более внимательно:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cpp&quot;&gt;ARG_WRITE:
            if (compIsForInlining())
            {

#ifdef DEBUG
                if (verbose)
                {
                    printf(&amp;quot;\n\nInline expansion aborted due to opcode at offset [%02u] which writes to an argument\n&amp;quot;,
                           codeAddr-codeBegp-1);
                }
#endif

                /* The inliner keeps the args as trees and clones them.  Storing the arguments breaks that
                 * simplification.  To allow this, flag the argument as written to and spill it before
                 * inlining.  That way the STARG in the inlinee is trivial. */
                inlineFailReason = &amp;quot;Inlinee writes to an argument.&amp;quot;;
                goto InlineNever;
            }
            else
            {
                noway_assert(sz == sizeof(BYTE) || sz == sizeof(WORD));
                if (codeAddr &amp;gt; codeEndp - sz)
                goto TOO_FAR;
                varNum = (sz == sizeof(BYTE)) ? getU1LittleEndian(codeAddr)
                                              : getU2LittleEndian(codeAddr);
                varNum = compMapILargNum(varNum); // account for possible hidden param

                // This check is only intended to prevent an AV.  Bad varNum values will later
                // be handled properly by the verifier.
                if (varNum &amp;lt; lvaTableCnt)
                    lvaTable[varNum].lvArgWrite = 1;
            }
            break;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Действительно, всё выглядит так, что для опкода &lt;code&gt;starg&lt;/code&gt; в конечном итоге выполнится &lt;code&gt;goto InlineNever&lt;/code&gt;. В &lt;code&gt;DEBUG&lt;/code&gt;-режиме мы также получим сообщение, что процесс инлайнинга был прерван.&lt;/p&gt;
&lt;p&gt;Эта &#171;фича&#187; используется в других местах JIT-а. Взглянем на фрагмент файла &lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;importer.cpp&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;/******************************************************************************
 Is this the original &amp;quot;this&amp;quot; argument to the call being inlined?
 
 Note that we do not inline methods with &amp;quot;starg 0&amp;quot;, and so we do not need to
 worry about it.
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;decimal&quot;&gt;Смотрим на Decimal&lt;/h3&gt;
&lt;p&gt;Вернёмся к нашему конструктору класса &lt;code&gt;Decimal&lt;/code&gt;, убедимся, что копирование параметра &lt;code&gt;value&lt;/code&gt; в локальную переменную действительно помогает. Вооружимся &lt;a href=&quot;http://ilspy.net/&quot;&gt;ILSpy&lt;/a&gt; и взглянем на IL-код нашего конструктора:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Methods
.method public hidebysig specialname rtspecialname 
  instance void .ctor (
    int32 &#39;value&#39;
  ) cil managed 
{
  .custom instance void __DynamicallyInvokableAttribute::.ctor() = (
    01 00 00 00
  )
  // Method begins at RVA 0x222e8
  // Code size 51 (0x33)
  .maxstack 2
  .locals init (
    [0] int32
  )

  IL_0000: ldarg.1
  IL_0001: stloc.0
  IL_0002: ldloc.0
  IL_0003: ldc.i4.0
  IL_0004: blt.s IL_000f

  IL_0006: ldarg.0
  IL_0007: ldc.i4.0
  IL_0008: stfld int32 System.Decimal::&#39;flags&#39;
  IL_000d: br.s IL_001d

  IL_000f: ldarg.0
  IL_0010: ldc.i4 -2147483648
  IL_0015: stfld int32 System.Decimal::&#39;flags&#39;
  IL_001a: ldloc.0
  IL_001b: neg
  IL_001c: stloc.0

  IL_001d: ldarg.0
  IL_001e: ldloc.0
  IL_001f: stfld int32 System.Decimal::lo
  IL_0024: ldarg.0
  IL_0025: ldc.i4.0
  IL_0026: stfld int32 System.Decimal::mid
  IL_002b: ldarg.0
  IL_002c: ldc.i4.0
  IL_002d: stfld int32 System.Decimal::hi
  IL_0032: ret
} // end of method Decimal::.ctor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А что было бы, если бы мы не скопировали &lt;code&gt;value&lt;/code&gt; в локальную переменную? Давайте проверим. Напишем простой код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class MyDecimal
{
  private const int SignMask  = unchecked((int)0x80000000);
  private int flags, hi, lo, mid;

  public MyDecimal(int value)
  {
    if (value &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value = -value;
    }
    lo = value;
    mid = 0;
    hi = 0;
  }
}
class Program
{
  static void Main()
  {
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Скомпилируем его:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;csc Program.cs /optimize
Microsoft (R) Visual C# Compiler version 4.0.30319.33440
for Microsoft (R) .NET Framework 4.5
Copyright (C) Microsoft Corporation. All rights reserved.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И взглянем на IL:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class private auto ansi beforefieldinit MyDecimal
  extends [mscorlib]System.Object
{
  // Fields
  .field private static literal int32 SignMask = int32(-2147483648)
  .field private int32 &#39;flags&#39;
  .field private int32 hi
  .field private int32 lo
  .field private int32 mid

  // Methods
  .method public hidebysig specialname rtspecialname 
    instance void .ctor (
      int32 &#39;value&#39;
    ) cil managed 
  {
    // Method begins at RVA 0x2050
    // Code size 56 (0x38)
    .maxstack 8

    IL_0000: ldarg.0
    IL_0001: call instance void [mscorlib]System.Object::.ctor()
    IL_0006: ldarg.1
    IL_0007: ldc.i4.0
    IL_0008: blt.s IL_0013

    IL_000a: ldarg.0
    IL_000b: ldc.i4.0
    IL_000c: stfld int32 MyDecimal::&#39;flags&#39;
    IL_0011: br.s IL_0022

    IL_0013: ldarg.0
    IL_0014: ldc.i4 -2147483648
    IL_0019: stfld int32 MyDecimal::&#39;flags&#39;
    IL_001e: ldarg.1
    IL_001f: neg
    IL_0020: starg.s &#39;value&#39;

    IL_0022: ldarg.0
    IL_0023: ldarg.1
    IL_0024: stfld int32 MyDecimal::lo
    IL_0029: ldarg.0
    IL_002a: ldc.i4.0
    IL_002b: stfld int32 MyDecimal::mid
    IL_0030: ldarg.0
    IL_0031: ldc.i4.0
    IL_0032: stfld int32 MyDecimal::hi
    IL_0037: ret
  } // end of method MyDecimal::.ctor

} // end of class MyDecimal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как мы видим, в строчке &lt;code&gt;IL_0020&lt;/code&gt; действительно вызывается команда &lt;code&gt;starg.a&lt;/code&gt;. Подобный приём используется также в конструкторе, который принимает аргумент типа &lt;code&gt;long&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Constructs a Decimal from a long value.
//
public Decimal(long value) {
    //  JIT today can&#39;t inline methods that contains &amp;quot;starg&amp;quot; opcode.
    //  For more details, see DevDiv Bugs 81184: x86 JIT CQ: Removing the inline striction of &amp;quot;starg&amp;quot;.
    long value_copy = value;
    if (value_copy &amp;gt;= 0) {
        flags = 0;
    }
    else {
        flags = SignMask;
        value_copy = -value_copy;
    }
    lo = (int)value_copy;
    mid = (int)(value_copy &amp;gt;&amp;gt; 32);
    hi = 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;jit-1&quot;&gt;Проверяем возможности JIT&lt;/h3&gt;
&lt;p&gt;Для полноты исследования осталось убедиться, что JIT действительно себя ведёт именно так. Напишем простой код для проверки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Runtime.CompilerServices;

class Program
{
    static void Main()
    {
        var value = 0;
        value += SimpleMethod(0x11);
        value += MethodWithStarg(0x12);
        value += MethodWithStargAggressive(0x13);
        Console.WriteLine(value);
    }

    static int SimpleMethod(int value)
    {
        return value;
    }

    static int MethodWithStarg(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static int MethodWithStargAggressive(int value)
    {
        if (value &amp;lt; 0)
            value = -value;
        return value;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Метод &lt;code&gt;SimpleMethod&lt;/code&gt; очень маленький и будет заинлайнен. Метод &lt;code&gt;MethodWithStarg&lt;/code&gt; имеет следующее IL-представление:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;.method private hidebysig static 
  int32 MethodWithStarg (
    int32 &#39;value&#39;
  ) cil managed 
{
  // Method begins at RVA 0x2086
  // Code size 10 (0xa)
  .maxstack 8

  IL_0000: ldarg.0
  IL_0001: ldc.i4.0
  IL_0002: bge.s IL_0008

  IL_0004: ldarg.0
  IL_0005: neg
  IL_0006: starg.s &#39;value&#39;

  IL_0008: ldarg.0
  IL_0009: ret
} // end of method Program::MethodWithStarg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данный код в строчке &lt;code&gt;IL_0006&lt;/code&gt; содержит интересующую нас команду &lt;code&gt;starg.s&lt;/code&gt;. Метод &lt;code&gt;MethodWithStargAggressive&lt;/code&gt; имеет аналогичный код с той лишь разнице, что для него указан атрибут &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt;. Взглянем на ассемблерный код под x86:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;008A0050  push        ebp  
008A0051  mov         ebp,esp  
008A0053  push        esi  
008A0054  mov         ecx,12h  
008A0059  call        dword ptr ds:[7237BCh]  // MethodWithStarg
008A005F  add         eax,11h  
008A0062  mov         esi,eax  
008A0064  mov         ecx,13h  
008A0069  call        dword ptr ds:[7237C8h]  // MethodWithStargAggressive
008A006F  add         esi,eax  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Эксперимент прошёл успешно. Метод &lt;code&gt;SimpleMethod&lt;/code&gt; был заинлайнен, как и предполагалось. Метод &lt;code&gt;MethodWithStarg&lt;/code&gt; не был заинлайнен, т. к. содержит IL-команду &lt;code&gt;starg.s&lt;/code&gt;. Даже атрибут &lt;code&gt;[MethodImpl(MethodImplOptions.AggressiveInlining)]&lt;/code&gt; не поспособствовал тому, чтобы инлайнинг был выполнен.&lt;/p&gt;
&lt;p&gt;А теперь взглянем на ассемблерный код под x64:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00007FFCC8720094  mov         ecx,36h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как мы видим, JIT успешно выполнил инлайнинг всех методов и заранее предподсчитал результат.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Для возможности инлайнинга методов необходимо выполнение ряда условий. JIT-x86 не может заинлайнить метод, в теле которого присутствуют IL-команды &lt;code&gt;starg&lt;/code&gt; или &lt;code&gt;ldarga&lt;/code&gt;, при этом даже &lt;code&gt;MethodImplOptions.AggressiveInlining&lt;/code&gt; не в силах на это повлиять. Если вам критично, чтобы JIT мог выполнять инлайнинг, то порой придётся делать костыли, подобные тем, которые мы можем наблюдать в конструкторах класса &lt;code&gt;Decimal&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/decimal.cs,158&quot;&gt;.NET Reference Source: Constructs a Decimal from an integer value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/blob/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/flowgraph.cpp#L4252&quot;&gt;CoreCLR, JIT sources: flowgraph.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://raw.githubusercontent.com/dotnet/coreclr/65456c070ffbc97f14c1c32318dabc221646d8d6/src/jit/importer.cpp&quot;&gt;CoreCLR, JIT sources: importer.cpp (Feb 26, 2015)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.starg.aspx&quot;&gt;MSDN: starg&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.reflection.emit.opcodes.ldarga.aspx&quot;&gt;MSDN: ldarga&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/26369163/net-local-variable-optimization&quot;&gt;Stackoverflow: .NET local variable optimization&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Как я блог на кренделёк переводил</title>
            <link>http://aakinshin.net/ru/posts/migration-to-pretzel/</link> 
            <pubDate>Thu, 26 Feb 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/migration-to-pretzel/</guid>
            <description>&lt;p&gt;Наконец-то у меня дошли руки, и я сделал себе статический блог. Раньше я писал посты в &lt;a href=&quot;http://aakinshin.blogspot.ru/&quot;&gt;aakinshin.blogspot.ru&lt;/a&gt; на Google Blogger aka blogspot, но много чего мне в нём не нравилось, отбивалось всё желание писать. Теперь всё работает через GitHub, писать посты можно в MarkDown, шаблоны делать через Razor, кастомизировать всё по своему вкусу. И мультиленг нормальный =). Под катом можно найти техническую информацию.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/notes/migration-to-pretzel/pretzel.png&quot; height=&quot;100px&quot; /&gt;
&lt;/p&gt;&lt;!--more--&gt;
&lt;h2 id=&quot;blogspot&quot;&gt;Что не так с Blogspot&lt;/h2&gt;
&lt;p&gt;Чудо-блогодвижок от Google раздражал меня по многим причинам. Обозначу некоторые из них:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Нет нормального редактора. Приходится верстать всё в HTML в примитивной форме без подсветки синтаксиса и валидаций.&lt;/li&gt;
&lt;li&gt;Нет нормального предварительного просмотра. Google рендерит только картинку будущего поста, в которую даже потыкать нельзя. А временами ещё и подтягивает местоположение по ip и рендерит всё в местной локали: скажем, если пользоваться функцией просмотра из Израиля, то велика вероятность увидеть большое количество иврита и right-to-left-вёрстку.&lt;/li&gt;
&lt;li&gt;Нет возможности кастомизировать URL-ы. Я перфекционист, и хочу, чтобы адреса постов формировались согласно моим представлениям об этом мире. Скажем, мне не нравится &lt;code&gt;.html&lt;/code&gt; в конце адреса. Указание текущего года и месяца в адресе также считаю лишним. А ещё хочется раскладывать посты по категориям, которые также бы присутствовали в URL-е.&lt;/li&gt;
&lt;li&gt;Нет возможности вести мультиленг-блог. Т. е., чтобы была возможность сделать русскую и английскую версию поста и легко между ними переключаться. Ну и, соответственно, чтобы были отдельные подверсии блога только с русскими и только английскими постами.&lt;/li&gt;
&lt;li&gt;Нет удобных возможностей для редактирования шаблона. Наверное, если потратить приличное количество времени, то можно в тамошнем редакторе что-то хорошее сделать, но мои попытки обернулись провалом.&lt;/li&gt;
&lt;li&gt;Нет возможности прикрутить любимый мною git, чтобы нормально работать с версиями.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В общем, решил я сделать себе статический блог.&lt;/p&gt;
&lt;h2 id=&quot;jekyll&quot;&gt;Jekyll&lt;/h2&gt;
&lt;p&gt;Интернет подсказал мне, что многие крутые ребята ведут свои блоги на &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;. Отличное решение, приведу понравившиеся мне возможности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Можно поднять блог через GitHub, прикрутить для отображения кастомный домен.&lt;/li&gt;
&lt;li&gt;Можно отлаживать блог локально без доступа к интернету.&lt;/li&gt;
&lt;li&gt;Можно писать посты в Markdown, а по мере надобности прибегать к HTML+CSS.&lt;/li&gt;
&lt;li&gt;Можно самому сформировать всю нужную разметку шаблонов на &lt;a href=&quot;https://github.com/Shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Можно относительно легко импортировать старые посты из Blogger.&lt;/li&gt;
&lt;li&gt;Можно прописывать все конфиги в YML.&lt;/li&gt;
&lt;li&gt;Можно расширять функциональность движка собственными плагинами.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В общем, всё было хорошо, ушли все проблемы, которые мне мешали жить во вселенной blogspot. Впрочем, возникли некоторые трудности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Из коробки было далеко не всё, что я хотел видеть в своём новом бложике. Пришлось писать плагины. Jekyll написан на Ruby. И плагины тоже нужно писать на Ruby. Пришлось на старости лет освоить новый язык. Мне даже понравилось, прикольный код получается. Но после написания нескольких плагинчиков пришло осознание, что мне далеко до такого уровня Ruby-мастерства, на котором я смогу сделать эти плагины нормально. Эх, вот можно было бы нужный функционал писать на C#, было бы счастье.&lt;/li&gt;
&lt;li&gt;Liquid прикольный, но на нём далеко не всё делается настолько просто, настолько хотелось бы. Вот дали бы мне мой любимый Razor, жить было бы легче.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;И я понял, что мне в идеале нужен аналог Jekyll, но только на .NET-стеке.&lt;/p&gt;
&lt;h2 id=&quot;pretzel&quot;&gt;Pretzel&lt;/h2&gt;
&lt;p&gt;Ещё немного поиска в интернете — и я нашёл его! Отличный проект под названием &lt;a href=&quot;https://github.com/Code52/pretzel&quot;&gt;pretzel&lt;/a&gt;. Совместим с Jekyll, можно писать функционал на C# и верстать шаблоны на Razor. Увы, проект немного сыроват, многие нужные штуки не работали. Пришлось чутка &lt;a href=&quot;https://github.com/Code52/pretzel/commits/master?author=AndreyAkinshin&quot;&gt;поконтрибьютить&lt;/a&gt; в проект, чтобы мой Jekyll-блог на нём завёлся. Затем ушло какое-то время, чтобы сделать нормальный мультиленг и сверстать всё так, чтобы выглядело хотя бы более или менее вменяемо. С базовой частью я наконец-то справился, блог завёлся и опубликовался в интернете. Остался, правда, небольшой набор тикетов (например, пагинатор, странички для тегов и категорий, косяки в вёрстке и т. п.), но я надеюсь решить их в рабочем режиме. Главное — теперь есть удобный инструмент для написания постов. За последние месяцы у меня накопилось много интересных заметок, планирую оформить их в обозримом будущем в письменном виде. Надеюсь, моя писанина окажется полезной для других разработчиков.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Статические поля в generic-классах</title>
            <link>http://aakinshin.net/ru/posts/static-field-in-generic-type/</link> 
            <pubDate>Wed, 21 Jan 2015 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/static-field-in-generic-type/</guid>
            <description>&lt;p&gt;Сегодня мы кратко поговорим о статических полях в generic-классах. Тема простая, но у некоторых разработчиков она вызывает трудности. Итак, задачка: что выведет следующий код?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;class Foo&amp;lt;T&amp;gt;
{
  public static int Bar;
}
void Main()
{
  Foo&amp;lt;int&amp;gt;.Bar++;
  Console.WriteLine(Foo&amp;lt;double&amp;gt;.Bar);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;em&gt;Правильный ответ:&lt;/em&gt; &lt;code&gt;0&lt;/code&gt;. Всё дело в том, что &lt;code&gt;Foo&amp;lt;int&amp;gt;&lt;/code&gt; и &lt;code&gt;Foo&amp;lt;double&amp;gt;&lt;/code&gt; — это два разных класса, у каждого своё собственное статическое поле. И это весьма логично. Действительно, раз у нас есть поле, то оно должно принадлежать экземпляру какого-то класса, а экземпляр &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; создать невозможно, необходимо явно указать &lt;code&gt;T&lt;/code&gt;. Как можно догадаться, &lt;code&gt;typeof(Foo&amp;lt;int&amp;gt;) != typeof(Foo&amp;lt;double&amp;gt;)&lt;/code&gt;, поэтому каждый класс получит собственное статическое поле. Если поменять значение этого поля в одном классе, то это никак не повлияет на значение соответствующего поля в другом классе. Вроде бы просто, но не всем очевидно: мне доводилось видеть, как данный нюанс вызывал проблемы в продакшн-проектах. Поэтому я и решил написать небольшую заметку по этому поводу.&lt;/p&gt;
&lt;p&gt;Приведу также цитату из документации языка C#. &lt;strong&gt;CSharp Language Specification 5.0, 10.5.1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When a field declaration includes a  static modifier, the fields introduced by the declaration are static fields. When no  static modifier is present, the fields introduced by the declaration are instance fields. Static fields and instance fields are two of the several kinds of variables (&#167;5) supported by C#, and at times they are referred to as static variables and instance variables, respectively. A static field is not part of a specific instance; instead, it is shared amongst all instances of a closed type (&#167;4.4.2). No matter how many instances of a closed class type are created, there is only ever one copy of a static field for the associated application domain.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;У MS в разделе &lt;strong&gt;Code Analysis for Managed Code Warnings&lt;/strong&gt; есть такое предупреждение: &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms182139.aspx&quot;&gt;CA1000&lt;/a&gt;: Do not declare static members on generic types (DoNotDeclareStaticMembersOnGenericTypes). Ну и, само собой, в ReSharper также есть подобный warning под названием StaticMemberInGenericType (см. &lt;a href=&quot;https://confluence.jetbrains.com/display/ReSharper/Static+field+in+generic+type&quot;&gt;ReSharper wiki&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Мораль:&lt;/strong&gt; старайтесь не делать изменяемые статические поля в generic-классах. А ещё лучше — просто старайтесь не делать изменяемые статические поля. Как правило, в нормальном проекте такую потребность всегда можно обойти с помощью красивого архитектурного решения. Даже если вы считаете, что изменяемое статическое поле вам просто необходимо, и при этом прекрасно понимаете нюансы, связанные с его использованием в generic-классах (используете эту фичу в своих целях), то помните, что кто-нибудь, кто будет работать с вашим кодом, может не понять авторскую задумку и чего-нибудь испортить или использовать не по плану. А архитектуру нужно стараться делать так, чтобы что-то испортить было чертовски сложно.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Задачи&lt;/h3&gt;
&lt;p&gt;Приведённая задачка доступна в &lt;a href=&quot;http://problembook.net/&quot;&gt;ProblemBookt.NET&lt;/a&gt; &lt;a href=&quot;http://problembook.net/content/ru/Oop/StaticFieldInGenericType-P.html&quot;&gt;на русском&lt;/a&gt; и &lt;a href=&quot;http://problembook.net/content/en/Oop/StaticFieldInGenericType-P.html&quot;&gt;на английском&lt;/a&gt;.&lt;/p&gt;</description>
        </item>
        <item>
            <title>List.ForEach в .NET 4.5</title>
            <link>http://aakinshin.net/ru/posts/listforeach-net-45/</link> 
            <pubDate>Mon, 24 Nov 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/listforeach-net-45/</guid>
            <description>&lt;p&gt;Продолжим обсуждать &lt;a href=&quot;http://aakinshin.blogspot.ru/2014/11/dotnet-list-version-side-effect.html&quot;&gt;тему&lt;/a&gt; изменения коллекции внутри цикла &lt;code&gt;foreach&lt;/code&gt;. Следующий код&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var list = new List&amp;lt;int&amp;gt; { 1, 2 };
foreach (var i in list)
{
    if (i == 1)
        list.Add(3);
    Console.WriteLine(i);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;выбросит &lt;code&gt;InvalidOperationException&lt;/code&gt;. А как думаете, что случится при выполнении цикла через &lt;a href=&quot;http://msdn.microsoft.com/library/bwabdf9z.aspx&quot;&gt;List&amp;lt;T&amp;gt;.ForEach&lt;/a&gt;?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var list = new List&amp;lt;int&amp;gt; { 1, 2 };
list.ForEach(i =&amp;gt;
{
    if (i == 1)
        list.Add(3);
    Console.WriteLine(i);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Правильный ответ: зависит.&lt;!--more--&gt; Ранее (.NET 4.0) данный код замечательно отрабатывал и выводил &lt;code&gt;1 2 3&lt;/code&gt;. Это было не очень хорошо. Поэтому в .NET 4.5 поведение поменялось, &lt;code&gt;ForEach&lt;/code&gt; начал бросать &lt;code&gt;InvalidOperationException&lt;/code&gt; для случая, если кто-то внутри цикла менял коллекцию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void ForEach(Action&amp;lt;T&amp;gt; action) {
  if( action == null) { 
    ThrowHelper.ThrowArgumentNullException(ExceptionArgument.match);
  } 
  Contract.EndContractBlock();

  int version = _version;

  for(int i = 0 ; i &amp;lt; _size; i++) {
    if (version != _version &amp;amp;&amp;amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5) { 
      break; 
    }
    action(_items[i]); 
  }

  if (version != _version &amp;amp;&amp;amp; BinaryCompatibility.TargetsAtLeast_Desktop_V4_5)
    ThrowHelper.ThrowInvalidOperationException(
        ExceptionResource.InvalidOperation_EnumFailedVersion); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span style=&quot;text-decoration: line-through;&quot;&gt;Что касается Mono, то в нём никаких исключение не бросается (даже в последнем стабильном на текущий момент Mono 3.10).&lt;/span&gt; Когда я узнал, что в Mono 3.10 всё плохо, то очень расстроился. А потом пошёл и завёл &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=24775&quot;&gt;баг-репорт&lt;/a&gt;. Вскоре баг был &lt;a href=&quot;https://github.com/mono/mono/commit/5517c56afa66f4d54575b01adb86fe1577128c01&quot;&gt;исправлен&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;А в старых версий (например, 2.10) был &lt;a href=&quot;http://lists.ximian.com/pipermail/mono-bugs/2011-June/112085.html&quot;&gt;баг&lt;/a&gt;, в результате которого исключение не происходило даже внутри обычного &lt;code&gt;foreach&lt;/code&gt;, если коллекцию менять через индексатор (&lt;a href=&quot;http://ideone.com/A3DbN&quot;&gt;ideone&lt;/a&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;

namespace test
{
    public class test
    {
        public static void Main()
        {
            List x = new List();
            x.Add(1);
            x.Add(4);
            x.Add(9);
            foreach(int i in x){
                x[2] = 3;
            }
            foreach(int i in x){
                System.Console.WriteLine(i);
            }
        }
    }
}

Actual Results (Mono 2.10):
1
4
3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/webdev/archive/2012/11/19/all-about-httpruntime-targetframework.aspx&quot;&gt;.NET Web Development and Tools Blog: All about : All about &amp;lt;httpRuntime targetFramework&amp;gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/dotnet/archive/2012/10/17/net-framework-4-5-off-to-a-great-start.aspx&quot;&gt;.NET Framework Blog: .NET Framework 4.5 – Off to a great start&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AndreyAkinshin/ItDepends.NET/tree/master/ListForEach&quot;&gt;ItDepends.NET: ListForEach&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/library/system.invalidoperationexception.aspx&quot;&gt;MSDN: InvalidOperationException&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lists.ximian.com/pipermail/mono-bugs/2011-June/112085.html&quot;&gt;Mono Bug 699182: Modifications to a Collection via indexer during foreach should throw InvalidOperationException&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=24775&quot;&gt;Mono Bug 24775: List.ForEach does not throw InvalidOperationException when collection was modified&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Сайд-эффект внутренней реализации List</title>
            <link>http://aakinshin.net/ru/posts/list-version-side-effect/</link> 
            <pubDate>Wed, 19 Nov 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/list-version-side-effect/</guid>
            <description>&lt;p&gt;Если вы делаете &lt;code&gt;foreach&lt;/code&gt; по некоторому &lt;a href=&quot;http://msdn.microsoft.com/library/6sh2ey19.aspx&quot;&gt;List&lt;/a&gt;-у, то менять итерируемый лист внутри цикла крайне не рекомендуется, ведь это верный способ получить &lt;a href=&quot;http://msdn.microsoft.com/library/system.invalidoperationexception.aspx&quot;&gt;InvalidOperationException&lt;/a&gt;. А теперь загадка: как думаете, что случится со следующим кодом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var list = new List&amp;lt;int&amp;gt; { 0, 1, 2 };
foreach(var x in list)
{
  if (x == 0)
  {
    for (int i = int.MinValue; i &amp;lt; int.MaxValue; i++)
      list[0] = 0;
    list.Add(3);
  }
  Console.WriteLine(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Правильный ответ: этот код замечательно отработает.	На консоли вы увидете:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0
1
2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Разгадка кроется во внутренней реализации класса List (см. реализацию в	&lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs&quot;&gt;MS.NET&lt;/a&gt;	и в
&lt;a href=&quot;https://github.com/mono/mono/blob/mono-3.10.0/mcs/class/corlib/System.Collections.Generic/List.cs&quot;&gt;Mono 3.10&lt;/a&gt;). При итерировании наш List должен как-то следить, не поменял ли его кто-нибудь внутри очередной итерации. Для этого используется приватное поле &lt;code&gt;_version&lt;/code&gt;. При любой операции &lt;code&gt;_version&lt;/code&gt; увеличивается на 1. При создании Enumerator-для цикла это значение &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,1199&quot;&gt;запоминается&lt;/a&gt;, а при каждом вызове &lt;code&gt;MoveNext&lt;/code&gt;
происходит &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,1224&quot;&gt;проверка&lt;/a&gt;, что номер версии не поменялся. Если кто-то менял элементы коллекции, то &lt;a href=&quot;http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs,1225&quot;&gt;будет брошен&lt;/a&gt; &lt;a href=&quot;http://msdn.microsoft.com/library/system.invalidoperationexception.aspx&quot;&gt;InvalidOperationException&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Но приведённый выше код отлично отрабатывает без всяких исключений. Как же так? Разгадка проста: для хранения &lt;code&gt;_version&lt;/code&gt; используется тип &lt;code&gt;int&lt;/code&gt;. А что будет, если &lt;code&gt;int&lt;/code&gt;-переменную увеличить на &lt;code&gt;1&lt;/code&gt; ровно &lt;i&gt;2 &lt;sup&gt;32&lt;/sup&gt;&lt;/i&gt; раза? Она вернётся к своему исходному значению. В примере внутренний цикл (от	&lt;code&gt;int.MinValue&lt;/code&gt; до &lt;code&gt;int.MaxValue&lt;/code&gt;) изменяет бедный &lt;code&gt;_version&lt;/code&gt; ровно &lt;i&gt;2 &lt;sup&gt;32&lt;/sup&gt;-1&lt;/i&gt; раз. А строчка &lt;code&gt;list.Add(3)&lt;/code&gt; пополняет лист новым элементом и совершает финальный инкремент &lt;code&gt;_version&lt;/code&gt;, который возвращает его к исходному значению. В результате при следующем вызове &lt;code&gt;MoveNext()&lt;/code&gt; никто не подозревает, что мы что-то поменяли. Идеальное преступление.&lt;/p&gt;
&lt;p&gt;Документация нам &lt;a href=&quot;http://msdn.microsoft.com/library/system.collections.ienumerator.movenext.aspx&quot;&gt;говорит&lt;/a&gt;, что исключение должно быть брошено, если кто-то поменял коллекцию. Так что формально данный пример иллюстрирует небольшую .NET-багу. Впрочем, особо волноваться по этому поводу не стоит: вероятность наткнуться на подобную проблему реальной жизни достаточно мала. Закладываться на такое поведение и как-то его учитывать тоже не стоит, т.к. впоследствии оно может поменяться (например, &lt;code&gt;_version&lt;/code&gt; сделают 64-битным).&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/26718990/184842&quot;&gt;StackOverflow: Why this code throws &#39;Collection was modified&#39; and when I iterate something before it, it doesn&#39;t?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Об экранировании URI в .NET</title>
            <link>http://aakinshin.net/ru/posts/uri-escaping/</link> 
            <pubDate>Thu, 13 Nov 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/uri-escaping/</guid>
            <description>&lt;h2 id=&quot;section&quot;&gt;Часть 1&lt;/h2&gt;
&lt;p&gt;Загадка на сегодня: что выведет код?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var uri = new Uri(&amp;quot;http://localhost/%2F1&amp;quot;);
Console.WriteLine(uri.OriginalString);
Console.WriteLine(uri.AbsoluteUri);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Правильный ответ: зависит. Давайте немножко поразбираемся.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Так что же он выведет?&lt;/h3&gt;
&lt;p&gt;Результат работы зависит от версии .NET:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// .NET 4.0
http://localhost/%2F1
http://localhost//1
// .NET 4.5
http://localhost/%2F1
http://localhost/%2F1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Да как же так-то?&lt;/h3&gt;
&lt;p&gt;Увы, до версии .NET 4.0 имела место &lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/511010/erroneous-uri-parsing-for-encoded-reserved-characters-according-to-rfc-3986&quot;&gt;неприятная бага&lt;/a&gt; с экранированием слеша (он же &lt;code&gt;%2F&lt;/code&gt;). В 4.5 её решили пофиксить, чтобы поведение соответствовало &lt;a href=&quot;http://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;. Сделали вроде бы правильно, но добавили дополнительной головной боли разработчикам, которые не знают про этот небольшой нюанс: теперь механизм экранирования зависит от версии Framework-а. Лучше всего использовать правильный механизм из .NET 4.5. Но что, если у нас нет .NET 4.5? Имеется путь починить поведение в .NET 4.0. Для этого необходимо добавить в *.config-файл вашего приложения магические строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configuration&amp;gt;
  &amp;lt;uri&amp;gt;
    &amp;lt;schemeSettings&amp;gt;
      &amp;lt;add name=&amp;quot;http&amp;quot; 
           genericUriParserOptions=&amp;quot;DontUnescapePathDotsAndSlashes&amp;quot; /&amp;gt;
    &amp;lt;/schemeSettings&amp;gt;
  &amp;lt;/uri&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Работает приведённый фокус-покус начиная с .NET 4.0 beta 2. Т.е., скажем, в .NET 3.5 так сделать не получится. Так что придётся крутиться и вертеться. Например, на просторах интернета &lt;a href=&quot;http://stackoverflow.com/a/784937/184842&quot;&gt;можно найти&lt;/a&gt; вот такой чудо-хак:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;void ForceCanonicalPathAndQuery(Uri uri)
{
  string paq = uri.PathAndQuery; // need to access PathAndQuery
  FieldInfo flagsFieldInfo = typeof(Uri).GetField(&amp;quot;m_Flags&amp;quot;, 
    BindingFlags.Instance | BindingFlags.NonPublic);
  ulong flags = (ulong) flagsFieldInfo.GetValue(uri);
  flags &amp;amp;= ~((ulong) 0x30); // Flags.PathNotCanonical|Flags.QueryNotCanonical
  flagsFieldInfo.SetValue(uri, flags);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;mono&quot;&gt;А что будет в Mono?&lt;/h3&gt;
&lt;p&gt;В Mono &lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=16960&quot;&gt;накосячили&lt;/a&gt; точно также. Починка осуществилась совсем недавно с &lt;a href=&quot;http://www.mono-project.com/docs/about-mono/releases/3.10.0/&quot;&gt;выходом&lt;/a&gt; Mono 3.10.0 в октябре 2014. Так что если вы сидите на последней версии, то у вас уже всё должно быть хорошо. Но как же нам теперь переключаться между старым и новым поведением? Для этих целей в классе &lt;code&gt;System.Uri&lt;/code&gt; имеется свойство &lt;code&gt;IriParsing&lt;/code&gt;. Заглянем в &lt;a href=&quot;https://github.com/mono/mono/blob/mono-3.10.0/mcs/class/System/System/Uri.cs&quot;&gt;код&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private static bool s_IriParsing;

internal static bool IriParsing {
    get { return s_IriParsing; }
    set { s_IriParsing = value; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выставляется свойство следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;static Uri ()
{
#if NET_4_5
    IriParsing = true;
#endif

    var iriparsingVar = 
        Environment.GetEnvironmentVariable (&amp;quot;MONO_URI_IRIPARSING&amp;quot;);
    if (iriparsingVar == &amp;quot;true&amp;quot;)
        IriParsing = true;
    else if (iriparsingVar == &amp;quot;false&amp;quot;)
        IriParsing = false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Т.е. выставить его проще всего через переменную окружения &lt;code&gt;MONO_URI_IRIPARSING&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Заключение&lt;/h3&gt;
&lt;p&gt;Бага не особо приятная и может стоить вам многих часов душевного спокойствия, если вы на неё случайно наткнётесь. Поэтому я решил оформить такую вот небольшую заметку, чтобы побольше людей было в курсе. Помните о неоднозначности экранирования некоторых URI и пишите стабильный код.&lt;/p&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://connect.microsoft.com/VisualStudio/feedback/details/511010/erroneous-uri-parsing-for-encoded-reserved-characters-according-to-rfc-3986&quot;&gt;MS Connect 511010: Erroneous URI parsing for encoded, reserved characters, according to RFC 3986&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=16960&quot;&gt;Mono Bug 16960&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/20769150/184842&quot;&gt;StackOverflow: Getting a Uri with escaped slashes on mono&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/q/781205/184842%22%3EStackOverflow&quot;&gt;GETting a URL with an url-encoded slash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mono-project.com/docs/about-mono/releases/3.10.0/&quot;&gt;Mono 3.10.0 release notes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://mikehadlow.blogspot.co.uk/2011/08/how-to-stop-systemuri-un-escaping.html&quot;&gt;Mike Hadlow: How to stop System.Uri un-escaping forward slash characters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://grootveld.com/archives/21/url-encoded-slashes-in-systemuri&quot;&gt;Arnout&#39;s Eclectica: URL-encoded slashes in System.Uri&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;section-5&quot;&gt;Часть 2&lt;/h2&gt;
&lt;p&gt;На StackOverflow мне попался интересный вопрос: &lt;a href=&quot;http://stackoverflow.com/q/27062562/184842&quot;&gt;&#171;Unit test ReSharper and NUnit give different results&#187;&lt;/a&gt;. Суть заключалась в том, что ReSharper и NUnit дают разные результаты при экранировании URI. Я решил немножко углубиться в эту проблему. Разобраться с проблемой нам поможет следующая небольшая программка:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
    Print(&amp;quot;http://localhost/a%2Fb&amp;quot;);
    Print(&amp;quot;http://localhost/a.?b&amp;quot;);
    Print(&amp;quot;http://localhost/a?b=c%3Fd%3De&amp;quot;);
}

public void Print(string uriString)
{
    var uri = new Uri(uriString);
    Console.WriteLine(&amp;quot;Original: &amp;quot; + uri.OriginalString);
    Console.WriteLine(&amp;quot;Absolute: &amp;quot; + uri.AbsoluteUri);
    Console.WriteLine(&amp;quot;ToString: &amp;quot; + uri.ToString());
    Console.WriteLine();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Я взял на рассмотрение три строки: с экранированным слешом, с точкой и с экранированными вопросом и знаком равенства. Программа запускалась под MS.NET 4.0, MS.NET 4.0 с опцией &lt;code&gt;genericUriParserOptions=&amp;quot;DontUnescapePathDotsAndSlashes&amp;quot;&lt;/code&gt;, MS.NET 4.5, Mono 3.2.8, Mono 3.10.0. Результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// MS.NET 4.0:

Original: http://localhost/a%2Fb
Absolute: http://localhost/a/b
ToString: http://localhost/a/b

Original: http://localhost/a.?b
Absolute: http://localhost/a?b
ToString: http://localhost/a?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c?d=e

// MS.NET 4.0 (DontUnescapePathDotsAndSlashes):

Original: http://localhost/a%2Fb
Absolute: http://localhost/a%2Fb
ToString: http://localhost/a/b

Original: http://localhost/a.?b
Absolute: http://localhost/a?b
ToString: http://localhost/a?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c?d=e

// MS.NET 4.5:

Original: http://localhost/a%2Fb
Absolute: http://localhost/a%2Fb
ToString: http://localhost/a%2Fb

Original: http://localhost/a.?b
Absolute: http://localhost/a.?b
ToString: http://localhost/a.?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c%3Fd%3De

// Mono 3.2.8

Original: http://localhost/a%2Fb
Absolute: http://localhost/a/b
ToString: http://localhost/a/b

Original: http://localhost/a.?b
Absolute: http://localhost/a.?b
ToString: http://localhost/a.?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c%3Fd=e

// Mono 3.10

Original: http://localhost/a%2Fb
Absolute: http://localhost/a%2Fb
ToString: http://localhost/a%2Fb

Original: http://localhost/a.?b
Absolute: http://localhost/a.?b
ToString: http://localhost/a.?b

Original: http://localhost/a?b=c%3Fd%3De
Absolute: http://localhost/a?b=c%3Fd%3De
ToString: http://localhost/a?b=c%3Fd%3De
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Внимательное созерцание результатов может подтолкнуть к следующим выводам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;uri.AbsoluteUri&lt;/code&gt; совсем не обязательно совпадает с &lt;code&gt;uri.ToString()&lt;/code&gt;. Например, &lt;code&gt;DontUnescapePathDotsAndSlashes&lt;/code&gt; хак в MS.NET 4.0 при экранировании слеша влияет на &lt;code&gt;AbsoluteUri&lt;/code&gt;, но не оказывает влияния на &lt;code&gt;ToString()&lt;/code&gt;. Под Mono 3.2.8 можно увидеть проблемы с экранированным знаком равенства в &lt;code&gt;AbsoluteUri&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;В Mono и MS.NET были разные проблемы с обработкой URI. Например, под MS.NET 4.0 строка &lt;code&gt;a.?b&lt;/code&gt; превратилась в &lt;code&gt;a?b&lt;/code&gt;, а под Mono 3.2.8 мы увидели всё тот же &lt;code&gt;a.?b&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;В последних версиях (MS.NET 4.5 и Mono 3.10) всё хорошо: &lt;code&gt;AbsoluteUri&lt;/code&gt; и &lt;code&gt;ToString()&lt;/code&gt; на &lt;em&gt;приведённых примерах&lt;/em&gt; совпадают с &lt;code&gt;OriginalString&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Что касается изначального StackOverflow-вопроса, то ReSharper проводит тестирование правильно: он запускает тесты под нужную версию .NET. А NUnit при консольном тестировании без указания специфических параметров по каким-то причинам может подхватить логику из старых библиотек.&lt;/p&gt;
&lt;h3 id=&quot;section-6&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Если вы работаете с URI, в который могут попасть разные спецсимволы в экранированном или явном виде, то лучше бы вам не полагаться на стандартную реализацию по обработке исходной строчки: результат работы &lt;code&gt;AbsoluteUri&lt;/code&gt; и &lt;code&gt;ToString()&lt;/code&gt; могут вас неприятно удивить. Если вы уверены, что у вас повсеместно используется MS.NET 4.5+ или Mono 3.10+, то скорее всего у вас всё будет нормально, но при поддержке старых версий .NET лучше бы написать свою логику по работе с URI.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Nullable-арифметика</title>
            <link>http://aakinshin.net/ru/posts/cheatsheet-nullable/</link> 
            <pubDate>Tue, 11 Nov 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/cheatsheet-nullable/</guid>
            <description>&lt;p&gt;Что будет, если &lt;code&gt;null&lt;/code&gt; поделить на ноль? А сколько будет &lt;code&gt;null | true&lt;/code&gt;? А &lt;code&gt;null &amp;amp; true&lt;/code&gt;? А &lt;code&gt;((string)null + null)&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Практика подсказывает, что C#-разработчики зачастую не особо задумываются о том, как будут оцениваться выражения, если один из операндов равен &lt;code&gt;null&lt;/code&gt;. Поэтому я решил составить небольшую шпаргалку на эту тему.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Числа&lt;/h3&gt;
&lt;p&gt;Обычные арифметические операции с числами, в которых один из операндов равен &lt;code&gt;null&lt;/code&gt;, всегда будут возвращать &lt;code&gt;null&lt;/code&gt;. Т.е. если у нас имеется некоторый &lt;code&gt;X&lt;/code&gt; типа &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt; или &lt;code&gt;decimal&lt;/code&gt;, то для любых значений &lt;code&gt;X&lt;/code&gt; работает нижеприведённая табличка. Даже если &lt;code&gt;X==0&lt;/code&gt;, то выражения &lt;code&gt;null / X&lt;/code&gt; и &lt;code&gt;null % X&lt;/code&gt; всё равно вернут &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+------------+-------+
| Expression | Value |
+------------+-------+
| X + null   | null  |
| X - null   | null  |
| X * null   | null  |
| X / null   | null  |
| X % null   | null  |
| null + X   | null  |
| null - X   | null  |
| null * X   | null  |
| null / X   | null  |
| null % X   | null  |
+------------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Сравнения&lt;/h3&gt;
&lt;p&gt;Операции &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; всегда возвращают &lt;code&gt;false&lt;/code&gt;, если один из операндов равен &lt;code&gt;null&lt;/code&gt;. Операции &lt;code&gt;==&lt;/code&gt; и &lt;code&gt;!=&lt;/code&gt; работают так, как подсказывает логика.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------+-------+-------+-------+-------+-------+-------+
|   X   |   Y   |  X&amp;lt;Y  | X&amp;lt;=Y  |  X&amp;gt;Y  | X&amp;gt;=Y  | X==Y  | X!=Y  |
+-------+-------+-------+-------+-------+-------+-------+-------+
| 0     | 0     | false | true  | false | true  | true  | false |
| 0     | null  | false | false | false | false | false | true  |
| null  | 0     | false | false | false | false | false | true  |
| null  | null  | false | false | false | false | true  | false |
+-------+-------+-------+-------+-------+-------+-------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Логические операции&lt;/h3&gt;
&lt;p&gt;Логические операции &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; вызывают большее количество непонимания у людей. Проиллюстрируем булеву арифметику ещё одной табличной:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------+-------+-------+-------+-------+
|   X   |   Y   | X | Y | X &amp;amp; Y | X ^ Y |
+-------+-------+-------+-------+-------+
| false | false | false | false | false |
| false | true  | true  | false | true  |
| false | null  | null  | false | null  |
| true  | false | true  | false | true  |
| true  | true  | true  | true  | false |
| true  | null  | true  | null  | null  |
| null  | false | null  | false | null  |
| null  | true  | true  | null  | null  |
| null  | null  | null  | null  | null  |
+-------+-------+-------+-------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Строки&lt;/h3&gt;
&lt;p&gt;В операциях конкатенации строк &lt;code&gt;null&lt;/code&gt; всегда заменяется на пустую строчку. Таким образом,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;&amp;quot;foo&amp;quot; + null == &amp;quot;foo&amp;quot;
(string)null + null + null == &amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.microsoft.com/downloads/en/details.aspx?FamilyID=DFBF523C-F98C-4804-AFBD-459E846B268E&quot;&gt;C# Language Specification&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;4.1.10 Nullable types&lt;/li&gt;
&lt;li&gt;6.1.4 Implicit nullable conversions&lt;/li&gt;
&lt;li&gt;6.2.3 Explicit nullable conversions&lt;/li&gt;
&lt;li&gt;7.3.7 Lifted operators&lt;/li&gt;
&lt;li&gt;7.8.4 Addition operator&lt;/li&gt;
&lt;li&gt;7.10.9 Equality operators and null&lt;/li&gt;
&lt;li&gt;7.11.4 Nullable boolean logical operators&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/library/2cf62fcy.aspx&quot;&gt;MSDN: Using Nullable Types (C# Programming Guide)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>About UTF-8 conversions in Mono</title>
            <link>http://aakinshin.net/posts/mono-utf8-conversions/</link> 
            <pubDate>Mon, 10 Nov 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/mono-utf8-conversions/</guid>
            <description>&lt;p&gt;This post is a logical continuation of the Jon Skeet&#39;s blog post &lt;a href=&quot;http://codeblog.jonskeet.uk/2014/11/07/when-is-a-string-not-a-string&quot;&gt;“When is a string not a string?”&lt;/a&gt;. Jon showed very interesting things about behavior of ill-formed Unicode strings in .NET. I wondered about how similar examples will work on Mono. And I have got very interesting results.&lt;/p&gt;
&lt;h3 id=&quot;experiment-1-compilation&quot;&gt;Experiment 1: Compilation&lt;/h3&gt;
&lt;p&gt;Let&#39;s take the Jon&#39;s code with a small modification. We will just add &lt;code&gt;text&lt;/code&gt; null check in &lt;code&gt;DumpString&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.ComponentModel;
using System.Text;
using System.Linq;
[Description(Value)]
class Test
{
    const string Value = &amp;quot;X\ud800Y&amp;quot;;
    static void Main()
    {
        var description = (DescriptionAttribute)typeof(Test).
            GetCustomAttributes(typeof(DescriptionAttribute), true)[0];
        DumpString(&amp;quot;Attribute&amp;quot;, description.Description);
        DumpString(&amp;quot;Constant&amp;quot;, Value);
    }
    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint) c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Let&#39;s compile the code with MS.NET (csc) and Mono (mcs). The resulting IL files will have one important distinction:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 ED A0 80 59 00 00 ) // ...X...Y..
// Mono compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 59 BF BD 00 00 00 ) // ...XY.....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 1:&lt;/strong&gt; MS.NET and Mono transform original C# strings to UTF-8 IL strings in different ways. But both ways give non-valid UTF-8 strings (&lt;code&gt;58 ED A0 80 59&lt;/code&gt; and &lt;code&gt;58 59 BF BD 00&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&quot;experiment-2-run&quot;&gt;Experiment 2: Run&lt;/h3&gt;
&lt;p&gt;Ok, let&#39;s run it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler / MS.NET runtime
Attribute: 0058 fffd fffd 0059
Constant: 0058 d800 0059
// MS.NET compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
// Mono compiler / MS.NET runtime
Attribute: 0058 0059 fffd fffd 0000
Constant: 0058 d800 0059
// Mono compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 2:&lt;/strong&gt; Mono runtime can&#39;t use our non-valid UTF-8 IL strings. Instead, Mono use &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;experiment-3-manual-utf-8-to-string-conversion&quot;&gt;Experiment 3: Manual UTF-8 to String conversion&lt;/h3&gt;
&lt;p&gt;Ok, but what if we create non-valid UTF-8 string in runtime? Let&#39;s check it! The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Text;
using System.Linq;

class Test
{
    static void Main()
    {
        DumpString(&amp;quot;(1)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0xED, 0xA0, 0x80, 0x59 }));
        DumpString(&amp;quot;(2)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0x59, 0xBF, 0xBD, 0x00 }));
    }

    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint)c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
(1): 0058 fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
// Mono runtime
(1): 0058 fffd fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MS.NET and Mono implement UTF-8 to String conversion in different ways. The &lt;code&gt;ED A0 80&lt;/code&gt; sequence transforms to &lt;code&gt;FFDD FFDD&lt;/code&gt; on MS.NET and to &lt;code&gt;FFDD FFDD FFDD&lt;/code&gt; on Mono.&lt;/p&gt;
&lt;h3 id=&quot;experiment-4-manual-string-to-utf-8-conversion&quot;&gt;Experiment 4: Manual String to UTF-8 conversion&lt;/h3&gt;
&lt;p&gt;Let&#39;s look to the reverse conversion (from String to UTF-8). The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var bytes = Encoding.UTF8.GetBytes(&amp;quot;X\ud800Y&amp;quot;);
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, bytes.Select(b =&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
58 ef bf bd 59
// Mono runtime
58 59 bf bd 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 4:&lt;/strong&gt; MS.NET and Mono implement String to UTF-8 conversion in different ways too.&lt;/p&gt;
&lt;h3 id=&quot;experiment-5-prohibition-of-ill-formed-string&quot;&gt;Experiment 5: Prohibition of ill-formed string&lt;/h3&gt;
&lt;p&gt;Also, Jon&#39;s has written about prohibition of ill-formed strings in some attributes. For example, the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DllImport(Value)]
static extern void Foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc or Roslyn. But it will be successfully compile on Mono!&lt;/p&gt;
&lt;p&gt;Another example: the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Conditional(Value)]
void Bar() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc and Mono:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
error CS0647:
Error emitting ‘DllImportAttribute’ attribute
// Mono compiler
error CS0633:
The argument to the ‘ConditionalAttribute’ attribute must be a valid identifier
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Encodings are hard.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Об UTF-8-преобразованиях в Mono</title>
            <link>http://aakinshin.net/ru/posts/mono-utf8-conversions/</link> 
            <pubDate>Mon, 10 Nov 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/mono-utf8-conversions/</guid>
            <description>&lt;p&gt;Данный пост является логическим продолжением поста Джона Скита &lt;a href=&quot;http://codeblog.jonskeet.uk/2014/11/07/when-is-a-string-not-a-string&quot;&gt;“When is a string not a string?”&lt;/a&gt;. Jon showed very interesting things about behavior of ill-formed Unicode strings in .NET. I wondered about how similar examples will work on Mono. And I have got very interesting results.&lt;/p&gt;
&lt;h3 id=&quot;experiment-1-compilation&quot;&gt;Experiment 1: Compilation&lt;/h3&gt;
&lt;p&gt;Let&#39;s take the Jon&#39;s code with a small modification. We will just add &lt;code&gt;text&lt;/code&gt; null check in &lt;code&gt;DumpString&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.ComponentModel;
using System.Text;
using System.Linq;
[Description(Value)]
class Test
{
    const string Value = &amp;quot;X\ud800Y&amp;quot;;
    static void Main()
    {
        var description = (DescriptionAttribute)typeof(Test).
            GetCustomAttributes(typeof(DescriptionAttribute), true)[0];
        DumpString(&amp;quot;Attribute&amp;quot;, description.Description);
        DumpString(&amp;quot;Constant&amp;quot;, Value);
    }
    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint) c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Let&#39;s compile the code with MS.NET (csc) and Mono (mcs). The resulting IL files will have one important distinction:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 ED A0 80 59 00 00 ) // ...X...Y..
// Mono compiler
.custom instance void class
[System]System.ComponentModel.DescriptionAttribute::&#39;.ctor&#39;(string) =
(01 00 05 58 59 BF BD 00 00 00 ) // ...XY.....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 1:&lt;/strong&gt; MS.NET and Mono transform original C# strings to UTF-8 IL strings in different ways. But both ways give non-valid UTF-8 strings (&lt;code&gt;58 ED A0 80 59&lt;/code&gt; and &lt;code&gt;58 59 BF BD 00&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&quot;experiment-2-run&quot;&gt;Experiment 2: Run&lt;/h3&gt;
&lt;p&gt;Ok, let&#39;s run it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler / MS.NET runtime
Attribute: 0058 fffd fffd 0059
Constant: 0058 d800 0059
// MS.NET compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
// Mono compiler / MS.NET runtime
Attribute: 0058 0059 fffd fffd 0000
Constant: 0058 d800 0059
// Mono compiler / Mono runtime
Attribute: null
Constant: 0058 d800 0059
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 2:&lt;/strong&gt; Mono runtime can&#39;t use our non-valid UTF-8 IL strings. Instead, Mono use &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;experiment-3-manual-utf-8-to-string-conversion&quot;&gt;Experiment 3: Manual UTF-8 to String conversion&lt;/h3&gt;
&lt;p&gt;Ok, but what if we create non-valid UTF-8 string in runtime? Let&#39;s check it! The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Text;
using System.Linq;

class Test
{
    static void Main()
    {
        DumpString(&amp;quot;(1)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0xED, 0xA0, 0x80, 0x59 }));
        DumpString(&amp;quot;(2)&amp;quot;, Encoding.UTF8.GetString(
            new byte[] { 0x58, 0x59, 0xBF, 0xBD, 0x00 }));
    }

    static void DumpString(string name, string text)
    {
        Console.Write(&amp;quot;{0}: &amp;quot;, name);
        if (text != null)
        {
            var utf16 = text.Select(c =&amp;gt; ((uint)c).ToString(&amp;quot;x4&amp;quot;));
            Console.WriteLine(string.Join(&amp;quot; &amp;quot;, utf16));
        }
        else
            Console.WriteLine(&amp;quot;null&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
(1): 0058 fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
// Mono runtime
(1): 0058 fffd fffd fffd 0059
(2): 0058 0059 fffd fffd 0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 3:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MS.NET and Mono implement UTF-8 to String conversion in different ways. The &lt;code&gt;ED A0 80&lt;/code&gt; sequence transforms to &lt;code&gt;FFDD FFDD&lt;/code&gt; on MS.NET and to &lt;code&gt;FFDD FFDD FFDD&lt;/code&gt; on Mono.&lt;/p&gt;
&lt;h3 id=&quot;experiment-4-manual-string-to-utf-8-conversion&quot;&gt;Experiment 4: Manual String to UTF-8 conversion&lt;/h3&gt;
&lt;p&gt;Let&#39;s look to the reverse conversion (from String to UTF-8). The code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var bytes = Encoding.UTF8.GetBytes(&amp;quot;X\ud800Y&amp;quot;);
Console.WriteLine(string.Join(&amp;quot; &amp;quot;, bytes.Select(b =&amp;gt; b.ToString(&amp;quot;x2&amp;quot;))));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET runtime
58 ef bf bd 59
// Mono runtime
58 59 bf bd 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;The interesting fact 4:&lt;/strong&gt; MS.NET and Mono implement String to UTF-8 conversion in different ways too.&lt;/p&gt;
&lt;h3 id=&quot;experiment-5-prohibition-of-ill-formed-string&quot;&gt;Experiment 5: Prohibition of ill-formed string&lt;/h3&gt;
&lt;p&gt;Also, Jon&#39;s has written about prohibition of ill-formed strings in some attributes. For example, the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[DllImport(Value)]
static extern void Foo();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc or Roslyn. But it will be successfully compile on Mono!&lt;/p&gt;
&lt;p&gt;Another example: the code&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Conditional(Value)]
void Bar() {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will not compile on csc and Mono:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// MS.NET compiler
error CS0647:
Error emitting ‘DllImportAttribute’ attribute
// Mono compiler
error CS0633:
The argument to the ‘ConditionalAttribute’ attribute must be a valid identifier
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Encodings are hard.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Endianness в .NET</title>
            <link>http://aakinshin.net/ru/posts/endianness/</link> 
            <pubDate>Wed, 29 Oct 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/endianness/</guid>
            <description>&lt;table class=&quot;table-ok&quot;&gt;
    &lt;tr&gt;
        &lt;td valign=&quot;top&quot;&gt;
            &lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
                &lt;img src=&quot;/img/posts/dotnet/endianness/front.png&quot; alt=&quot;Endian funny image&quot; style=&quot;margin: 0 2em 1em 0;&quot; /&gt;
            &lt;/div&gt;
        &lt;/td&gt;
        &lt;td valign=&quot;top&quot;&gt;
            &lt;p&gt;Рассмотрим простую задачку: что выведет следующий код?&lt;/p&gt;
&lt;pre class=&quot;prettyprint lang-cs&quot;&gt;
[StructLayout(LayoutKind.Explicit)]
struct UInt16Wrapper
{
  [FieldOffset(0)]
  public UInt16 Value;
  [FieldOffset(0)]
  public Byte Byte1;
  [FieldOffset(1)]
  public Byte Byte2;
}
void Main()
{
  var uint16 = new UInt16Wrapper();
  uint16.Value = 1 + 2 * 256;
  Console.WriteLine(uint16.Byte1);
  Console.WriteLine(uint16.Byte2);
}
&lt;/pre&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Полагаю, что внимательный читатель должен обратить внимание на название поста и дать правильный ответ: &#171;зависит&#187;. Сегодня мы немного поговорим о том, как в .NET обстоят дела с порядком байтов.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Небольшой обзор&lt;/h3&gt;
&lt;p&gt;Про то, что такое endianness и зачем он нужен, я писать не буду — на эту тему и так хватает материала (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness&quot;&gt;Endianness&lt;/a&gt;), &lt;a href=&quot;http://en.wikipedia.org/wiki/Comparison_of_instruction_set_architectures#Endianness&quot;&gt;Comparison of instruction set architectures&lt;/a&gt;, &lt;a href=&quot;http://habrahabr.ru/post/233245/&quot;&gt;Разбираемся с прямым и обратным порядком байтов&lt;/a&gt;). Ответ на задачку можно легко найти в &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-335.htm&quot;&gt;ECMA-335&lt;/a&gt;, &#171;I.12.6.3  Byte ordering&#187;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For data types larger than 1 byte, the byte ordering is dependent on the target CPU. Code that depends on byte ordering might not run on all platforms. The PE file format (see &#167;I.12.2) allows the file to be marked to indicate that it depends on a particular type ordering.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ну, казалось бы, всё просто: зависит от конкретной архитектуры. Только вот архитектур у нас много. Например, Mono &lt;a href=&quot;http://www.mono-project.com/docs/about-mono/supported-platforms/&quot;&gt;поддерживает&lt;/a&gt; в числе прочего &lt;a href=&quot;http://en.wikipedia.org/wiki/X86&quot;&gt;x86&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/X86-64&quot;&gt;x64&lt;/a&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness#Little-endian&quot;&gt;Little-endian&lt;/a&gt;); &lt;a href=&quot;http://en.wikipedia.org/wiki/IBM_ESA/390&quot;&gt;s390&lt;/a&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness#Big-endian&quot;&gt;Big-endian&lt;/a&gt;); &lt;a href=&quot;http://en.wikipedia.org/wiki/PowerPC&quot;&gt;PowerPC&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/SPARC&quot;&gt;SPARC&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/ARM_architecture&quot;&gt;ARM&lt;/a&gt;, &lt;a href=&quot;http://en.wikipedia.org/wiki/Itanium&quot;&gt;IA64&lt;/a&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Endianness#Bi-endian_hardware&quot;&gt;Bi-endian&lt;/a&gt;, т.е. есть возможность переключаться между Little/Big-endian). Общая мораль такова: лучше не закладываться на какой-то конкретный порядок байт. Конечно, скорее всего вы пишете под x86 или x64 и можете представлять себе всю память как Little-endian, но нужно держать в уме, что это может быть и не так (особенно актуально в свете распространённости ARM для мобильных устройств).&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Погружаемся внутрь&lt;/h3&gt;
&lt;p&gt;Данный раздел предназначен для тех, кто любит залезать внутрь своих программ. Если вы не из таких, то можете просто перейти к следующему разделу. А с теми, кому всё-таки интересно, вернёмся к рассмотрению нашего примера и взглянем на IL-код метода Main:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.class nested private explicit ansi sealed beforefieldinit UInt16Wrapper
  extends [mscorlib]System.ValueType
{
  // Fields
  .field [0] public uint16 Value
  .field [0] public uint8 Byte1
  .field [1] public uint8 Byte2
} // end of class UInt16Wrapper

.method private hidebysig 
  instance void Run () cil managed 
{
  // Method begins at RVA 0x205c
  // Code size 45 (0x2d)
  .maxstack 2
  .locals init (
    [0] valuetype Program/UInt16Wrapper uint16
  )

  IL_0000: ldloca.s uint16
  IL_0002: initobj Program/UInt16Wrapper
  IL_0008: ldloca.s uint16
  IL_000a: ldc.i4 513
  IL_000f: stfld uint16 Program/UInt16Wrapper::Value
  IL_0014: ldloca.s uint16
  IL_0016: ldfld uint8 Program/UInt16Wrapper::Byte1
  IL_001b: call void [mscorlib]System.Console::WriteLine(int32)
  IL_0020: ldloca.s uint16
  IL_0022: ldfld uint8 Program/UInt16Wrapper::Byte2
  IL_0027: call void [mscorlib]System.Console::WriteLine(int32)
  IL_002c: ret
} // end of method Program::Run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут всё достаточно просто: в нашей структуре имеется три поля: одно двухбайтовое (&lt;code&gt;uint16&lt;/code&gt;) и два однобайтовых (&lt;code&gt;uint8&lt;/code&gt;). Двухбайтовое поле &lt;code&gt;Value&lt;/code&gt; имеет смещение 0 байт. Первое однобайтовое поле &lt;code&gt;Byte1&lt;/code&gt; также имеет смещение 0 байт, т.е. указывает в точности туда же, куда и &lt;code&gt;Value&lt;/code&gt; (другими словами, на байт &lt;code&gt;Value&lt;/code&gt; с младшим адресом). Второе однобайтовое поле &lt;code&gt;Byte2&lt;/code&gt; имеет смещение 1 байт, т.е. указывает на байт &lt;code&gt;Value&lt;/code&gt; со старшим адресом. В примере значение &lt;code&gt;Value&lt;/code&gt; равно &lt;code&gt;1+2*256&lt;/code&gt;. На моём компьютере архитектура x64, что означает Little-endian. Для простоты примера соберём программу под x86 (с точно таким же Little-endian) А значит в &lt;code&gt;Byte1&lt;/code&gt; будет хранится &lt;code&gt;1&lt;/code&gt;, а в &lt;code&gt;Byte2&lt;/code&gt; — &lt;code&gt;2&lt;/code&gt;. На консоли мы увидим:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ради интереса взглянем на asm-код. Под Windows получим следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        {
            var uint16 = new UInt16Wrapper();
00DE29A1  mov         ebp,esp  
00DE29A3  sub         esp,8  
00DE29A6  xor         eax,eax  
00DE29A8  mov         dword ptr [ebp-8],eax  
00DE29AB  mov         dword ptr [ebp-4],ecx  
00DE29AE  cmp         dword ptr ds:[4B51058h],0  
00DE29B5  je          00DE29BC  
00DE29B7  call        73DFC310  
00DE29BC  lea         eax,[ebp-8]  
00DE29BF  mov         word ptr [eax],0  
            uint16.Value = 1 + 2 * 256;
00DE29C4  mov         word ptr [ebp-8],201h  
            Console.WriteLine(uint16.Byte1);
00DE29CA  movzx       ecx,byte ptr [ebp-8]  
00DE29CE  call        7325A920  
            Console.WriteLine(uint16.Byte2);
00DE29D3  lea         eax,[ebp-8]  
00DE29D6  movzx       ecx,byte ptr [eax+1]  
00DE29DA  call        7325A920  
        }
00DE29DF  nop  
00DE29E0  mov         esp,ebp  
00DE29E2  pop         ebp  
00DE29E3  ret  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Значение нашего поля в шестнадцатеричном представлении имеет вид &lt;code&gt;201h&lt;/code&gt;, а найти его мы можем по адресу &lt;code&gt;byte ptr [ebp-8]&lt;/code&gt;. В первом случае (&lt;code&gt;00DE29CA&lt;/code&gt;) мы просто загружаем значение по данному адресу в &lt;code&gt;ecx&lt;/code&gt;, а во втором (&lt;code&gt;00DE29D3&lt;/code&gt;) — сначала загружаем адрес в &lt;code&gt;eax&lt;/code&gt;, а затем получаем значение из &lt;code&gt;byte ptr [eax+1]&lt;/code&gt;. Для полноты эксперимента глянем также код под Linux. Я взял Ubuntu 14.04 и собрал следующую версию mono:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mono --version
Mono JIT compiler version 3.10.0
        TLS:           __thread
        SIGSEGV:       altstack
        Notifications: epoll
        Architecture:  amd64
        Disabled:      none
        Misc:          softdebug 
        LLVM:          supported, not enabled.
        GC:            sgen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Имеем код (x64-версия):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gram_Main:
//{
   0:   48 83 ec 08             sub    $0x8,%rsp
// var int16 = new Int16Wrapper();
   4:   66 c7 04 24 00 00       movw   $0x0,(%rsp)
   a:   66 c7 04 24 00 00       movw   $0x0,(%rsp)
// int16.Value = 1 + 2 * 256;
  10:   66 c7 04 24 01 02       movw   $0x201,(%rsp)
// Console.WriteLine(uint16.Byte1);
  16:   0f b6 3c 24             movzbl (%rsp),%edi
  1a:   49 bb 7e dc 0f 40 00    movabs $0x400fdc7e,%r11
  21:   00 00 00 
  24:   41 ff d3                callq  *%r11
// Console.WriteLine(uint16.Byte2);
  27:   0f b6 7c 24 01          movzbl 0x1(%rsp),%edi
  2c:   49 bb 7e dc 0f 40 00    movabs $0x400fdc7e,%r11
  33:   00 00 00 
  36:   41 ff d3                callq  *%r11
// }
  39:   48 83 c4 08             add    $0x8,%rsp
  3d:   c3                      retq 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Логика аналогична: по адресу &lt;code&gt;(%rsp)&lt;/code&gt; загружаем целевое значение &lt;code&gt;$0x201&lt;/code&gt;. Получаем &lt;code&gt;Byte1&lt;/code&gt; по адресу &lt;code&gt;(%rsp)&lt;/code&gt; и &lt;code&gt;Byte2&lt;/code&gt; по адресу &lt;code&gt;0x1(%rsp)&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;А как узнать порядок байт?&lt;/h3&gt;
&lt;p&gt;Если для вас критично то, в каком порядке байты идут в памяти, то неплохо было бы научиться узнавать: с какой архитектурой процессора мы имеем дело. Рассмотрим пару способов.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Простой способ.&lt;/strong&gt; Благо, разработчики .NET позаботились о программистах и сделали специальное поле &lt;a href=&quot;http://msdn.microsoft.com/library/system.bitconverter.islittleendian.aspx&quot;&gt;BitConverter.IsLittleEndian&lt;/a&gt;. Пользоваться им очень просто:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(BitConverter.IsLittleEndian ? &amp;quot;LittleEndian&amp;quot; : &amp;quot;BigEndian&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Класс &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.bitconverter.aspx&quot;&gt;BitConverter&lt;/a&gt; удобно использовать для работы с отдельными байтами &#171;большой&#187; переменной. И этот способ намного предпочтительней, чем ручная работа с байтами. Вот хороший фрагмент из примера в официальной документации:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int value = 12345678;
byte[] bytes = BitConverter.GetBytes(value);
Console.WriteLine(BitConverter.ToString(bytes));
if (BitConverter.IsLittleEndian)
   Array.Reverse(bytes);
Console.WriteLine(BitConverter.ToString(bytes));
// The example displays the following output on a little-endian system: 
//       4E-61-BC-00
//       00-BC-61-4E
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Способ для тех, кто лёгких способов не ищет.&lt;/strong&gt; Следующий пример приведён сугубо в академических целях, в реальных проектах так писать не стоит. Допустим, мы не доверяем значению &lt;code&gt;BitConverter.IsLittleEndian&lt;/code&gt; и хотим сами проверить порядок байт, в котором хранятся наши переменные. Нам в этом поможет &lt;code&gt;unsafe&lt;/code&gt;-code. Просто создадим уже знакомое нам значение &lt;code&gt;0x201&lt;/code&gt;, получим его адрес и возьмём байт по этому адресу. Получится следующий код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public bool IsLittleEndian()
{
  UInt16 value = 0x201;
  unsafe
  {
    UInt16* valueAddress = &amp;amp;value;
    Byte* firstByteAddress = (Byte*)valueAddress;
    Byte firstByte = *firstByteAddress;
    return firstByte == 1;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;binaryreaderbinarywriter&quot;&gt;BinaryReader/BinaryWriter&lt;/h3&gt;
&lt;p&gt;Ок, с хранением чисел в памяти разобрались. А что, если нам нужно читать/писать числа в бинарном виде? .NET предлагает нам для этого классы &lt;a href=&quot;msdn.microsoft.com/library/system.io.binaryreader.aspx&quot;&gt;BinaryReader&lt;/a&gt; и &lt;a href=&quot;http://msdn.microsoft.com/library/system.io.binarywriter.aspx&quot;&gt;BinaryWriter&lt;/a&gt;. Но тут нужно быть аккуратным и помнить, что согласно документации эти классы &lt;em&gt;всегда&lt;/em&gt; работают с данными в Little-endian формате. Если по какой-то причине вы хотите поработать с данными в формате с заданным порядком байт, то придётся либо ручками реверсировать каждое число для Big-endian, либо использовать какую-нибудь внешнюю библиотеку (например, класс EndianBitConverter из &lt;a href=&quot;http://www.yoda.arachsys.com/csharp/miscutil/&quot;&gt;MiscUtil&lt;/a&gt; от Джона Скита).&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Всегда нужно помнить, что в разных местах для хранения чисел может использоваться разный порядок байт. А если вам доводится работать с памятью в бинарном виде, хранить числа в бинарном виде, передавать их по сети в бинарном виде или ещё что-нибудь делать с числами в бинарном виде, то к нюансу с порядком байт следует отнестись очень внимательно.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Эти занимательные региональные настройки</title>
            <link>http://aakinshin.net/ru/posts/cultureinfo/</link> 
            <pubDate>Sun, 21 Sep 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/cultureinfo/</guid>
            <description>&lt;p&gt;Сегодня мы поговорим о региональных настройках. Но сперва — небольшая задачка: что выведет нижеприведённый код? (Код приведён на языке C#, но рассматривается достаточно общая проблематика, так что вы можете представить на его месте какой-нибудь другой язык.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine((-42).ToString() == &amp;quot;-42&amp;quot;);
Console.WriteLine(double.NaN.ToString() == &amp;quot;NaN&amp;quot;);
Console.WriteLine(int.Parse(&amp;quot;-42&amp;quot;) == -42);
Console.WriteLine(1.1.ToString().Contains(&amp;quot;?&amp;quot;) == false);
Console.WriteLine(new DateTime(2014, 1, 1).ToString().Contains(&amp;quot;2014&amp;quot;));
Console.WriteLine(&amp;quot;i&amp;quot;.ToUpper() == &amp;quot;I&amp;quot; || &amp;quot;I&amp;quot;.ToLower() == &amp;quot;i&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сколько значений &lt;code&gt;true&lt;/code&gt; у вас получилось? Если больше &lt;code&gt;0&lt;/code&gt;, то вам не мешает узнать больше про региональные настройки, т. к. правильный ответ: &#171;зависит&#187;. К сожалению, многие программисты вообще не задумываются о том, что настройки эти в различных окружениях могут отличаться. А выставлять для всего кода InvariantCulture этим программистом лениво, в результате чего их прекрасные приложения ведут себя очень странно, попадая к пользователям из других стран.&lt;/p&gt;
&lt;p&gt;Ошибки бывают самые разные, но чаще всего связаны они с форматированием и парсингом строк — достаточно частыми задачами для многих программистов. В статье приведена краткая подборка некоторых важных моментов, на которые влияют региональные настройки.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/cultureinfo/dotnet-cultureinfoexplorer.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Совсем немного теории: в .NET все сведения об определённом языке и региональных параметрах можно найти с помощью класса &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.aspx&quot;&gt;CultureInfo&lt;/a&gt;. Если вы ранее не сталкивались с культурами, то для первичного ознакомления хорошо подойдёт &lt;a href=&quot;http://habrahabr.ru/post/166053/&quot;&gt;этот пост&lt;/a&gt;. Искушённый программист, увлечённый изучением различных существующих региональных настроек, может утомиться от ручного просмотра всех &lt;code&gt;CultureInfo&lt;/code&gt;. Лично я в какой-то момент утомился. Поэтому появилось небольшое WPF-приложение под названием CultureInfoExplorer (&lt;a href=&quot;https://github.com/AndreyAkinshin/CultureInfoExplorer&quot;&gt;ссылка на GitHub&lt;/a&gt;, &lt;a href=&quot;https://github.com/AndreyAkinshin/CultureInfoExplorer/releases/tag/v1.0.0.0&quot;&gt;бинарники&lt;/a&gt;), представленное на вышеприведённом скриншоте. Оно позволяет:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;По данной	&lt;code&gt;CultureInfo&lt;/code&gt; посмотреть значение основных её свойств и то, как в ней выглядят некоторые заранее заготовленные строковые паттерны.&lt;/li&gt;
&lt;li&gt;По данному свойству посмотреть его возможные значения и список всех &lt;code&gt;CultureInfo&lt;/code&gt;, которые соответствуют каждому значению.&lt;/li&gt;
&lt;li&gt;По данному паттерну посмотреть возможные варианты того, во что он может превратиться, и для каждого варианта также посмотреть список соответствующих &lt;code&gt;CultureInfo&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Надеюсь, найдутся читатели, которым данная программка будет полезна. Можно узнать много нового о различных региональных настройках. Ну, а теперь перейдём к примерам.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Числа&lt;/h3&gt;
&lt;p&gt;За представление чисел у нас отвечает &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.aspx&quot;&gt;NumberFormatInfo&lt;/a&gt; (доступный через &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.numberformat.aspx&quot;&gt;CultureInfo.NumberFormat&lt;/a&gt;). И имеются в виду не только обычные числа, а также процентные и денежные значения. Обратите внимание на то, что значения бывают положительные и отрицательные: если вы работаете с локализацией/глобализацией, то важно обращать на это внимание. Настоятельно рекомендую хотя бы пробежаться глазами по документации и посмотреть доступные свойства.&lt;/p&gt;
&lt;p&gt;Одно из самых популярных свойств, которое вызывает проблемы у людей, называется &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numberdecimalseparator.aspx&quot;&gt;NumberDecimalSeparator&lt;/a&gt;. Оно отвечает за то, чем будет при форматировании числа отделяться целая часть от дробной. Типичный пример ошибки: программист сливает массив дробных чисел в строчку, разделяя их запятыми. После этого он пытается распарсить строчку обратно в массив. Если &lt;code&gt;NumberDecimalSeparator&lt;/code&gt; равен точке, то всё будет хорошо. Скажем, при выставленной культуре &lt;code&gt;en-US&lt;/code&gt; у программиста всё заработало, он выпустил свой продукт. Этот продукт скачивает пользователь с культурой &lt;code&gt;ru-RU&lt;/code&gt; и начинает грустить: ведь у него &lt;code&gt;NumberDecimalSeparator&lt;/code&gt; равен запятой: массив из элементов 1.2 и 3.4 при таком слиянии превратится в строчку &lt;code&gt;&amp;quot;1,2,3,4&amp;quot;&lt;/code&gt;, а её распарсить будет проблемно. Лично мне становится ещё грустнее тогда, когда встретивший подобную проблему программист не пытается решить её нормально, указывая правильный &lt;code&gt;NumberFormatInfo&lt;/code&gt; при форматировании, а начинает колдовать с заменами точек на запятые или запятых на точки. Нужно понимать, что &lt;code&gt;NumberDecimalSeparator&lt;/code&gt;, в принципе, может быть любой. Например, в культуре &lt;code&gt;fa-IR&lt;/code&gt; (Persian) он равен слешу (&lt;code&gt;&#39;/&#39;&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Ещё в нашем распоряжении имеются аналогичные свойства для процентов и валют: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentdecimalseparator.aspx&quot;&gt;PercentDecimalSeparator&lt;/a&gt; и &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.currencydecimalseparator.aspx&quot;&gt;CurrencyDecimalSeparator&lt;/a&gt;. Все эти три значения вовсе не обязаны совпадать. Например, у казахов (&lt;code&gt;kk-KZ&lt;/code&gt;) &lt;code&gt;NumberDecimalSeparator&lt;/code&gt; и &lt;code&gt;PercentDecimalSeparator&lt;/code&gt; равны запятой, а &lt;code&gt;CurrencyDecimalSeparator&lt;/code&gt; равен знаку минус (точно такому же, с помощью которого обозначаются отрицательные числа).&lt;/p&gt;
&lt;p&gt;Некоторые считают, что целое число при конвертации в строку даёт значение, состоящее только из цифр. Но цифры эти могут разбиваться на группы. За размер групп отвечает свойство &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numbergroupsizes.aspx&quot;&gt;NumberGroupSizes&lt;/a&gt;, а за их разделитель —
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numbergroupseparator.aspx&quot;&gt;NumberGroupSeparator&lt;/a&gt;	(аналогичные свойства есть у процентов и валют, но они опять-таки не обязаны совпадать). Группы могут быть разного размера: например, во многих культурах (&lt;code&gt;as-IN&lt;/code&gt;, &lt;code&gt;bn-BD&lt;/code&gt;, &lt;code&gt;gu-IN&lt;/code&gt;, &lt;code&gt;hi-IN&lt;/code&gt; и т.п.) &lt;code&gt;NumberGroupSizes&lt;/code&gt; равно {3, 2}. Скажем, число 1234567 в культуре as-IN будет выглядеть как &lt;code&gt;&amp;quot;12,34,567&amp;quot;&lt;/code&gt;. В качестве разделителя групп может выступать пробел &lt;code&gt;\u0020&lt;/code&gt; (например в &lt;code&gt;af-ZA&lt;/code&gt; и &lt;code&gt;lt-LT&lt;/code&gt;), но, увидев его, не торопитесь вбивать очередной костыль на парсинг и форматирование строк. Чаще всего вместо обычного пробела используется неразрывный пробел &lt;code&gt;\u00A0&lt;/code&gt; (наша родная &lt;code&gt;ru-RU&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Знаки для обозначения отрицательных и положительных чисел также входят в культуру: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.negativesign.aspx&quot;&gt;NegativeSign&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.positivesign.aspx&quot;&gt;PositiveSign&lt;/a&gt;. Слава богу, во всех доступных культурах они равны минусу и плюсу, но закладываться на это не стоит: окружение можно переопределить и задать свойствам любые значения. А самое интересное заключается не в знаках, а в паттернах форматирования положительных и отрицательных значений. Например, форматирование отрицательного числа определяется с помощью &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.numbernegativepattern.aspx&quot;&gt;NumberNegativePattern&lt;/a&gt;, у которого есть пять возможных значений:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0 (n)
1 -n
2 - n
3 n-
4 n -
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Например, в культуре &lt;code&gt;ti-ET&lt;/code&gt; (Tigrinya (Ethiopia)) значение &lt;code&gt;-5&lt;/code&gt; предстанет в виде &lt;code&gt;(5)&lt;/code&gt;. С процентами и валютами (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentnegativepattern.aspx&quot;&gt;PercentNegativePattern&lt;/a&gt;,	&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentpositivepattern.aspx&quot;&gt;PercentPositivePattern&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.currencynegativepattern.aspx&quot;&gt;CurrencyNegativePattern&lt;/a&gt;,	&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.currencypositivepattern.aspx&quot;&gt;CurrencyPositivePattern&lt;/a&gt;) дело обстоит ещё веселее. Например, для &lt;code&gt;CurrencyNegativePattern&lt;/code&gt; есть целых шестнадцать возможных значений:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0  ($n)
1  -$n
2  $-n
3  $n-
4  (n$)
5  -n$
6  n-$
7  n$-
8  -n $
9  -$ n
10 n $-
11 $ n-
12 $ -n
13 n- $
14 ($ n)
15 (n $)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Также есть специальные свойства для специальных знаков и специальных численных значений: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.percentsymbol.aspx&quot;&gt;PercentSymbol&lt;/a&gt;,	&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.permillesymbol.aspx&quot;&gt;PerMilleSymbol&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.nansymbol.aspx&quot;&gt;NaNSymbol&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.negativeinfinitysymbol.aspx&quot;&gt;NegativeInfinitySymbol&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.numberformatinfo.positiveinfinitysymbol.aspx&quot;&gt;PositiveInfinitySymbol&lt;/a&gt;. Мне доводилось видеть реальный проект, в котором брался double, форматировался в строку (разумеется, в текущей культуре пользователя), а затем в строковом виде сравнивался с &lt;code&gt;&#171;-Infinity&#187;&lt;/code&gt;. А в зависимости от этой самой текущей культуры &lt;code&gt;NegativeInfinitySymbol&lt;/code&gt; может принимать самые разные значения:&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot; style=&quot;white-space: pre-wrap&quot;&gt;&#39;- безкрайност&#39;, &#39;-- អនន្ត&#39;, &#39;(-) முடிவிலி&#39;, &#39;-∞&#39;, &#39;-Anfeidredd&#39;, &#39;-Anfin&#39;, &#39;-begalybė&#39;, &#39;-beskonačnost&#39;, &#39;&#201;igr&#237;och dhi&#250;ltach&#39;, &#39;-ifedh&#39;, &#39;-INF&#39;, &#39;-Infini&#39;, &#39;-infinit&#39;, &#39;-Infinit&#39;, &#39;-Infinito&#39;, &#39;-Infinitu&#39;, &#39;-infinity&#39;, &#39;Infinity-&#39;, &#39;-Infinity&#39;, &#39;miinusl&#245;pmatus&#39;, &#39;m&#237;nusz v&#233;gtelen&#39;, &#39;-nekonečno&#39;, &#39;-neskončnost&#39;, &#39;-nieskończoność&#39;, &#39;-njek&#243;nčne&#39;, &#39;-njesk&#243;ńcnje&#39;, &#39;-onendlech&#39;, &#39;-Sonsuz&#39;, &#39;-t&#252;keniksizlik&#39;, &#39;-unendlich&#39;, &#39;-Unendlich&#39;, &#39;-Άπειρο&#39;, &#39;-бесконачност&#39;, &#39;терс чексиздик&#39;, &#39;-უსასრულობა&#39;, &#39;אינסוף שלילי&#39;, &#39;-لا نهاية&#39;, &#39;منهای بی نهایت&#39;, &#39;مەنپىي چەكسىزلىك&#39;, &#39;-අනන්තය&#39;, &#39;ᠰᠦᠬᠡᠷᠬᠦ ᠬᠢᠵᠠᠭᠠᠷᠭᠦᠢ ᠶᠡᠬᠡ&#39;, &#39;མོ་གྲངས་ཚད་མེད་ཆུང་བ།&#39;, &#39;ߘߊ߲߬ߒߕߊ߲߫-&#39;, &#39;ꀄꊭꌐꀋꉆ&#39;, &#39;負無窮大&#39;, &#39;负无穷大&#39;&lt;/pre&gt;
&lt;p&gt;Примеры разных полезных свойств мы разобрали. А теперь давайте немножко пошалим: чуть-чуть изменим русскую культуру, чтобы её новое значение портило нам жизнь в примере из начала поста:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var myCulture = (CultureInfo)new CultureInfo(&amp;quot;ru-RU&amp;quot;).Clone();
myCulture.NumberFormat.NegativeSign = &amp;quot;!&amp;quot;;
myCulture.NumberFormat.PositiveSign = &amp;quot;-&amp;quot;;
myCulture.NumberFormat.PositiveInfinitySymbol = &amp;quot;+Inf&amp;quot;;
myCulture.NumberFormat.NaNSymbol = &amp;quot;Not a number&amp;quot;;
myCulture.NumberFormat.NumberDecimalSeparator = &amp;quot;?&amp;quot;;
Thread.CurrentThread.CurrentCulture = myCulture;
Console.WriteLine(-42); // !42
Console.WriteLine(double.NaN); // Not a number
Console.WriteLine(int.Parse(&amp;quot;-42&amp;quot;)); // 42
Console.WriteLine(1.1); // 1?1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Возможно, кто-то тут скажет мне: &#171;Да зачем такие примеры вообще рассматривать? Ни один программист такое никогда писать не будет!&#187;. А я отвечу: &#171;Ну-ну, ни один не будет, как же&#187;. Ситуация становится печальной, когда вы распространяете некоторую библиотеку, а один из её пользователей решил поразвлекаться с культурой. Может, он просто любит развлекаться, а может, пишет приложение для какой-то диковиной культуры (скажем, мёртвого или вымышленного языка). Но это не важно. А важно то, что ваша библиотека начинает вести себя странно в непривычном для неё окружении. Поэтому не стоит закладываться на то, что &lt;code&gt;NegativeSign&lt;/code&gt; и &lt;code&gt;PositiveSign&lt;/code&gt; никогда не меняются. Лучше просто явно указать нужную вам культуру и жить счастливо.&lt;/p&gt;
&lt;p&gt;А ещё, всем советую прочитать недавний пост Джона Скита &lt;a href=&quot;http://codeblog.jonskeet.uk/2014/08/08/the-bobbytables-culture/&quot;&gt;The BobbyTables culture&lt;/a&gt;. Краткая суть: Джон Скит ругается на тех, кто не экранирует параметры в SQL-запросах, даже если это числа и даты. И тогда Джон берёт пару запросов&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;SELECT * FROM Foo WHERE BarDate &amp;gt; &#39;&amp;quot; + DateTime.Today + &amp;quot;&#39;&amp;quot;
&amp;quot;SELECT * FROM Foo WHERE BarValue = &amp;quot; + (-10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и определяет чудо-культуру:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;CultureInfo bobby = (CultureInfo) CultureInfo.InvariantCulture.Clone();
bobby.DateTimeFormat.ShortDatePattern = ＠&amp;quot;yyyy-MM-dd&#39;&#39; OR &#39; &#39;=&#39;&#39;&amp;quot;;
bobby.DateTimeFormat.LongTimePattern = &amp;quot;&amp;quot;;
bobby.NumberFormat.NegativeSign = &amp;quot;1 OR 1=1 OR 1=&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Легким движением руки запросы превращаются в:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SELECT * FROM Foo WHERE BarDate &amp;gt; &#39;2014-08-08&#39; OR &#39; &#39;=&#39; &#39;
SELECT * FROM Foo WHERE BarValue = 1 OR 1=1 OR 1=10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, думаю, дальнейшие пояснения не нужны.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Дата и время&lt;/h3&gt;
&lt;p&gt;С датами и временем всё особенно тяжело. За даты у нас отвечает класс &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.datetimeformatinfo.aspx&quot;&gt;DateTimeFormatInfo&lt;/a&gt; (свойство &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.datetimeformat.aspx&quot;&gt;CultureInfo.DateTimeFormat&lt;/a&gt;), а в нём есть &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.datetimeformatinfo.calendar.aspx&quot;&gt;Calendar&lt;/a&gt;. Причём есть основной календарь культуры (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.calendar.aspx&quot;&gt;CultureInfo&lt;/a&gt;), а есть список доступных для использования календарей (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.cultureinfo.optionalcalendars.aspx&quot;&gt;CultureInfo.OptionalCalendar&lt;/a&gt;). В нашем распоряжении имеется большая пачка стандартных календарей:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.chineselunisolarcalendar.aspx&quot;&gt;ChineseLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.eastasianlunisolarcalendar.aspx&quot;&gt;EastAsianLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.gregoriancalendar.aspx&quot;&gt;GregorianCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.hebrewcalendar.aspx&quot;&gt;HebrewCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.hijricalendar.aspx&quot;&gt;HijriCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.japanesecalendar.aspx&quot;&gt;JapaneseCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.japaneselunisolarcalendar.aspx&quot;&gt;JapaneseLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.juliancalendar.aspx&quot;&gt;JulianCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.koreancalendar.aspx&quot;&gt;KoreanCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.koreanlunisolarcalendar.aspx&quot;&gt;KoreanLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.persiancalendar.aspx&quot;&gt;PersianCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.taiwancalendar.aspx&quot;&gt;TaiwanCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.taiwanlunisolarcalendar.aspx&quot;&gt;TaiwanLunisolarCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.thaibuddhistcalendar.aspx&quot;&gt;ThaiBuddhistCalendar&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.globalization.umalquracalendar.aspx&quot;&gt;UmAlQuraCalendar&lt;/a&gt;
(у некоторых есть ряд дополнительных важных параметров). Логика у них, доложу я вам, самая разная. Не будем останавливаться подробно, ибо на эту тему подробной информации в интернете достаточно, а материала хватит на серию самостоятельных постов. Правила форматирования дат и времени ещё более весёлые, чем у чисел: куча паттернов для разных вариантов форматирования даты, нативные имена для месяцев и дней недели, обозначения для AM/PM, разделители и т.п. Скажем, 31 декабря 2014 года может быть представлено (&lt;code&gt;dateTime.ToString(&amp;quot;d&amp;quot;)&lt;/code&gt;) в следующих форматах:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;09/03/36
10/3/1436
12/31/2014
1436/3/10
2014.12.21.
2014/12/21
2014-12-21
31. 12. 2014
31.12.14
31.12.14 &#253;.
31.12.2014
31.12.2014 г.
31.12.2014.
31/12/14
31/12/2014
31/12/2557
31-12-14
31-12-2014
31-дек 14
31-жел-14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И это только дефолтные значения (без подключения опциональных календарей). Но даже тут видно разнообразие летоисчислений: у кого-то на дворе 1436 год, а у кого-то — 2557 (это отсылка к предпоследней строчке примера из начала статьи). Если вы оперируете с датами, то следует задуматься: стоит ли их показывать всегда в одинаковом формате или же подстроиться под пользователя и отобразить дату в более привычном для него виде. Ну, а про парсинг дат я вообще умолчу.&lt;/p&gt;
&lt;h3 id=&quot;the-turkey-test&quot;&gt;The Turkey Test&lt;/h3&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/cultureinfo/turkey-flag.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Есть классический пост от 2008 года под называнием &lt;a href=&quot;http://www.moserware.com/2008/02/does-your-code-pass-turkey-test.html&quot;&gt;Does Your Code Pass The Turkey Test?&lt;/a&gt;. Подробно пересказывать его не буду, лучше самостоятельно прочитать оригинал. Краткая суть The Turkey Test такова: поменяйте текущую культуру на tr-TR (Turkish (Turkey)) и запустите ваше приложение. Всё ли нормально работает? В этой культуре хватает веселья и с датами, и с числами, и со строками. Если вернуться к нашему первому примеру, то в рассматриваемой культуре &lt;code&gt;&amp;quot;i&amp;quot;.ToUpper()&lt;/code&gt; не равно &lt;code&gt;&amp;quot;I&amp;quot;&lt;/code&gt;, а &lt;code&gt;&amp;quot;I&amp;quot;.ToLower()&lt;/code&gt; не равно &lt;code&gt;&amp;quot;i&amp;quot;&lt;/code&gt; (если вам интересно больше узнать про заглавные и строчные буквы, то крайне рекомендую &lt;a href=&quot;http://habrahabr.ru/post/147387/&quot;&gt;этот пост&lt;/a&gt;	и &lt;a href=&quot;http://stackoverflow.com/a/6163129/184842&quot;&gt;вот этот SO-ответ про UTF-8&lt;/a&gt;, это просто прекрасно). В конце поста приводится замечательный пример, в котором под регулярное выражение &lt;code&gt;\d{5}&lt;/code&gt; подходит строка состоящая из арабских цифр &lt;code&gt;&amp;quot;٤٦٠٣٨&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Вместо заключения&lt;/h3&gt;
&lt;p&gt;Наука о региональных настройках сложна. В этом посте я ни в коем случае не претендую на то, чтобы выдать полную информацию о том, на что же они могут влиять. Есть ещё очень много разных интересностей, связанных с интернализацией (думаю, только про идущий справа налево текст можно написать отдельный пост, да и не один). Мне просто хотелось показать несколько занимательных примеров того, как &lt;code&gt;CultureInfo.CurrentCulture&lt;/code&gt; может повлиять на ваше приложение. Надеюсь, в плане расширения общей эрудиции этот материал окажется кому-то полезным. Общая мораль такова: если вы не хотите думать о том, что в мире существует много разных культур, то используйте везде &lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt; (или другую подходящую вам культуру) — в подавляющем большинстве случаев вы сможете спать спокойно. А если вы об этом задумываетесь, то неплохо бы поизучать эту область более основательно. В этом может помочь вот эта хорошая книжка: &lt;a href=&quot;https://www.goodreads.com/book/show/1310940.Net_Internationalization&quot;&gt;Net Internationalization: The Developer&#39;s Guide to Building Global Windows and Web Applications&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Приветствуются любые дополнительные факты о том, как &lt;code&gt;CultureInfo&lt;/code&gt; может повлиять на работу различных функций. Думаю, у многих найдутся собственные увлекательные истории.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;habrahabr.ru/post/237209/&quot;&gt;Оригинал поста на Хабре&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Happy Monday!</title>
            <link>http://aakinshin.net/posts/happy-monday/</link> 
            <pubDate>Mon, 11 Aug 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/happy-monday/</guid>
            <description>&lt;p&gt;Today I tell you a story about one tricky bug. The bug is a tricky one because it doesn&#39;t allow me to debug my application on Mondays. I&#39;m serious right now: the debug mode doesn&#39;t work every Monday. Furthermore, the bug literally tell me: &amp;quot;Happy Monday!&amp;quot;.&lt;/p&gt;
&lt;p&gt;So, the story. It was a wonderful Sunday evening, no signs of trouble. We planned to release a new version of our software (a minor one, but it includes some useful features). Midnight on the clock. Suddenly, I came up with the idea that we have a minor bug that should be fixed. It requires a few lines of code and 10 minutes to do it. And I decided to write needed logic before I go to sleep. I open VisualStudio, lunch build, and wait. But something goes wrong, because I get the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hmm. It is a strange error. &lt;!--more--&gt; Furthermore, it doesn&#39;t allow to build my project without any additional information. I don&#39;t know neither location nor cause of the error. Maybe some of my local files were spoiled? Let&#39;s run &lt;code&gt;git clean -f -x -d&lt;/code&gt; and build it again! The result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hmm. Maybe there are some bad changes in the last commit? I checkout to the previous commit, then to the next one, then to the next one. Then I checkout to a super stable commit (I&#39;m 100% sure that it would work). Aaand the result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hmm. Maybe there are some bad changes in my environment? I reboot my laptop, build the project. The result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hmm. Maybe there some critical bad changes in my environment? I take another laptop, clone the repository, build the project. The result:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4am on the clock. I still can&#39;t build my project. I try every idea I have, but nothing helps. Accidentally, I change build configuration from Debug to Release, and a miracle happened: the build is completed successfully. I try to switch to debug and the see familiar error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What the.. The situation makes me angry. I open a console, run MSBuild, and start to read a very big log. And I find some remarkable lines in the middle of the log:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Starting the pipe server: &amp;quot;C:\ProgramData\PostSharp\3.1.28\bin.Release\postsharp.srv.4.0-x86.exe /tp &amp;quot;postsharp-S-1-5-21-1801181006-371574121-2664876850-1002-4.0-x86-release-3.1.28-a4c26157a4624bb9&amp;quot; /config &amp;quot;C:\ProgramData\PostSharp\3.1.28\bin.Release\postsharp.srv.4.0-x86.exe.config&amp;quot;&amp;quot;.
  : info : Executing PostSharp 3.1 [3.1.28.0, 32 bit, CLR 4.5, Release]
  : message : Happy Monday! As every Monday, you&#39;re getting all the features of the PostSharp Ultimate for free.
  : message : PostSharp 3.1 [3.1.28.0, 32 bit, CLR 4.5, Release] complete -- 0 errors, 0 warnings, processed in 102 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What a twist! &lt;a href=&quot;http://www.postsharp.net/&quot;&gt;PostSharp&lt;/a&gt; decided to wish my a happy Monday and give an access to all the features of the ultimate edition. But this wish broke my build. We didn&#39;t use PostSharp in the Release mode, and bug happens only in the Debug mode.&lt;/p&gt;
&lt;p&gt;If you google troubles with PostSharp, you can also find a lot of interesting stories (e.g. &lt;a href=&quot;http://www.postsharp.net/blog/post/URGENT-ACTION-REQUIRED-Critical-Defect-in-PostSharp-31-process-exits-with-code-199&quot;&gt;Critical Defect in PostSharp 3.1&lt;/a&gt;, &lt;a href=&quot;https://plus.google.com/113181962167438638669/posts/QF5pDB4XY6F&quot;&gt;&#171;PostSharp bugs that occur only on a Monday? Really? &#128550;&#187;&lt;/a&gt;. Fortunately, there is no such bug in the latest version of PostSharp. v3.1.48 still with me a happy Monday, but it doesn&#39;t broke the &amp;quot;pipe server&amp;quot;.&lt;/p&gt;
&lt;p&gt;It was a valuable lesson for me, and I hope you also find this story enlightening.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Happy Monday!</title>
            <link>http://aakinshin.net/ru/posts/happy-monday/</link> 
            <pubDate>Mon, 11 Aug 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/happy-monday/</guid>
            <description>&lt;p&gt;Хотелось бы рассказать историю одного волшебного бага. Волшебство его заключалось в том, что он не давал нам отлаживать по понедельникам. Я сейчас совершенно серьёзно: каждый понедельник у нас отваливался Debug mode. Мало того, этот баг с циничным видом желал нам счастливого понедельничка. Для меня это был очень ценный урок в плане того, какие же всё-таки разнообразные бывают проблемы. Возможно, кому-то ещё эта история покажется любопытной.&lt;/p&gt;
&lt;p&gt;Итак, как же я впервые встретился с этой багой. Был замечательный вечер воскресенья, ничего не предвещало беды. В понедельник планировался очередной релиз нашей программки (ничего мажорного, но клиенты ждали обещанных мелких фич). На часах отображалось 00:00, и тут мне пришла в голову мысль, что один из пользовательских сценариев для новой фичи мы не проработали. Нужно было дописать всего несколько дополнительных строк, делов минут на 10. Я решил, что сейчас быстренько допишу нужную логику и с чистой совестью лягу спать. Запускаю студию, запускаю билд проекта, жду. И тут моё лицо становится озадаченным, т.к. я вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Странная ошибка-то какая-то.&lt;!--more--&gt; Тем более, что она не даёт сбилдить проект, не сообщая о себе никакой дополнительной информации: ни место, ни причину возникновения. Думаю: ну, мб, я в каких-то пользовательских настройках проекта что-то испортил. Говорю:	&lt;code&gt;git clean -f -x -d&lt;/code&gt;, очисти мне всё, чего нет в репозитории. Запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ну, может чего-нибудь испортилось в самом последнем коммите? Откатываюсь на один коммит назад, на второй, на третий. Откатываюсь на месяц назад к супер-стабильной ревизии, с которой точно всё было хорошо. Запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ну, может чего-то в системном окружении сломалось? Перезагружаюсь, запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ну, может чего-то в системном окружении совсем-совсем сломалось? Переношу проект на чистый комп, запускаю билд, вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Часы начинают показывать 4-ый час ночи, а я ещё даже проект не сбилдил. В порядке протыкивания всего подряд меняю Configuration на Release. И о чудо — билд проходит успешно, приложение запускается. Возвращаю Debug — вижу ошибку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Error connecting to the pipe server.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Ситуация начинает меня злить, я запускаю из консоли MSBUILD и начинаю изучать километровый лог. И в нём я нахожу чудесные строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Starting the pipe server: &amp;quot;C:\ProgramData\PostSharp\3.1.28\bin.Release\postsharp.srv.4.0-x86.exe /tp &amp;quot;postsharp-S-1-5-21-1801181006-371574121-2664876850-1002-4.0-x86-release-3.1.28-a4c26157a4624bb9&amp;quot; /config &amp;quot;C:\ProgramData\PostSharp\3.1.28\bin.Release\postsharp.srv.4.0-x86.exe.config&amp;quot;&amp;quot;.
  : info : Executing PostSharp 3.1 [3.1.28.0, 32 bit, CLR 4.5, Release]
  : message : Happy Monday! As every Monday, you&#39;re getting all the features of the PostSharp Ultimate for free.
  : message : PostSharp 3.1 [3.1.28.0, 32 bit, CLR 4.5, Release] complete -- 0 errors, 0 warnings, processed in 102 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вы только поглядите: &lt;a href=&quot;http://www.postsharp.net/&quot;&gt;PostSharp&lt;/a&gt;	решил пожелать мне счастливого понедельника, угостив плюшками Ultimate-версии (которые мне не особо нужны), но сломав при этом построение моего проекта! Не ожидал я от него такого, не ожидал. Но почему же только отлаживать было нельзя? А всё потому, что мы использовали PostSharp для логирования в Debug mode, в Release он не попадал.&lt;/p&gt;
&lt;p&gt;Если у вас возникла подобная проблема, то лечится она просто. Некоторое гугление даёт нам информацию о том, что в недавних версиях PostSharp-а были различные дефекты (например, такой: &lt;a href=&quot;http://www.postsharp.net/blog/post/URGENT-ACTION-REQUIRED-Critical-Defect-in-PostSharp-31-process-exits-with-code-199&quot;&gt;Critical Defect in PostSharp 3.1&lt;/a&gt;), которые могли сделать вашу жизнь достаточно грустной. Описанный выше баг является достаточно старым. Я нашёл историю от марта 2012 (PostSharp 2.1) с замечательным названием &lt;a href=&quot;https://plus.google.com/113181962167438638669/posts/QF5pDB4XY6F&quot;&gt;&#171;PostSharp bugs that occur only on a Monday? Really? &#128550;&#187;&lt;/a&gt;. К счастью, в актуальной версии PostSharp-а проблема вроде бы ушла. У меня на 3.1.48 всё заработало хорошо. Счастливого понедельника PostSharp мне всё ещё желает, но pipe server при этом остаётся целым.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Мне сложно сформировать какую-то конкретную мораль этой истории. Скажу только то, что она научила меня шире смотреть на проблемы, которые могу возникнуть. А ещё, если студия плюётся в вас какими-то непонятными ошибками, то в первую очередь нужно не думать о проблеме и о возможных причинах её возникновения, а сразу смотреть лог от MSBUILD-а. А ещё я выяснил, что за последние несколько месяцев никто в нашей команде не отлаживал приложение по понедельникам =)&lt;/p&gt;</description>
        </item>
        <item>
            <title>Получение MCP: личный опыт</title>
            <link>http://aakinshin.net/ru/posts/ms-mcp/</link> 
            <pubDate>Thu, 24 Jul 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/ms-mcp/</guid>
            <description>&lt;p&gt;Не так давно мне на работе перепал ваучер на бесплатную сдачу экзамена от Microsoft. &#171;А почему бы и нет?&#187; — подумал я. План был выполнен успешно, в связи с чем мне хотелось бы поделиться личным опытом. Возможно, эта история пригодится тем, кто только собирается начать получать сертификации от Microsoft.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/ms-mcp/mvp-roadmap.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;section&quot;&gt;Выбираем экзамен&lt;/h3&gt;
&lt;p&gt;Я очень долго медитировал на схему, приведённую выше. Ух, ну и понаделали же разных экзаменов! Увы, большинство из них (всякие Lync Server, SharePoint, JavaScript и т.п.) не привлекли моего внимания. Выбор остановился на экзамене &lt;a href=&quot;https://www.microsoft.com/learning/ru-ru/exam-70-483.aspx&quot;&gt;070-483&lt;/a&gt; &#171;Programming in C#&#187;.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Готовимся к экзамену&lt;/h3&gt;
&lt;p&gt;Перед экзаменом полагается готовиться.
Я пришёл к выводу, что лучшей подготовкой к экзамену будет несколько лет программирования на C#.
Если хочется почитать книжку, то лучше всего пойдёт классика под .NET: &lt;a href=&quot;https://www.goodreads.com/book/show/16033480-clr-via-c&quot;&gt;CLR via C#&lt;/a&gt;	от Джеффри Рихтера.
Но, давайте взглянем, что же предлагает нам интернет в плане подготовки.
Первой книжкой, которая попалась мне на глаза, была	&lt;a href=&quot;https://www.goodreads.com/book/show/17082095-mcsd-certification-toolkit-exam-70-483&quot;&gt;MCSD Certification Toolkit (Exam 70-483): Programming in C#&lt;/a&gt;.
Ох, лучше бы я её никогда не открывал. И вам не советую. С первых же глав в глаза бросается чудовищное количество ошибок. Причём, не спорных мест, а именно очень грубых ошибок. Готовиться по ней к чему бы то ни было просто не представляется возможным.
Второй книжка была &lt;a href=&quot;https://www.goodreads.com/book/show/16144492-exam-ref-70-483&quot;&gt;Exam Ref 70-483: Programming in C#&lt;/a&gt; от замечательного человека по имени &lt;a href=&quot;http://wouterdekort.blogspot.ru/&quot;&gt;Wouter de Kort&lt;/a&gt;. Это уже намного более адекватное чтиво. Не скажу, что по ней можно на 100% подготовится, но она хотя бы даёт неплохое представление о том, что вообще нужно знать к экзамену.
Можете также почитать достаточно подробную &lt;a href=&quot;http://sonyks2007.blogspot.ru/2014/02/microsoft-exam-70-483.html&quot;&gt;рецензию на эти книжки&lt;/a&gt;.
А ещё, я наткнулся на замечательный блог &lt;a href=&quot;http://mypathto70-483.blogspot.ru/&quot;&gt;mypathto70-483.blogspot.ru&lt;/a&gt;. Автор блога основательно готовится к экзамену, подробно прорабатывая каждую (даже самую небольшую) тему из экзаменационного перечня. По мере подготовки с хорошей регулярностью появляются соответствующие посты. &lt;em&gt;Update: В настоящее время автор успешно сдал экзамен&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Хочется отметить, что если вы неплохой .NET-разработчик, если вы понимаете как работает платформа и неплохо помните стандартные классы, то можно почти не готовиться. Разве что, просмотреть те темы, с которыми вам сталкиваться не приходилось (например, криптографию, многопоточность, работу со сборками или профилирование приложений — далеко не всем по работе попадаются все тематики экзамена).&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Записываемся на экзамен&lt;/h3&gt;
&lt;p&gt;Большую часть времени я нахожусь в Новосибирске, так что экзамен решил проходить тут же. В Нск сертификацией от Microsoft занимается &lt;a href=&quot;http://www.sibinfo.ru/&quot;&gt;Сибинфоцентр&lt;/a&gt;. Если есть какие-то непонятности, то можно туда позвонить и получить подробную консультацию по всем интересующим вас вопросом.&lt;/p&gt;
&lt;p&gt;Непосредственную регистрацию необходимо проходить на сайте &lt;a href=&quot;https://www.prometric.com&quot;&gt;https://www.prometric.com&lt;/a&gt;. У сайта, мягко говоря, с навигацией проблемы. Дам подсказку: чтобы записаться на экзамен, нужно сначала зарегистрироваться. А регистрация происходит по нажатию на надпись &#171;IT TEST TAKER Account Sign-In&#187; в центре страницы, которая умело маскируется под радиобаттон. После этого всё просто: проходите регистрацию, выбираете экзамен (категория &lt;i&gt;Microsoft (070, 071, 074, MBx)&lt;/i&gt;), выбираете нужный центр тестирования и удобное для вас время. Как правило, свободного времени хватает — отчего-то особых очередей на сдачу Microsoft-овских экзаменов не наблюдается.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Сдаём экзамен&lt;/h3&gt;
&lt;p&gt;В Сибинфоцентре мне очень понравилось. Пришёл я с хорошим временным запасом, так что мне предложили дождаться начала экзамене в местной комнате отдыха:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/ms-mcp/subinfocenter.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Комната отдыха хороша: есть чай, кофе и вкусные печеньки. Причём, печеньки действительно вкусные — ощущается, что ребята не набрали каких попало, а именно выбирали повкуснее. Ценю я внимание к мелочам =). Также есть всякие проспектики о проводимых в центре сертификациях, так что вполне можно занять себя кофейком и полезным чтением.&lt;/p&gt;
&lt;p&gt;Вскоре пришёл ответственный за проведение Microsoft-овского тестирования. Надо отдать ему должное — он меня хорошо проинструктировал о процессе прохождении экзамена и подробно ответил на все вопросы. В общем, ребята держат достойный уровень.&lt;/p&gt;
&lt;p&gt;Перед экзаменом необходимо предъявить два удостоверения личности (в моём случае подошли паспорт и водительское удостоверение). Все личные вещи складываются в сейф, т.к. в экзаменационную комнату их проносить нельзя. С собой выдаётся лишь два специальных листа бумаги и два маркера (впрочем, за время экзамена мне не довелось их испытать).&lt;/p&gt;
&lt;p&gt;Перед экзаменом я наподписывал всяких &lt;a href=&quot;https://www.microsoft.com/learning/en-us/certification-exam-policies.aspx&quot;&gt;NDA&lt;/a&gt;, поэтому особо ничего про экзамен рассказать не могу, ограничусь лишь впечатлениями. Экзамен меня порадовал: все вопросы весьма адекватные и корректные (что особенно радует после подготовительной литературы). Было несколько вопросов, которые меня смутили, но тут скорее всего со мной что-то не так, а не с экзаменом. Тестирующая система тоже порадовала: всё понятно, пользоваться удобно, ничего не глючит — сплошное удовольствие. Перед экзаменом также можно пройти быстрый туториал по тому, как ей пользоваться, ввиду чего непонятных моментов не остаётся вовсе. Основная часть экзамена идёт два часа, но этого более, чем достаточно. Если вы всё знаете, то можно успеть прочитать каждый вопрос на несколько раз, подумать, ещё раз перечитать вопрос, ещё раз основательно подумать, выбрать правильный ответ, а по окончанию тестирования ещё раз всё проверить. А если вы что-то не знаете, то дополнительное время не особо поможет. У меня на всё вместе с проверкой ушло 1.5 часа. После окончания тестирования вам предложат написать комментарии к вопросам (они отправляются в Microsoft для улучшения качества тестирования), а также пройти короткий опросник об уровне сертификации (но это всё опционально). Предварительные результаты (а скорее всего они и будут окончательными) сразу показываются на экране.&lt;/p&gt;
&lt;p&gt;После успешного прохождения экзамена вам на руки выдаются ваши результаты в печатном виде с рифлёной печатью и подписью, после чего предлагается ждать письма на почту. Результаты тестирования отправляются сперва в Prometrics, затем в Microsoft, где их должны аккуратно проверить в течении 7 рабочих дней. Начитавшись разных отзывов о получении MCP (&lt;a href=&quot;http://sonyks2007.blogspot.ru/2014/02/mcp.html&quot;&gt;раз&lt;/a&gt;,	&lt;a href=&quot;http://www.danshin.ms/2007/12/mcp.html&quot;&gt;два&lt;/a&gt;) я опасался, что эта часть затянется. Но Microsoft меня порадовали: уже на следующий день мне пришло письмо, по ссылке из которого я зарегистировался на сайте &lt;a href=&quot;http://mcp.microsoft.com/&quot;&gt;mcp.microsoft.com&lt;/a&gt;. После этой процедуры выдаётся учётная запись, с которой связывается свежевыданный &lt;em&gt;Micrisoft Certification ID&lt;/em&gt;. Из под этой учётной записи можно в любой момент смотреть все сданные экзамены, планировать будущие экзамены и расшаривать данные о сертификатах заинтересованным лицам. Собственно говоря, после регистрации я увидел у себя две записи: &lt;em&gt;MCPS: Microsoft Certified Professional&lt;/em&gt; и &lt;em&gt;MS: Programming in C# Specialist&lt;/em&gt;. Выглядят они примерно так:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/ms-mcp/mcp.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;У Microsoft есть также более крутые сертификации, для получения которых нужно пройти несколько экзаменов. После 70-483 можно качаться либо в &lt;em&gt;MCSD: Windows Store Apps Using C#&lt;/em&gt;, либо в &lt;em&gt;MCSD: Web Applications&lt;/em&gt;. Но, увы, подобные штуки меня уже не настолько вдохновляют. Так что будем ждать, когда MS проведут очередную реорганизацию системы сертификатов, чтобы в ней появилось что-нибудь более заманчивое =).&lt;/p&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Впечатления от мероприятия сугубо положительные, опыт полезный. Если вы в себе ощущаете силы пройти подобную сертификацию, а также у вас есть на это время и возможности ($80 или ваучер), то я бы посоветовал озадачиться. Как минимум, это достаточно интересно, а бумажка от MS тоже лишней не будет, можно будет включить в резюме.&lt;/p&gt;</description>
        </item>
        <item>
            <title>To Refactor Or Not To Refactor?</title>
            <link>http://aakinshin.net/posts/refactoring/</link> 
            <pubDate>Sat, 19 Jul 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/refactoring/</guid>
            <description>&lt;p&gt;I like refactoring. No, I love refactoring. No, not even like this. I awfully love refactoring.&lt;/p&gt;
&lt;p&gt;I hate bad code and bad architecture. I feel quite creepy when I design a new feature and the near-by class contains absolute mess. I just can’t look at the sadly-looking variables. Sometimes before falling asleep I close my eyes and imagine what could be improved in the project. Sometimes I wake up at 3:00AM and go to my computer to improve something. I want to have not just code, but a masterpiece that is pleasant to look at, that is pleasant to work with at any stage of the project.&lt;/p&gt;
&lt;p&gt;If you just a little bit share my feelings we have something to talk about. The matter is that over some time something inside me began to hint that it’s a bad idea to refactor all code, everywhere and all the time. Understand me correctly – code should be good (even better when it’s ideal), but in real life it’s not reasonable to improve code instantly. I formed some rules about the refactoring timeliness. If I am itching to improve something, I look at these rules and think “Is that the moment when I need to refactor the code?” So, let’s talk about when refactoring is necessary and when it’s inappropriate.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Disclaimer:&lt;/em&gt; Most likely many of you will immediately say: “We have discussed it 60 times!” or “This is so obvious, why writing about it?” Probably, you’re right, but there is one moment: there is chaos all around. It looks like everything is clear, but in fact it’s not that clear at all. That is why I think it won’t be much harm to have another look at this issue. If you have no problems with refactoring you can just miss this post, everything is already ok for you.&lt;/p&gt;
&lt;h3 id=&quot;too-early-refactoring&quot;&gt;Too early refactoring&lt;/h3&gt;
&lt;p&gt;Do you remember when you had a permanent project specification that hasn’t been changed for months? I can hardly remember such a situation. We live in real world, requirements constantly change. And it’s not always about external requirements; it can be about your own requirements to the project. Here is the sample: let’s assume you got a mid-sized task for one or two days. Some classes have been created, but there is nothing to run yet – you create harsh architectural part. And here you notice that one of the parts is not very universal: “What if we need to do X in six months, everyone will suffer”. It’s understandable that you don’t want to commit bad code to the repository to make other developers apply harsh epithets to you. And you start refactoring the unfinished feature. Sometimes it’s reasonable, but there should be a “DANGER” label on this way. You will fix one issue, then another one, then one more issue. A week has passed, the feature still can’t run, but you say: “It’s all done inappropriately. Now I really know how I need to do it. I will re-write everything from scratch.” The main problem is that you have no feedback on the feature and you have already started improving code base. Such approach will hardly bring much success. I don’t know how it is about you, I often begin to understand that the feature should work a bit differently right after it’s been finished. And this is not because I am so stupid and couldn’t think it over properly. You need to touch some functionality to understand how it should be done in the release version. Sometimes a small prototype (allowing bad code and bugs) is necessary to discuss the feature with colleagues. Sometimes you need to show a thing to the customer to get his feedback: “No, I didn’t want it in this way, you need to do it in the opposite way”. Users don’t like innovations, they want everything as it was before. The problem with new features is that it’s difficult to predict their future. Very often all practical work goes to trash because the team decided to do it in a different way after some discussions. Summary: don’t refactor too early especially if you are not sure your code will stay in the project.&lt;/p&gt;
&lt;h3 id=&quot;off-purpose-refactoring&quot;&gt;Off purpose refactoring&lt;/h3&gt;
&lt;p&gt;Most likely you have development plan for the nearest future. Most likely there is the deadline (even if you set it). Projects should be released in time, don’t delay it. You need to control yourself, you need to do the things that are within your direct purposes. Assume, you’ve got code snippet that looks like… Looks awfully. And you don’t work with this code at the moment. This code works stably, does the job successfully and is not connected to your current task. So, don’t touch it! Yes, you can feel sad that the other part of the project isn’t that good. But notice that it doesn’t affect you in any way. You have current tasks, work on them. Of course, there are tasks to improve code base; but very often it’s usually more important to add new features or fix bugs. Focus on your current tasks and don’t delay them because something is wrong somewhere.&lt;/p&gt;
&lt;h3 id=&quot;refactoring-for-refactoring&quot;&gt;Refactoring for refactoring&lt;/h3&gt;
&lt;p&gt;Ok, you came to conclusion that you certainly need to refactor some part of your project. Well, let’s refactor. It seems that all planned modifications are done and here you get an idea: “What else can be improved? Here is the thing.” And there obviously will be another thing and then another, and one more thing, etc. It’s necessary to understand that there is bad code, good code and ideal code. The last one will never be available in a big project. It doesn’t mean that you don’t need to achieve it, but you need to understand its inaccessibility. Usually the task is to write good code, not ideal. Assume that after refactoring, you got quite understandable code that works in an obvious manner, that doesn’t contain kludges and that is quite easy-to-use. Ask yourself: “May it’s time to stop?” Yes, you can continue improving the code. And you can do it infinitely in a quite big project. But right now it does the job, it’s convenient to use, it almost doesn’t annoy you. It’s very important to determine acceptable quality of code that prevents you from further improvement (until its acceptability is lost). Remember that there are so many cool things that you can create. Don’t refactor for refactoring, for ideal code. It’s necessary to refactor when you have solid reasons: the code is unreadable, it’s difficult to maintain, develop and use. If none of these reasons appear, you don’t need refactoring.&lt;/p&gt;
&lt;h3 id=&quot;a-day-before-release-refactoring&quot;&gt;A-day-before-release refactoring&lt;/h3&gt;
&lt;p&gt;It happens that the release should be delivered today/ tomorrow/the day after tomorrow (underline the applicable variant). This is an important moment in the project life cycle. Developers need to spend time for testing, fixing of critical bugs, finishing work. Believe me, this is a really bad idea to refactor code base (and it’s even worse – do it qualitatively) when you need to provide code to production. My experience says that it’s better to release the project and then improve code with no mess. Some developers can ask: “Why?” If there is such a question you probably have never done complicated refactoring. I will give you a hint: when you improve the code, it’s not necessarily improved – sometimes it can break. It’s not always about complicated refactoring. Sometimes you just fix a single method of five lines, miss some dependency and the other part of project gets critical bug that your users immediately face with. It seems that you don’t do anything wrong and here you are attacked by the beast called “It was obvious” and it drowns you in the pond of improper initial estimation. Though may be I am a bad developer – I like to break something. It’s possible that you always refactor in an absolutely right manner and with due control of the whole project. In this case I can congratulate you, but I won’t refuse my advice about pre-release refactoring. Believe me, refactoring won’t run away in several days and the entire team will sleep a little bit better.&lt;/p&gt;
&lt;h3 id=&quot;refactoring-of-the-very-old-code&quot;&gt;Refactoring of the very old code&lt;/h3&gt;
&lt;p&gt;The question is difficult, very difficult. The situation is as follows: there is an enormous amount of code lines that you’ve got from the previous developers (probably, this previous developer was you several years ago before you got to know how to write the correct code at once). Code should be maintained. Here and there developers add kludges and duplicates; entropy increases. Day by day you even more and more want to throw everything away and start from the very beginning. At this moment you need to think carefully about all risks. Yes, it’s possible that this activity will be helpful in the future. But in what future? and how much helpful? Most likely in the process of big refactoring or re-writing of separate parts, you will replace the old working bad code with new ideal code, yet with bugs. And this is not because you are a bad programmer and write bad code. It’s just about the fact that you may not know this code enough. You may not know why the author projected everything in this manner, and there could be some reasons. Sometimes you have to write a very rear and awkward code. I can give a lot of samples: suppression of tricky processor optimizations; adjustment to the bugs of some third party library, suppression of some multi-threaded issues, etc. I don’t say that you can’t solve these issues properly. Sometimes when you replace the absurd code with the good one, you get lots of bugs. Yes, you could do it properly, but you might not realize the entire splendor of the hut of kludges instead of sticks, if you don’t ask author of this code why it’s written in this way (and this is quite a rare opportunity). Be careful when you re-write the old code that you don’t completely understand (and especially when you think there is nothing to understand).&lt;/p&gt;
&lt;h3 id=&quot;so-when-to-refactor&quot;&gt;So, when to refactor?&lt;/h3&gt;
&lt;p&gt;I am sorry if the first part of this article made you think that refactoring only brings problems. I still insist that the code should be readable and understandable. It also should be convenient to use and easy to maintain and develop. Positive approach is better than the negative one. So, think of refactoring not as of the source of problems, but as of your good friend who will come to rescue in an hour of need. Moreover, this friend can reduce the amount of such hours in your promising future. I would like to indicate several moments when refactoring is really relevant.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Nothing to do.&lt;/strong&gt; Sometimes there happens project downtime when all critical tasks are closed and the new ones haven’t been set yet. It’s not really that there is nothing to do at all, but you have some free time. Spend it to improve the code. Give understandable names to substances, get rid of duplicates, re-write inaccurate architecture. Though no new features are added, you make contribution to peace of mind of developers who will continue working in the project. Believe me, this is very important.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Everyday pain.&lt;/strong&gt; It happens that there is a part of the project that makes you sigh every day. And you hear similar sighs of your colleagues from the nearby working places. Of course, the release date is not tomorrow, but there are lots of important tasks. Nevertheless, week passes by week and it becomes more and more disappointing to see this code. Say: “This is enough!” If the business plan is created by your chief then you need to explain that this code just should be re-designed. If you have a customer, convince him that a week spent for refactoring will save much time in the future. If you work for users, make the decision that this time it would be better for the users to wait for a new version for one more week and then enjoy stable software and regular updates. Yes, it’s not that easy to agree with the others and with yourself, but do your best.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;The problem of late refactoring.&lt;/strong&gt; Don’t overemphasize the rule of early refactoring. Some developers think: “Now I will improve something and it won’t come useful – that’s a shame.” You need to understand that the application engine can contain critical parts that would better be written properly. Remember that the later you make refactoring the higher will be its cost because you will spend more time and effort for re-writing. Critical base code (that is used throughout the project) should constantly be in a good condition. It would be great for your team to have the following statement work: “Refactoring never comes late. It comes exclusively when it thinks it’s necessary.”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Meeting with a monster.&lt;/strong&gt; You begin to add new features that should use the old project part which looks like a real monster: you’re scared only at a glance on the external interface. If you have enough time it would be better to fix code base and then focus on the new functions and don’t get distracted to add some kludges for code re-use.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Reasonable perfectionism.&lt;/strong&gt; Have you noticed bad code? Want to fix it? Really want to fix it? If you really want it, do it. But pay attention to the word “reasonable”. Correlate time spent for refactoring to benefits you get from code improvement. Don’t postpone the deadline and don’t go deep into infinite improving of the code. Though if you refactor timely and reasonably, the project will succeed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;All the above is a personal summary of experience related to the work on some projects. Of course, I haven’t covered all situations. Every team has its own requirements to the code, its own business plan and its rules. I am sure many developers have a couple of stories like: “And there was a case when all the advice doesn’t work”. This is absolutely ok, it should be like this. There is no silver bullet to define the amount of effort for code optimization (like “We will refactor every day for 47 minutes and 23 seconds and everything will be ok”). In your certain team, in every certain project and based on your personal experience, you need to find the golden mean between adding the new code and improving the old code. I agitate for reasonable approach to everything, without fanaticism (“Why improve the code, no new functions will appear” / “I need to make all code ideal, so it will be fine to work with.”). Be wise when allocating time for the work with the existing code and everything will be ok for you.&lt;/p&gt;
&lt;p&gt;You’re welcome with ideas and thoughts on when it’s ok or not ok to refactor. One of the most valuable things in the field is experience of real developers who work with real projects.&lt;/p&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-refactor-or-not-to-refactor-part-i/&quot;&gt;blogs.perpetuumsoft.com, Part I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-refactor-or-not-to-refactor-part-ii/&quot;&gt;blogs.perpetuumsoft.com, Part II&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Рефакторить или не рефакторить?</title>
            <link>http://aakinshin.net/ru/posts/refactoring/</link> 
            <pubDate>Sat, 19 Jul 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/refactoring/</guid>
            <description>&lt;p&gt;Мне нравится рефакторинг. Нет, не так. Я люблю рефакторинг. Не, даже не так. Я &lt;em&gt;чертовски&lt;/em&gt; люблю рефакторинг.&lt;/p&gt;
&lt;p&gt;Я не переношу плохой код и плохую архитектуру. Меня коробит, когда я пишу новую фичу, а в соседнем классе творится полный бардак. Я просто не могу смотреть на печально названные переменные. Иногда перед сном я закрываю глаза и представляю, что можно было бы улучшить в проекте. Иногда я просыпаюсь в три часа ночи и иду к ноутбуку, чтобы что-нибудь поправить. Мне хочется, чтобы на любой стадии разработки код был не просто кодом, а произведением искусства, на которое приятно смотреть, с которым приятно работать.&lt;/p&gt;
&lt;p&gt;Если вы хоть немного разделяете мои ощущения, то нам есть о чём поговорить. Дело в том, что со временем что-то внутри меня начало подсказывать, что рефакторить всё подряд, везде и всё время — не самая лучшая идея. Поймите меня правильно, код должен быть хорошим (а лучше бы ему быть идеальным), но в условиях суровой реальности не всегда разумно постоянно заниматься улучшением кода. Я вывел для себя несколько правил о своевременности рефакторинга. Если у меня начинают чесаться руки что-нибудь улучшить, то я оглядываюсь на эти правила и начинаю думать: &#171;А действительно ли сейчас тот момент, когда нужно нарефакторить?&#187;. Давайте порассуждаем о том, в каких же случаях рефакторинг уместен, а в каких — не очень.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dev/refactoring/front.png&quot; height=&quot;200px&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;&lt;strong&gt;Дисклеймер.&lt;/strong&gt; Скорее всего, многим захочется после прочтения поста сразу сказать: &#171;Да это уже 600 раз обсуждалось!&#187; или &#171;Это же настолько очевидно, зачем же об этом писать?&#187;. Возможно, вы и правы, но только вот какой момент: в окружающем мире по-прежнему творится хаос. Вроде бы всем всё понятно, но на деле получается, что не так уж и понятно. Поэтому я думаю, что не будет слишком вредно ещё разок взглянуть на эту тему. Но если конкретно у вас проблем с рефакторингом нет, то можете просто пропустить этот пост, у вас уже всё хорошо.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Слишком ранний рефакторинг&lt;/h3&gt;
&lt;p&gt;Можете ли вы припомнить, когда у вас последний раз было постоянное ТЗ, которое месяцами не менялось? У меня вот такое вспомнить не очень получается. Мы живём в реальном мире, требования всё время меняются. Причём это не обязательно внешние требования — это могут быть ваши собственные требования к проекту. Поясню мысль на примере: допустим, вы взяли задачку среднего размера на один-два дня. Первые несколько классов уже написаны, но запустить пока нечего — идёт процесс написания суровой архитектурной части. И тут вы замечаете, что одна из частей проекта написана не особо универсально: &#171;А вот если через полгода понадобится сделать X, то все будут страдать&#187;. Вполне разумно, что вам не хочется отправлять в репозиторий хреновый код, чтобы другие разработчики потом вспоминали вас плохим словом. И вы начинаете рефакторить &lt;em&gt;ещё не готовую фичу&lt;/em&gt;. Иногда это оправдано, но на подобном пути следовало бы повесить табличку &#171;ОПАСНОСТЬ&#187;. Вот поправите вы одну штуку, потом другую, потом третью. Неделя прошла, фича всё ещё не запускается, а вы говорите: &#171;Как-то всё неправильно сделано. Но теперь я &lt;em&gt;точно понял&lt;/em&gt;, как надо делать. Сейчас быстренько всё перепишу с нуля&#187;. Основная проблема заключается в том, что фидбека по фиче ещё не получено, а вы уже начали работать над улучшением кодовой базы. Подобный подход редко приводит к успеху. Не знаю, как у вас, а у меня часто бывает, что после реализации фичи я начинаю понимать, что работать всё должно несколько иначе. И это не из-за того, что я такой глупый, заранее не смог нормально продумать. Просто некоторую функциональность нужно &#171;пощупать&#187;, чтобы понять как всё должно быть в релизе. Иногда нужен небольшой прототипчик (пусть даже с говнокодом и багами), чтобы обсудить фичу с коллегами. Иногда нужно что-то показать заказчику, чтобы он мог сказать: &#171;Не, ну я не так хотел, всё должно быть наоборот&#187;. Порой пользователями не нравятся нововведения, они хотят всё как было. Проблема новых фич в том, что сложно предсказать их судьбу. Нередко случается так, что все наработки отправляются в помойку, т. к. после обсуждения первой версии коллектив принял решение делать всё иначе. Общий вывод: не стоит рефакторить код слишком рано, особенно если вы не уверены, что этот код 100 % останется в проекте.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Нецелевой рефакторинг&lt;/h3&gt;
&lt;p&gt;Скорее всего, у вас есть план разработки на ближайшее время. Вполне вероятно, что у вас есть сроки (даже если вы их поставили сами). Релизы нужно делать вовремя, затягивать разработку не стоит. Нужно контролировать себя, нужно заниматься теми вещами, которые входят в ваши непосредственные цели. Допустим, у вас есть кусок кода, который выглядит как полное... Ну, в общем, плохо выглядит. Но, продолжим наше допущение, вы с ним сейчас не работаете. Этот плохой кусок кода стабильно работает, успешно справляется со своими задачами и никак не связан с вашей текущей задачей. Ну так и не трогайте его! Да, вас может крайне печалить то обстоятельство, что на другом конце проекта &lt;em&gt;всё очень плохо&lt;/em&gt;. Но заметьте, что прямо сейчас вам это никак не мешает. У вас есть текущие задачи, занимайтесь ими. Конечно, бывают задачи по улучшению кодовой базы, но нечасто — зачастую важнее добавлять новый функционал или фиксить баги. Концентрируйтесь на текущих задачах и не бросайте их из-за того, что где-то там что-то как-то не так.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Рефакторинг ради рефакторинга&lt;/h3&gt;
&lt;p&gt;Ок, вы пришли к выводу, что нужно обязательно отрефакторить часть проекта. Хорошо, давайте отрефакторим. Вроде бы запланированные улучшения выполнены, но тут возникает мысль: &#171;А что я могу ещё улучшить? Ага, вон ту штуку&#187;. А после вон той штуки появится вот эта штука, а потом ещё одна, а потом ещё и т. д. Нужно понимать, что есть плохой код, есть хороший код, есть идеальный код. Последнего в большом проекте у вас никогда не будет. Это не значит, что не нужно к нему стремиться, но нужно понимать его недостижимость. Обычно задача стоит в написании хорошего кода, а не идеального. Допустим, после рефакторинга у вас получился вполне читаемый код, который работает более или менее очевидным образом, в котором нет костылей и которым не так сложно пользоваться. Задайте себе вопрос: &#171;А может, пора остановиться?&#187;. Да, код можно улучшать. Причём в достаточно большом проекте его можно улучшать до бесконечности. Но вот прямо сейчас он справляется со своими функциями, им удобно пользоваться, он практически не вызывает у вас дискомфорта. Очень важно определить для себя &lt;em&gt;приемлемое&lt;/em&gt; качество кода, после которого вы перестанете его улучшать (до тех пор, пока свойство приемлемости не будет утрачено). Вспомните, что есть ещё так много разных клёвых штук, которые можно дописать. Не нужно рефакторить ради самого рефакторинга, ради идеального кода. Нужно рефакторить, когда у вас есть &lt;em&gt;веские&lt;/em&gt; причины на это: код сложно прочитать, код сложно поддерживать, код сложно развивать, код сложно использовать и т. п. Если ни одного &#171;сложно&#187; не возникает, то &lt;em&gt;веских&lt;/em&gt; причин тратить время на рефакторинг у вас нет.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Рефакторинг за день до релиза&lt;/h3&gt;
&lt;p&gt;Бывает так, что релиз послезавтра/завтра/сегодня/должен был быть вчера (нужное подчеркнуть). Это важный момент в жизни проекта. Нужно уделить особое внимание тестированию, фиксам критических багов, финальным доделкам. Поверьте, это действительно плохая идея — перерабатывать кодовую базу (а ещё хуже — качественно перерабатывать) в тот момент, когда нужно отдавать проект в продакшн. Опытная практика подсказывает, что нужно зарелизиться, а потом с чистой совестью спокойно улучшать код. Некоторые спросят: &#171;А почему?&#187;. Если такой вопрос возник, то, наверное, вам ещё не приходилось делать сложный рефакторинг. Подскажу: при переписывании код не всегда обязательно улучшается — иногда он может сломаться. Да что там сложный рефакторинг — бывает, поправишь один метод на пять строк, не уследишь за какой-нибудь зависимостью, а на другом конце проекта выползет бага, с которой сразу же встретятся ваши любимые пользователи. Вот вроде бы ничего плохого и не делаешь, а тут внезапно на тебя нападает зверь &#171;Это было неочевидно&#187; и топит тебя в пруду ложной первоначальной оценки. Хотя, может, это просто я такой плохой программист — люблю что-нибудь сломать. Вполне возможно, что вы всегда рефакторите всё абсолютно правильно и с полным контролем всего проекта. В таком случае я могу вас поздравить, но от совета с запретом предрелизного рефакторинга всё-таки не откажусь. Поверьте, за несколько дней рефакторинг никуда не убежит, а сон у всей команды будет чуточку, но спокойней.&lt;/p&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Рефакторинг очень старого кода&lt;/h3&gt;
&lt;p&gt;Вопрос тяжёлый, очень тяжёлый. Ситуация: есть огромное количество ужасных строк кода, которые достались вам от старых разработчиков (возможно, этими старыми разработчиками были вы несколько лет назад, ещё до того, как научились писать всё правильно и сразу). Код приходится поддерживать. То там, то тут возникают костыли и дублирования, энтропия растёт. С каждым днём всё больше хочется выкинуть всё и переписать с нуля. В такой момент нужно &lt;em&gt;очень хорошо&lt;/em&gt; подумать о рисках. Да, вполне вероятно, что в перспективе такая деятельность будет полезна. Но в какой именно перспективе и насколько полезна? Скорее всего, в процессе большого рефакторинга или переписывания отдельных частей вы замените старый работающий говнокод новым, идеально написанным кодом, но с багами. И вовсе не из-за того, что вы плохой программист и пишете плохо. Просто вы можете не знать этот код &lt;em&gt;в достаточной мере&lt;/em&gt;. Вы можете не знать, почему автор написал всё именно так, а ведь причины могли быть. Иногда приходится писать очень странный и кривой код. Я могу придумать очень много примеров: подавление хитрых оптимизаций процессора, подстройка под баги сторонней библиотеки, подавление каких-нибудь многопоточных косяков и т. д. Я не говорю, что нельзя все эти проблемы решить нормально. Просто иной раз при переписывании казалось бы абсурдного кода на нормальный появляются баги. Да, можно было всё сделать нормально, но вы можете просто не осознать всё величие шалаша из костылей вместо палок, если не узнаете у автора кода, почему он написал именно так (а подобная возможность предоставляется далеко не всегда). Будьте осторожны, когда переписываете старый код, который понимаете не до конца (а особенно, если думаете, что понимать там нечего).&lt;/p&gt;
&lt;h3 id=&quot;section-5&quot;&gt;А когда рефакторить-то?&lt;/h3&gt;
&lt;p&gt;Я прошу прощения, если из этой статьи у вас сложилось впечатление, что от рефакторинга одни проблемы. Я всё ещё настаиваю на том, что код должен быть читаемым и красивым, им должно быть удобно пользоваться, его должно быть легко развивать. Позитивный подход лучше негативного, так что относитесь к рефакторингу не как к источнику проблем, а как к своему очень хорошему другу, который выручит вас в трудную минуту. Более того, этот друг может сделать так, чтобы в вашем светлом будущем трудных минут было бы поменьше. Хотелось бы в завершении обозначить несколько моментов, когда рефакторинг действительно уместен.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Нечего делать.&lt;/strong&gt;
Бывают спокойные времена простоя, когда все важные задачи закрыты, а новых пока не поставлено. Ну, не то чтобы совсем нечего делать, но определённое количество свободного времени есть. Потратьте его на улучшение кода. Дайте сущностям понятные имена, избавьтесь от дублирования, перепишите неудачный кусок архитектуры. Хоть нового функционала и не добавляется, но вы вкладываете свою лепту в душевное спокойствие разработчиков, которые будут продолжать проект. Поверьте, это важно.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Каждодневные страдания.&lt;/strong&gt;
А бывает так, что есть кусок проекта, который заставляет вас тяжело вздыхать каждый день. А из-за соседних столов слышатся тяжёлые вздохи ваших коллег. Конечно, хоть и релиз и не завтра, но важных задач хватает. Тем не менее, за неделей проходит неделя, а смотреть на этот кусок проекта всё грустнее. Скажите себе: &#171;Хватит это терпеть!&#187;. Если бизнес-план составляет начальник, то объясните ему, что этот код просто необходимо переписать. Если работаете на заказчика, то убедите его, что потраченная на рефакторинг неделя позволит сэкономить много времени на разработку в будущем. Если работаете на пользователей, то примите решение о том, что лучше бы этим пользователям в этот раз подождать релиза на недельку больше, но зато потом наслаждаться стабильным ПО и регулярными обновлениями. Да, договориться со всеми и с самим собой не всегда просто, но вы уж постарайтесь.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Проблема запоздалого рефакторинга.&lt;/strong&gt;
Не стоит абсолютизировать правило про слишком ранний рефакторинг. Некоторые считают так: &#171;Я вот сейчас наулучшаю чего-нибудь, а оно не пригодится — обидно же будет&#187;. Нужно понимать, что в ядре программы вполне могут быть важные части, которым лучше бы быть написанными хорошо. Помните, что чем позже вы проводите рефакторинг — тем выше его цена, ведь вы потратите больше времени и сил на переписывание. Критические базисные вещи (которые используются по всему проекту) должны быть в максимально хорошей форме постоянно. Будет просто прекрасно, если в вашей команде будет работать тезис
&lt;em&gt;&#171;Рефакторинг не опаздывает. Он приходит строго тогда, когда считает нужным&#187;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Встреча с монстром.&lt;/strong&gt;
Вы начинаете пилить новый функционал, который должен использовать старый кусок проекта, который выглядит как настоящий монстр: вам становится страшно только при взгляде на внешний интерфейс. Если время позволяет, то поправьте сперва базовую часть кода, чтобы потом сосредоточиться на новом функционале и не отвлекаться на то, чтобы вбить пяток костылей ради повторного использования кода.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Разумный перфекционизм.&lt;/strong&gt;
Заметили плохой кусок кода? Хочется его поправить? Очень хочется его поправить? Ну, если прям очень хочется, то можно. Но обратите внимание на слово &#171;разумный&#187;. Соотносите время, потраченное на рефакторинг, с выгодой от улучшения кода. Не стоит срывать сроки и зарываться в бесконечные улучшения. Однако если своевременно и в меру заниматься рефакторингом, то проекту от этого станет только лучше.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-6&quot;&gt;Вместо заключения&lt;/h3&gt;
&lt;p&gt;Всё вышеперечисленное является чисто субъективным обобщением опыта работы над рядом проектов. Разумеется, я покрыл далеко не все жизненные ситуации. В каждой команде свои требования к коду, свой бизнес-план и свои правила. Уверен, что у многих найдётся пяток историй из серии &#171;А вот у меня был случай, когда все эти советы не работают&#187;. Это абсолютно нормально, так и должно быть. Нет универсальной серебряной пули для определения количества усилий на улучшение кода (&#171;Мы будем каждый день 47 минут 23 секунды заниматься рефакторингом — и всё у нас будет хорошо&#187;). Вам нужно исходя из собственного опыта в вашем конкретном проекте, в вашей конкретной команде попытаться найти золотую середину между написанием нового кода и улучшением старого. Я агитирую только за то, чтобы ко всему было рациональное отношение без фанатизма (&#171;Зачем улучшать код, нового функционала от этого не появится&#187; / &#171;Нужно срочно весь код сделать идеальным, чтобы потом с ним можно было нормально работать&#187;). Подходите разумно к распределению времени на работу над существующим кодом — и всё у вас будет хорошо.&lt;/p&gt;
&lt;p&gt;Приветствуются любые дополнительные мысли о том, когда стоит или не стоит рефакторить. Одна из наиболее ценных вещей в этой области — опыт реальных разработчиков над реальными проектами.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://habrahabr.ru/company/enterra/blog/229051/&quot;&gt;Оригинал на Хабрахабре&lt;/a&gt;&lt;/p&gt;</description>
        </item>
        <item>
            <title>Раскрашиваем R в терминале: пакет colorout</title>
            <link>http://aakinshin.net/ru/posts/r-colorout/</link> 
            <pubDate>Fri, 11 Jul 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-colorout/</guid>
            <description>&lt;p&gt;В последнее время мне часто приходится гонять R-скрипты на удалённом Linux-сервере. Большую часть работы я выполняю на домашней машине, но иногда приходится отлаживать скрипты прямо на сервере. В этом мне очень помогает пакет &lt;strong&gt;colorout&lt;/strong&gt;, который умеет красиво раскрашивать R в терминале. Давайте взглянем на него чуть подробнее.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Пакета нет в &lt;a href=&quot;http://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt;, но зато он &lt;a href=&quot;https://github.com/jalvesaq/colorout&quot;&gt;выложен&lt;/a&gt; на GitHub-е, так что установить последнюю версию проще всего с помощью &lt;a href=&quot;http://cran.r-project.org/web/packages/devtools/index.html&quot;&gt;devtools&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(devtools)
install_github(&#39;jalvesaq/colorout&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Чтобы пакет подключался автоматически, необходимо прописать &lt;code&gt;library(colorout)&lt;/code&gt; в &lt;code&gt;.Rprofile&lt;/code&gt; или &lt;code&gt;Rprofile.site&lt;/code&gt;. Если вы запускаете R из различных окружений, то сперва стоит проверить, что данная сессия запущена из терминала (в этом поможет &lt;code&gt;Sys.getenv(&amp;quot;TERM&amp;quot;)&lt;/code&gt;). Давайте взглянем на то, как теперь выглядит работа с R. Для этого воспользуемся &lt;a href=&quot;http://www.lepem.ufc.br/jaa/colorout.html&quot;&gt;примером&lt;/a&gt; от автора пакета:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;cat(&amp;quot;Different colors for normal text, \&amp;quot;string\&amp;quot;, dates (&amp;quot;,
     as.character(Sys.Date()), &amp;quot;)\n&amp;quot;,
     &amp;quot;numbers (12, -1.3), NULL, NA, NaN, Inf, TRUE and FALSE.\n&amp;quot;, sep = &amp;quot;&amp;quot;)
x &amp;lt;- data.frame(logic=c(T, T, F), factor=factor(c(&amp;quot;abc&amp;quot;, &amp;quot;def&amp;quot;, &amp;quot;ghi&amp;quot;)),
                string=c(&amp;quot;ABC&amp;quot;, &amp;quot;DEF&amp;quot;, &amp;quot;GHI&amp;quot;), real=c(1.23, -4.56, 7.89),
                cien.not = c(1.234e-23, -4.56e+45, 7.89e78),
                date=as.Date(c(&amp;quot;2012-02-21&amp;quot;, &amp;quot;2013-02-12&amp;quot;, &amp;quot;2014-03-04&amp;quot;)),
                stringsAsFactors = FALSE)
rownames(x) &amp;lt;- 1:3
x
summary(x[, c(1, 2, 4, 6)])
# Warnings and erros are highlighted (even if not in English):
warning(&amp;quot;This is an example of warning.&amp;quot;)
example.of.error
# Messages sent to stderr are highlighted:
library(KernSmooth)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Если ваш терминал поддерживает 256 цветов (&lt;code&gt;Sys.getenv(&amp;quot;TERM&amp;quot;)&lt;/code&gt; равно &lt;code&gt;&amp;quot;xterm-256color&amp;quot;&lt;/code&gt;, а не просто &lt;code&gt;&amp;quot;xterm&amp;quot;&lt;/code&gt;), то вы можете тонко подстроить цветовую гамму:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;# The colors are customizable:
setOutputColors()
setOutputColors256(normal = 39, number = 51, negnum = 183, date = 43,
                   string = 79, const = 75, verbose = FALSE)
x
setOutputColors256(202, 214, 209, 184, 172, 179, verbose = FALSE)
x
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Если поддержки 256 цветов нет, то выставить нужные цвета поможет обычный &lt;code&gt;setOutputColors&lt;/code&gt;. На сегодняшний день у функций &lt;code&gt;setOutputColors&lt;/code&gt; и &lt;code&gt;setOutputColors256&lt;/code&gt;
имеются следующие аргументы:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  normal: Formating and color of normal text.
  number: Formating and color of numbers.
  negnum: Formating and color of negative numbers.
    date: Formating and color of dates (output in the format
          &#39;yyyy-mm-dd&#39;).
  string: Formating and color of quoted text.
   const: Formating and color of &#39;TRUE&#39;, &#39;FALSE&#39;, &#39;NULL&#39;, &#39;NA&#39;, &#39;NaN&#39;
          and &#39;Inf&#39;.
stderror: Formating and color of text sent to stderr.
    warn: Formating and color of warnings.
   error: Formating and color of errors.
 verbose: Logical value indicating whether to print colored words
          showing the result of the setup.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как и всегда, полную справку вы можете получить с помощью команд &lt;code&gt;?setOutputColors&lt;/code&gt;, &lt;code&gt;?setOutputColors256&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В общем, &lt;strong&gt;colorout&lt;/strong&gt; — отличный штука! Всем рекомендую. А с помощью пакета &lt;strong&gt;txtplot&lt;/strong&gt; можно прямо в консоли смотреть цветные графики =).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(txtplot)
txtcurve(sin(pi*x),from=0,to=2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/colorout/screen4.png&quot; /&gt;
&lt;/p&gt;</description>
        </item>
        <item>
            <title>Strange behavior of FindElementsInHostCoordinates in WinRT</title>
            <link>http://aakinshin.net/posts/findelementsinhostcoordinates/</link> 
            <pubDate>Tue, 29 Apr 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/findelementsinhostcoordinates/</guid>
            <description>&lt;p&gt;Silverlight features a splendid method: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.media.visualtreehelper.findelementsinhostcoordinates(v=vs.95).aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt;. It allows the &lt;code&gt;HitTest&lt;/code&gt;, i.e. makes it possible for a point or rectangle to search for all visual sub-tree objects that intersect this rectangle or point. Formally the same method &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates.aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt; is available in WinRT. And it seems the method looks in the same way, but there is a little nuance. It works differently in different versions of the platform. So, let’s see what’s going on.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Let’s create a simple Silverlight 5 application. The markup will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid x:Name=&amp;quot;LayoutRoot&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas MouseLeftButtonDown=&amp;quot;OnMainCanvasMouseLeftButtonDown&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s very simple: we have a &lt;code&gt;Canvas&lt;/code&gt;, an &lt;code&gt;Ellipse&lt;/code&gt; and a &lt;code&gt;Path&lt;/code&gt; are on the Canvas. A &lt;code&gt;TextBlock&lt;/code&gt; for entering some useful info is located under this wonderful masterpiece. The app looks in the following way:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Now we will add a mouse click event handler: we will get the elements we clicked on. Here we will use two versions of &lt;code&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/code&gt; (for point and for rectangle):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static IEnumerable FindElementsInHostCoordinates(
 Point intersectingPoint,
 UIElement subtree
)
public static IEnumerable FindElementsInHostCoordinates(
 Rect intersectingRect,
 UIElement subtree
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A list of elements we get will be displayed in &lt;code&gt;StatusBlock&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private void OnMainCanvasMouseLeftButtonDown(object sender, 
                                             MouseButtonEventArgs e)
{
  var p = e.GetPosition(MainCanvas);
  var listPoint = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Point(p.X, p.Y), MainCanvas).ToList();
  var listRect = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Rect(p.X, p.Y, 1, 1), MainCanvas).ToList();
  var strPoint = string.Join(&amp;quot;, &amp;quot;, 
                   listPoint.Select(el =&amp;gt; el.GetType().Name.ToString()));
  var strRect = string.Join(&amp;quot;, &amp;quot;, 
                   listRect.Select(el =&amp;gt; el.GetType().Name.ToString()));
  StatusBlock.Text = string.Format(&amp;quot;[{0}] vs [{1}]&amp;quot;, strPoint, strRect);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our perfect app is ready! Something tells me that considering the rectangle size (1&#215;1) results of two method overloads won’t differ. Let’s check it by clicking on different areas. The picture below shows the result of this test:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Everything seems to be ok: all methods work as expected. Now let’s proceed to WinRT. Create a new Windows Store application and add the same markup to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid Background=&amp;quot;{StaticResource ApplicationPageBackgroundThemeBrush}&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas Tapped=&amp;quot;OnMainCanvasTapped&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code of the &lt;code&gt;OnMainCanvasTapped&lt;/code&gt; handler matched &lt;code&gt;OnMainCanvasMouseLeftButtonDown&lt;/code&gt; code. Let’s run the application and click on it. Results look as follows:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;What a turn out! A short test of the app results in the following conclusion: point &lt;code&gt;HitTest&lt;/code&gt; works in the same way as in the Silverlight application while rectangle HitTest for the Path-figures works not for the figure itself, but for its BoundingBox. WinRT applications are created based on the Touch First principle, that’s why Rect-version of the code if more interesting. In most cases this issue won’t be critical, but if an application is oriented to interaction with various arcuate elements, it’s better to pay special attention to the behavior of &lt;code&gt;FindElementsInHostCoordinates&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/silverlight/strange-behavior-of-findelementsinhostcoordinates-in-winrt/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Странное поведение FindElementsInHostCoordinates в WinRT</title>
            <link>http://aakinshin.net/ru/posts/findelementsinhostcoordinates/</link> 
            <pubDate>Tue, 29 Apr 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/findelementsinhostcoordinates/</guid>
            <description>&lt;p&gt;Есть в Silverlight отличный метод: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.windows.media.visualtreehelper.findelementsinhostcoordinates(v=vs.95).aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt; — позволяет выполнять &lt;code&gt;HitTest&lt;/code&gt;, т.е. для некоторой точки или прямоугольника искать все объекты визуального поддерева, которые с этими точкой или прямоугольником пересекаются. Внешне точно такой же метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/windows/apps/windows.ui.xaml.media.visualtreehelper.findelementsinhostcoordinates.aspx&quot;&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/a&gt; можно встретить в WinRT. И вроде выглядит-то он точно также, но есть нюанс: работает этот чудо-метод в разных версиях платформы по-разному. Давайте разберёмся.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Сначала создадим простое Silverlight 5 приложение. Основная вёрстка будет выглядеть следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid x:Name=&amp;quot;LayoutRoot&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas MouseLeftButtonDown=&amp;quot;OnMainCanvasMouseLeftButtonDown&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут всё очень просто: имеется &lt;code&gt;Canvas&lt;/code&gt;, а на нём лежит &lt;code&gt;Ellipse&lt;/code&gt; и &lt;code&gt;Path&lt;/code&gt;. Прямо под этим чудесным произведением искусства находится &lt;code&gt;TextBlock&lt;/code&gt; в который мы можем вывести что-нибудь полезное. Выглядит приложение следующим образом:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Теперь напишем обработчик события для клика мышкой по нашему &lt;code&gt;Canvas&lt;/code&gt;-элементу: будем искать элементы, в которые мы попали. Для этого нам пригодятся две версии &lt;code&gt;VisualTreeHelper.FindElementsInHostCoordinates&lt;/code&gt; (для точки и для прямоугольника):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static IEnumerable FindElementsInHostCoordinates(
 Point intersectingPoint,
 UIElement subtree
)
public static IEnumerable FindElementsInHostCoordinates(
 Rect intersectingRect,
 UIElement subtree
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Список полученных объектов будем выводить в &lt;code&gt;StatusBlock&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private void OnMainCanvasMouseLeftButtonDown(object sender, 
                                             MouseButtonEventArgs e)
{
  var p = e.GetPosition(MainCanvas);
  var listPoint = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Point(p.X, p.Y), MainCanvas).ToList();
  var listRect = VisualTreeHelper.FindElementsInHostCoordinates(
                    new Rect(p.X, p.Y, 1, 1), MainCanvas).ToList();
  var strPoint = string.Join(&amp;quot;, &amp;quot;, 
                   listPoint.Select(el =&amp;gt; el.GetType().Name.ToString()));
  var strRect = string.Join(&amp;quot;, &amp;quot;, 
                   listRect.Select(el =&amp;gt; el.GetType().Name.ToString()));
  StatusBlock.Text = string.Format(&amp;quot;[{0}] vs [{1}]&amp;quot;, strPoint, strRect);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Наше отличное приложение готово! Что-то внутри подсказывает, что ввиду размеров прямоугольника (1x1) результаты работы двух перегрузок метода не должны отличаться. Давайте проверим, потыкав в разные места. Следующая картинка показывает результаты проведённого опыта:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Ну, вроде всё хорошо, методы отработали, как и ожидалось. А теперь перейдём к WinRT. Создадим новое Windows Store приложение и снабдим его аналогичной вёрсткой:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Grid Background=&amp;quot;{StaticResource ApplicationPageBackgroundThemeBrush}&amp;quot;&amp;gt;
  &amp;lt;Grid.RowDefinitions&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;*&amp;quot;/&amp;gt;
    &amp;lt;RowDefinition Height=&amp;quot;100&amp;quot;/&amp;gt;
  &amp;lt;/Grid.RowDefinitions&amp;gt;

  &amp;lt;Canvas Tapped=&amp;quot;OnMainCanvasTapped&amp;quot; 
          x:Name=&amp;quot;MainCanvas&amp;quot; Background=&amp;quot;LightGreen&amp;quot;&amp;gt;
    &amp;lt;Ellipse Width=&amp;quot;200&amp;quot; Height=&amp;quot;200&amp;quot; Fill=&amp;quot;LightCoral&amp;quot; /&amp;gt;
    &amp;lt;Path Fill=&amp;quot;LightBlue&amp;quot; Data=&amp;quot;M 10,100 C 10,300 300,-200 300,100&amp;quot;/&amp;gt;
  &amp;lt;/Canvas&amp;gt;

  &amp;lt;TextBlock Grid.Row=&amp;quot;1&amp;quot; x:Name=&amp;quot;StatusBlock&amp;quot; /&amp;gt;
&amp;lt;/Grid&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Код обработчика &lt;code&gt;OnMainCanvasTapped&lt;/code&gt; полностью совпадает с кодом &lt;code&gt;OnMainCanvasMouseLeftButtonDown&lt;/code&gt;. Давайте запустим приложение и потыкаем в него. Результаты:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/findelementsinhostcoordinates/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Вот это поворот! Недолгое кликанье по приложению быстро подведёт нас к выводу: точечный HitTest работает точно также, как и в Silverlight, а вот HitTest по прямоугольнику для Path-фигур работает не по самой фигуре, а по её BoundingBox-у (ограничивающему прямоугольнику). WinRT-приложения делаются по принципу Touch First, так что наиболее интересна именно Rect-версия метода. В большинстве случаев этот момент скорее всего будет не особо принципиален, но вот если приложение ориентировано на взаимодействие с различными изогнутыми элементами, то на особенность такого поведения &lt;code&gt;FindElementsInHostCoordinates&lt;/code&gt; лучше бы обратить особое внимание.&lt;/p&gt;</description>
        </item>
        <item>
            <title>CodeFest 2014: Отчёт</title>
            <link>http://aakinshin.net/ru/posts/codefest-2014/</link> 
            <pubDate>Tue, 01 Apr 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/codefest-2014/</guid>
            <description>&lt;p&gt;Есть в Сибири одна очень хорошая конференция, &lt;a href=&quot;http://codefest.ru&quot;&gt;CodeFest&lt;/a&gt; называется, бывает раз в год. В минувшие выходные это замечательное мероприятие проводилось уже в пятый раз, мы с друзьями просто не могли такое пропустить. Конференция прошла просто на отличненько, в связи с чем хотелось бы поделиться впечатлениями.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/notes/codefest-2014/front.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;section&quot;&gt;Организация&lt;/h3&gt;
&lt;p&gt;Мероприятие организовано просто чудесно. Некоторые, конечно, жаловались на разные штуки типа огромных очередей. Но, чёрт возьми, это же конференция на 1700 человек! Бывал я на многих мероприятиях, у большинства проблема что-то нормально организовать даже человек на 50–100. Для масштабов CodeFest-а всё было великолепно, мелкие косяки вполне можно простить. Действо происходило в &lt;a href=&quot;http://www.novosibexpo.ru/&quot;&gt;Новосибирском экспоцентре&lt;/a&gt;. На популярных докладах было, конечно, не протолкнуться, но в целом здание внушающих размеров, парковки на всех хватает. Особо порадовали сушилки для рук в туалете, они прям как для людей сделаны (а какой вид из окна, какой вид).&lt;/p&gt;
&lt;p&gt;Размеры очереди на регистрации в первый день &lt;a href=&quot;http://instagram.com/p/mHIFCeDo0V/&quot;&gt;поражали воображение&lt;/a&gt;, из-за этого начало конференции немного задержалось. Думаю, стоило бы организовать регистрацию в несколько потоков, ну да ладно. Организаторы не растерялись, начали раздавать пакеты участников ожидающим. Помимо прочего всем дали по праздничной дуделке в честь др CodeFest-а. Расчёты показали, что если бы каждый из участников подудел бы 1 секунду, то можно было бы почти на полчаса волну организовать.&lt;/p&gt;
&lt;p&gt;Помимо докладов традиционно были стенды от разных компаний, которые раздавали ништяки, конкурсы всякие проводили. Некоторые даже &lt;a href=&quot;http://instagram.com/p/mIFpmfA1Gv/&quot;&gt;телефоны выигрывали&lt;/a&gt;. Наибольший ажиотаж собрал Oculus Rift, можно было надеть шапочку и погрузиться в мир виртуальной реальности. Отдельно была организована кофе-брейк зона. Правда, кофе и плюшки очень быстро заканчивались (о, как же некоторым не хватало кофе), но запасы относительно быстро пополнялись. Да и вообще, много всего прикольного было, есть на что посмотреть.&lt;/p&gt;
&lt;p&gt;Отдельная проблема была с тем, чтобы накормить всю эту толпу. Организаторы предоставляли обеды по заявкам, но &lt;a href=&quot;http://instagram.com/p/mKElsZodXG/&quot;&gt;очередная очередь&lt;/a&gt;
делала многих грустными. А мы с ребятами накануне наделали вкусных штук, спокойно покушали и даже вовремя успели на доклады.&lt;/p&gt;
&lt;p&gt;А если говорить в целом, то CodeFest безумно завлекает своей атмосферой и вниманием, которое организаторы проявляют к участником в весьма неформальном стиле.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Тусовка&lt;/h3&gt;
&lt;p&gt;А вообще, всё это не ради докладов делается. Не, доклады, конечно, были хороши. Но их и в записи посмотреть потом можно, пользы столько же будет. Главное в подобных мероприятиях — живое общение. Было очень приятно встретить несколько десятков знакомых лиц с разных уголков страны. Также удалось познакомиться с кучей новых людей, пообщаться на it-шные тематики, обменяться опытом. Лично я очень долго зависал на стенде от &lt;a href=&quot;http://www.jetbrains.com/&quot;&gt;JetBrains&lt;/a&gt;, там всё время интересные разговоры велись (JetBrains — вообще чудесные ребята, каждый CodeFest радуют).&lt;/p&gt;
&lt;p&gt;География события широка, народ съехался отовсюду, жилищный вопрос для многих стоял достаточно остро. Благо, в моём распоряжении находится квартира в Новосибирске, в которой на время конференции прописались делегации из Барнаула и Томска. Многие подобным образом собирались на квартирах у знакомых, что только добавляло шарма мероприятию — общение можно было вести ночью, днём, ночью, днём и ещё раз ночью. Некоторые товарищи после первого дня пошли на афтепати, а вот мы устроили своё афтепати: шашлыки жарили и за программирование разговаривали.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Доклады&lt;/h3&gt;
&lt;p&gt;Доклады были хороши, очень сильную команду спикеров набрали. В прошлом году мне несколько меньше понравилось (я по образованию .NET-разработчик, в связи с чем я чувствовал себя чужим на этом JavaScript-овом празднике жизни). В этом году (исключительно по моему скромному мнению) удалось достичь большего баланса: для каждого нашлось очень много интересного и полезного. Если в прошлом году мою конференцию сделал Кирилл Скрыган из JetBrains с &lt;a href=&quot;http://2013.codefest.ru/lecture/59&quot;&gt;докладом&lt;/a&gt;
про оптимизацию .NET-приложений, то в этом году свою медаль зрительских симпатий я отдал Алексею Шипилёву из Oracle за &lt;a href=&quot;http://2014.codefest.ru/lecture/832&quot;&gt;рассказ&lt;/a&gt;
про бенчмарки. На второй день он же устроил чудесную &lt;a href=&quot;http://2014.codefest.ru/lecture/896&quot;&gt;лекцию&lt;/a&gt; про Java Memory Model. JetBrains также порадовали
&lt;a href=&quot;http://2014.codefest.ru/lecture/842&quot;&gt;докладом&lt;/a&gt; от Сергея Шкредова про управление зависимостями.&lt;/p&gt;
&lt;p&gt;Во второй день наибольшую популярность имела PM секция, которая состояла просто из офигительных докладов. Меня больше всего впечатлили доклады от &lt;a href=&quot;http://2014.codefest.ru/lecture/806&quot;&gt;Григория Бакунова&lt;/a&gt; и &lt;a href=&quot;http://2014.codefest.ru/lecture/887&quot;&gt;Максима Дорофеева&lt;/a&gt; . Как появится видео — обязательно буду пересматривать. Коллеги из области QA свою секцию тоже очень хвалят — доклады читали те, кто действительно понимаю в тестировании.&lt;/p&gt;
&lt;p&gt;Да и вообще, хороших докладов было очень много, каждая секция для своей целевой аудитории была интересна. Увы, не удалось сходить на всё, но как только появится видео (организаторы обещают его в скором времени), нужно будет обязательно наверстать упущенное.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Заключение&lt;/h3&gt;
&lt;p&gt;Рассказ у меня получился очень сумбурным, но это просто от переполняющих меня впечатлений. Я просто хотел сказать, что CodeFest — это просто прекрасно, исключительно положительные ощущения. Много полезных знаний в голове, много новых интересных знакомств, много бесценного общения. Побольше было бы таких конференций. В следующем году однозначно нужно опять идти.&lt;/p&gt;</description>
        </item>
        <item>
            <title>About System.Drawing.Color and operator ==</title>
            <link>http://aakinshin.net/posts/system-drawing-color-equals/</link> 
            <pubDate>Fri, 21 Feb 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/system-drawing-color-equals/</guid>
            <description>&lt;p&gt;Operator &lt;code&gt;==&lt;/code&gt; that allows easy comparison of your objects is overridden for many standard structures in .NET. Unfortunately, not every developer really knows what is actually compared when working with this wonderful operator. This brief blog post will show the comparison logic based on a sample of &lt;code&gt;System.Drawing.Color&lt;/code&gt;. What do you think the following code will get:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var redName = Color.Red;
var redArgb = Color.FromArgb(255, 255, 0, 0);
Console.WriteLine(redName == redArgb);
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;“It’s red here and it’s red there. Probably, the objects should be equal”, the reader might think. Let’s open &lt;a href=&quot;http://www.dotnetframework.org/default.aspx/Net/Net/3@5@50727@3053/DEVDIV/depot/DevDiv/releases/whidbey/netfxsp/ndp/fx/src/CommonUI/System/Drawing/Color@cs/1/Color@cs&quot;&gt;source code&lt;/a&gt; and review the operator &lt;code&gt;==&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static bool operator ==(Color left, Color right) {
    if (left.value == right.value
        &amp;amp;&amp;amp; left.state == right.state
        &amp;amp;&amp;amp; left.knownColor == right.knownColor) {

        if (left.name == right.name) {
            return true;
        }

        if (left.name == (object) null || right.name == (object) null) {
            return false;
        }

        return left.name.Equals(right.name);
    }

    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code review help us make an interesting conclusion: colors are compared by the Name property rather than the ARGB-value. What are the names of our objects? Let’s see.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.Name); // Red
Console.WriteLine(redArgb.Name); // ffff0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hmm, they’ve got different names. So, the expression &lt;code&gt;redName == redArgb&lt;/code&gt; gets &lt;code&gt;False&lt;/code&gt;. There may occur an irritating situation, for example, when initial &lt;code&gt;Color.Red&lt;/code&gt; was serialized to ARGB and then de-serialized back and then you decided to compare the final color with the original. Let’s read what &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.op_equality(v=vs.110).aspx&quot;&gt;MSDN&lt;/a&gt; says about operator &lt;code&gt;==&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method compares more than the ARGB values of the	&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color(v=vs.110).aspx&quot;&gt;Color&lt;/a&gt; structures. It also does a comparison of some state flags. If you want to compare just the ARGB values of two Color structures, compare them using the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.toargb(v=vs.110).aspx&quot;&gt;ToArgb&lt;/a&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Everything is clear now. In order to compare our colors we need the &lt;code&gt;ToArgb&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.ToArgb() == redArgb.ToArgb()); // True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;I think you shouldn’t relay on a guess about logic of the standard comparison methods even if they might seem obvious to you. If you use operator == or Equals method for value types it would be a good idea to have a look at the documentation and check what will be actually compared.&lt;/p&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/about-system-drawing-color-and-operator/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Про System.Drawing.Color и оператор ==</title>
            <link>http://aakinshin.net/ru/posts/system-drawing-color-equals/</link> 
            <pubDate>Fri, 21 Feb 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/system-drawing-color-equals/</guid>
            <description>&lt;p&gt;Для многих стандартных структур в .NET-е переопределён оператор &lt;code&gt;==&lt;/code&gt;, который позволяет легко сравнивать ваши объекты. К сожалению, далеко не все задумываются о том, что на самом деле сравнивается при работе с этим замечательным оператором. В этой короткой заметке мы посмотрим логику сравнения объектов на примере &lt;code&gt;System.Drawing.Color&lt;/code&gt;. Как вы думаете, что выведет следующий код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var redName = Color.Red;
var redArgb = Color.FromArgb(255, 255, 0, 0);
Console.WriteLine(redName == redArgb);
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;&#171;И тут красный, и там красный. Наверное, объекты должны быть равны.&#187;, — подумает читатель. Но давайте откроем &lt;a href=&quot;http://www.dotnetframework.org/default.aspx/Net/Net/3@5@50727@3053/DEVDIV/depot/DevDiv/releases/whidbey/netfxsp/ndp/fx/src/CommonUI/System/Drawing/Color@cs/1/Color@cs&quot;&gt;исходный код&lt;/a&gt; и посмотрим на оператор &lt;code&gt;==&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static bool operator ==(Color left, Color right) {
    if (left.value == right.value
        &amp;amp;&amp;amp; left.state == right.state
        &amp;amp;&amp;amp; left.knownColor == right.knownColor) {

        if (left.name == right.name) {
            return true;
        }

        if (left.name == (object) null || right.name == (object) null) {
            return false;
        }

        return left.name.Equals(right.name);
    }

    return false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Изучение исходного кода подталкивает нас к интересному выводу: цвета сравниваются не по ARGB-значанию, а по свойству Name. Какое же имя у наших объектов? Давайте посмотрим:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.Name); // Red
Console.WriteLine(redArgb.Name); // ffff0000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм, имена-то разные. Таким образом, выражение &lt;code&gt;redName == redArgb&lt;/code&gt; вернёт нам &lt;code&gt;False&lt;/code&gt;. Неприятная ситуация может получиться, если, например, исходный &lt;code&gt;Color.Red&lt;/code&gt; был сериализован в ARGB, затем десериализрован обратно, после чего вы вздумали сравнить итоговый цвет с оригиналом. Давайте почитаем, что &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.op_equality(v=vs.110).aspx&quot;&gt;пишут&lt;/a&gt; про оператор &lt;code&gt;==&lt;/code&gt; в &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.op_equality(v=vs.110).aspx&quot;&gt;MSDN&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This method compares more than the ARGB values of the	&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color(v=vs.110).aspx&quot;&gt;Color&lt;/a&gt; structures. It also does a comparison of some state flags. If you want to compare just the ARGB values of two Color structures, compare them using the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.color.toargb(v=vs.110).aspx&quot;&gt;ToArgb&lt;/a&gt; method.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ну, теперь всё понятно, для сравнения ARGB-значений наших цветов нам нужен метод &lt;code&gt;ToArgb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Console.WriteLine(redName.ToArgb() == redArgb.ToArgb()); // True
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Я думаю, не следует полагаться на догадки о логике работы стандартных методов сравнения, которые изначально могут показаться вам очевидными. Если вы пользуетесь оператором == или методом Equals для значимых типов, то неплохо было бы сначала заглянуть в документацию и проверить, что именно будет сравниваться.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Setting up build configuration in .NET</title>
            <link>http://aakinshin.net/posts/msbuild-configurations/</link> 
            <pubDate>Sat, 08 Feb 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/msbuild-configurations/</guid>
            <description>&lt;p&gt;You get two default build configurations: Debug and Release, when creating a new project in Visual Studio. And it’s enough for most small projects. But there can appear a necessity to extend it with the additional configurations. It’s ok if you need to add just a couple of new settings, but what if there are tens of such settings? And what if your solution contains 20 projects that need setting up of these configurations? In this case it becomes quite difficult to manage and modify build parameters.&lt;/p&gt;
&lt;p&gt;In this article, we will review a way to make this process simpler by reducing description of the build configurations.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Open csproj file of one of your projects, you will find the following strings there:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
  &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first problem we face with is that the strings are duplicated (or almost duplicated) in all projects. Luckily, csproj files support export of configurations. So, let’s create the &lt;code&gt;Configurations.targets&lt;/code&gt; file in the solution root folder. It will contain:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that you will be able to change the corresponding strings in the source csproj file to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Import Project=&amp;quot;..\Configurations.targets&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Cool, we got rid of the duplicated configuration descriptions. Now we can focus on editing of a single file. You can notice that some strings are still duplicated in Debug and Release configurations. Assume that a developer wants to setup all these parameters individually for every configuration. If there is no such need, it’s possible to take the duplicated lines out to the common &lt;code&gt;PropertyGroup&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Is it possible to enhance anything else? Let’s think. The eye catches &lt;code&gt;OutputPath&lt;/code&gt; which can be figured out from the configuration name. When you have two configurations you can set individual settings for each of them. But if you have quite a lot of configurations it would be great to make &lt;code&gt;OutputPath&lt;/code&gt; figure out of the configuration name. Here we get the &lt;code&gt;$(Configuration)&lt;/code&gt; variable that will help us to determine this name.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! We got rid of duplication. What else can be optimized? As a rule, the properties being set up depend only on the configuration; change of the platform doesn’t influence anything. Let’s remove this unnecessary condition.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Debug&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Release&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now let’s add new configurations. Assume we want to add a Demo mode to the application. Not all features are available in this mode. The Demo mode may also require debugging that is why it’s reasonable to create &lt;code&gt;DebugDemo&lt;/code&gt; and &lt;code&gt;ReleaseDemo&lt;/code&gt; configurations. And, for example, we want to add a build mode that will require a user to use a license. We may also want to license Demo version. So, we have 4 more configurations: &lt;code&gt;DebugLicense&lt;/code&gt;, &lt;code&gt;ReleaseLicense&lt;/code&gt;, &lt;code&gt;DebugDemoLicense&lt;/code&gt;, &lt;code&gt;ReleaseDemoLicense&lt;/code&gt;. This situation is just a sample, your project can be absolutely different. &lt;code&gt;Demo&lt;/code&gt; and &lt;code&gt;License&lt;/code&gt; will add new variables to &lt;code&gt;DefineConstants&lt;/code&gt;. It seems that you just need to create 8 separate &lt;code&gt;PropertyGroups&lt;/code&gt; for 8 configurations. But something in my mind begins to protest. Luckily, you can add a more complicated condition than just comparison to the &lt;code&gt;Condition&lt;/code&gt;. In this sample, we will search for the set substring in the configuration name:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks quite good. There is a little problem: Visual Studio can’t get a list of available configurations. This issue can be solved by adding empty &lt;code&gt;PropertyGroups&lt;/code&gt; with the same &lt;code&gt;Condition&lt;/code&gt; as in the beginning. And you can add only those configurations you will actually use in your work. For example, we don’t want to debug &lt;code&gt;Demo&lt;/code&gt; and &lt;code&gt;License&lt;/code&gt; configurations. In this case we can write the following strings:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you’ve got the inborn hatred to duplication of anything, you can take out additional properties duplicated in all projects to the file you’ve got. For example, in this way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;Configuration Condition=&amp;quot; &#39;$(Configuration)&#39; == &#39;&#39; &amp;quot;&amp;gt;Release&amp;lt;/Configuration&amp;gt;
    &amp;lt;Platform Condition=&amp;quot; &#39;$(Platform)&#39; == &#39;&#39; &amp;quot;&amp;gt;AnyCPU&amp;lt;/Platform&amp;gt;    
    &amp;lt;TargetFrameworkVersion&amp;gt;v4.0&amp;lt;/TargetFrameworkVersion&amp;gt;
    &amp;lt;SolutionDir Condition=&amp;quot;$(SolutionDir) == &#39;&#39; Or $(SolutionDir) == &#39;*Undefined*&#39;&amp;quot;&amp;gt;..\&amp;lt;/SolutionDir&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we got rid of all duplication for sure. And it’s so easy to setup configurations. I’d like to notice that this approach may not suit you; many projects are perfectly developed without editing of the configurations. And sometimes it’s necessary to setup each configuration for each project and for each platform manually – in this case you won’t be able to save your time by removing duplications. But if you’ve got a problem with setting up of quite a lot of configurations for quite a lot of projects, this practice may be a good fit. You can also get more information on build in MSDN.&lt;/p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/0k6kkbsd.aspx&quot;&gt;MSBuild Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms164307.aspx&quot;&gt;MSBuild Conditional Constructs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/7szfhaft.aspx&quot;&gt;MSBuild Conditions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd633440.aspx&quot;&gt;Expand Property Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms171459.aspx&quot;&gt;How to: Use Environment Variables in a Build&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb629394.aspx&quot;&gt;Common MSBuild Project Properties&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb629388.aspx&quot;&gt;Common MSBuild Project Items&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/setting-up-build-configuration-in-net/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Настраиваем конфигурации сборок в .NET</title>
            <link>http://aakinshin.net/ru/posts/msbuild-configurations/</link> 
            <pubDate>Sat, 08 Feb 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/msbuild-configurations/</guid>
            <description>&lt;p&gt;При создании нового проекта в Visual Studio по умолчанию вы получаете две конфигурации сборки: Debug и Release. И для большинства мелких проектов этого вполне достаточно. Но с ростом проекта может возникнуть потребность добавить дополнительные конфигурации. И хорошо, если нужно добавить одну-две новые конфигурации, а если их добрый десяток? А если при этом в солюшене находится штук 20 проектов, для каждого из которых эти конфигурации нужно настроить? В данном случае управлять параметрами сборки и модифицировать их становится достаточно сложно.&lt;/p&gt;
&lt;p&gt;В этом посте будет рассмотрен способ, с помощью которого вы сможете немного упростить себе жизнь, существенно сократив описание конфигураций сборок.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Откройте csproj-файл одного из ваших проектов, вы найдёте в нём строчки такого вида:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
  &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
  &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
  &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
  &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
  &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
  &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
  &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
&amp;lt;/PropertyGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Первая проблема, которая стоит перед нами, состоит в том, что эти строчки дублируются (или практически дублируются) во всех проектах. К счастью, csproj-файлы поддерживают импорт конфигураций, так что создадим в корне солюшена файл &lt;code&gt;Configurations.targets&lt;/code&gt; следующего содержания:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого вы сможете заменить соответствующие строчки в исходном csproj-файле на&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Import Project=&amp;quot;..\Configurations.targets&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отлично, теперь дублирование описаний конфигураций ушло, можно сосредоточиться на редактировании единственного файла. Можно заметить, что в Debug и Release конфигурациях некоторые строчки всё ещё дублируются. Предполагается, что разработчик захочет настроить все эти параметры индивидуально для каждой конфигурации. Если такой потребности нет, то можно вынести дублирующиеся строчки в общую &lt;code&gt;PropertyGroup&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Debug\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\Release\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно ли ещё что-нибудь улучшить? Давайте подумаем. Глаз сразу цепляется за &lt;code&gt;OutputPath&lt;/code&gt;, который можно &#171;вычислить&#187; из названия конфигурации. При наличии двух конфигураций можно оставить для каждой индивидуальную настройку, но вот если конфигураций будет очень много, то здорово было бы сделать так, чтобы &lt;code&gt;OutputPath&lt;/code&gt;
выводился из названия конфигурации. Тут нам на помощь приходит переменная &lt;code&gt;$(Configuration)&lt;/code&gt;, с помощью которой это самое название можно узнать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot; &#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Замечательно, дублирование ушло. От чего ещё можно избавиться? Как правило, выставляемые свойства зависят только от конфигурации, изменение платформы ни на что не влияет. Давайте уберём лишнее условие:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Debug&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)&#39; == &#39;Release&#39; &amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь добавим новых конфигураций. Положим, мы хотим ввести в наше приложение Demo-режим, в котором будут доступны не все функции. Demo-режим также может потребоваться отладить, поэтому разумно создать конфигурации &lt;code&gt;DebugDemo&lt;/code&gt; и &lt;code&gt;ReleaseDemo&lt;/code&gt;. А ещё, к примеру, мы хотим ввести режим сборки, при котором от пользователя будет требоваться лицензия. Demo-версию также может понадобится лицензировать, так что мы имеем ещё 4 конфигурации: &lt;code&gt;DebugLicense&lt;/code&gt;, &lt;code&gt;ReleaseLicense&lt;/code&gt;, &lt;code&gt;DebugDemoLicense&lt;/code&gt;, &lt;code&gt;ReleaseDemoLicense&lt;/code&gt; (данная ситуация приведена только для примера, в вашем проекте может быть всё иначе). &lt;code&gt;Demo&lt;/code&gt; и &lt;code&gt;License&lt;/code&gt; будут добавлять новые переменные в &lt;code&gt;DefineConstatns&lt;/code&gt;. Казалось бы, для 8 конфигураций нужно сделать 8 отдельных &lt;code&gt;PropertyGroup&lt;/code&gt;, но что-то внутри сознания сразу начинает протестовать. К счастью, в &lt;code&gt;Condition&lt;/code&gt; можно разместить более сложное условие, нежели простое сравнение. В данном примере будем искать заданную подстроку в названии конфигурации:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выглядит вполне неплохо. Но только образовалась проблема: Visual Studio теперь &#171;не видит&#187; список доступных конфигураций. Эту проблему можно решить, добавив пустых &lt;code&gt;PropertyGroup&lt;/code&gt; c таким же &lt;code&gt;Condition&lt;/code&gt; , как были вначале. При этом можно добавлять не все возможные конфигурации, а только те, которые вы реально будете использовать при работе. Например, мы не хотим отлаживать &lt;code&gt;Demo&lt;/code&gt; и &lt;code&gt;License&lt;/code&gt; конфигурации, тогда можно написать так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;    
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если у вас есть врождённая ненависть к дублированию чего угодно, то в получившийся файл можно также вынести дополнительные свойства, которые дублируются во всех проектах. Например так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;Project DefaultTargets=&amp;quot;Build&amp;quot; xmlns=&amp;quot;http://schemas.microsoft.com/developer/msbuild/2003&amp;quot;&amp;gt;
  &amp;lt;!-- Common --&amp;gt;
  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;Configuration Condition=&amp;quot; &#39;$(Configuration)&#39; == &#39;&#39; &amp;quot;&amp;gt;Release&amp;lt;/Configuration&amp;gt;
    &amp;lt;Platform Condition=&amp;quot; &#39;$(Platform)&#39; == &#39;&#39; &amp;quot;&amp;gt;AnyCPU&amp;lt;/Platform&amp;gt;    
    &amp;lt;TargetFrameworkVersion&amp;gt;v4.0&amp;lt;/TargetFrameworkVersion&amp;gt;
    &amp;lt;SolutionDir Condition=&amp;quot;$(SolutionDir) == &#39;&#39; Or $(SolutionDir) == &#39;*Undefined*&#39;&amp;quot;&amp;gt;..\&amp;lt;/SolutionDir&amp;gt;
    &amp;lt;OutputPath&amp;gt;bin\$(Configuration)\&amp;lt;/OutputPath&amp;gt;
    &amp;lt;PlatformTarget&amp;gt;AnyCPU&amp;lt;/PlatformTarget&amp;gt;
    &amp;lt;ErrorReport&amp;gt;prompt&amp;lt;/ErrorReport&amp;gt;
    &amp;lt;WarningLevel&amp;gt;4&amp;lt;/WarningLevel&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt; 

  &amp;lt;!-- Conditional --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Debug&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugSymbols&amp;gt;true&amp;lt;/DebugSymbols&amp;gt;
    &amp;lt;DebugType&amp;gt;full&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;false&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;DEBUG;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Release&#39;))&amp;quot;&amp;gt;
    &amp;lt;DebugType&amp;gt;pdbonly&amp;lt;/DebugType&amp;gt;
    &amp;lt;Optimize&amp;gt;true&amp;lt;/Optimize&amp;gt;
    &amp;lt;DefineConstants&amp;gt;TRACE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;License&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);LICENSE&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;$(Configuration.Contains(&#39;Demo&#39;))&amp;quot;&amp;gt;
    &amp;lt;DefineConstants&amp;gt;$(DefineConstants);DEMO&amp;lt;/DefineConstants&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;  

  &amp;lt;!-- Available --&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Debug|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;Release|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemo|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
  &amp;lt;PropertyGroup Condition=&amp;quot;&#39;$(Configuration)|$(Platform)&#39; == &#39;ReleaseDemoLicense|AnyCPU&#39;&amp;quot; /&amp;gt;
&amp;lt;/Project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь точно всё дублирование ушло, а настраивать конфигурации стало легко и просто. Хочется отметить, что совершенно не обязательно данный подход подойдёт именно вам, многие проекты отлично пишутся и без правки конфигураций. А иногда каждую конфигурацию для каждого проекта и каждой платформы приходится настраивать вручную — в этом случае не особо получится сэкономить на удалении дублирования. Но если всё-таки возникла проблема с настройкой большого количества конфигураций для большого количество проектов, то, возможно, этот способ вам пригодится. Также будет полезно почитать справочные сведения о сборке в MSDN:&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/0k6kkbsd.aspx&quot;&gt;Справочные сведения о MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/ms164307.aspx&quot;&gt;Условные конструкции MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/7szfhaft.aspx&quot;&gt;Условия MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/dd633440.aspx&quot;&gt;Функции свойств&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/ms171459.aspx&quot;&gt;Использование переменных среды в построении&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb629394.aspx&quot;&gt;Общие свойства проектов MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb629388.aspx&quot;&gt;Общие элементы проектов MSBuild&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Изменения в правилах защиты диссертаций от 1 января 2014</title>
            <link>http://aakinshin.net/ru/posts/government-decree-842/</link> 
            <pubDate>Sun, 19 Jan 2014 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/government-decree-842/</guid>
            <description>&lt;p&gt;В нашей стране очень любят принимать разные новые законы. Вот, добрались и до защиты диссертаций: с 1-го января 2014 вступило в силу новое положение. В 2014-ом пройти по старым правилам могут только те, чьи диссертации были приняты к защите до 1-го января при условии, что защита пройдёт до 1-го июля 2014. Вокруг новых правил много шума: все говорят, что многое поменялось, но не все могут сказать, что именно. Давайте разберёмся.&lt;/p&gt;
&lt;p&gt;Было: &lt;a href=&quot;http://elementy.ru/library9/p74.htm&quot;&gt;Постановление Правительства РФ от 30 января 2002 г. № 74 &#171;Об утверждении Единого реестра ученых степеней и ученых званий и Положения о порядке присуждения ученых степеней&#187;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Стало: &lt;a href=&quot;http://government.ru/media/files/41d492460dd8923e356f.pdf&quot;&gt;Постановление Правительства РФ от 24 сентября 2013 г. № 842 &#171;О порядке присуждения ученых степеней&#187;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Новый документ достаточно большой (35 страниц, 86 пунктов), поэтому я решил сделать обзор наиболее важных изменений с ссылками на пункты постановлений.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для сравнения старого и нового положения я буду обозначать соответствующие пункты положений как 74.a и 842.b. Итак, имеем:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.13)&lt;/strong&gt;
Повысилось количество необходимых публикаций в рецензируемых журналах. Для кандидата в области искусствоведения и культурологии, социально-экономических, общественных и гуманитарных наук — не менее 3, в остальных областях — не менее 2. Для доктора соответственно 15 и 10. Раньше (74.10) кандидатам наук нужно было иметь хотя бы одну публикацию, а для докторов этот вопрос не регламентировался.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.15)&lt;/strong&gt;
Диссертация предоставляется в совет только на правах рукописи. Раньше (74.8) разрешались также научные доклады и опубликованные монографии.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.17)&lt;/strong&gt;
Сделали отдельный пункт про госслужащих: &lt;em&gt;&#171;Соискателю ученой степени, являющемуся руководителем органа государственной власти или органа местного самоуправления, а также государственным (муниципальным) служащим, выполняющим работу, которая влечет за собой конфликт интересов, способных повлиять на принимаемые решения по вопросам государственной научной аттестации, запрещается представлять к защите диссертацию в диссертационные советы, созданные на базе организаций, находящихся в ведении этих органов.&#187;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.19)&lt;/strong&gt;
Решение диссертационного совета о приеме или об отказе в приеме диссертации к защите размещается на официальном сайте организации. В случае отказа из-за несоблюдения требований диссертация размещается на сайте на 10 лет с указанием причины отказа.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.20)&lt;/strong&gt;
Очень подробно расписаны основания для отказа в приёме к защите. Особенно хочется отметить пункт по борьбе с плагиатом: &lt;em&gt;&#171;использование в диссертации заимствованного материала без ссылки на автора и (или) источник заимствования, результатов научных работ, выполненных соискателем ученой степени в соавторстве, без ссылок на соавторов&#187;&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.22)&lt;/strong&gt;
Ужесточили требования к оппонентам по сравнению с пунктом 74.21: теперь оппонентами не могут быть &lt;em&gt;&#171;работники (в том числе работающие по совместительству) организаций, где выполнялась диссертация или работает соискатель ученой степени, его научный руководитель или научный консультант, а также где ведутся научно-исследовательские работы, по которым соискатель ученой степени является руководителем или работником организации-заказчика или исполнителем (соисполнителем). Оппоненты должны являться работниками разных организаций в случае осуществления ими трудовой деятельности&#187;.&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.23)&lt;/strong&gt;
Отзывы оппонентов на диссертацию публикуются в интернете.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.24)&lt;/strong&gt;
Также ужесточаются требования к ведущей организации (по сравнению с 74.23): &lt;em&gt;&#171;Ведущей организацией не могут быть организации, в которых работают соискатель ученой степени, научные руководители (научные консультанты) соискателя ученой степени, а также организации, где ведутся научно-исследовательские работы, по которым соискатель ученой степени является руководителем или работником организации-заказчика или исполнителем (соисполнителем)&#187;.&lt;/em&gt; Отзыв ведущей организации также нужно публиковать в интернете.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.26)&lt;/strong&gt; Исходный текст диссертационной работы теперь также публикуется в интернете. Причём, публикация должна быть осуществлена для кандидата наук — минимум за 2 месяца, для доктора — минимум за 3 месяца. Это требование увеличивает и определяет минимальный срок до защиты, за который должен быть готов итоговый вариант текста диссертационной работы. Раньше у соискателей был месяц (за месяц до защиты нужно было опубликовать в интернете автореферат). Впрочем, история знает случаи, когда люди дописывали свои диссертации в последние дни перед защитой — теперь такой фокус не пройдёт.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.28)&lt;/strong&gt;
Все отзывы на автореферат и текст диссертационной работы также публикуются в интернете.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;842.65–77)&lt;/strong&gt;
Очень подробно расписана процедура лишения учёных степеней (раньше в пунктах 74.41–43 этот вопрос был освещён достаточно скудно). Если кратко, то теперь любое физическое или юридическое лицо может подать заявление о лишении учёной степени в течении 10 лет со дня защиты (против 3 лет в старом положении). Если человека всё-таки лишают учёной степени, то в интернете публикуется подробная информация о всех, кто был причастен к защите: о членах диссовета, научном руководителе, оппонентах и ведущей организации.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Как можно заметить, практически все нововведения направлены на борьбу с плагиатом: основной акцент сделан на гласность и увеличение ответственности за недобросовестные работы. Наверное, в чём-то это хорошо, но жизнь честных соискателей также усложниться. Наиболее значительными моментами являются увеличение срока до защиты, за который диссертация должна быть готова (2 месяца для кандидатов и 3 для докторов), и трудности в поисках оппонентов и ведущей организации.&lt;/p&gt;
&lt;p&gt;Для тех, кто собирается писать диссертацию по ГОСТ-у на LaTeX могу посоветовать специальный шаблон: &lt;a href=&quot;https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template&quot;&gt;Russian-Phd-LaTeX-Dissertation-Template&lt;/a&gt;.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Cache-Conscious Binary Search</title>
            <link>http://aakinshin.net/ru/posts/cache-conscious-binary-search/</link> 
            <pubDate>Wed, 20 Nov 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/cache-conscious-binary-search/</guid>
            <description>&lt;p&gt;
	Рассмотрим простую задачу: есть некоторый достаточно большой неизменный набор чисел, к нему осуществляется множество запросов на наличие некоторого числа в этом наборе, необходимо максимально быстро эти запросы обрабатывать. Одно из классических решений заключается в формировании отсортированного массива и обработке запросов через бинарный поиск. Но можно ли добиться более высокой производительности, чем в классической реализации? В этой статье мне хотелось бы рассказать про Cache-Conscious Binary Search. В данном алгоритме предлагается переупорядочить элементы массива таким образом, чтобы использование кэша процессора происходило максимально эффективно.
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt; &lt;b&gt;Дисклеймер:&lt;/b&gt;
	я не пытаюсь создать самое эффективное решение данной задачи. Мне хотелось бы просто обсудить подход к построению структур данных на основе учёта особенностей работы с кэшом процессора, т.к. многие при решении оптимизационных задач в принципе не задумываются о процессорной архитектуре. Я также не собираюсь писать идеальную реализацию Cache-Conscious Binary Search, мне хотелось бы посмотреть эффект от подобного подхода на достаточно простом примере (также в целях упрощения кода количество вершин берётся равным N=2^K-1). В качестве языка программирования я буду использовать C# (общее быстродействие для нас не принципиально, т.к. основной акцент делается не на создании самой быстрой программы в мире, а на относительном сравнении различных подходов к решению задачи). Стоит также отметить, что алгоритм эффективен только на больших массивах, поэтому не следует использовать данный подход во всех задачах, сперва нужно убедиться в его целесообразности. Предполагается, что у читателя имеются базовые представления о том, что такое кэш процессора, и как он работает.
&lt;/p&gt;
&lt;p&gt;
	Рассмотрим классическую реализацию бинарного поиска: пусть у нас имеется отсортированный массив
	&lt;code&gt;a&lt;/code&gt;
	и некоторый элемент
	&lt;code&gt;x&lt;/code&gt;
	, который мы будем в нём искать:
&lt;/p&gt;
&lt;pre class=&quot;prettyprint lang-cs&quot;&gt;&lt;br /&gt;public bool Contains(int x)&lt;br /&gt;{&lt;br /&gt;    int l = 0, r = N - 1;&lt;br /&gt;    while (l &amp;lt;= r)&lt;br /&gt;    {&lt;br /&gt;        int m = (l + r) / 2;&lt;br /&gt;        if (a[m] == x)&lt;br /&gt;            return true;&lt;br /&gt;        if (a[m] &gt; x)&lt;br /&gt;            r = m - 1;&lt;br /&gt;        else&lt;br /&gt;            l = m + 1;&lt;br /&gt;    }&lt;br /&gt;    return false;&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;
&lt;p&gt;
	В данной реализации на первых итерациях алгоритма запросы будут осуществляться к элементам массива, которые находятся далеко друг от друга. Изобразим дерево поиска для массива из 15-и элементов:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://3.bp.blogspot.com/-lS77713GjIQ/Uoygymx31cI/AAAAAAAAAOw/o37c1lotLHo/s1600/img1.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-lS77713GjIQ/Uoygymx31cI/AAAAAAAAAOw/o37c1lotLHo/s640/img1.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	Из рисунка видно, что при проходе по такому дереву сперва будет обращение к 7-му элементу, а затем (в случае
	&lt;code&gt;a[7]!=x&lt;/code&gt;
	) к 3-ему или 11-ому. На таком маленьком массиве это не критично, но в большом массиве эти обращения будут соответствовать разным строчкам кэша процессора, что негативно скажется на производительности. Давайте попробуем переупорядочить элементы так, чтобы последовательные обращения к массиву приходились на близкие участки памяти. В первом приближении можно попробовать расположить друг за другом каждый уровень дерева с помощью простого поиска в ширину. На нашем тестовом дереве получим следующий результат:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://4.bp.blogspot.com/-7v_UqTv09FM/UoyhCIEiIII/AAAAAAAAAO0/EJmozES7E2w/s1600/img2.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-7v_UqTv09FM/UoyhCIEiIII/AAAAAAAAAO0/EJmozES7E2w/s640/img2.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	Теперь элементы массива, к которым мы будем обращаться на первых итерациях, находятся недалеко друг от друга. Но с ростом номера итерации мы всё равно получим большое количество cache miss-ов. Чтобы исправить данную ситуацию, разобьём наше &#171;большое&#187; дерево бинарного поиска на небольшие поддеревья. Каждое такое поддерево будет соответствовать нескольким уровням оригинального дерева, а элементы поддерева будут находится недалеко друг от друга. Таким образом, cache miss будут образовываться в основном при переходе к очередному поддереву. Высоту поддерева можно варьировать, подбирая её в соответствии с процессорной архитектурой. Проиллюстрируем данные построения на нашем примере, взяв высоту поддерева равным 2:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://4.bp.blogspot.com/-w7UB4jgCGEQ/UoyhFYPW4YI/AAAAAAAAAO8/BUDzRYVmjCY/s1600/img3.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://4.bp.blogspot.com/-w7UB4jgCGEQ/UoyhFYPW4YI/AAAAAAAAAO8/BUDzRYVmjCY/s640/img3.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	А теперь перейдём к практическим исследованиям. Для чистоты эксперимента и получения точных результатов будем замерять время с помощью проекта
	&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;
	. Рассмотрим самую тривиальную реализацию рассмотренного алгоритма без каких-либо дополнительных оптимизаций (исходный код
	&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/CacheConsciousBinarySearchCompetition.cs&quot;&gt;приведён&lt;/a&gt;
	на GitHub). Сравнивать будем классическую реализацию и cache-conscious-реализации с разными высотами поддеревьев (CacheConsciousSearchK соответствует поддереву с высотой K). Высоту дерева возьмём равной 24. На моей машине (Intel Core i7-3632QM CPU 2.20GHz) получились следующие результаты (алгоритм очень чувствителен к процессорной архитектуре, поэтому у вас могут получиться совсем другие временные оценки):
&lt;/p&gt;
&lt;pre class=&quot;prettyprint&quot;&gt;&lt;br /&gt;// Microsoft.NET 4.5 x64&lt;br /&gt;SimpleSearch          : 6725ms&lt;br /&gt;CacheConsciousSearch1 : 4428ms&lt;br /&gt;CacheConsciousSearch2 : 3963ms&lt;br /&gt;CacheConsciousSearch3 : 3778ms&lt;br /&gt;CacheConsciousSearch4 : 3774ms&lt;br /&gt;CacheConsciousSearch5 : 3762ms&lt;br /&gt;&lt;/pre&gt;
&lt;div class=&quot;spoiler&quot; title=&quot;Исходный код бенчмарка&quot;&gt;
	&lt;pre class=&quot;prettyprint lang-cs&quot;&gt;&lt;br /&gt;public class CacheConsciousBinarySearchCompetition : BenchmarkCompetition&lt;br /&gt;{&lt;br /&gt;    private const int K = 24, N = (1 &amp;lt;&amp;lt; K) - 1, IterationCount = 10000000;&lt;br /&gt;    private readonly Random random = new Random();&lt;br /&gt;&lt;br /&gt;    private Tree originalTree;&lt;br /&gt;    private int[] bfs;&lt;br /&gt;&lt;br /&gt;    protected override void Prepare()&lt;br /&gt;    {&lt;br /&gt;        originalTree = new Tree(Enumerable.Range(0, N).Select(x =&amp;gt; 2 * x).ToArray());&lt;br /&gt;        bfs = originalTree.Bfs();&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void SimpleSearch()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(originalTree);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch1()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 1));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch2()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 2));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch3()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 3));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch4()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 4));&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    [BenchmarkMethod]&lt;br /&gt;    public void CacheConsciousSearch5()&lt;br /&gt;    {&lt;br /&gt;        SingleRun(new CacheConsciousTree(bfs, 5));&lt;br /&gt;    }&lt;br /&gt;    &lt;br /&gt;    private int SingleRun(ITree tree)&lt;br /&gt;    {&lt;br /&gt;        int searchedCount = 0;&lt;br /&gt;        for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)&lt;br /&gt;        {&lt;br /&gt;            int x = random.Next(N * 2);&lt;br /&gt;            if (tree.Contains(x))&lt;br /&gt;                searchedCount++;&lt;br /&gt;        }&lt;br /&gt;        return searchedCount;&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    interface ITree&lt;br /&gt;    {&lt;br /&gt;        bool Contains(int x);&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    class Tree : ITree&lt;br /&gt;    {&lt;br /&gt;        private readonly int[] a;&lt;br /&gt;&lt;br /&gt;        public Tree(int[] a)&lt;br /&gt;        {&lt;br /&gt;            this.a = a;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public bool Contains(int x)&lt;br /&gt;        {&lt;br /&gt;            int l = 0, r = N - 1;&lt;br /&gt;            while (l &amp;lt;= r)&lt;br /&gt;            {&lt;br /&gt;                int m = (l + r) / 2;&lt;br /&gt;                if (a[m] == x)&lt;br /&gt;                    return true;&lt;br /&gt;                if (a[m] &amp;gt; x)&lt;br /&gt;                    r = m - 1;&lt;br /&gt;                else&lt;br /&gt;                    l = m + 1;&lt;br /&gt;            }&lt;br /&gt;            return false;&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public int[] Bfs()&lt;br /&gt;        {&lt;br /&gt;            int[] bfs = new int[N], l = new int[N], r = new int[N];&lt;br /&gt;            int tail = 0, head = 0;&lt;br /&gt;            l[head] = 0;&lt;br /&gt;            r[head++] = N - 1;&lt;br /&gt;            while (tail &amp;lt; head)&lt;br /&gt;            {&lt;br /&gt;                int m = (l[tail] + r[tail]) / 2;&lt;br /&gt;                bfs[tail] = a[m];&lt;br /&gt;                if (l[tail] &amp;lt; m)&lt;br /&gt;                {&lt;br /&gt;                    l[head] = l[tail];&lt;br /&gt;                    r[head++] = m - 1;&lt;br /&gt;                }&lt;br /&gt;                if (m &amp;lt; r[tail])&lt;br /&gt;                {&lt;br /&gt;                    l[head] = m + 1;&lt;br /&gt;                    r[head++] = r[tail];&lt;br /&gt;                }&lt;br /&gt;                tail++;&lt;br /&gt;            }&lt;br /&gt;            return bfs;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    class CacheConsciousTree : ITree&lt;br /&gt;    {&lt;br /&gt;        private readonly int[] a;&lt;br /&gt;        private readonly int level;&lt;br /&gt;&lt;br /&gt;        public CacheConsciousTree(int[] bfs, int level)&lt;br /&gt;        {&lt;br /&gt;            this.level = level;&lt;br /&gt;            int size = (1 &amp;lt;&amp;lt; level) - 1, counter = 0;&lt;br /&gt;            a = new int[N];&lt;br /&gt;            var was = new bool[N];&lt;br /&gt;            var queue = new int[size];&lt;br /&gt;            for (int i = 0; i &amp;lt; N; i++)&lt;br /&gt;                if (!was[i])&lt;br /&gt;                {&lt;br /&gt;                    int head = 0;&lt;br /&gt;                    queue[head++] = i;&lt;br /&gt;                    for (int tail = 0; tail &amp;lt; head; tail++)&lt;br /&gt;                    {&lt;br /&gt;                        a[counter++] = bfs[queue[tail]];&lt;br /&gt;                        was[queue[tail]] = true;&lt;br /&gt;                        if (queue[tail] * 2 + 1 &amp;lt; N &amp;amp;&amp;amp; head &amp;lt; size)&lt;br /&gt;                            queue[head++] = queue[tail] * 2 + 1;&lt;br /&gt;                        if (queue[tail] * 2 + 2 &amp;lt; N &amp;amp;&amp;amp; head &amp;lt; size)&lt;br /&gt;                            queue[head++] = queue[tail] * 2 + 2;&lt;br /&gt;                    }&lt;br /&gt;                }&lt;br /&gt;        }&lt;br /&gt;&lt;br /&gt;        public bool Contains(int x)&lt;br /&gt;        {&lt;br /&gt;            int u = 0, deep = 0, leafCount = 1 &amp;lt;&amp;lt; (level - 1);&lt;br /&gt;            int root = 0, rootOffset = 0;&lt;br /&gt;            while (deep &amp;lt; K)&lt;br /&gt;            {&lt;br /&gt;                int value = a[root + u];&lt;br /&gt;                if (value == x)&lt;br /&gt;                    return true;&lt;br /&gt;                if (++deep % level != 0)&lt;br /&gt;                {&lt;br /&gt;                    if (value &amp;gt; x)&lt;br /&gt;                        u = 2 * u + 1;&lt;br /&gt;                    else&lt;br /&gt;                        u = 2 * u + 2;&lt;br /&gt;                }&lt;br /&gt;                else&lt;br /&gt;                {&lt;br /&gt;                    int subTreeSize = (1 &amp;lt;&amp;lt; Math.Min(level, K - deep)) - 1;&lt;br /&gt;                    if (value &amp;gt; x)&lt;br /&gt;                        rootOffset = rootOffset * leafCount * 2 + (u - leafCount + 1) * 2;&lt;br /&gt;                    else&lt;br /&gt;                        rootOffset = rootOffset * leafCount * 2 + (u - leafCount + 1) * 2 + 1;&lt;br /&gt;                    root = (1 &amp;lt;&amp;lt; deep) - 1 + rootOffset * subTreeSize;&lt;br /&gt;                    u = 0;&lt;br /&gt;                }&lt;br /&gt;            }&lt;br /&gt;            return false;&lt;br /&gt;        }&lt;br /&gt;    }&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;
	На всякий случай я запустил бенчмарк под различными версиями .NET Framework и с различной битностью. Все конфигурации дали схожие результаты:
&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://3.bp.blogspot.com/-vup5W3aaqRg/UoyhK7lTPaI/AAAAAAAAAPE/JHDLACXG7Eg/s1600/ms.net.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-vup5W3aaqRg/UoyhK7lTPaI/AAAAAAAAAPE/JHDLACXG7Eg/s640/ms.net.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;Под Mono результаты также получились аналогичными:&lt;/p&gt;
&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;
	&lt;a href=&quot;http://2.bp.blogspot.com/-L8WX6UDHCA4/UoyhOjLKhvI/AAAAAAAAAPM/RBnImyRSQk0/s1600/mono.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;
		&lt;img border=&quot;0&quot; src=&quot;http://2.bp.blogspot.com/-L8WX6UDHCA4/UoyhOjLKhvI/AAAAAAAAAPM/RBnImyRSQk0/s640/mono.png&quot; /&gt;
	&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
	Из этих картинок видно, что классическая реализация бинарного поиска значительно уступает Cache-Conscious-реализации. Стоит отметить, что по началу с ростом высоты поддеревьев быстродействие возрастает, но эта тенденция наблюдается недолго (поддеревья начинают приносить мало пользы, если внутри поддерева возникает большое количество cashe miss-ов).
&lt;/p&gt;
&lt;p&gt;
	Разумеется, Cache-Conscious Binary Search является лишь примером того, как можно адаптировать программу к особенностям работы кэша процессора. Подобные Cache-Conscious Data Structures могут оказать неоценимую помощь при оптимизации приложения, если ваши структуры данных имеют достаточно большой объём, а последовательные запросы к ним приходятся на разные участки памяти. Но не стоит бездумно бросаться переписывать всё под Cache-Conscious: помните, что код станет намного сложнее, а повышение эффективности в значительной степени зависит от используемой процессорной архитектуры. В реальной жизни лучше сперва подумать о выборе наиболее оптимальных алгоритмов с хорошей асимптотикой, различных предподсчётах, эвристиках и т.п., а Cache-Conscious приберечь на времена, когда всё станет совсем плохо.
&lt;/p&gt;
&lt;p&gt;
	Дополнение от Хабраюзера
	&lt;a href=&quot;http://habrahabr.ru/users/MikeMirzayanov/&quot;&gt;MikeMirzayanov&lt;/a&gt;
	: Есть такой трюк. Если надо бинпоиском поискать в массиве длине n, то можно разбить его на sqrt(n) блоков по sqrt(n) элементов. Затем бинпоиском за log(sqrt(n)) подыскать нужный блок и в нём вторым бинпоиском за log(sqrt(n)) найти элемент. В сумме получается всё тот же log(n), но попаданий в кэш значительно больше, т.к. каждый раз ищем на довольно коротком массиве длины sqrt(n).
&lt;/p&gt;
&lt;p&gt;Быстрых вам приложений!&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Также можно почитать по теме:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://www.vldb.org/conf/1999/P7.pdf&quot;&gt;Cache Conscious Indexing for Decision-Support in Main Memory&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/trishulc/papers/ccds.pdf&quot;&gt;Cache-Conscious Data Structures&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://mspiegel.github.io/publications/michael-spiegel-dissertation.pdf&quot;&gt;Cache-Conscious Concurrent Data Structures&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://ftp.cse.buffalo.edu/users/azhang/disc/disc01/cd1/out/papers/sigmod/p475-rao/p475-rao.pdf&quot;&gt;Making B+-Trees Cache Conscious in Main Memory&lt;/a&gt;
	&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Переписываем список коммитеров в Git</title>
            <link>http://aakinshin.net/ru/posts/git-rewrite-commiter-list/</link> 
            <pubDate>Sun, 10 Nov 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/git-rewrite-commiter-list/</guid>
            <description>&lt;p&gt;Иногда возникает потребность переписать коммитеров в Git-репозитории. Задача достаточно редкая, но иногда всё-таки приходится ей заниматься. Давайте разберёмся в ситуации подробней. Прежде всего, взглянем на текущий список коммитеров:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&amp;quot;%an &amp;lt;%aE&amp;gt;&amp;quot; | sort -u
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Допустим, мы получили следующий список:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ivan &amp;lt;ivan＠gmail.com&amp;gt;
Ivan &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
Ivan &amp;lt;ivan-ivan＠gmail.com&amp;gt;
Ivan Ivanov &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
Vanya Ivanov &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
Vanya &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Наблюдаем следующую проблему: некий Иван Иванов делал коммиты, указывая каждый раз разную информацию об имени пользователя и почтовом адресе. Для начала нужно дать по рукам Ивану и сказать, чтобы больше так не делал. Лучше всего использовать для всех коммитов одинаковую учётную информацию (например,
&lt;code&gt;Ivan Ivanov &amp;lt;ivan.ivanov＠gmail.com&amp;gt;&lt;/code&gt;). Проблема может встать особенно остро, если в проекте используются дополнительные сервисы, которые работают с репозиторием (code review system, build server и т.п.). Ну, а пока Иван размышляет над своим поведением, мы займёмся переписыванием истории.&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;На текущий момент в репозитории имеется ряд коммитеров с именем &lt;code&gt;Ivan&lt;/code&gt; . Давайте их все объединим! А поможет нам в этом замечательная команда &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-filter-branch.html&quot;&gt;git filter-branch&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git filter-branch --commit-filter &#39;
        if [ &amp;quot;$GIT_AUTHOR_NAME&amp;quot; = &amp;quot;Ivan&amp;quot; ];
        then
                GIT_AUTHOR_NAME=&amp;quot;Ivan Ivanov&amp;quot;;
                GIT_AUTHOR_EMAIL=&amp;quot;ivan.ivanov＠gmail.com&amp;quot;;
                git commit-tree &amp;quot;$＠&amp;quot;;
        else
                git commit-tree &amp;quot;$＠&amp;quot;;
        fi&#39; HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь все Иваны ушли из нашего репозитория, список коммитеров выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ivan Ivanov &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
Vanya Ivanov &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
Vanya &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После перезаписи истории git сохраняет оригинальные указатели на ветки в &lt;code&gt;.git/refs/original&lt;/code&gt; . Для выполнения следующей перезаписи истории (давайте объединим пользователей по почтовому адресу) нам необходимо либо удалить эту папку, либо выполнить команду с ключом &lt;code&gt;-f&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git filter-branch -f --commit-filter &#39;
        if [ &amp;quot;$GIT_AUTHOR_EMAIL&amp;quot; = &amp;quot;ivan.ivanov＠gmail.com&amp;quot; ];
        then
                GIT_AUTHOR_NAME=&amp;quot;Ivan Ivanov&amp;quot;;
                GIT_AUTHOR_EMAIL=&amp;quot;ivan.ivanov＠gmail.com&amp;quot;;
                git commit-tree &amp;quot;$＠&amp;quot;;
        else
                git commit-tree &amp;quot;$＠&amp;quot;;
        fi&#39; HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ура! У нас остался единственный коммитер:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ivan Ivanov &amp;lt;ivan.ivanov＠gmail.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Проверив правильность изменений, можно с чистой совестью удалить папку &lt;code&gt;.git/refs/original&lt;/code&gt; с бэкапом данных. После этого в репозитории будет находится много мусора. Не помешает явно избавиться от него c помощью &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-gc.html&quot;&gt;git gc&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git gc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Далее наступает ответственный этап: отправка изменённой истории на сервер:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git push --all -f origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого можно порекомендовать вашим коллегам по репозиторию снести свою локальную копию и скачать все данные с нуля (думаю, это наиболее безболезненный способ перехода на новое дерево коммитов).&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Важно!&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Помните, что коммиты содержат SHA-1 своих родителей, поэтому будут переписаны SHA-1 не только целевых коммитов, но и всех их потомков. Соответственно, если была привязка сторонних сервисов к коммитам вашего репозитория по SHA-1, то она &#171;погибнет&#187; после перезаписи истории. Да и остальные разработчики в вашей команде будут безмерно удивлены полностью переписанной истории на сервере. Поэтому не используйте перезапись истории на сервере, если у вас нет действительно веских причин для этого.&lt;/li&gt;
&lt;li&gt;Процесс перезаписи истории быстрым не назовёшь, время работы прямо пропорционально общему количеству коммитов. Если ваш репозиторий достаточно большой, то придётся запастись терпением.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Jon Skeet&#39;s Quiz</title>
            <link>http://aakinshin.net/posts/jon-skeet-quiz/</link> 
            <pubDate>Sun, 03 Nov 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/jon-skeet-quiz/</guid>
            <description>&lt;p&gt;Jon Skeet was once asked to give three questions to check how well you know C#. He asked the &lt;a href=&quot;http://www.dotnetcurry.com/magazine/jon-skeet-quiz.aspx&quot;&gt;following questions&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q1.&lt;/strong&gt; &lt;em&gt;What constructor call can you write such that this prints True (at least on the Microsoft .NET implementation)?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new /* fill in code here */;
object y = new /* fill in code here */;
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note that it’s just a constructor call, and you can’t change the type of the variables.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q2.&lt;/strong&gt; &lt;em&gt;How can you make this code compile such that it calls three different method overloads?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;void Foo()
{
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q3.&lt;/strong&gt; &lt;em&gt;With a local variable (so no changing the variable value cunningly), how can you make this code fail on the second line?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These questions seemed interesting to me, that is why I decided to discuss the solutions.&lt;!--more--&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-1.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One of the simplest ways is using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/1t3y8s4s(v=vs.90).aspx&quot;&gt;Nullable&lt;/a&gt; types:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new int?();
object y = new int?();
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In spite of the explicit call of the constructor, values we got are equal to null and thus they match.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-2.&lt;/strong&gt;
Or you can remember of &lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/09/28/string-interning-and-string-empty.aspx&quot;&gt;string interning&lt;/a&gt; and declare two empty strings:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new string(new char[0]);
object y = new string(new char[0]);
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A2.&lt;/strong&gt; The second question is the most complicated one. It’s necessary to offer the solution which calls tree different method overloads. I can suggest the following code as a sample:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ReferenceGeneric&amp;lt;T&amp;gt; where T : class { }

public class EvilClassBase
{
  protected void EvilMethod&amp;lt;T&amp;gt;()
  {
    Console.WriteLine(&amp;quot;int?&amp;quot;);
  }
}

public class EvilClass : EvilClassBase
{
  public void Run()
  {
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
  }

  private void EvilMethod&amp;lt;T&amp;gt;(ReferenceGeneric&amp;lt;T&amp;gt; arg = null) where T : class
  {
    Console.WriteLine(&amp;quot;string&amp;quot;);
  }

  private void EvilMethod&amp;lt;T&amp;gt;(T? arg = null) where T : struct
  {
    Console.WriteLine(&amp;quot;int&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s consider &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; types. Here it’s quite simple: &lt;code&gt;string&lt;/code&gt; is a reference type and &lt;code&gt;int&lt;/code&gt; is a value type. The following constructions will help us write the code: &lt;code&gt;where T : class&lt;/code&gt;, &lt;code&gt;where T : struct&lt;/code&gt;. The default parameters will explicitly use &lt;code&gt;T&lt;/code&gt; type in the corresponding way: the first method will use argument of the following type: &lt;code&gt;ReferenceGeneric&amp;lt;T&amp;gt;&lt;/code&gt; (it can accept only reference types), and the second method will use &lt;code&gt;T&lt;/code&gt;? (it can accept only value non-nullable types). Now calls of &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; and &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; will get correct overloads.&lt;/p&gt;
&lt;p&gt;Let’s proceed to &lt;code&gt;int?&lt;/code&gt;. We will create overload with a signature without any additional conditions &lt;code&gt;EvilMethod&amp;lt;T&amp;gt;()&lt;/code&gt; (unfortunately, C# doesn’t allow you to write anything of this kind &lt;code&gt;where T : Nullable&amp;lt;int&amp;gt;&lt;/code&gt;). But if you declare this method in the same class, it will get calls of the first two methods. That is why you need to send it the base class.&lt;/p&gt;
&lt;p&gt;Let’s look at what we have. Calls of &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; and &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; will see the suitable overloads in the current class and will use them. Call of &lt;code&gt;EvilMethod&amp;lt;int?&amp;gt;()&lt;/code&gt; won’t find a suitable overload in the current class and will apply to the base class for it. Power of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa691336%28v=vs.71%29.aspx&quot;&gt;C# Overload resolution rules&lt;/a&gt; helped us once again!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A3.&lt;/strong&gt; Again, Nullable types will help us!&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var x = new int?();
string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9hd15ket.aspx&quot;&gt;Remember&lt;/a&gt; that &lt;code&gt;ToString()&lt;/code&gt; method is overloaded in &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, it will get an empty string for the null value. Unfortunately, this trick won’t work for &lt;code&gt;GetType()&lt;/code&gt;. It can’t be overloaded and will through an exception for the null value. You can also &lt;a href=&quot;http://stackoverflow.com/questions/12725631/nullable-type-gettype-throws-exception&quot;&gt;read&lt;/a&gt; the Jon’s original answer to this question.&lt;/p&gt;
&lt;p&gt;Don’t forget that if you really want you can always access methods table via the unmanaged code and manually substitute reference to &lt;code&gt;GetType()&lt;/code&gt;, but we were asked not to shuffle =).&lt;/p&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/jon-skeets-quiz/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Jon Skeet&#39;s Quiz</title>
            <link>http://aakinshin.net/ru/posts/jon-skeet-quiz/</link> 
            <pubDate>Sun, 03 Nov 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/jon-skeet-quiz/</guid>
            <description>&lt;p&gt;Однажды Джона Скита попросили сформулировать три интересных вопроса на знание C#. Он спросил следующее (&lt;a href=&quot;http://www.dotnetcurry.com/magazine/jon-skeet-quiz.aspx&quot;&gt;оригинал вопросника&lt;/a&gt;,	&lt;a href=&quot;http://timyrguev.blogspot.ru/2013/10/blog-post.html&quot;&gt;перевод статьи&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q1.&lt;/strong&gt; &lt;em&gt;Вызов какого конструктора можно использовать, чтобы следующий код вывел True (хотя бы в реализации Microsoft.NET)?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new /* fill in code here */;
object y = new /* fill in code here */;
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Учтите, что это просто вызов конструктора, вы не можете поменять тип переменных.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q2.&lt;/strong&gt; &lt;em&gt;Как сделать так, чтобы следующий код вызывал три различных перегрузки метода?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;void Foo()
{
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Q3.&lt;/strong&gt; &lt;em&gt;Как заставить следующий код выбросить исключение во второй строчке с помощью локальной переменной (без хитрого изменения её значения)?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вопросы показались мне интересными, поэтому я решил обсудить их решения.&lt;!--more--&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-1.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Одним из самых простых способов является использование &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/1t3y8s4s(v=vs.90).aspx&quot;&gt;Nullable&lt;/a&gt;-типов:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new int?();
object y = new int?();
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Несмотря на явный вызов конструктора, получившиеся значения равны &lt;code&gt;null&lt;/code&gt;, а следовательно совпадают.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A1-2.&lt;/strong&gt; Или можно вспомнить про &lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/09/28/string-interning-and-string-empty.aspx&quot;&gt;интернирование строк&lt;/a&gt; и объявить две пустые строчки:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object x = new string(new char[0]);
object y = new string(new char[0]);
Console.WriteLine(x == y);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A2.&lt;/strong&gt; Вторая задачка — самая сложная из трёх предложенных. Необходимо придумать такое решение, чтобы запускались именно три &lt;em&gt;разных&lt;/em&gt; перегрузки нашего метода. В качестве варианта решения можно рассмотреть следующий код:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ReferenceGeneric&amp;lt;T&amp;gt; where T : class { }

public class EvilClassBase
{
  protected void EvilMethod&amp;lt;T&amp;gt;()
  {
    Console.WriteLine(&amp;quot;int?&amp;quot;);
  }
}

public class EvilClass : EvilClassBase
{
  public void Run()
  {
    EvilMethod&amp;lt;string&amp;gt;();
    EvilMethod&amp;lt;int&amp;gt;();
    EvilMethod&amp;lt;int?&amp;gt;();
  }

  private void EvilMethod&amp;lt;T&amp;gt;(ReferenceGeneric&amp;lt;T&amp;gt; arg = null) where T : class
  {
    Console.WriteLine(&amp;quot;string&amp;quot;);
  }

  private void EvilMethod&amp;lt;T&amp;gt;(T? arg = null) where T : struct
  {
    Console.WriteLine(&amp;quot;int&amp;quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для начала разберёмся с типам &lt;code&gt;string&lt;/code&gt; и &lt;code&gt;int&lt;/code&gt;. Тут всё просто: &lt;code&gt;string&lt;/code&gt; является ссылочным типом, а &lt;code&gt;int&lt;/code&gt; — значимым. При написании кода нам помогут конструкции &lt;code&gt;where T : class&lt;/code&gt;, &lt;code&gt;where T : struct&lt;/code&gt; и параметры по умолчанию, которые явно задействуют тип &lt;code&gt;T&lt;/code&gt; соответствующим образом: в первый метод пойдёт аргумент типа &lt;code&gt;ReferenceGeneric&amp;lt;T&amp;gt;&lt;/code&gt; (он может принимать только ссылочные типы), а во второй — &lt;code&gt;T?&lt;/code&gt; (он может принимать только значимые non-nullable типы). Теперь вызовы &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; и &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; &#171;найдут&#187; себе правильные перегрузки.&lt;/p&gt;
&lt;p&gt;Едем дальше, вспомним про &lt;code&gt;int?&lt;/code&gt;. Для него создадим перегрузку с сигнатурой без всяких дополнительных условий &lt;code&gt;EvilMethod&amp;lt;T&amp;gt;()&lt;/code&gt; (увы, C# не позволяет написать что-нибудь вроде &lt;code&gt;where T : Nullable&amp;lt;int&amp;gt;&lt;/code&gt;). Но если мы объявим такой метод в том же классе, то он &#171;заберёт&#187; себе вызовы первых двух методов. Поэтому следует &#171;отправить&#187; его в базовый класс, там он нам мешать не будет.&lt;/p&gt;
&lt;p&gt;Давайте взглянем на то, что получилось. Вызовы &lt;code&gt;EvilMethod&amp;lt;string&amp;gt;()&lt;/code&gt; и &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;()&lt;/code&gt; &#171;увидят&#187; подходящие перегрузки в текущем классе и будут их использовать. Вызов &lt;code&gt;EvilMethod&amp;lt;int&amp;gt;;()&lt;/code&gt; подходящей перегрузки в текущем классе &#171;не найдёт&#187;, поэтому &#171;пойдёт&#187; за ней в базовый класс. Сила &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa691336%28v=vs.71%29.aspx&quot;&gt;C# Overload resolution rules&lt;/a&gt; опять помогла нам!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A3.&lt;/strong&gt; И снова Nullable-типы спешат на помощь!&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var x = new int?();
string text = x.ToString(); // No exception
Type type = x.GetType(); // Bang!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9hd15ket.aspx&quot;&gt;Вспомним&lt;/a&gt;, что метод &lt;code&gt;ToString()&lt;/code&gt; перегружен в &lt;code&gt;Nullable&amp;lt;T&amp;gt;&lt;/code&gt;, для null-значения он вернёт пустую строчку. Увы, для &lt;code&gt;GetType()&lt;/code&gt; такой фокус не пройдёт, он не может быть перегружен и на null-значении выбросит исключение. Также вы &lt;a href=&quot;http://stackoverflow.com/questions/12725631/nullable-type-gettype-throws-exception&quot;&gt;можете почитать&lt;/a&gt; оригинальный ответ Джона на свой вопрос.&lt;/p&gt;
&lt;p&gt;Не забываем, что при очень большом желании через неуправляемый код мы всегда можем долезть до таблицы методов и ручками подменить ссылку на &lt;code&gt;GetType()&lt;/code&gt;, но сегодня нас просили не хитрить =).&lt;/p&gt;</description>
        </item>
        <item>
            <title>Внутреннее устройство массивов в .NET</title>
            <link>http://aakinshin.net/ru/posts/arrays-internal-structure/</link> 
            <pubDate>Fri, 11 Oct 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/arrays-internal-structure/</guid>
            <description>&lt;p&gt;Иногда бывает полезно понимать, как выглядит внутреннее представление объектов, с которыми мы работаем. В этой статье я хотел бы поговорить о массивах: как именно они хранятся в памяти, какие IL-команды используются для работы с ними, как выглядит ассемблерный код при обращении к их элементам. Я рассмотрю три вида массивов: single (&lt;code&gt;T[]&lt;/code&gt;), rectangular (&lt;code&gt;T[,]&lt;/code&gt;), jagged (&lt;code&gt;T[][]&lt;/code&gt;). Также будет затронута тема массивов с ненулевой нижней границей (&lt;code&gt;T[*]&lt;/code&gt;) и нюансов работы с ними.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;При рассмотрении низкоуровневых данных (например, дампов памяти) следует понимать, что адреса различных объектов будут меняться от одного запуска программы к запуску. В примерах нас больше будет интересовать относительное размещение объектов. В качестве целевой архитектуры взята
&lt;code&gt;x86&lt;/code&gt;
. Для удобства восприятия многие данные переведены из родной шестнадцатеричной формы в десятичную (за исключением адресов, они начинаются с префикса
&lt;code&gt;0x&lt;/code&gt;
). Данная статья не претендует на фундаментальное описание внутреннего представления массивов, скорее это просто краткий обзор организации различных массивов на низком уровне. В качестве реализации платформы рассматривается стандартная MS.NET, Mono обсуждать не будем.&lt;/p&gt;
&lt;h3 id=&quot;single-array&quot;&gt;Single array&lt;/h3&gt;
&lt;p&gt;Такие массивы часто называются также &lt;em&gt;SZ-массивами&lt;/em&gt; (single-dimensional, zero-based) или &lt;em&gt;векторами&lt;/em&gt;. Создадим обычный &lt;code&gt;int[]&lt;/code&gt;-массив (каждый элемент занимает 4 байта) длинной 5 элементов, который заполним числами от 0 до 4:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int[] a = new int[5];
for (int i = 0; i &amp;lt; 5; i++)
    a[i] = i;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В памяти он будет представлен следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x03022424           0  // SyncBlockIndex
0x03022428  0x61B9C448  // *MethodTable
0x0302242C           5  // a.Length
0x03022430           0  // a[0]
0x03022434           1  // a[1]
0x03022438           2  // a[2]
0x0302243C           3  // a[3]
0x03022440           4  // a[4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Воспользуемся расширением отладчика &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb190764.aspx&quot;&gt;SOS&lt;/a&gt; и через Immediate Window посмотрим чуть больше информации о нашем массиве:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.load sos.dll
!DumpArray 0x03022428
Name:        System.Int32[]
MethodTable: 61b9c448
EEClass:     6180c0d0
Size:        32(0x20) bytes
Array:       Rank 1, Number of elements 5, Type Int32
Element Methodtable: 61b9c480
[0] 03022430
[1] 03022434
[2] 03022438
[3] 0302243c
[4] 03022440
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут всё достаточно просто. Переменная &lt;code&gt;a&lt;/code&gt; указывает на адрес &lt;code&gt;0x03022428&lt;/code&gt;, по которому хранится указатель на таблицу методов соответствующего типа (в данном случае
&lt;code&gt;System.Int32[]&lt;/code&gt;), которая занимает 4 байта (для &lt;code&gt;x64&lt;/code&gt; — 8 байт). Перед ней находится SyncBlockIndex (отсчитывается от 1, 0 означает пустое значение; размер под
&lt;code&gt;x86&lt;/code&gt; — 4 байта, под &lt;code&gt;x64&lt;/code&gt; — 8 байт). После &lt;code&gt;*MethodTable&lt;/code&gt; идёт сначала размер массива, а затем по порядку все его элементы.&lt;/p&gt;
&lt;p&gt;Для операций с SZ-массивами предусмотрены следующие IL-команды:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;newarr &amp;lt;etype&amp;gt;&lt;/code&gt; : создание нового массива с элементами типа etype&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldelem &amp;lt;typeTok&amp;gt;&lt;/code&gt;: добавить значение элемента по заданному индексу в стек&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldelema &amp;lt;class&amp;gt;&lt;/code&gt;: добавить адрес элемента по заданному индексу в стек&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldlen&lt;/code&gt;: добавить длину массива в стек&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stelem &amp;lt;typeTok&amp;gt;&lt;/code&gt;: заменить значение элемента по заданному индексу значением из стека&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Обращение к элементу на уровне ассемблера имеет примерно следующий вид: &lt;code&gt;[ebx+ecx*4+8]&lt;/code&gt;. Здесь &lt;code&gt;ebx&lt;/code&gt; обозначает базовый адрес массива, &lt;code&gt;ecx&lt;/code&gt; — индекс элемента (он умножается на 4, т.к. Int32 занимает в памяти 4 байта), &lt;code&gt;8&lt;/code&gt; — смещение для нулевого элемента (пропускаем MethodTable и количество элементов массива, т.е. два значения по 4 байта).&lt;/p&gt;
&lt;h3 id=&quot;rectangular-array&quot;&gt;Rectangular array&lt;/h3&gt;
&lt;p&gt;Создадим двумерный массив&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int[,] a = new int[2, 3];
for (int i = 0; i &amp;lt; 2; i++)
    for (int j = 0; j &amp;lt; 3; j++)
        a[i, j] = i * 3 + j;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и по аналогии взглянем на дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x03022444           0  // SyncBlockIndex
0x03022448  0x61B5E938  // *MethodTable
0x0302244C           6  // a.Length
0x03022450           2  // a.GetLength(0)
0x03022454           3  // a.GetLength(1)
0x03022458           0  // a.GetLowerBound(0)
0x0302245C           0  // a.GetLowerBound(1)
0x03022460           0  // a[0, 0]
0x03022464           1  // a[0, 1]
0x03022468           2  // a[0, 2]
0x0302246C           3  // a[1, 0]
0x03022470           4  // a[1, 1]
0x03022474           5  // a[1, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x03022448
Name:        System.Int32[,]
MethodTable: 61b5e938
EEClass:     617fd0c4
Size:        52(0x34) bytes
Array:       Rank 2, Number of elements 6, Type Int32
Element Methodtable: 61b9c480
[0][0] 03022460
[0][1] 03022464
[0][2] 03022468
[1][0] 0302246c
[1][1] 03022470
[1][2] 03022474
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Структура немного усложнилась. Сперва (как и в первом случае), идут &lt;code&gt;SyncBlockIndex&lt;/code&gt; и &lt;code&gt;*MethodTable&lt;/code&gt; (&lt;code&gt;a&lt;/code&gt; указывает именно на *MethodTable, т.е. на &lt;code&gt;0x03022448&lt;/code&gt;). Далее точно также идёт длина массива, т.е. общее количество элементов, которые в нём содержатся. А после этого идут отличительные данные для rectangular-массива: длины по каждому измерению и нижние границы (их мы подробнее обсудим чуть позже, по умолчанию они равны нулю). Количество измерений массива (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.rank.aspx&quot;&gt;a.Rank&lt;/a&gt;) можно узнать из типа (&lt;code&gt;System.Int32[,]&lt;/code&gt;). Далее идут непосредственно сами элементы.&lt;/p&gt;
&lt;p&gt;Для работы с элементами rectangular-массива на IL-уровне нет специальных команд, приходится вызывать методы &lt;code&gt;Get&lt;/code&gt; и &lt;code&gt;Set&lt;/code&gt;. На уровне ассемблера для двумерного массива мы будем иметь инструкцию вида &lt;code&gt;[ebx+ecx*4+18h]&lt;/code&gt;. &lt;code&gt;ebx&lt;/code&gt; — базовый адрес массива, &lt;code&gt;ecx&lt;/code&gt; — номер элемента (который высчитывается на основе индексов i, j), &lt;code&gt;18h&lt;/code&gt;
— смещение (больше, чем в &lt;code&gt;single&lt;/code&gt;-версии, т.к. теперь нам нужно пропустить больше служебных значений: &lt;code&gt;18h=24=6*4&lt;/code&gt; — &lt;code&gt;TypeHandle&lt;/code&gt;, &lt;code&gt;a.Length&lt;/code&gt;, &lt;code&gt;a.GetLength(0)&lt;/code&gt;, &lt;code&gt;a.GetLength(1)&lt;/code&gt;, &lt;code&gt;a.GetLowerBound(0)&lt;/code&gt;, &lt;code&gt;a.GetLowerBound(1))&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;jagged-array&quot;&gt;Jagged array&lt;/h3&gt;
&lt;p&gt;Создадим двумерный изломанный массив&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;int[][] a = new int[2][];
for (int i = 0; i &amp;lt; 2; i++)
{
    a[i] = new int[3];
    for (int j = 0; j &amp;lt; 3; j++)
        a[i][j] = i * 3 + j;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и по аналогии взглянем на дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x03022478           0  // SyncBlockIndex (a)
0x0302247C  0x61B8D5BC  // *MethodTable (a)
0x03022480           2  // a.Length
0x03022484  0x617A4C8A  // *TypeDesc (int[])
0x03022488  0x03022494  // a[0]
0x0302248C  0x030224AC  // a[1]
0x03022490           0  // SyncBlockIndex (a[0])
0x03022494  0x61B9C448  // *MethodTable (a[0])
0x03022498           3  // a[0].Length
0x0302249C           0  // a[0][0]
0x030224A0           1  // a[0][1]
0x030224A4           2  // a[0][2]
0x030224A8           0  // SyncBlockIndex (a[1])
0x030224AC  0x61B9C448  // *MethodTable (a[1])
0x030224B0           3  // a[1].Length
0x030224B4           3  // a[1][0]
0x030224B8           4  // a[1][1]
0x030224BC           5  // a[1][2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x0302247C
Name:        System.Int32[]
MethodTable: 61b8d5bc
EEClass:     618ab450
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 2, Type SZARRAY
Element Methodtable: 617a4c8a
[0] 03022494
[1] 030224ac

!DumpObj 0x0302247C
Name:        System.Int32[][]
MethodTable: 61b8d5bc
EEClass:     618ab450
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 2, Type SZARRAY
Fields:
None

!DumpArray 0x03022494
Name:        System.Int32[]
MethodTable: 61b9c448
EEClass:     6180c0d0
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 3, Type Int32
Element Methodtable: 61b9c480
[0] 0302249c
[1] 030224a0
[2] 030224a4

!DumpArray 0x030224AC
Name:        System.Int32[]
MethodTable: 61b9c448
EEClass:     6180c0d0
Size:        24(0x18) bytes
Array:       Rank 1, Number of elements 3, Type Int32
Element Methodtable: 61b9c480
[0] 030224b4
[1] 030224b8
[2] 030224bc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;По сути &lt;code&gt;int[][]&lt;/code&gt; представляет собой массив массивов. Т.е. это одномерный массив, элементами которого являются ссылки на другие массивы. Команда &lt;code&gt;DumpArray&lt;/code&gt;
не может нормально восстановить тип объекта, для этой цели необходимо пользоваться командой &lt;code&gt;DumpObj&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Методы по работе с jagged-массивом на IL и ASM уровнях аналогичны single-массиву с той лишь разницей, что теперь нам необходимо перейти к нужному элементу одномерного массива не один раз, а несколько (в зависимости от количества размерностей). По адресу &lt;code&gt;0x03022484&lt;/code&gt; находится указатель на TypeDesc для &lt;code&gt;int[]&lt;/code&gt; (&lt;a href=&quot;http://aakinshin.blogspot.ru/2013/09/dotnet-typehandle.html&quot;&gt;тут&lt;/a&gt; можно почитать подробнее).&lt;/p&gt;
&lt;h3 id=&quot;non-zero-based-single-array&quot;&gt;Non-zero based single array&lt;/h3&gt;
&lt;p&gt;Явно объявить одномерный массив с ненулевой нижней границей нельзя, для этого нам понадобится метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.createinstance.aspx&quot;&gt;Array.CreateInstance&lt;/a&gt;, в который передаётся тип элементов, массив длин и массив нижних границ. Создадим элемент из 5-ти элементов с нижней границей 2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Array a = Array.CreateInstance(typeof(int), new[] { 5 }, new[] { 2 });
for (int i = 2; i &amp;lt; 7; i++)
    a.SetValue(i, i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Взглянем на соответствующий дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x030224FC           0  // SyncBlockIndex
0x03022500  1639311728  // *MethodTable
0x03022504           5  // a.Length
0x03022508           5  // a.GetLength(0)
0x0302250C           2  // a.GetLowerBound(0)
0x03022510           2  // a[2]
0x03022514           3  // a[3]
0x03022518           4  // a[4]
0x0302251C           5  // a[5]
0x03022520           6  // a[6]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x03022500
Name:        System.Int32[]
MethodTable: 61b5e970
EEClass:     617fd110
Size:        40(0x28) bytes
Array:       Rank 1, Number of elements 5, Type Int32
Element Methodtable: 61b9c480
[0] 03022508
[1] 0302250c
[2] 03022510
[3] 03022514
[4] 03022518
[5] 0302251c
[6] 03022520

!DumpObj 0x03022500
Name:        System.Int32[*]
MethodTable: 61b5e970
EEClass:     617fd110
Size:        40(0x28) bytes
Array:       Rank 1, Number of elements 5, Type Int32
Fields:
None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тип данного объекта: &lt;code&gt;System.Int32[*]&lt;/code&gt;. Знак &lt;code&gt;*&lt;/code&gt; означает, что CLR знает о ненулевой нижней границе. Синтаксис C# не позволяет явно объявить переменную такого типа, также запрещается явное обращение к его элементам посредствам стандартного синтаксиса, поэтому приходится пользоваться методами &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.getvalue.aspx&quot;&gt;GetValue&lt;/a&gt; и &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.array.setvalue.aspx&quot;&gt;SetValue&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Обратите внимание, что команда &lt;code&gt;DumpArray&lt;/code&gt; не умеет корректно отображать тип одномерного массива с ненулевой нижней границей. Правильный тип можно получить, используя команду &lt;code&gt;DumpObj&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Что касается структуры массива в памяти, то она полностью аналогична структуре rectangular-массива. Для доступа к элементам массива специальных IL-команд не предусмотрено, приходится вновь явно вызывать методы.&lt;/p&gt;
&lt;h3 id=&quot;non-zero-based-rectangular-array&quot;&gt;Non-zero based rectangular array&lt;/h3&gt;
&lt;p&gt;А теперь создадим двумерный массив 2 на 3 с нижними границами 4 и 5. Поможет нам в этом уже знакомый метод &lt;code&gt;Array.CreateInstance&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;Array a = Array.CreateInstance(typeof(int), new[] { 2, 3 }, new[] { 4, 5 });
for (int i = 4; i &amp;lt; 6; i++)
    for (int j = 5; j &amp;lt; 8; j++)
        a.SetValue(i * 3 + j - 17, i, j);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x03022588           0  // SyncBlockIndex
0x0302258C  1639311672  // *MethodTable
0x03022590           6  // a.Length
0x03022594           2  // a.GetLength(0)
0x03022598           3  // a.GetLength(1)
0x0302259C           4  // a.GetLowerBound(0)
0x030225A0           5  // a.GetLowerBound(1)
0x030225A4           0  // a[4, 5]
0x030225A8           1  // a[4, 6]
0x030225AC           2  // a[4, 7]
0x030225B0           3  // a[5, 5]
0x030225B4           4  // a[5, 6]
0x030225B8           5  // a[5, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;!DumpArray 0x0302258C
Name:        System.Int32[,]
MethodTable: 61b5e938
EEClass:     617fd0c4
Size:        52(0x34) bytes
Array:       Rank 2, Number of elements 6, Type Int32
Element Methodtable: 61b9c480
[4][5] 030225a4
[4][6] 030225a8
[4][7] 030225ac
[5][5] 030225b0
[5][6] 030225b4
[5][7] 030225b8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Заметим, что для rectangular-массивов с ненулевой нижней границей команда &lt;code&gt;DumpArray&lt;/code&gt; прекрасно работает. Несложно понять, что структура хранения и организации rectangular-массива не зависит от нижней границы: представление в памяти всегда будет одинаковое, тип всегда будет &lt;code&gt;System.Int32[,]&lt;/code&gt;, IL и ASM инструкции будут аналогичны.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Общее устройство массива выглядит следующим образом:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SyncBlockIndex&lt;/code&gt; (по отрицательному смещению)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*MethodTable&lt;/code&gt; (по нулевому смещению)&lt;/li&gt;
&lt;li&gt;Общая длина массива&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*TypeDesc&lt;/code&gt; для элементов массива (только для массивов из элементов ссылочного типа; &lt;code&gt;int[][]&lt;/code&gt; является частным случаем, т.к. это массив из &lt;code&gt;int[]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Длины по каждому измерению массива (только для одномерных массивов с заданной нижней границей и многомерных массивов)&lt;/li&gt;
&lt;li&gt;Нижние индексы по каждому измерению массива (только для одномерных массивов с заданной нижней границей и многомерных массивов)&lt;/li&gt;
&lt;li&gt;Элементы массива&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Учимся округлять в C#</title>
            <link>http://aakinshin.net/ru/posts/cheatsheet-rounding/</link> 
            <pubDate>Wed, 18 Sep 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/cheatsheet-rounding/</guid>
            <description>&lt;p&gt;А знаете ли вы, что &lt;code&gt;Math.Round(1.5) == Math.Round(2.5) == 2&lt;/code&gt;? Можете ли сходу сказать, сколько будет &lt;code&gt;-7%3&lt;/code&gt; и &lt;code&gt;7%-3&lt;/code&gt;? Помните ли, чем отличаются
&lt;code&gt;Math.Round&lt;/code&gt;, &lt;code&gt;Math.Floor&lt;/code&gt;, &lt;code&gt;Math.Ceiling&lt;/code&gt;, &lt;code&gt;Math.Truncate&lt;/code&gt;? А как происходит округление при использовании &lt;code&gt;string.Format&lt;/code&gt;? Давайте немного погрузимся в мир округлений и разберёмся с нюансами, которые не для всех могут быть очевидными.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;math.round&quot;&gt;Math.Round&lt;/h3&gt;
&lt;p&gt;MSDN:
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.round.aspx&quot;&gt;Round&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static decimal Round(decimal value)
public static double Round(double value)
public static decimal Round(decimal value, int digits)
public static double Round(double value, int digits)
public static decimal Round(decimal value, MidpointRounding mode)
public static double Round(double value, MidpointRounding mode)
public static decimal Round(decimal value, int digits, MidpointRounding mode)
public static double Round(double value, int digits, MidpointRounding mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Math.Round&lt;/code&gt; — это метод округления к ближайшему числу или к ближайшему числу с заданным количеством знаков после запятой. Работает с типами &lt;code&gt;decimal&lt;/code&gt; и &lt;code&gt;double&lt;/code&gt;, в параметрах можно встретить три вида параметров:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value&lt;/code&gt;: округляемое число&lt;/li&gt;
&lt;li&gt;&lt;code&gt;digits&lt;/code&gt;: количество знаков в дробной части, которые нужно оставить&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mode&lt;/code&gt;: параметр, который определяет в какую сторону округлять число, которое находится ровно посередине между двумя вариантами&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Параметр &lt;code&gt;mode&lt;/code&gt; используется, когда округляемое значение находится ровно посередине между двумя вариантами. Принимает значение из следующего перечисления:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public enum MidpointRounding { AwayFromZero, ToEven}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;AwayFromZero&lt;/code&gt;: округление происходит к тому числу, которое дальше от нуля.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ToEven&lt;/code&gt;: округление происходит к чётному числу.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Обратите внимание, что по умолчанию &lt;code&gt;mode == MidpointRounding.ToEven&lt;/code&gt;, поэтому &lt;code&gt;Math.Round(1.5) == Math.Round(2.5) == 2&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;math.floor-math.ceiling-math.truncate&quot;&gt;Math.Floor, Math.Ceiling, Math.Truncate&lt;/h3&gt;
&lt;p&gt;MSDN:
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.floor.aspx&quot;&gt;Floor&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.ceiling.aspx&quot;&gt;Ceiling&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.math.truncate.aspx&quot;&gt;Truncate&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public static decimal Floor(decimal value)
public static double Floor(double value)
public static decimal Ceiling(decimal value)
public static double Ceiling(double value)
public static decimal Truncate(decimal value)
public static double Truncate(double value)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Math.Floor&lt;/code&gt; округляет вниз по направлению к отрицательной бесконечности.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Math.Ceiling&lt;/code&gt; округляет вверх по направлению к положительной бесконечности.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Math.Truncate&lt;/code&gt; округляет вниз или вверх по направлению к нулю.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section&quot;&gt;Сводная таблица&lt;/h3&gt;
&lt;p&gt;Сориентироваться в методах округления может помочь следующая табличка:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value               | -2.9 | -0.5 | 0.3 | 1.5 | 2.9 |
--------------------+------+------+-----+-----+-----+
Round(ToEven)       |   -3 |    0 |   0 |   2 |   3 |
Round(AwayFromZero) |   -3 |   -1 |   0 |   2 |   3 |
Floor               |   -3 |   -1 |   0 |   1 |   2 |
Ceiling             |   -2 |    0 |   1 |   2 |   3 |
Truncate            |   -2 |    0 |   0 |   1 |   2 |
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Округление проводится в соответствии со стандартом &lt;em&gt;IEEE Standard 754, section 4&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Целочисленное деление и взятие по модулю&lt;/h3&gt;
&lt;p&gt;В C# есть два замечательных оператора над целыми числами: &lt;code&gt;/&lt;/code&gt; для целочисленного деления (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/3b1ff23f.aspx&quot;&gt;MSDN&lt;/a&gt;) и &lt;code&gt;%&lt;/code&gt;
для взятия остатка от деления (&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/0w4e0fzs.aspx&quot;&gt;MSDN&lt;/a&gt;). Деление производится по следующим правилам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;При целочисленном делении результат всегда округляется по направлению к нулю.&lt;/li&gt;
&lt;li&gt;При взятии остатка от деления должно выполняться следующее правило: &lt;code&gt;x % y = x – (x / y) * y&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также можно пользоваться шпаргалкой:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; a |  b | a/b | a%b |
---+----+-----+-----+
 7 |  3 |  2  |  1  |
-7 |  3 | -2  | -1  |
 7 | -3 | -2  |  1  |
-7 | -3 |  2  | -1  |
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;string.format&quot;&gt;string.Format&lt;/h3&gt;
&lt;p&gt;При форматировании чисел в виде строки можно пользоваться функцией &lt;code&gt;string.Format&lt;/code&gt; (см. &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dwhawy9k.aspx&quot;&gt;Standard Numeric Format Strings&lt;/a&gt;, &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/0c899ak8.aspx&quot;&gt;Custom Numeric Format Strings&lt;/a&gt;). Например, для вывода числа с двумя знаками после десятичной точки можно воспользоваться &lt;code&gt;string.Format(&amp;quot;{0:0.00}&amp;quot;, value)&lt;/code&gt; или &lt;code&gt;string.Format(&amp;quot;{0:N2}&amp;quot;, value)&lt;/code&gt;. Округление происходит по принципу &lt;code&gt;AwayFromZero&lt;/code&gt;. Проиллюстрируем правила округления очередной табличкой:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;value  | string.Format(&amp;quot;{0:N2}&amp;quot;, value) |
-------+--------------------------------+
-2.006 | -2.01                          |
-2.005 | -2.01                          |
-2.004 | -2.00                          |
 2.004 |  2.00                          |
 2.005 |  2.01                          |
 2.006 |  2.01                          |
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Задачи&lt;/h3&gt;
&lt;p&gt;На приведённую тему есть две задачки в &lt;a href=&quot;http://problembook.net&quot;&gt;ProblemBook.NET&lt;/a&gt;: &lt;a href=&quot;http://problembook.net/content/ru/Math/Rounding1-P.html&quot;&gt;Rounding1&lt;/a&gt;, &lt;a href=&quot;http://problembook.net/content/ru/Math/Rounding2-P.html&quot;&gt;Rounding2&lt;/a&gt;.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Вся правда о TypeHandle в .NET</title>
            <link>http://aakinshin.net/ru/posts/typehandle/</link> 
            <pubDate>Sat, 14 Sep 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/typehandle/</guid>
            <description>&lt;p&gt;В разных умных книжках и статьях про .NET я часто наталкивался на упоминания про TypeHandle. Чаще всего пишут, что у каждого .NET-объекта в заголовке находится некоторый TypeHandle, который представляет собой ссылку на тип. Ещё пишут, что TypeHandle — это всегда указатель на таблицу методов типа. А в некоторых местах мне доводилось встречать информацию о том, что TypeHandle указывает на некий TypeDesc. В общем, я устал от неразберихи: давайте вместе разберёмся что к чему. А для этого нам придётся немного подизассемблировать, поизучать дампы памяти и залезть в исходники CLI.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Что нам понадобится?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Нам нужна будет Visual Studio. А в ней нам понадобится консольное приложение, над которым мы будем ставить наши эксперименты. Для чистоты эксперимента не забываем поставить сборку проекта в &lt;code&gt;Release mode&lt;/code&gt;, а для честного дебага уберём галочку Suppress JIT optimization on module load (&lt;code&gt;Tools&lt;/code&gt; -&amp;gt; &lt;code&gt;Options&lt;/code&gt; -&amp;gt; &lt;code&gt;Debugging&lt;/code&gt; -&amp;gt; &lt;code&gt;General&lt;/code&gt;). В свойствах проекта на вкладке &lt;code&gt;Debug&lt;/code&gt; нужно включить опцию &lt;code&gt;Enable native code debugging&lt;/code&gt;. Для простоты примера будем собирать наш проект под &lt;code&gt;x86&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Расширение отладки &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/bb190764.aspx&quot;&gt;SOS&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.microsoft.com/en-us/download/details.aspx?id=4917&quot;&gt;Shared Source Common Language Infrastructure 2.0&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Пример 1&lt;/h3&gt;
&lt;p&gt;Начнём с совсем простого примера:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;object a = new object();
Console.WriteLine(a);
Console.ReadLine();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Последние пара строчек нужна затем, чтобы можно было нормально подебажить (в дальнейшем я их приводить не буду). Давайте поставим точку останова на второй строчке и запустим наше приложение из студии (через &lt;code&gt;F5&lt;/code&gt;). Для удобной отладки нам понадобится несколько окошек: &lt;code&gt;Disassembly&lt;/code&gt;, &lt;code&gt;Registers&lt;/code&gt;, &lt;code&gt;Memory&lt;/code&gt; (их можно найти в &lt;code&gt;Debug&lt;/code&gt; -&amp;gt; &lt;code&gt;Windows&lt;/code&gt;).&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/typehandle/screen.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Наш объект только что создался, а его адрес вернулся нам через регистр &lt;code&gt;eax&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;;       object a = new object();
00000000  push        ebp 
00000001  mov         ebp,esp 
00000003  push        esi 
00000004  mov         ecx,65C4B060h 
00000009  call        FE6BF7A0      ; адрес нового объекта записывается в eax
0000000e  mov         esi,eax 
;       Console.WriteLine(a);
00000010  call        63ECA5E4 
;       ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В окне &lt;code&gt;Registers&lt;/code&gt; находим значение eax (у вас адреса будут другие)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EAX = 01ED1598 EBX = 0543EA64 
ECX = 65C4B060 EDX = 005495E8 
ESI = 01ED1598 EDI = 0543E9D0 
EIP = 01CF2970 ESP = 0543E9B0 
EBP = 0543E9B4 EFL = 00000212 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и копируем его в поле Address окна Memory:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x01ED1594  00000000  
0x01ED1598  65c4b060  
0x01ED159C  00000000  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Заметьте, что я привёл дамп памяти размером 12 байт — именно столько занимает сейчас наш объект. Разберёмся более подробно: в заголовке каждого объекта всегда присутствует два поля: &lt;code&gt;SyncBlockIndex&lt;/code&gt; (который размещается непосредственно перед объектом, т.е. обладает отрицательным смещением) и то, что мы пока назовём &#171;ссылкой на тип&#187;. Под архитектуру &lt;code&gt;x86&lt;/code&gt; каждое из этих полей занимает 4 байта. Но особенности работы GC требуют, чтобы минимальный размер объекта был 12 байт. Поэтому CLR аккуратненько дополняет объект 4 байтами до нужного размера. Давайте посмотрим на наш объект с помощью SOS. Откроем Immediate Window (для каждой дебаг-сессии необходимо включить SOS с помощью команды &lt;code&gt;.load sos.dll&lt;/code&gt;) и воспользуемся командой &lt;code&gt;!DumpObj&lt;/code&gt;, которой отдадим адрес нашего объекта:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.load sos.dll
!DumpObj 0x01ED1598
Name:        System.Object
MethodTable: 65c4b060
EEClass:     65854920
Size:        12(0xc) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
Object
Fields:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ага, теперь понятно: значение &lt;code&gt;0x65c4b060&lt;/code&gt; — это адрес таблицы методов (MethodTable) для нашего объекта. Давайте проверим эту гипотезу: воспользуемся командой
&lt;code&gt;!DumpMT&lt;/code&gt; для просмотра таблицы методов (если вы запустите эту команду с ключом &lt;code&gt;-MD&lt;/code&gt;
, то кроме заголовочной информации увидите ещё и все методы):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!DumpMT 65c4b060
EEClass:         65854920
Module:          65851000
Name:            System.Object
mdToken:         02000002
File:            C:\WINDOWS\Microsoft.Net\assembly\GAC_32\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
BaseSize:        0xc
ComponentSize:   0x0
Slots in VTable: 12
Number of IFaces in IFaceMap: 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Казалось бы всё понятно: в начале каждого объекта хранится ссылка на MethodTable — так CLR узнаёт к какому типу относится объект. Но не будем делать выводы по одному примеру: давайте взглянем на исходники CLI. В этом нам поможет &lt;a href=&quot;http://en.wikipedia.org/wiki/Shared_Source_Common_Language_Infrastructure&quot;&gt;SSCLI&lt;/a&gt; (в узких кругах известная как Rotor) — это открытые исходники реализации CLI от Microsoft. Увы, последняя версия SSCLI 2.0 датируется 2006-ым годом и относится к .NET Framework 2.0. Понадеемся, что базовые принципы хранения объектов в памяти не сильно поменялись за последнее время. Если открыть файл &lt;code&gt;sscli20\clr\src\vm\object.h&lt;/code&gt;, то ближе к началу можно найти такие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Object
{
  protected:
    MethodTable*    m_pMethTab;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, вроде всё верно: в объекте действительно хранится указатель на MethodTable. Такое заключение вы можете встретить во многих статьях и книжках. Только вот некоторые называют его просто указателем на MethodTable, а некоторые — TypeHandle. Как считаете, правильно ли это? Давайте разбираться дальше.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Пример 2&lt;/h3&gt;
&lt;p&gt;А теперь перейдём к устройству массива:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var a = new object[1];
a[0] = new object();  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Точно также перейдём в дебаггер, найдём адрес массива через регистры и посмотрим дамп памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;0x02F9240C  00000000  // SyncBlockIndex (a)
0x02F92410  65bfab98  // System.Object[] MethodTable (a)
0x02F92414  00000001  // a.Length
0x02F92418  65c4b060  // (???) Type of elements in a
0x02F9241C  02f92424  // &amp;amp;a[0]
0x02F92420  00000000  // SyncBlockIndex (a[0])
0x02F92424  65c4b060  // System.Object MethodTable (a[0])
0x02F92428  00000000  // Free space (a[0])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После ссылки на таблицу методов для массива &lt;code&gt;a&lt;/code&gt; идёт количество элементов в массиве (1), а затем — &#171;ссылка на тип&#187; элементов массива. Обратите внимание, я ещё ничего не утверждаю об этих данных в общем случае. Просто имеется известный факт о том, что у массивов, элементы которых являются ссылочным типом, имеются дополнительные данные, которые некоторым образом характеризуют тип элементов массива. После всех этих служебных данных находится содержание массива — единственный элемент, хранящий адрес созданного &lt;code&gt;object&lt;/code&gt;. Легко видеть, что поле&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x02F92418  65c4b060 // System.Object[] MethodTable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;указывает на таблицу методов для &lt;code&gt;System.Object&lt;/code&gt;. Ну, вроде бы всё понятно: в массивах, элементы которого являются ссылочным типом, появляется дополнительное поле, которое указывает на MethodTable типа элементов. Но так ли это? Продолжим наше исследование.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Пример 3&lt;/h3&gt;
&lt;p&gt;А теперь создадим jagged-массив:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var a = new object[1][];
a[0] = new object[1];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратимся к дампу памяти:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x0301240C  00000000  // SyncBlockIndex (a)
0x03012410  011731d4  // System.Object[][] MethodTable (a)
0x03012414  00000001  // a.Length
0x03012418  65854d7a  // (???) Type of elements in a
0x0301241C  03012424  // &amp;amp;a[0]
0x03012420  00000000  // SyncBlockIndex (a[0])
0x03012424  65bfab98  // System.Object[] MethodTable
0x03012428  00000001  // a[0].Length
0x0301242C  65c4b060  // Type of elements in a[0] = System.Object MethodTable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В этом дампе можно увидеть нечто странное: поле, которое должно определять тип элементов массива &lt;code&gt;a&lt;/code&gt; (по адресу &lt;code&gt;0x03012418&lt;/code&gt;) не ведёт на &lt;code&gt;System.Object[]&lt;/code&gt;
MethodTable — ведь адрес этой таблицы можно найти по адресу (&lt;code&gt;0x03012424&lt;/code&gt;) при описании MethodTable для &lt;code&gt;a[0]&lt;/code&gt; — и они различаются. Давайте убедимся, что значение
&lt;code&gt;0x65854d7a&lt;/code&gt; не определяет MethodTable:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;!DumpMT 65854d7a
65854d7a is not a MethodTable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Хм... Но что же это тогда такое? Давайте обратимся к исходникам CLI за объяснением. В фале &lt;code&gt;sscli20\clr\src\vm\object.h&lt;/code&gt; также можно найти следующий код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// ArrayBase encapuslates all of these details.  In theory you should never
// have to peek inside this abstraction
class ArrayBase : public Object
{
    ...
    // This MUST be the first field, so that it directly follows Object.  This is because
    // Object::GetSize() looks at m_NumComponents even though it may not be an array (the
    // values is shifted out if not an array, so it&#39;s ok). 
    DWORD       m_NumComponents;
    ...
    // What comes after this conceputally is:
    // TypeHandle elementType;        Only present if the method table is shared among many types (arrays of pointers)
    // INT32      bounds[rank];       The bounds are only present for Multidimensional arrays   
    // INT32      lowerBounds[rank];  Valid indexes are lowerBounds[i] &amp;lt;= index[i] &amp;lt; lowerBounds[i] + bounds[i]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы видим, что для массивов из элементов ссылочного типа (arrays of pointers) действительно появляется дополнительное поле, а тип его — TypeHandle. Но что же это такое? Перейдём к файлу &lt;code&gt;sscli20\clr\src\vm\typehandle.h&lt;/code&gt; . В самом начале файла к комментариях можно найти следующую полезную информацию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// A TypeHandle is the FUNDAMENTAL concept of type identity in the CLR.
// That is two types are equal if and only if their type handles
// are equal.  A TypeHandle, is a pointer sized struture that encodes 
// everything you need to know to figure out what kind of type you are
// actually dealing with.  

// At the present time a TypeHandle can point at two possible things
//
//      1) A MethodTable    (Intrinsics, Classes, Value Types and their instantiations)
//      2) A TypeDesc       (all other cases: arrays, byrefs, pointer types, function pointers, generic type variables)  
//
// or with IL stubs, a third thing:
//
//      3) A MethodTable for a native value type.
//
// MTs that satisfy IsSharedByReferenceArrayTypes are not 
// valid TypeHandles: for example no allocated object will
// ever return such a type handle from Object::GetTypeHandle(), and
// these type handles should not be passed across the JIT Interface
// as CORINFO_CLASS_HANDLEs.  However some code in the EE does create 
// temporary TypeHandles out of these MTs, so we can&#39;t yet assert 
// !IsSharedByReferenceArrayTypes() in the TypeHandle constructor.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ага, значит TypeHandle может быть как указателем на MethodTable, так и указателем на TypeDesc, в зависимости от типа объекта. Для массивов он указывает на TypeDesc. Тип &lt;code&gt;object[][]&lt;/code&gt; — это массив, элементами которого являются &lt;code&gt;object[]&lt;/code&gt;, для которых TypeHandle=TypeDesc. Эта информация объясняет наш пример, но всё ещё остаются некоторые вопросы. Например: а как же отличить, на что именно указывает TypeHandle? Поможет нам в этом дальнейшее изучение исходников CLI:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   FORCEINLINE BOOL IsUnsharedMT() const {
        LEAF_CONTRACT;
        STATIC_CONTRACT_SO_TOLERANT;
        return((m_asTAddr &amp;amp; 2) == 0);
    }

    FORCEINLINE BOOL IsTypeDesc() const  {
        WRAPPER_CONTRACT;
        return(!IsUnsharedMT());
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё зависит от второго бита в адресе: нулевое значение определяет MethodTable, а единичное — TypeDesc. Если мы работаем с шестнадцатеричными адресами, то можно легко определить вид TypeHandle по последней цифре:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MethodTable: 0, 1, 4, 5, 8, 9, C, D
TypeDesc   : 2, 3, 6, 7, A, B, E, F
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь взглянем ещё раз на дамп памяти нашего примера. Можно видеть, что для &lt;code&gt;System.Object[]&lt;/code&gt; в дампе присутствуют указатели как на его TypeDesc, так и на MethodTable. Не смотря на то, что под TypeHandle в данном случае подразумевается TypeDesc, заголовочный указатель для &lt;code&gt;a[0]&lt;/code&gt; всё-таки указывает на MethodTable. Поэтому некорректно говорить о том, что в заголовке каждого объекта хранится TypeHandle: там хранится указатель на MethodTable, а это далеко не всегда одно и то же.&lt;/p&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Пример 4&lt;/h3&gt;
&lt;p&gt;Последний пример проиллюстрирует недавно полученное правило про последнюю цифру адреса. Мы можем получить TypeHandle прямо из управляемого кода, а по этому значению мы можем определить, что именно под ним подразумевается:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private void Run()
{
    Print(typeof(int));
    Print(typeof(object));
    Print(typeof(Stream));
    Print(typeof(int[]));
    Print(typeof(int[][]));
    Print(typeof(object[]));
}

private void Print(Type type)
{
    bool isTypeDesc = ((int)type.TypeHandle.Value &amp;amp; 2) &amp;gt; 0;
    Console.WriteLine(&amp;quot;{0}: {1} =&amp;gt; {2}&amp;quot;, 
        type.Name.PadRight(10), 
        type.TypeHandle.Value.ToString(&amp;quot;X&amp;quot;), 
        (isTypeDesc ? &amp;quot;TypeDesc&amp;quot; : &amp;quot;MethodTable&amp;quot;));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У меня этот код выводит следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Int32     : 65C4C480 =&amp;gt; MethodTable
Object    : 65C4B060 =&amp;gt; MethodTable
Stream    : 65C4D954 =&amp;gt; MethodTable
Int32[]   : 65854C8A =&amp;gt; TypeDesc
Int32[][] : 658F6BD6 =&amp;gt; TypeDesc
Object[]  : 65854D7A =&amp;gt; TypeDesc
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-5&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;В ходе нашего маленького исследования были получены следующие выводы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TypeHandle является указателем либо на MethodTable, либо на TypeDesc (зависит от типа объекта)&lt;/li&gt;
&lt;li&gt;В заголовке каждого объекта для идентификации его типа всегда хранится указатель на MethodTable (это не всегда TypeHandle)&lt;/li&gt;
&lt;li&gt;Для массивов, чьи элементы должны представлять ссылочный тип, хранится дополнительное поле, которое представляет собой TypeHandle для типа элементов.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Сравнение производительности массивов в .NET</title>
            <link>http://aakinshin.net/ru/posts/arrays-access-performance/</link> 
            <pubDate>Sat, 31 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/arrays-access-performance/</guid>
            <description>&lt;h2 id=&quot;section&quot;&gt;Часть 1&lt;/h2&gt;
&lt;p&gt;Платформа .NET поддерживает два способа задания многомерных массивов: прямоугольные (rectangular) и изломанные (jagged). Второй способ по сути представляет собой массив массивов. Это обстоятельство создаёт у многих программистов иллюзию того, что jagged-массивы должны работать медленнее, т.к. обращение к их элементам реализуется через многократные переходы по ссылкам в управляемой куче. Но на самом деле jagged-массивы могут работают быстрее (если речь идёт непосредственно о работе с массивами, а не о их инициализации), ведь они представляют собой комбинацию одномерных (single) массивов, работа с которыми в CLR весьма оптимизирована (за счёт IL-команд &lt;code&gt;newarr&lt;/code&gt;, &lt;code&gt;ldelem&lt;/code&gt;, &lt;code&gt;ldelema&lt;/code&gt;, &lt;code&gt;ldlen&lt;/code&gt;, &lt;code&gt;stelem&lt;/code&gt;). Другим подходом к представлению многомерных данных является использование одномерного массива с ручным преобразованием координат (в массиве размерности N&lt;em&gt;M для обращения к элементу [i,j] будем писать [i&lt;/em&gt;M+j]). Если производительности не хватает, то можно использовать неуправляемый код, но этот случай мы сейчас рассматривать не будем, остановимся на трёх вышеозначенных способах. Для замеров времени используется
&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt;. Рассмотрим C# код, который замеряет время работы каждого варианта (полный вариант кода:
&lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs&quot;&gt;MultidimensionalArrayProgram.cs&lt;/a&gt;, тестировать следует в &lt;strong&gt;Release mode without debugging&lt;/strong&gt;). Данные результаты получены в сборке под x64 для процессора Intel Core i7-3632QM CPU 2.20GHz и параметров N=M=100, IterationCount=100000. Исследование вопроса о влиянии используемой архитектуры и параметров запуска на результат бенчмарка можно найти во второй части статьи.&lt;!--more--&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int N = 100, M = 100, IterationCount = 100000;
private int[] single;
private int[][] jagged;
private int[,] rectangular;

public void Run()
{
    var competition = new BenchmarkCompetition();

    competition.AddTask(&amp;quot;Single&amp;quot;,
        () =&amp;gt; single = new int[N * M],
        () =&amp;gt; SingleRun(single));

    competition.AddTask(&amp;quot;Jagged&amp;quot;,
        () =&amp;gt;
        {
            jagged = new int[N][];
            for (int i = 0; i &amp;lt; N; i++)
                jagged[i] = new int[M];
        },
        () =&amp;gt; JaggedRun(jagged));

    competition.AddTask(&amp;quot;Rectangular&amp;quot;,
        () =&amp;gt; rectangular = new int[N, M],
        () =&amp;gt; RectangularRun(rectangular));

    competition.Run();
}

private int SingleRun(int[] a)
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            for (int j = 0; j &amp;lt; M; j++)
                sum += a[i * M + j];
    return sum;
}

private int JaggedRun(int[][] a)
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            for (int j = 0; j &amp;lt; M; j++)
                sum += a[i][j];
    return sum;
}

private int RectangularRun(int[,] a)
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            for (int j = 0; j &amp;lt; M; j++)
                sum += a[i, j];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот пример на моём ноутбуке даёт следующие результаты (запускать следует в Release mode):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Single:      542ms
Jagged:      346ms
Rectangular: 755ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно видеть, доступ к элементам jagged-массива всегда осуществляется заметно быстрее, чем доступ к элементам rectangular-массива. Работа с single-массивом будет происходить быстрее, чем с rectangular, но чуть медленнее, чем с jagged. Мне думается, что single работает чуть медленнее jagged в большей степени из-за следующей причины:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;На расчёт индекса i*M+j требуется время, не дающее оптимизации в сравнении с лишним вызовом &lt;code&gt;ldelem.ref&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Чтобы лучше разобраться рассмотрим IL-код каждого из методов в release режиме (для упрощения чтения из каждого метода был убран цикл итераций по &lt;code&gt;iteration&lt;/code&gt;).&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;single.il&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method private hidebysig instance 
    int32 SingleAccessTest(int32[] a) cil managed
{
    .maxstack 4
    .locals init (
        [0] int32 sum,
        [1] int32 i,
        [2] int32 j)
    L_0000: ldc.i4.0     // Stack = [0]
    L_0001: stloc.0      // sum = 0, Stack = []
    L_0002: ldc.i4.0     // Stack = [0]
    L_0003: stloc.1      // i = 0, Stack = []
    L_0004: br.s L_0022  // GoTo L_0022
CY1 L_0006: ldc.i4.0     // Stack = [0]
    L_0007: stloc.2      // j = 0, Stack = []
    L_0008: br.s L_0019  // GoTo L_0019
CY2 L_000a: ldloc.0      // Stack = [sum]
    L_000b: ldarg.1      // Stack = [sum, a]
    L_000c: ldloc.1      // Stack = [sum, a, i]
    L_000d: ldc.i4.s 100 // Stack = [sum, a, i, 100]
    L_000f: mul          // Stack = [sum, a, i * 100]
    L_0010: ldloc.2      // Stack = [sum, a, i * 100, j]
    L_0011: add          // Stack = [sum, a, i * 100 + j]
    L_0012: ldelem.i4    // Stack = [sum, a[i * 100 + j]]
    L_0013: add          // Stack = [sum + a[i * 100 + j]]
    L_0014: stloc.0      // sum = sum + a[i * 100 + j], Stack = []
    L_0015: ldloc.2      // Stack = [j]
    L_0016: ldc.i4.1     // Stack = [j, 1]
    L_0017: add          // Stack = [j + 1]
    L_0018: stloc.2      // j = j + 1, Stack = []
CY2 L_0019: ldloc.2      // Stack = [j]
    L_001a: ldc.i4.s 100 // Stack = [j, 100]
    L_001c: blt.s L_000a // GoTo L_000a (if j &amp;lt; 100), Stack = []
    L_001e: ldloc.1      // Stack = [i]
    L_001f: ldc.i4.1     // Stack = [i, 1]
    L_0020: add          // Stack = [i + 1]
    L_0021: stloc.1      // i = i + 1, Stack = []
CY1 L_0022: ldloc.1      // Stack = [i]
    L_0023: ldc.i4.s 100 // Stack = [i, 100]
    L_0025: blt.s L_0006 // GoTo L_0006 (if i &amp;lt; 100), Stack = []
    L_0027: ldloc.0      // Stack = [sum]
    L_0028: ret          // return sum, Stack = []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;jagged.il&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method private hidebysig instance 
    int32 JaggedAccessTest(int32[][] a) cil managed
{
    .maxstack 3
    .locals init (
        [0] int32 sum,
        [1] int32 i,
        [2] int32 j)
    L_0000: ldc.i4.0     // Stack = [0]
    L_0001: stloc.0      // sum = 0, Stack = []
    L_0002: ldc.i4.0     // Stack = [0]
    L_0003: stloc.1      // i = 0, Stack = []
    L_0004: br.s L_001f  // GoTo L_001f
CY1 L_0006: ldc.i4.0     // Stack = [0]
    L_0007: stloc.2      // j = 0, Stack = []
    L_0008: br.s L_0016  // Stack = []
CY2 L_000a: ldloc.0      // Stack = [sum]
    L_000b: ldarg.1      // Stack = [sum, a]
    L_000c: ldloc.1      // Stack = [sum, a, i]
    L_000d: ldelem.ref   // Stack = [sum, a[i]]
    L_000e: ldloc.2      // Stack = [sum, a[i], j]
    L_000f: ldelem.i4    // Stack = [sum, a[i][j]]
    L_0010: add          // Stack = [sum + a[i][j]]
    L_0011: stloc.0      // sum = sum + a[i][j], Stack = []
    L_0012: ldloc.2      // Stack = [j]
    L_0013: ldc.i4.1     // Stack = [j + 1]
    L_0014: add          // Stack = [j + 1]
    L_0015: stloc.2      // j = j + 1, Stack = []
CY2 L_0016: ldloc.2      // Stack = [j]
    L_0017: ldc.i4.s 100 // Stack = [j, 100]
    L_0019: blt.s L_000a // GoTo L_000a (if j &amp;lt; 100)
    L_001b: ldloc.1      // Stack = [i]
    L_001c: ldc.i4.1     // Stack = [i, 1]
    L_001d: add          // Stack = [i + 1]
    L_001e: stloc.1      // i = i + 1, Stack = []
CY1 L_001f: ldloc.1      // Stack = [i]
    L_0020: ldc.i4.s 100 // Stack = [i, 100]
    L_0022: blt.s L_0006 // GoTo L_0006 (if i &amp;lt; 100)
    L_0024: ldloc.0      // Stack = [sum]
    L_0025: ret          // return sum, Stack = []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;rectangular.il&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method private hidebysig instance 
    int32 RectangularAccessTest(int32[0...,0...] a) cil managed
{
    .maxstack 4
    .locals init (
        [0] int32 sum,
        [1] int32 i,
        [2] int32 j)
    L_0000: ldc.i4.0     // Stack = [0]
    L_0001: stloc.0      // sum = 0, Stack = []
    L_0002: ldc.i4.0     // Stack = [0]
    L_0003: stloc.1      // i = 0, Stack = []
    L_0004: br.s L_0022  // GoTo L_0022
CY1 L_0006: ldc.i4.0     // Stack = [0]
    L_0007: stloc.2      // j = 0, Stack = []
    L_0008: br.s L_0019  // GoTo L_0019
CY2 L_000a: ldloc.0      // Stack = [sum]
    L_000b: ldarg.1      // Stack = [sum, a]
    L_000c: ldloc.1      // Stack = [sum, a, i]
    L_000d: ldloc.2      // Stack = [sum, a, i, j]
    L_000e: call instance int32 int32[0...,0...]::Get(int32, int32)
                         // Stack = [sum, a[i, j]]
    L_0013: add          // Stack = [sum + a[i, j]]
    L_0014: stloc.0      // sum = sum + a[i, j], Stack = []
    L_0015: ldloc.2      // Stack = [j]
    L_0016: ldc.i4.1     // Stack = [j, 1]
    L_0017: add          // Stack = [j + 1]
    L_0018: stloc.2      // j = j +1, Stack = []
CY2 L_0019: ldloc.2      // Stack = [j]
    L_001a: ldc.i4.s 100 // Stack = [j, 100]
    L_001c: blt.s L_000a // GoTo L_000a (if j &amp;lt; 100), Stack = []
    L_001e: ldloc.1      // Stack = [i]
    L_001f: ldc.i4.1     // Stack = [i, 1]
    L_0020: add          // Stack = [i + 1]
    L_0021: stloc.1      // i = i + 1, Stack = []
CY1 L_0022: ldloc.1      // Stack = [i]
    L_0023: ldc.i4.s 100 // Stack = [i, 100]
    L_0025: blt.s L_0006 // GoTo L_0006 (if i &amp;lt; 100), Stack = []
    L_0027: ldloc.0      // Stack = [sum]
    L_0028: ret          // return sum, Stack = []
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;section-1&quot;&gt;Часть 2&lt;/h2&gt;
&lt;p&gt;В первой части статьи я задался задачей сравнить производительность многомерных массивов. Рассматривались данные в виде двумерного массива N*M, тестировалась скорость доступа к элементу &lt;code&gt;[i,j]&lt;/code&gt; при итерировании по всему массиву двумя циклами. Для сравнения было выбрано три варианта: одномерный массив &lt;code&gt;single[i * N + j]&lt;/code&gt; и двумерные массивы &lt;code&gt;jagged[i][j]&lt;/code&gt;, &lt;code&gt;rectangular[i, j]&lt;/code&gt;. Изначально у меня получилось, что &lt;code&gt;jagged&lt;/code&gt;-версия работает быстрее &lt;code&gt;single&lt;/code&gt; версии, но более детальное изучение проблемы показало, что дело может измениться в зависимости от используемых JIT-оптимизаций. Разберёмся с проблемой более подробно.&lt;/p&gt;
&lt;p&gt;Рассмотрим методы из &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/MultidimensionalArrayProgram.cs&quot;&gt;бенчмарка&lt;/a&gt; с наборами параметров &lt;code&gt;&#171;100&#187;&lt;/code&gt; (N=M=100, IterationCount=100000) и &lt;code&gt;&#171;101&#187;&lt;/code&gt; (N=M=101, IterationCount=100001) под x86 и x64. На моей машине (Intel Core i7-3632QM CPU 2.20GHz) получились следующие результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  100-x86
Single      : 1012ms
Jagged      :  772ms
Rectangular : 1460ms

  101-x86
Single      : 1036ms
Jagged      :  785ms
Rectangular : 1485ms  

  100-x64
Single      : 544ms
Jagged      : 346ms
Rectangular : 741ms

  101-x64
Single      :  785ms
Jagged      :  793ms
Rectangular : 1050ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Любопытно, не правда ли? Ну, давайте разбираться. Сразу видно, что &lt;code&gt;Rectangular&lt;/code&gt;-версия всегда работает медленнее двух других. Так происходит из-за того, что работа с одномерными массивами реализуется через команды &lt;code&gt;newarr&lt;/code&gt;, &lt;code&gt;ldelem&lt;/code&gt;, &lt;code&gt;ldelema&lt;/code&gt;, &lt;code&gt;ldlen&lt;/code&gt;, &lt;code&gt;stelem&lt;/code&gt;, которые CLR в достаточной мере оптимизирует. Поэтому отложим рассмотрение &lt;code&gt;Rectangular&lt;/code&gt;-метода на будущее, а сейчас сосредоточимся на сравнении &lt;code&gt;Single&lt;/code&gt; и &lt;code&gt;Jagged&lt;/code&gt; методов.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;x86&quot;&gt;x86&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Single-100-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push ebp 
01 mov  ebp,esp 
03 push edi 
04 push esi 
05 push ebx 
06 push eax 
07 xor  ecx,ecx                       ; sum = 0
09 mov  dword ptr [ebp-10h],ecx       ; iteration = 0
0c xor  ebx,ebx                       ; i = 0
0e xor  esi,esi                       ; j = 0
10 mov  edi,dword ptr [edx+4]         ; edi = a.Length
13 imul eax,ebx,64h                   ; eax = i * 100
16 add  eax,esi                       ; eax = i * 100 + j
18 cmp  eax,edi                       ; if i * 100 + j &amp;gt;= a.Length then
1a jae  00000040                      ; throw IndexOutOfRangeException
1c add  ecx,dword ptr [edx+eax*4+8]   ; sum += a[i * 100 + j]
20 inc  esi                           ; j++
21 cmp  esi,64h                       ; if j &amp;lt; 100 then
24 jl   00000013                      ; loop by j
26 inc  ebx                           ; i++
27 cmp  ebx,64h                       ; if i &amp;lt; 100 then
2a jl   0000000E                      ; loop by i
2c inc  dword ptr [ebp-10h]           ; iteration++
2f cmp  dword ptr [ebp-10h],186A0h    ; if iteration &amp;lt; 100000 then
36 jl   0000000C                      ; loop by iteration
38 mov  eax,ecx                       ; eax = sum (Result)
3a pop  ecx 
3b pop  ebx 
3c pop  esi 
3d pop  edi 
3e pop  ebp 
3f ret   
40 call 65BC5A15                      ; IndexOutOfRangeException
45 int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Jagged-100-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00  push ebp 
01  mov  ebp,esp 
03  push edi 
04  push esi 
05  push ebx 
06  push eax 
07  mov  ecx,edx                       ; ecx = &amp;amp;a
09  xor  ebx,ebx                       ; sum = 0
0b  mov  dword ptr [ebp-10h],ebx       ; iteration = 0
0e  xor  edx,edx                       ; i = 0
10  xor  esi,esi                       ; j = 0
12  mov  eax,dword ptr [ecx+4]         ; eax = a.Length
15  cmp  edx,eax                       ; if i &amp;gt;= a.Length then
17  jae  00000048                      ; throw IndexOutOfRangeException
19  mov  eax,dword ptr [ecx+edx*4+0Ch] ; eax = &amp;amp;a[i]
1d  mov  edi,dword ptr [eax+4]         ; edi = a[i].Length
20  cmp  esi,edi                       ; if j &amp;gt;= a[i].Length
22  jae  00000048                      ; throw IndexOutOfRangeException
24  add  ebx,dword ptr [eax+esi*4+8]   ; sum += a[i][j]
28  inc  esi                           ; j++
29  cmp  esi,64h                       ; if j &amp;lt; 100 then
2c  jl   00000020                      ; loop by j
2e  inc  edx                           ; i++
2f  cmp  edx,64h                       ; if i &amp;lt; 100 then
32  jl   00000010                      ; loop by i
34  inc  dword ptr [ebp-10h]           ; iteration++
37  cmp  dword ptr [ebp-10h],186A0h    ; if iteration &amp;lt; 100000 then
3e  jl   0000000E                      ; loop by iteration
40  mov  eax,ebx                       ; eax = sum (Result)
42  pop  ecx 
43  pop  ebx 
44  pop  esi 
45  pop  edi 
46  pop  ebp 
47  ret    
48  call 66935A55                      ; IndexOutOfRangeException
4d  int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Большая часть кода в обоих методах совпадает. Сравним непосредственный код обращения к элементу:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;; Single
13 imul eax,ebx,64h                    ; eax = i * 100
16 add  eax,esi                        ; eax = i * 100 + j
1c add  ecx,dword ptr [edx+eax*4+8]    ; sum += a[i * 100 + j]
; Jagged
19 mov  eax,dword ptr [ecx+edx*4+0Ch] ; eax = &amp;amp;a[i]
24 add  ebx,dword ptr [eax+esi*4+8]   ; sum += a[i][j]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отсюда можно понять, почему же &lt;code&gt;jagged&lt;/code&gt;-версия лидирует в скорости: для доступа к массиву нам необходимо всего навсего перейти по паре ссылок, а вот в &lt;code&gt;single&lt;/code&gt;-версии приходится использовать &#171;тяжёлые&#187; операции &lt;code&gt;imul&lt;/code&gt; и &lt;code&gt;add&lt;/code&gt; для подсчёта индекса массива.&lt;/p&gt;
&lt;p&gt;Оптимизаций по развертке цикла (см. &lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unwinding&quot;&gt;Loop unwinding&lt;/a&gt;) в данных методах не наблюдается, поэтому версия методов &lt;code&gt;101-x86&lt;/code&gt;
не будет отличаться от &lt;code&gt;100-x86&lt;/code&gt; за исключением подставленных констант.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;x64&quot;&gt;100-x64&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Single-100-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000 push   rbx 
001 push   rbp 
002 push   rsi 
003 push   rdi 
004 push   r12 
006 push   r13 
008 push   r14 
00a push   r15 
00c sub    rsp,28h 
010 mov    rbx,rdx                     ; rbx = &amp;amp;a
013 xor    r11d,r11d                   ; iteration = 0
016 mov    r9d,r11d                    ; sum = 0
019 nop    dword ptr [rax+00000000h] 
020 xor    edi,edi                     ; (i*100) = 0
022 lea    eax,[rdi+64h]                
025 movsxd rcx,eax                      
028 lea    rbp,[rcx*4+00000000h]        ; rbp = 400  
030 movsxd rax,edi                     
033 lea    r10,[rax*4+00000000h]        ; j = 0
03b movsxd rax,edi 
03e lea    r8,[rax*4+00000000h] 
046 mov    rdx,qword ptr [rbx+8]        ; rdx = a.Length
04a lea    rsi,[rdx*4+00000000h]        ; rsi = a.Length * 4
052 lea    eax,[rdi+1] 
055 movsxd rcx,eax 
058 lea    r12,[rcx*4+00000000h]        ; r12 = 1 * 4
060 sub    r12,r8 
063 lea    r14,[rdx*4+00000000h]        ; r14 = a.Length * 4
06b lea    eax,[rdi+2] 
06e movsxd rcx,eax                        
071 lea    r13,[rcx*4+00000000h]        ; r13 = 2 * 4
079 sub    r13,r8                       
07c lea    r15,[rdx*4+00000000h]        ; r15 = a.Length * 4
084 lea    eax,[rdi+3]                  
087 movsxd rcx,eax                         
08a shl    rcx,2                           
08e sub    rcx,r8                       ; rcx = 3 * 4
091 shl    rdx,2                        ; rdx = a.Length * 4
095 cmp    r10,rsi                      ; if j &amp;gt;= a.Length then
098 jae    0000000000000110             ; throw IndexOutOfRangeException
09a mov    eax,dword ptr [rbx+r10+10h]  ; eax = a[j]
09f add    r9d,eax                      ; sum += a[j]
0a2 lea    rax,[r10+r12]                ; rax = (j + 1)*4
0a6 cmp    rax,r14                      ; if j + 1 &amp;gt;= a.Length then
0a9 jae    0000000000000110             ; throw IndexOutOfRangeException
0ab mov    eax,dword ptr [rbx+rax+10h]  ; eax = a[j + 1]
0af add    r9d,eax                      ; sum += a[j + 1]
0b2 lea    rax,[r10+r13]                ; rax = (j + 2)*4
0b6 cmp    rax,r15                      ; if j + 2 &amp;gt;= a.Length
0b9 jae    0000000000000110             ; throw IndexOutOfRangeException
0bb mov    eax,dword ptr [rbx+rax+10h]  ; eax = a[j + 2]
0bf add    r9d,eax                      ; sum += a[j + 2]
0c2 lea    rax,[r10+rcx]                ; rax = (j + 3)*4
0c6 cmp    rax,rdx                      ; if j &amp;gt;= a.Length
0c9 jae    0000000000000110             ; throw IndexOutOfRangeException
0cb mov    eax,dword ptr [rbx+rax+10h]  ; eax = a[j + 3]
0cf add    r9d,eax                      ; sum += a[j + 3]
0d2 add    r10,10h                      ; j += 4
0d6 cmp    r10,rbp                      ; if j &amp;lt; 100 then
0d9 jl     0000000000000095             ; loop by j
0db add    edi,64h                      ; (i*100) += 100
0de cmp    edi,2710h                    ; if (i*100) &amp;lt; 10000 then
0e4 jl     0000000000000022             ; loop by i
0ea inc    r11d                         ; iteration++
0ed cmp    r11d,186A0h                  ; if iteration &amp;lt; 100000 then
0f4 jl     0000000000000020             ; loop by iteration
0fa mov    eax,r9d                      ; eax = sum (Result)
0fd add    rsp,28h 
101 pop    r15 
103 pop    r14 
105 pop    r13 
107 pop    r12 
109 pop    rdi 
10a pop    rsi 
10b pop    rbp 
10c pop    rbx 
10d ret      
10e xchg   ax,ax 
110 call   000000005FA5AC24             ; IndexOutOfRangeException
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Jagged-100-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push rbx                                 
01 sub  rsp,20h                           
05 mov  r10,rdx                        ; r10 = &amp;amp;a
08 xor  edx,edx                        ; iteration = 0
0a mov  r8d,edx                        ; sum = 0
0d nop  dword ptr [rax]                    
10 xor  ecx,ecx                        ; i = 0
12 xor  r9d,r9d                        ; j = 0
15 mov  rax,qword ptr [r10+8]          ; rax = a.Length
19 cmp  rcx,rax                        ; if i &amp;gt;= a.Length
1c jae  0000000000000099               ; throw IndexOutOfRangeException
1e mov  r11,qword ptr [r10+rcx*8+18h]  ; r11 = &amp;amp;a[i]
23 mov  rax,qword ptr [r11+8]          ; rax = a[i].Length
27 mov  ebx,60h                        ; ebx = 96
2c cmp  rbx,rax                        ; if 96 &amp;gt;= a[i].Length
2f jae  0000000000000099               ; throw IndexOutOfRangeException
31 mov  ebx,61h                        ; ebx = 97
36 cmp  rbx,rax                        ; if 97 &amp;gt;= a[i].Length
39 jae  0000000000000099               ; throw IndexOutOfRangeException
3b mov  ebx,62h                        ; ebx = 98
40 cmp  rbx,rax                        ; if 98 &amp;gt;= a[i].Length
43 jae  0000000000000099               ; throw IndexOutOfRangeException
45 mov  ebx,63h                        ; ebx = 99
4a cmp  rbx,rax                        ; if 99 &amp;gt;= a[i].Length
4d jae  0000000000000099               ; throw IndexOutOfRangeException
4f nop                                      
50 mov  eax,dword ptr [r11+r9+10h]     ; eax = a[i][j]
55 add  r8d,eax                        ; sum += a[i][j]
58 mov  eax,dword ptr [r11+r9+14h]     ; eax = a[i][j + 1]
5d add  r8d,eax                        ; sum += a[i][j + 1]
60 mov  eax,dword ptr [r11+r9+18h]     ; eax = a[i][j + 2]
65 add  r8d,eax                        ; sum += a[i][j + 2]
68 mov  eax,dword ptr [r11+r9+1Ch]     ; eax = a[i][j + 3]
6d add  r8d,eax                        ; sum += a[i][j + 3]
70 add  r9,10h                         ; j + 4
74 cmp  r9,190h                        ; if j &amp;lt; 100 then
7b jl   0000000000000050               ; loop by j
7d inc  rcx                            ; i++
80 cmp  rcx,64h                        ; if i &amp;lt; 100 then
84 jl   0000000000000012               ; loop by i
86 inc  edx                            ; iteration++
88 cmp  edx,186A0h                     ; if iteration &amp;lt; 100000 then
8e jl   0000000000000010               ; loop by iteration
90 mov  eax,r8d                        ; eax = sum (Result)
93 add  rsp,20h                            
97 pop  rbx                               
98 ret                                      
99 call 000000005FA69BF4               ; IndexOutOfRangeException
9e nop              
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут тоже всё понятно: &lt;code&gt;single&lt;/code&gt;-версия тормозит из-за кучи операций с высчитыванием индексов, в то время как в &lt;code&gt;jagged&lt;/code&gt; достаточно просто пару раз перейти по ссылкам. Обе версии работают намного быстрее своего x86-аналога, т.к. теперь у нас достаточно регистров, чтобы сделать оптимизацию по развёртке цикла (см. &lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unwinding&quot;&gt;Loop unwinding&lt;/a&gt;).&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;x64-1&quot;&gt;101-x64&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Single-101-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push   rbx 
01 sub    rsp,20h 
05 mov    r10,rdx                      ; r10 = &amp;amp;a
08 xor    edx,edx                      ; iteration = 0
0a mov    r9d,edx                      ; sum = 0
0d nop    dword ptr [rax] 
10 xor    r8d,r8d                      ; i = 0
13 nop    word ptr [rax+rax+00000000h] 
20 lea    eax,[r8+65h]                 ; eax = (i*101)+101
24 movsxd rcx,eax                      ; rcx = (i*101)+101
27 lea    rbx,[rcx*4+00000000h]        ; rbx = ((i*101)+101) * 4
2f movsxd rax,r8d                      ; rax = (i*101) * 4
32 lea    rcx,[rax*4+00000000h]        ; j = (i*101)
3a mov    rax,qword ptr [r10+8]        ; rax = a.Length
3e lea    r11,[rax*4+00000000h]        ; r11 = a.Length * 4
46 cmp    rcx,r11                      ; if j &amp;lt; a.Length
49 jae    0000000000000080             ; throw IndexOutOfRangeException
4b mov    eax,dword ptr [r10+rcx+10h]  ; eax = a[i * 101 + j]
50 add    r9d,eax                      ; sum += a[i * 101 + j]
53 add    rcx,4                        ; j++
57 cmp    rcx,rbx                      ; if j &amp;lt; (i*101)+101 then
5a jl     0000000000000046             ; loop by j
5c add    r8d,64h                      ; (i*100) += 100
60 cmp    r8d,2774h                    ; if (i*100) &amp;lt; 10100
67 jl     0000000000000020             ; loop by i
69 inc    edx                          ; iteration++
6b cmp    edx,186A1h                   ; if iteration &amp;lt; 100001 then
71 jl     0000000000000010             ; loop by iteration
73 mov    eax,r9d                      ; eax = sum (Result)
76 add    rsp,20h 
7a pop    rbx 
7b ret       
7c nop    dword ptr [rax] 
80 call   000000005FA5AC24             ; IndexOutOfRangeException
85 nop       
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Jagged-101-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push rbx 
01 sub  rsp,20h 
05 mov  r10,rdx                        ; r10 = &amp;amp;a
08 xor  edx,edx                        ; iteration = 0
0a mov  r9d,edx                        ; sum = 0
0d nop  dword ptr [rax] 
10 xor  ecx,ecx                        ; i = 0
12 xor  r8d,r8d                        ; j = 0
15 mov  rax,qword ptr [r10+8]          ; rax = a.Length
19 cmp  rcx,rax                        ; if i &amp;gt;= a.Length then
1c jae  0000000000000062               ; throw IndexOutOfRangeException
1e mov  r11,qword ptr [r10+rcx*8+18h]  ; r11 = &amp;amp;a[i]
23 mov  rax,qword ptr [r11+8]          ; rax = a[i].Length
27 mov  ebx,64h                        ; ebx = 100
2c cmp  rbx,rax                        ; if 100 &amp;gt;= a[i].Length then
2f jae  0000000000000062               ; throw IndexOutOfRangeException
31 mov  eax,dword ptr [r11+r8+10h]     ; eax = a[i][j]
36 add  r9d,eax                        ; sum += a[i][j]
39 add  r8,4                           ; j++
3d cmp  r8,194h                        ; if j &amp;lt; 101 then
44 jl   0000000000000031               ; loop by j
46 inc  rcx                            ; i++
49 cmp  rcx,65h                        ; if i &amp;lt; 101 then
4d jl   0000000000000012               ; loop by i
4f inc  edx                            ; iteration++
51 cmp  edx,186A1h                     ; if iteration &amp;lt; 100001 then
57 jl   0000000000000010               ; loop by iteration
59 mov  eax,r9d                        ; eax = sum (Result)
5c add  rsp,20h 
60 pop  rbx 
61 ret   
62 call 000000005FA69D04               ; IndexOutOfRangeException
67 nop   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно видеть, в &lt;code&gt;101&lt;/code&gt;-версии оптимизации развёртки цикла по очевидным причинам не стало. Однако, скорость работы методов сравнялась. Так произошло из-за того, что JIT под &lt;code&gt;x64&lt;/code&gt; более оптимально реализовал &lt;code&gt;Single&lt;/code&gt;-версию: он не стал явно высчитывать индекс каждый раз, а вместо этого он для каждой строки матрицы данных перед циклом по &lt;code&gt;j&lt;/code&gt; высчитывает смещение, относительно которого берутся элементы. Таким образом, &lt;code&gt;Single&lt;/code&gt; и &lt;code&gt;Jagged&lt;/code&gt; версии выполняют практически одни и те же операции для получения элементов массива.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Быстродействие многих методов сильно зависит от произведённых JIT-оптимизаций, которые в свою очередь зависят от используемой архитектуры. Оптимизация развёртки цикла применяется в обоих случаях по самому вложенному циклу и не влияет на сравнение быстродействий разных способов. &lt;code&gt;Rectangular&lt;/code&gt; версия всегда работает медленнее своих &#171;конкурентов&#187;, т.к. в CLR работа с многомерными массивами такого рода организована сложнее, чем с одномерными.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Single&lt;/code&gt;-метод (&lt;code&gt;single[i*M+j]&lt;/code&gt;) &lt;em&gt;обычно&lt;/em&gt; работает медленнее, чем &lt;code&gt;Jagged&lt;/code&gt; (&lt;code&gt;jagged[i][j]&lt;/code&gt;), т.к. вычисление индекса &lt;code&gt;i*N+j&lt;/code&gt; на каждой итерации является более затратной операцией, чем явный переход по двум ссылкам. Однако, они &lt;em&gt;могут сравняться&lt;/em&gt; по времени работы, если JIT нужным образом соптимизирует &lt;code&gt;Single&lt;/code&gt; версию. Если же говорить о непосредственном доступе к элементу без расчёта индекса, то &lt;code&gt;single[i]&lt;/code&gt; будет лидировать в скорости по сравнению с &lt;code&gt;jagged[i][j]&lt;/code&gt;.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Об итерировании статичных массивов в .NET</title>
            <link>http://aakinshin.net/ru/posts/static-array-iteration/</link> 
            <pubDate>Thu, 29 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/static-array-iteration/</guid>
            <description>&lt;h2 id=&quot;section&quot;&gt;Часть 1&lt;/h2&gt;
&lt;p&gt;Управляемый подход платформы .NET делает жизнь разработчиков достаточно простой, беря на себя многие рутинные операции. Большую часть времени программист может вообще не вспоминать о технической реализации платформы, сосредоточившись исключительно на логике своего приложения. Но иногда попадаются задачи, критичные по производительности. Существует множество различных подходов к оптимизации кода в таких ситуациях вплоть до переписывания наиболее важных частей кода через неуправляемый код. Однако, зачастую для увеличения скорости приложения достаточно понимать, сколько времени тратится на ту или иную операцию. Знание подобных вещей позволит оптимизировать некоторые методы с помощью достаточно простых модификаций исходного кода.&lt;/p&gt;
&lt;p&gt;В этой статье мне хотелось бы поговорить о скорости доступа к массивам, ссылки на которые хранятся в статичных переменных. Дело в том, что в скорость итерирования по ним в зависимости от условий запуска может быть ниже, чем для массива, ссылка на который хранится в обычном поле экземпляра класса или локальной переменной. Рассмотрим пример.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;В примере будем решать простую задачу: подсчёт суммы элементов массива. В первом случае мы будем использовать обычное боле класса, а во втором — статическое. Для замеров времени будем использовать &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; (исходный код примера: &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/ArrayIterationProgram.cs&quot;&gt;ArrayIterationProgram.cs&lt;/a&gt;, тестировать следует в &lt;strong&gt;Release mode without debugging&lt;/strong&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int N = 1000, IterationCount = 1000000;

private int[] nonStaticField;
private static int[] staticField;

public void Run()
{
    nonStaticField = staticField = new int[N];

    var competition = new BenchmarkCompetition();
    competition.AddTask(&amp;quot;Non-static&amp;quot;, () =&amp;gt; NonStaticRun());
    competition.AddTask(&amp;quot;Static&amp;quot;, () =&amp;gt; StaticRun());
    competition.Run();
}

private int NonStaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += nonStaticField[i];
    return sum;
}

private int StaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += staticField[i];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На своей машине я получил следующие результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 346ms
Static     : 535ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если мы взглянем на IL-код целевых методов, то увидим, что они различаются только в одном месте, при обращении к полю:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static:
L_000b: ldarg.0 
L_000c: ldfld int32[] Benchmarks.StaticFieldBenchmark::nonStaticField
Static:
L_000b: ldsfld int32[] Benchmarks.StaticFieldBenchmark::staticField
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Заметим, что физически оба поля ссылаются на одну и ту же область памяти. Мы можем ускорить работу со статическим полем, если перед многократным обращением к полю сохраним его в локальную переменную:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private int StaticRun()
{
    var localField = staticField;
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += localField[i];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В итоге &lt;code&gt;StaticRun&lt;/code&gt; будет работать столько же, сколько и &lt;code&gt;NonStaticRun&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Объяснение такого поведения можно прочитать во второй части статьи.&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;Часть 2&lt;/h2&gt;
&lt;p&gt;В первой части я встретился с весьма интересной ситуацией. Были измерены скорости работы двух методов, в первом из которых считалась сумма элементов массива, ссылка на который хранилась в обычном поле объекта, а во втором — массива, ссылка на который хранилась в статичном поле. Результаты меня удивили: массивы были одинаковые, но второй метод работал ощутимо дольше. Сперва я подумал, что дело в организации скорости доступа к статичным полям, но более детальный анализ ситуации и разговоры с коллегами помогли мне понять, что истинная причина такого поведения намного интересней: для массивов, длина которых кратна 4, JIT использует различные оптимизации в случае обычных и статичных массивов. Давайте разберёмся с ситуацией более детально.&lt;/p&gt;
&lt;p&gt;Напомню методы, поведение которых мы будем изучать:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private const int N = 1000, IterationCount = 1000000;
private int[] nonStaticField;
private static int[] staticField;

public void Run()
{
    nonStaticField = staticField = new int[N];
    NonStaticRun();
    StaticRun();
}

private int NonStaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += nonStaticField[i];
    return sum;
}

private int StaticRun()
{
    int sum = 0;
    for (int iteration = 0; iteration &amp;lt; IterationCount; iteration++)
        for (int i = 0; i &amp;lt; N; i++)
            sum += staticField[i];
    return sum;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для начала поменяем Platform target на x86 и запустим &lt;a href=&quot;https://github.com/AndreyAkinshin/BenchmarkDotNet/blob/master/Benchmarks/ArrayIterationProgram.cs&quot;&gt;бенчмарк&lt;/a&gt;. Получим следующие результаты:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 708ms
Static     : 709ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Интересный вывод: на x86 результаты тестов одинаковы. Чтобы лучше разобраться в проблеме взглянем на нативный код, который получается после JIT-оптимизаций (изучается версия в Release mode without debugging). Конфигурация моей машины, на которой я проводил тестирование: Intel Core i7-3632QM CPU 2.20GHz.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NonStaticRun-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push ebp 
01 mov  ebp,esp 
03 push edi 
04 push esi 
05 push ebx 
06 xor  edi,edi                     ; sum = 0
08 xor  ebx,ebx                     ; iteration
0a xor  edx,edx                     ; i = 0
0c mov  eax,dword ptr [ecx+4]       ; eax = &amp;amp;nonStaticField
0f mov  esi,dword ptr [eax+4]       ; esi = nonStaticField.Length
12 cmp  edx,esi                     ; if i &amp;gt;= nonStaticField.Length then
14 jae  00000033                    ; throw IndexOutOfRangeException
16 add  edi,dword ptr [eax+edx*4+8] ; sum += nonStaticField[i];
1a inc  edx                         ; i++
1b cmp  edx,3E8h                    ; if i &amp;lt; 1000 then
21 jl   00000012                    ; loop by i
23 inc  ebx                         ; iteration++
24 cmp  ebx,0F4240h                 ; if iteration &amp;lt; 1000000 then
2a jl   0000000A                    ; loop by iteration
2c mov  eax,edi                     ; eax = sum (Result)
2e pop  ebx 
2f pop  esi 
30 pop  edi 
31 pop  ebp 
32 ret 
33 call 63495C4D                    ; IndexOutOfRangeException
38 int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StaticRun-x86.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 push ebp 
01 mov  ebp,esp 
03 push edi 
04 push esi 
05 push ebx 
06 xor  edi,edi                      ; sum = 0
08 xor  ebx,ebx                      ; iteration = 0
0a xor  eax,eax                      ; i = 0
0c mov  edx,dword ptr ds:[03943380h] ; edx = &amp;amp;staticField
12 mov  esi,dword ptr [edx+4]        ; esi = staticField.Length 
15 cmp  eax,esi                      ; if i &amp;gt;= staticField.Length then
17 jae  00000035                     ; throw IndexOutOfRangeException
19 add  edi,dword ptr [edx+eax*4+8]  ; sum += staticField[i];
1d inc  eax                          ; i++
1e cmp  eax,3E8h                     ; if i &amp;lt; 1000 then
23 jl   00000015                     ; loop by i
25 inc  ebx                          ; iteration++
26 cmp  ebx,0F4240h                  ; if iteration &amp;lt; 1000000 then
2c jl   0000000A                     ; loop by iteration
2e mov  eax,edi                      ; eax = sum (Result)
30 pop  ebx 
31 pop  esi 
32 pop  edi 
33 pop  ebp 
34 ret 
35 call 639E52D5                     ; IndexOutOfRangeException
3a int  3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Из этого кода становится понятно, что разнице во времени взяться неоткуда: методы отличаются только в одной строчке, в которой берётся адрес интересующего нас массива. В обоих случаях используется команда &lt;code&gt;move&lt;/code&gt; , просто её аргументы разнятся, это не должно сказаться на производительности.&lt;/p&gt;
&lt;p&gt;Теперь поменяем платформу на x64 и запустим бенчмарк:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 347ms
Static     : 533ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Любопытно: в обоих случаях быстродействие значительно возросло, но только в случае статичного поля оптимизация вышла &#171;слабее&#187;. В чём же дело? Обратимся опять к машинному коду:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NonStaticRun-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h
04 mov  r8,rcx
07 xor  ecx,ecx
09 mov  edx,ecx                      ; sum = 0
0b nop  dword ptr [rax+rax]
10 xor  r10d,r10d                    ; i = 0
13 mov  r9,qword ptr [r8+8]          ; r9 = &amp;amp;nonStaticField
17 mov  rax,qword ptr [r9+8]         ; rax = nonStaticField.Length
1b mov  r11d,3E4h                    ; r11 = 996
21 cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
24 jae  000000000000008A             ; throw IndexOutOfRangeException
26 mov  r11d,3E5h                    ; r11 = 997
2c cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
2f jae  000000000000008A             ; throw IndexOutOfRangeException
31 mov  r11d,3E6h                    ; r11 = 998
37 cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
3a jae  000000000000008A             ; throw IndexOutOfRangeException
3c mov  r11d,3E7h                    ; r11 = 999
42 cmp  r11,rax                      ; if r11 &amp;gt;= nonStaticField.Length then
45 jae  000000000000008A             ; throw IndexOutOfRangeException
47 nop  word ptr [rax+rax+00000000h]
50 mov  eax,dword ptr [r9+r10+10h]   ; eax = nonStaticField[i]
55 add  edx,eax                      ; sum += eax
57 mov  eax,dword ptr [r9+r10+14h]   ; eax = nonStaticField[i+1]
5c add  edx,eax                      ; sum += eax
5e mov  eax,dword ptr [r9+r10+18h]   ; eax = nonStaticField[i+2]
63 add  edx,eax                      ; sum += eax
65 mov  eax,dword ptr [r9+r10+1Ch]   ; eax = nonStaticField[i+3]
6a add  edx,eax                      ; sum += eax
6c add  r10,10h                      ; i += 4
70 cmp  r10,0FA0h                    ; if i &amp;lt; 1000 then
77 jl   0000000000000050             ; loop by i
79 inc  ecx                          ; iteration++
7b cmp  ecx,0F4240h                  ; if iteration &amp;lt; 1000000  then
81 jl   0000000000000010             ; loop by iteration
83 mov  eax,edx                      ; eax = sum (Result)
85 add  rsp,28h
89 ret   
8a call 000000005FA4AE14             ; IndexOutOfRangeException
8f nop 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот пример намного интересней! Вспомним, что в x86 нам доступно только 8 регистров по 32 бита (EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, R8D), а в x64 доступно 16 регистров по 64 бита (RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI, R8 — R15). Увеличение количества регистров позволило произвести JIT-оптимизацию &#171;размотка цикла&#187; (см.
&lt;a href=&quot;http://en.wikipedia.org/wiki/Loop_unwinding&quot;&gt;Loop unwinding&lt;/a&gt;). При этом важную роль играет то обстоятельство, что количество итераций в каждом из циклов кратно четвёрке. Мы ещё вернёмся к этому моменту, а пока взглянем на static-версию.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StaticRun-x64.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h 
04 xor  ecx,ecx                       ; iteration = 0
06 mov  edx,ecx                       ; sum = 0
08 nop  dword ptr [rax+rax+00000000h] 
10 xor  r8d,r8d                       ; i = 0
13 mov  r9,12D756F0h                  ; r9 = staticField
1d mov  r9,qword ptr [r9]             ; r9 = &amp;amp;staticField
20 mov  r10,qword ptr [r9+8]          ; r10 = staticField.Length
24 cmp  r8,r10                        ; if r8 &amp;gt;= staticField.Length then
27 jae  0000000000000080              ; throw IndexOutOfRangeException
29 mov  eax,dword ptr [r9+r8*4+10h]   ; eax = staticField[i]
2e add  edx,eax                       ; sum += eax
30 lea  rax,[r8+1]                    ; rax = i+1
34 cmp  rax,r10                       ; if rax &amp;gt;= staticField.Length then
37 jae  0000000000000080              ; throw IndexOutOfRangeException
39 mov  eax,dword ptr [r9+rax*4+10h]  ; eax = staticField[i+1]
3e add  edx,eax                       ; sum += eax
40 lea  rax,[r8+2]                    ; rax = i+2
44 cmp  rax,r10                       ; if rax &amp;gt;= staticField.Length then
47 jae  0000000000000080              ; throw IndexOutOfRangeException
49 mov  eax,dword ptr [r9+rax*4+10h]  ; eax = staticField[i+2]
4e add  edx,eax                       ; sum += eax
50 lea  rax,[r8+3]                    ; rax = i+3
54 cmp  rax,r10                       ; if rax &amp;gt;= staticField.Length then
57 jae  0000000000000080              ; throw IndexOutOfRangeException
59 mov  eax,dword ptr [r9+rax*4+10h]  ; eax = staticField[i+3]
5e add  edx,eax                       ; sum += eax
60 add  r8,4                          ; i += 4
64 cmp  r8,3E8h                       ; if i &amp;lt; 1000 then
6b jl   0000000000000013              ; loop by i
6d inc  ecx                           ; iteration++
6f cmp  ecx,0F4240h                   ; if iteration &amp;lt; 1000000 then
75 jl   0000000000000010              ; loop by iteration
77 mov  eax,edx                       ; eax = sum (result)
79 add  rsp,28h 
7d ret     
7e xchg ax,ax 
80 call 000000005FA49F64              ; IndexOutOfRangeException
85 nop   
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Из примера видно, что для статичного массива оптимизация размотки цикла прошла несколько иначе. Причём, если в методе &lt;code&gt;StaticRun&lt;/code&gt; сохранить ссылку на статический массив в локальную переменную и итерировать по ней, то машинный код будет аналогичен примеру NonStaticRun-x64.asm, а производительность обоих методов станет одинаковой. В текущей версии static-версия &#171;проседает&#187; по скорости из-за следующих обстоятельств:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Вместо того, чтобы явно хранить смещения элементов, хранится индекс, который в момент вычисления адреса умножается на 4 для получения смещения.&lt;/li&gt;
&lt;li&gt;Вычисление адресов элементов [i+1], [i+2], [i+3] происходит в регистрах вместо того, чтобы использовать константные смещения в 4h, 8h, bh, относительно элемента [i].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Теперь попробуем изменить длину массива, чтобы она больше не делилась на 4: N = 1001. Результаты бенчмарка:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Non-static : 550ms
Static     : 719ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Static-версия по скорости &#171;вернулась&#187; к результату без оптимизации, который мы видели в x86-версии. В NonStatic-версии результат интереснее: текущая версия работает медленнее, чем для N=1000, но быстрее, чем для x86. Опять обратимся к машинному коду, чтобы разобраться:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NonStaticRun-x64-1001.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h 
04 mov  r9,rcx 
07 xor  ecx,ecx 
09 mov  edx,ecx 
0b nop  dword ptr [rax+rax] 
10 xor  r8d,r8d 
13 mov  r10,qword ptr [r9+8] 
17 mov  rax,qword ptr [r10+8] 
1b mov  r11d,3E8h 
21 cmp  r11,rax 
24 jae  0000000000000055 
26 nop  word ptr [rax+rax+00000000h] 
30 mov  eax,dword ptr [r10+r8+10h] 
35 add  edx,eax 
37 add  r8,4 
3b cmp  r8,0FA4h 
42 jl   0000000000000030 
44 inc  ecx 
46 cmp  ecx,0F4240h 
4c jl   0000000000000010 
4e mov  eax,edx 
50 add  rsp,28h 
54 ret    
55 call 000000005FA5AE14 
5a nop    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;StaticRun-x64-1001.asm&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;00 sub  rsp,28h 
04 xor  ecx,ecx 
06 mov  edx,ecx 
08 nop  dword ptr [rax+rax+00000000h] 
10 xor  r8d,r8d 
13 mov  r9,12B556F0h 
1d mov  r9,qword ptr [r9] 
20 mov  rax,qword ptr [r9+8] 
24 cmp  r8,rax 
27 jae  0000000000000050 
29 mov  eax,dword ptr [r9+r8*4+10h] 
2e add  edx,eax 
30 inc  r8 
33 cmp  r8,3E9h 
3a jl   0000000000000013 
3c inc  ecx 
3e cmp  ecx,0F4240h 
44 jl   0000000000000010 
46 mov  eax,edx 
48 add  rsp,28h 
4c ret   
4d nop  dword ptr [rax] 
50 call 000000005FA69FA4 
55 nop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Из примеров можно заметить, что в методах NonStaticRun-x86, StaticRun-x86, StaticRun-x64-1001 для вычисления очередного элемента массива используется формула:
&lt;code&gt;BaseAddress + i * 4 + 10h&lt;/code&gt;, а в методе NonStaticRun: &lt;code&gt;BaseAddress + offset + 10h&lt;/code&gt;, где &lt;code&gt;offset = i * 4&lt;/code&gt; — уже готовое смещение. Этим и объясняется разница в скорости.&lt;/p&gt;
&lt;p&gt;Данную тему можно изучать ещё очень долго: пробовать менять конфигурацию сборки, пробовать различные длины массивов и т.п. Но я ограничусь формулировкой основного вывода.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;Скорость итерирования может значительно зависеть от следующих обстоятельств:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Тип ссылки на массив: статичное поле или обычное поле/локальная переменная&lt;/li&gt;
&lt;li&gt;Используемая архитектура процессора&lt;/li&gt;
&lt;li&gt;Делимость количества элементов на степени двойки&lt;/li&gt;
&lt;li&gt;Версия CLR&lt;/li&gt;
&lt;li&gt;Фаза луны&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Всем хороших бенчмарков =)&lt;/p&gt;</description>
        </item>
        <item>
            <title>To Add Comments or Not to Add?</title>
            <link>http://aakinshin.net/posts/comments/</link> 
            <pubDate>Wed, 28 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/comments/</guid>
            <description>&lt;p&gt;&lt;em&gt;A really good comment is the one you managed to avoid. (c) Uncle Bob&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Lately, I’ve been feeling really tired of hot discussions on if it’s necessary to add comments in the code. As a rule, there are self-confident juniors with the indisputable statement as: “Why not to comment it, it will be unreadable without the comments!” on one side. And experienced seniors are on the other side. They understand that if it’s possible to go without the comments than “You better, damn it, do it in this way!” Probably, many developers got comment cravings since they’ve been students when professors made them comment every code line, “to make the student better understand it”. Real projects shouldn’t contain a lot of comments that only spoil the code. I don’t agitate for avoiding comments at all, but if you managed to write the code that doesn’t need comments, you can consider it your small victory. I would like to refer you to some good books that helped form my position. I like and respect these authors and completely share their opinion.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670&quot;&gt;Steven C. McConnell, Code Complete&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882&quot;&gt;Robert Martin, Clean Code: A Handbook of Agile Software Craftsmanship&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.amazon.com/The-Readable-Code-Theory-Practice/dp/0596802293&quot;&gt;Dustin Boswell, Trevor Foucher, The Art of Readable Code (Theory in Practice)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;So, what makes me mad about the comments? Here are some main statements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Comments spoil the code itself, make it less readable;&lt;/li&gt;
&lt;li&gt;Comments require time for writing and maintenance;&lt;/li&gt;
&lt;li&gt;Comments lie (starting from the improperly composed comments and ending with the obsolete ones)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Basically, I agree that in some cases the comments are necessary. But the less such cases exist the more beautiful your code is. Besides, writing a good comment is the art as well. Unfortunately, just few developers have that skill, the rest of them write the comments anyhow. The benefit of such commenting is quite doubtful. Isn’t it better not to spend time and effort for writing a good comment but to spend it for re-writing the code in the way it could go without any comments?&lt;/p&gt;
&lt;p&gt;Let’s discuss some typical scenarios and define to what extent the comment is necessary. I provide C# code, but this is not that critical for this article.&lt;/p&gt;
&lt;h2 id=&quot;when-you-can-go-without-the-comments&quot;&gt;When you can go without the comments&lt;/h2&gt;
&lt;h3 id=&quot;comments-that-repeat-code&quot;&gt;Comments that repeat code&lt;/h3&gt;
&lt;p&gt;Let’s have a look at the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// This method is responsible for calculating array elements sum
// The method receives elements array at the input
public int CalcSumOfElement(int[] elements)
{
  int result = 0; // Creating a special variable for the result
  int n = elements.Length; // Defining array length, i.e. number of elements
  for (int i = 0; i &amp;lt; n; i++) // Running cycle for all elements
    result += elements[i]; // Adding an element to the result
  return result; // Returning the result
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, this sample is fake, but unfortunately, I don’t overdo. I saw such code quite often. In this sample, the comments don’t provide any new information; everything can be understood from code. And reading this code without the comments would be much easier. I don’t even say about maintenance of such code: it’s quite tiresome to support this level of commenting. Most likely, when the code becomes more sophisticated half of code won’t have comments, the rest of code will include obsolete comments.&lt;/p&gt;
&lt;h3 id=&quot;comments-explaining-syntax&quot;&gt;Comments explaining syntax&lt;/h3&gt;
&lt;p&gt;Here is the sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Item
{
  private int value; // This is a private field, it’s not available from outside

  // This is a constructor
  public Item(int twoValue)
  {
    value = twoValue &amp;gt;&amp;gt; 1; // Two characters don’t mean bitwise sift to the right
    // so, we divide the value in two
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If this is a laboratory research of a fresher, it’s ok. But if this is the production code and your developers need such comments, I’ve got bad news for you. Probably, this article is not for you.&lt;/p&gt;
&lt;h3 id=&quot;comments-explaining-standard-classes&quot;&gt;Comments explaining standard classes&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;HashSet set; // This is data structure called Hash-Set
// It represents a set of elements
// We can easily find out if an element is included in this set
// More information on hash-tables can be found in wikipedia:
// http://ru.wikipedia.org/wiki
// /%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If a programmer really doesn’t know designation of some standard class or method, he can always use Google search / read documentation / ask an associate. Most good developers already know it. That’s why I strongly doubt usefulness of such comments.&lt;/p&gt;
&lt;h3 id=&quot;comments-explaining-improper-names&quot;&gt;Comments explaining improper names&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Setting up server connection
public void DoIt()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I agree that it’s not always possible to name a class/method/property/variable properly. And if the project deadline is yesterday, there is no time to think over good names. Let’s take some arbitrary name and explain what’s happening in the comments. This is much easier and quicker! Or you will spare a minute or two to give an understandable name?&lt;/p&gt;
&lt;h3 id=&quot;comments-explaining-a-paragraph&quot;&gt;Comments explaining a paragraph&lt;/h3&gt;
&lt;p&gt;I often hear the following phrases: “This method is 300 lines, it does lots of things. You can’t understand it without the comments. I will comment every 10 lines”. If this is the case, you, probably, do something wrong. May be it’s better to divide this big 300-lines method into several smaller methods. And give an understandable name to every small method. In this way you won’t need the comments.&lt;/p&gt;
&lt;h3 id=&quot;comments-explaining-constants&quot;&gt;Comments explaining constants&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public int GetSeconds(int hours)
{
  return hours * 3600; // 3600 – this is amount of seconds forming an hour
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this variant, availability of the comment is a more adequate variant that just a figure added to the code and meaning something. But it’s even better to create a named constant which name made everything understandable.&lt;/p&gt;
&lt;p&gt;For example, in this way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int SecondsInHour = 3600;
public int GetSeconds(int hours)
{
  return hours * SecondsInHour;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;comments-not-related-to-programming&quot;&gt;Comments not related to programming&lt;/h3&gt;
&lt;p&gt;I like a story from “Code Complete” about how a developer tried to understand the following comment for the whole night:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;MOV AX, 723h ; R. I. P. L. V. В.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some months later he met the author of this code and learnt that the comment meant the following: &#171;Rest in peace, Ludwig van Beethoven&#187; as 723 is a hexadecimal view of the year of Beethoven’s death. Unfortunately, some programmers think that the code is some kind of a forum where they can communicate. Some of them try to be witty (nearly telling funny stories), others tell something about themselves (for example, “It’s 3.00am right now and I am still writing this class as I am fond of programming”). You don’t do it in this way; there are hundreds of other communication means. If the comment is included in the project it should add some value to this project.&lt;/p&gt;
&lt;h3 id=&quot;comments-containing-thoughts&quot;&gt;Comments containing thoughts&lt;/h3&gt;
&lt;p&gt;It happens that a comment contains some smart ideas that are very useful. But very often this is not the case:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Main()
{
  // Well, this is a very useful method
  // It executes main logic of this class.
  // At first I wanted to name it Run.
  // But then I thought that Run means “to go quickly”.
  // And this method doesn’t run, it’s very slow.
  // I was thinking about it when washing the dishes.
  // And when I finished washing the dishes and got back to my computer I renamed the method to Main.
  // This is the main method of this class, let it be Main.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;comments-containing-use-cases&quot;&gt;Comments containing use cases&lt;/h3&gt;
&lt;p&gt;Sometimes an author of the method is not sure that everybody will correctly understand how to use his method. And he gives use cases that demonstrate what the method gets with the definite data:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Sum(1, 2) == 3
// Sum(2, 1) == 3
// Sum(2, 2) == 4
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think that every task should have its own tool. And unit tests were created for this exact purpose. This is a very smart thing. Necessity of unit tests is a debatable topic as well. But if you need to describe samples of the returned results for the method, why not to do a corresponding unit test?&lt;/p&gt;
&lt;h3 id=&quot;comments-containing-code-history&quot;&gt;Comments containing code history&lt;/h3&gt;
&lt;p&gt;Luckily, I haven’t seen such comments for quite a long time. But sometimes I have to review the following comments: // 11.06.13: Fixed a bug in the method. Previously it worked in the following way, now it works in this way. // 12.06.13: Oops, that bug wasn’t a bug at all. Got everything back. I will repeat once again: there is a separate tool for every task. Source control systems are able to store change history. You don’t need to overload source code with unnecessary history of how the code was written. If anyone gets interested in it, he can always review it in the repository.&lt;/p&gt;
&lt;h3 id=&quot;comments-containing-code&quot;&gt;Comments containing code&lt;/h3&gt;
&lt;p&gt;Such comments make me especially sad. Let’s say you are reviewing the code of some good class and subbenly you see:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// int number = GetNumber()
// int number = 4;
// int number = 5;
int number = 4;
// double number = 4.5;
// decimal number = 4.5;
// string number = &amp;quot;This number&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What did author want to say in this comment? Some developers want to say: “I am making some experiments changing the code, but I don’t want to lose old versions of this code in case I will need to get back to them”. This phrase reminds us of the idea to use repository for this purpose, since it can store intermediate versions of your code and they won’t get lost. Take pity on the developers who will read your code. And the worst thing is that this code will stay in the project for a long time. The author just forgets to delete bad code version after a number of experiments. His associates are afraid to thoughtlessly delete the code which designation is unclear: “I will delete the thing and then it will occur that it was absolutely necessary.There was a great idea and I spoiled everything”.&lt;/p&gt;
&lt;h3 id=&quot;incomprehensible-comments&quot;&gt;Incomprehensible comments&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;bool flagA = true;
bool flagB = false;
bool flagC = true;
if (Condition(flagA, flagB, flagC))
  Foo();
// else checkbox true, turn off server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In such cases you can’t guess what an author wanted to say. What checkbox is true? Is it always set to true in the else-branch? Or is it necessary to add some code that will set the checkbox to true? What is the server? Why is it turned off? Will it turn off automatically? Or do we need to do it manually?&lt;/p&gt;
&lt;p&gt;Such comments are likely to do more harm, than good. It doesn’t contain any useful information and just confuses the reader. Don’t confuse your readers! Or don’t write anything at all. Or spend a little more time to write a message everyone will understand.&lt;/p&gt;
&lt;h3 id=&quot;comments-containing-too-much-text&quot;&gt;Comments containing too much text&lt;/h3&gt;
&lt;p&gt;Some commenters are afraid of being misunderstood. Or to provide too little information. That is why a comment for a three-lines method can take several screens. In this extensive essay, you will read about the used algorithms, their temporary complexity, see pseudo-code of the method, diagram in ASCII graphics, variable names rationale, some general ideas. And everything will be given in so many details to make even a first-grader understand it.&lt;/p&gt;
&lt;p&gt;This is a bad approach. It makes a reader spend much time to review your essay. If you decide to insert a comment take care about its laconism (of course, without prejudice to its readability and information value).&lt;/p&gt;
&lt;h3 id=&quot;comments-that-lie&quot;&gt;Comments that lie&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;// two figures product
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, you confuse your reader. What happens here? Probably, sometimes the method got a product and then it was converted to sum and the comment became obsolete. Or vice-versa, the comment was updated, but method name got out of attention. And may be the method got sum from the very beginning and a programmer just made a mistake while inserting a comment. The method can be very complicated and it can take much time to understand which one of the turtles lie.&lt;/p&gt;
&lt;h2 id=&quot;when-you-can-insert-a-comment&quot;&gt;When you can insert a comment&lt;/h2&gt;
&lt;h3 id=&quot;comments-that-add-abstraction-level&quot;&gt;Comments that add abstraction level&lt;/h3&gt;
&lt;p&gt;Domain scope can be very complicated. It’s not always possible to get simple and clear names for the classes that will immediately indicate the things they correspond to. That is why it’s ok to set some concise term to denote a complicated domain. Main team developers know it by heart. And it is good to insert a laconic comment for new team members that will explain everything.&lt;/p&gt;
&lt;h3 id=&quot;comments-that-explain-unexplainable&quot;&gt;Comments that explain unexplainable&lt;/h3&gt;
&lt;p&gt;It’s a pity, but sometimes you can’t write the code that is understandable as it is. Probably, some sophisticated algorithm is used. Or a coming deadline made you write a quick but not readable code. May be you need to deliver the project yesterday and have no time to put it in order. It doesn’t matter how the unreadable code got in your project. If it becomes more understandable, let the comment be added in the code.&lt;/p&gt;
&lt;h3 id=&quot;todo-comments&quot;&gt;TODO comments&lt;/h3&gt;
&lt;p&gt;The issue is disputable as well. Someone can say that there is an Issue Tracker, let’s store all tasks in it. Others can say that there is no need to generate lots of small issues when it’s possible to insert special comments that will attract developers’ attention to the fact that some functionality needs to be added. It’s good that today’s IDE’s can search for TODO comments and output them as a big fine list, so you won’t worry the instructions will be lost. It’s just necessary to agree within a team on what methodology will be used. Many programmers think that TODO comments are very convenient and there is no harm to use them.&lt;/p&gt;
&lt;h3 id=&quot;comments-that-attract-attention&quot;&gt;Comments that attract attention&lt;/h3&gt;
&lt;p&gt;Sometimes there appear some important things in the code which you want your reader to pay attention to. But it’s impossible to do with the code means. For example, you need to warn a reader that the method executes for a long time. Or the class is being developed and refactored by several people, it contains some bad piece of code that needs to be deleted or revised. But you better don’t do it since it’s very important and everything will fail without it. In general, if there are some important but not obvious aspects of your code, you can add a comment, it won’t be excessive.&lt;/p&gt;
&lt;h3 id=&quot;comments-that-documentation&quot;&gt;Comments that documentation&lt;/h3&gt;
&lt;p&gt;Many developers generate documentation based on the specific comments (such approach is used in many languages). There are other means to create documentation without the comments. But depending on some circumstances it’s a concept to use the comments for documenting, you can’t do anything with it. Here we talk about a public API, not about a private method in the in-house project. The team should agree on when and where this approach to documenting will be used. Time is priceless; don’t spend it for generating documentation that no one will read.&lt;/p&gt;
&lt;h3 id=&quot;comments-containing-legal-information&quot;&gt;Comments containing legal information&lt;/h3&gt;
&lt;p&gt;Some projects require adding a header-comment with license or copyright information in every file. No discussions in this case.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;I would like to focus on the main idea: though I insist on reduction of the comments number, it doesn’t mean that comments are evil incarnate that shouldn’t appear in the project. If you can justify the availability of a comment in this code snippet, if you really can’t avoid it, if you can compose it correctly and laconically – you’re welcome to insert a comment since it makes the source code more informative. Unfortunately, most comments don’t provide much benefit and just spoil the code. If you are about to write another wonderful comment, give yourself some more time to think if the comment is really wonderful, can’t you go without it?&lt;/p&gt;
&lt;p&gt;I also would like to note that, in real life, many things depend on the programming language, on IDE, on team agreements. Probably, in your definite situation it’s necessary to insert a lot of comments (it can be a complicated algorithm, low-level code, sophisticated optimizations, etc.). May be you are writing local code at the moment and comments make it more convenient to work with the code (though nobody makes you commit comments to the repository). It may occur that your project is 100 lines of code and it’s easier to add some comments than to create a complicated extensible architecture. In this article, I offered some general recommendations for a big project in a high-level language. These recommendations can save you and your associates from unnecessary headache. Just don’t consider the suggested practices as the absolute rules. You need to get the situation: is it appropriate to add a comment? Is it necessary here? Or it’s better to go without it? Just try to pay more attention to such things and your project will be better.&lt;/p&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-add-comments-or-not-to-add/&quot;&gt;blogs.perpetuumsoft.com, Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/to-add-comments-or-not-to-add-part-2/&quot;&gt;blogs.perpetuumsoft.com, Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Perfect code and real projects</title>
            <link>http://aakinshin.net/posts/perfect-code-and-real-projects/</link> 
            <pubDate>Wed, 28 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/perfect-code-and-real-projects/</guid>
            <description>&lt;p&gt;I’ve got a problem. I am a perfectionist. I like perfect code. This is not only the correct way to develop applications but also the real proficiency. I enjoy reading a good listing not less than reading a good book. Developing architecture of a big project is no simpler than designing architecture of a big building. In case the work is good the result is no less beautiful. I am sometimes fascinated by how elegantly the patterns are entwined in the perfect software system. I am delighted by the attention to details when every method is so simple and understandable that can be a classic sample of the perfect code.&lt;/p&gt;
&lt;p&gt;But, unfortunately, this splendor is ruined by stern reality and real projects. If we talk about production project, users don’t care how beautiful your code is and how wonderful your architecture is, they care to have a properly working project. But I still think that in any case you need to strive for writing good code, but without getting stuck on this idea. After reading various holy-war discussions related to correct approaches to writing code I noticed a trend: everyone tries to apply the mentioned approaches not to programming in general, but to personal development experience, to their own projects. Many developers don’t understand that good practice is not an absolute rule that should be followed in 100% of scenarios. It’s just an advice on what to do in most cases. You can get a dozen of scenarios where the practice won’t work at all. But it doesn’t mean that the approach is not that good, it’s just used in the wrong environment.&lt;/p&gt;
&lt;p&gt;There is another problem: some developers are not that good as they think. I often see the following situation: such developer got some idea (without getting deep into details) in the big article about the perfect code and he started to use it everywhere and the developer’s code became even worse. And then I have to listen to: “they read articles about these approaches and then start writing code in this way”. And what if this is not about the articles? If some programmers use good practices inappropriately it doesn’t mean that good development practices shouldn’t be discussed. Willingness to write correct code is good, but it’s necessary to estimate development skills soberly. There are a lot of maneuvers of stunt flying described for pilots. But it doesn’t mean that every newbie pilot should try to do them all in the very first flight. The same thing is for junior programmers: he doesn’t need to use tens of patterns he got to know after reading the book of GoF in his next project.&lt;/p&gt;
&lt;p&gt;But let’s get back to the discussion of the perfect code. Approach to the correct programming depends on many factors: on purpose, terms, team, etc. I’d like to review several types of projects that have absolutely different purposes. Let’s think to what extent the code should be clear and to what extent the architecture should be elaborated in each case. We will see patterns used in some projects that are inappropriate in other projects. Next time when you got outraged by some advice in a development related article, you should first think what purpose an author had. Maybe this is not advice that is bad, and just your project differs from the author’s one. So, let’s start.&lt;/p&gt;
&lt;h2 id=&quot;project-size&quot;&gt;Project size&lt;/h2&gt;
&lt;h3 id=&quot;small-projects&quot;&gt;Small projects&lt;/h3&gt;
&lt;p&gt;For example, there is one man who develops the project for several days. It is some simple utility that solves a small separate task. Most likely it won’t be actively developed and transformed into something big. You can keep in mind all system elements (and even variables) in such projects. You don’t need sophisticated architecture in this project: if you get a task that can be resolved with a two code lines patch, you better do it. Of course, you can spend two days to develop a complicated architecture that will be convenient to use when new simple tasks arise. But there is a nuance: these simple tasks will hardly appear in such a small project while time has been already spent. In this situation, you don’t need to think about writing the perfect code. You shouldn’t write explicitly bad code as well, just do it right.&lt;/p&gt;
&lt;h3 id=&quot;medium-size-projects&quot;&gt;Medium size projects&lt;/h3&gt;
&lt;p&gt;Assume we’ve got a team of 5-6 developers and the project for several months. You can’t dabble here; it’s necessary to think over the system and structure the complete code. It’s better to control the amount of workarounds. Developers can spend some time for initial research, analysis and design, but not too much. It’s good if you manage to create an ideal plan for development of the ideal system by the deadline, but it’s even much better to develop not a very ideal but working system. At worst, if everything goes wrong, it’s not that difficult to re-design the whole architecture by all team members (I had to do it for several times, it’s not that horrible). If this is a custom development project, a customer will pay not for the wonderful code, but for working features implemented in time. Don’t forget about it.&lt;/p&gt;
&lt;h3 id=&quot;big-projects&quot;&gt;Big projects&lt;/h3&gt;
&lt;p&gt;And now we have dozens of developers and the project will be developed for several years. And here it’s better to think over the architecture carefully from the very beginning. If there is a need for a workaround then maybe it’s better to re-design the architecture on early stages in the way that new features fit into it seamlessly. Every improper line of code written now will turn into great sufferings in a year or two. Read books about clear coding and correct architecture; they contain much advice that will come in handy. You just need to use it correctly, not everywhere. I like a story from the Martin Fowler’s book: Fowler did some consulting for a company that developed quite a big project. The project code was terrible and Fowler insisted on a slight refactoring. In a couple of days, they managed to get rid of half code without any damage to the system functionality. Programmers were very glad, but executives were not that happy since this work didn’t result in new features. The old code worked and its optimization didn’t seem economically viable. That is why further consulting recommendations were not followed by the executives. They forced sooner development of new features without any additional work on the code. In half a year the project was closed as the code became too complicated to maintain.&lt;/p&gt;
&lt;h2 id=&quot;project-maintenance&quot;&gt;Project maintenance&lt;/h2&gt;
&lt;h3 id=&quot;projects-without-maintenance&quot;&gt;Projects without maintenance&lt;/h3&gt;
&lt;p&gt;Activity that is well known by various freelancers and outsourcers. After the project is delivered you will never remember all this horror hidden under the car hood. Deep in your mind, you hope that they will just use the project and no one will ever review the source code. And this is an acceptable approach, since we are required to provide a working application, but not the perfect code. In the very beginning of the project you can afford designing architecture, writing correct code. But when there is just two days till the deadline and only half of features are implemented, it’s not about lofty matters. It’s allowed to add any workarounds, infringe all imaginable approaches to good code. And this is ok in this case. I don’t say this is good and don’t guide to make it in this way. But this is normal. Here we talk about programming not as about art, here we talk about the project that should be delivered in time and that won’t be maintained. If you start writing everything ideally, you get a risk to exceed the time frame. You will quit on the customer, won’t get money, loose your time and code won’t be demanded by anyone. You should always remember about the purposes.&lt;/p&gt;
&lt;h3 id=&quot;maintained-projects&quot;&gt;Maintained projects&lt;/h3&gt;
&lt;p&gt;And here I would write the good code, get right architecture and clear code. This is such a wonderful feeling when a customer asks you to add some sophisticated feature and you cope with this task in an hour. And this is because new code can be easily added to the project since it is ideally laid on the existing architecture. It’s so easy to work with the existing code base; the code is understandable and easy-to-orientate. And there is another feeling when a customer asks to add some minor feature (the customer is just absolutely sure this is a minor feature and easy to add) and you look at the classes cacophony, try to estimate how many days you would spend on this minor functionality, but for some reason you don’t even want to touch the keyboard. You can’t even look at this code.&lt;/p&gt;
&lt;h2 id=&quot;project-publicity&quot;&gt;Project publicity&lt;/h2&gt;
&lt;h3 id=&quot;in-house-projects&quot;&gt;In-house projects&lt;/h3&gt;
&lt;p&gt;You create a project for you or your team and won’t make it public. In this case you are allowed a lot of things. No one makes you digress from your ideals in software development, but if you want to, you can – there is nothing improper. There is no need to create detailed documentation, you can write comments in your native language (if everyone engaged in the project understands it), and some complicated architectural solutions can be explained to your team members orally. I don’t say that you should certainly do it in this way. But if you are in a hurry some good practices can be ignored.&lt;/p&gt;
&lt;h3 id=&quot;public-projects&quot;&gt;Public projects&lt;/h3&gt;
&lt;p&gt;Here is an absolutely different situation. Here you need to document your project properly, so that you don’t get hundreds of questions from your customers every day. And you better write comments in English to make it easy for everyone to understand them. If you have an API, you better think over it; don’t add some interface which will allow you to get all necessary data only if you really need to. Remember that the project belongs not only to you, but also to third party developers. Respect those developers who will work with your code. Write code in the way that won’t make others want to stop you in the dark backstreet and hurt you.&lt;/p&gt;
&lt;h2 id=&quot;specific-projects&quot;&gt;Specific projects&lt;/h2&gt;
&lt;h3 id=&quot;highload-projects&quot;&gt;Highload projects&lt;/h3&gt;
&lt;p&gt;Highload is a separate matter. In practice, you have to sacrifice a lot of things including good architecture and understandable code for high productivity. Sometimes you may want to cry when you look at what your cozy project turned to after optimization. But what can you do? Instead, program execution time reduced twice. Sometimes you don’t have a choice.&lt;/p&gt;
&lt;h3 id=&quot;projects-using-third-party-libraries&quot;&gt;Projects using third-party libraries&lt;/h3&gt;
&lt;p&gt;When I talk about third-party libraries some my associates start looking at me understandingly. I see in their faces – they suffered in the same way. In real conditions of the big project you will hardly develop absolutely all functionality. There are usually quite common tasks that have been already solved by someone. In this situation it’s reasonable to use a ready-made solution than to reinvent the wheel. This is it, but sometimes it appears that authors of this ready solution are not good programmers. Their project solves its main task, but it’s developed…not really professionally. And integrating it into your project is… not really easy. This circumstance makes you add terrible kludges spoiling your fine architecture. But this is an operational need since it’s not cost-effective to implement this functionality on your own. (I will tell you in secret, several times I couldn’t bear it and developed my own library instead of using the third-party one. But this is an exception, not a rule.)&lt;/p&gt;
&lt;h3 id=&quot;project-of-newbie-developers&quot;&gt;Project of newbie developers&lt;/h3&gt;
&lt;p&gt;You can often hear that an average developer should know this and that. It’s assumed that a developer knows some programming language (if we talk about OOP-language, he should at least know polymorphism and inheritance), he can understand complex syntax constructions, basic platform mechanisms, he knows common patterns (when he sees a class named Visitor, he will immediately understand the definite system part), he easily reads comments in English and can do much more things. But before becoming an average developer everyone was a newbie developer. And nowadays there are a lot of people who begin to study this science. And this is ok that they don’t know and can’t do a lot of things. This is a usual situation when some novice developers form a team and start developing a project. They learn many new tricks while developing the project. Of course they will do a lot of things in improper way. And you shouldn’t expect the opposite. It would be good if senior colleagues help with different issues: how to re-write code in a better way, what books to read, etc. But you shouldn’t specify the same requirements as to senior staff. Junior developers’ project may have lots of deviation from “how it should be” as they are just studying. Advice and recommendations are good while the requirement to write an ideal architecture from the first time is not that good.&lt;/p&gt;
&lt;h2 id=&quot;non-production-projects&quot;&gt;Non-production projects&lt;/h2&gt;
&lt;h3 id=&quot;demo-projects&quot;&gt;Demo projects&lt;/h3&gt;
&lt;p&gt;Sometimes I have to create demo projects to show some great features to my associates. It can be language, engine, library or something else they haven’t seen before. As a rule, the project should be detailed and simple with lots of comments. In some cases there are tens of lines of comments for a single line of code and this is ok. You don’t write the perfect code, you just use the code as illustration. At the same time the code can be very bad and execute for too long. It doesn’t matter as we have a different purpose to demonstrate some technology to the public.&lt;/p&gt;
&lt;h3 id=&quot;research-projects&quot;&gt;Research projects&lt;/h3&gt;
&lt;p&gt;In this project, we don’t show anything to anyone. We want to understand some new interesting feature by ourselves. Let’s say we examine some algorithm. It’s ok to write 10 versions of the algorithm side by side. Probably, versions will be in different languages. It will be ok not to care about the agreement on names (that is good to follow when creating a real project) and to name the same things in the same way – by names set in the book. It doesn’t matter what’s the common practice in this or that language. We examine the algorithm; we don’t care about such things right now. If you are going to show the result to someone else you should work over the code, but this is another story. And while you are on the research stage your main purpose is the research, not the perfect code. Of course, you can combine these things, but this is not obligatory. The main thing is not to substitute the academic purpose with the perfect code purpose.&lt;/p&gt;
&lt;h3 id=&quot;local-projects&quot;&gt;Local projects&lt;/h3&gt;
&lt;p&gt;Many developers can say that it is necessary to get used to write good code everywhere. But local code has some specific, you don’t need to show it to anyone, you don’t need to report to anyone, you can be guided by your own ideas in development. There can appear a lot of bad intermediate code in the workflow. You can play with the platform, make some experiments. You can develop in the way convenient for you. You can create some data dump regardless of the general architecture and just save it to a local file from the most unacceptable place. It’s possible to write any amount of comments in any language, if this is more convenient for you.&lt;/p&gt;
&lt;p&gt;But remember that the situation changes when the creative process ends and you need to show the results to others (send local developments to the central repository). You need to clear the code in this case. All the experiments, kludges and excessive comments should be removed. Respect developers who will have to understand your writings.&lt;/p&gt;
&lt;h3 id=&quot;prototype-projects&quot;&gt;Prototype projects&lt;/h3&gt;
&lt;p&gt;The main purpose of such projects is to quickly create some features to get the idea how they will look like. This is a reasonable approach. Let’s say we have 5 different implementations: we will chuck together a common concept of each variant. After that you will be able to examine all approaches on live samples and choose the one that will be used in the main project. It’s important to understand prototyping tasks. You don’t need to clear this code, you don’t need to write it ideally. I am always impressed by people who criticize a prototype with the following statements: “this variable could be named in a more understandable manner” or “it would be good to move this interface button 1 pixel to the left”. Does it matter how the variable is named? This is a prototype, back off. Such discussion is reasonable for a finished project, but it has no sense for a prototype.&lt;/p&gt;
&lt;h3 id=&quot;entertainment-projects&quot;&gt;Entertainment projects&lt;/h3&gt;
&lt;p&gt;I remember that once I and my friends decided to make a birthday present to a good man. We created a Java project which represented in OOP his life, friends and other interesting things he interacts with. The program really worked, it was possible to execute some funny commands from the console. As to the source code, absolutely all names (classes, methods, variables, etc.) were written in Russian (Java allows such tricks). Javadoc was also written in Russian and didn’t contain any useful information. Logic was implemented in the simplest way. We used the simplest algorithms instead of the complicated ones. Architecture wasn’t too pretty; we even didn’t try to think over it.&lt;/p&gt;
&lt;p&gt;And the present worked out, though we haven’t used any good practice of writing the perfect code. And the matter is in absolutely different purposes of the project.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Once again I would like to draw your attention to main ideas. If you want to become a good programmer, you should develop, learn to write better code, work to improve yourself. You should try to write as clear and good code as possible. But you need to understand that your code will never be ideal in a big project. You shouldn’t admit bad code; write it in the way that you won’t be ashamed of. At the same time don’t forget about the project purpose since in most cases the perfect code is not the purpose, but means to reach it. It’s not necessary to intentionally write bad code, but show no fanaticism about the perfect code as well. Remember about your purposes and situation. It’s not that easy to write good code. Compare your effort spent for code improvement and the result it will get. If you read a good article about the good code, don’t extract separate pieces of advice that you will use everywhere without a second thought. Pay attention to the context of the given advice. Think of the situation described in the article. Think when it’s appropriate to use known patterns and when it’s not. And in general, think more, it’s very useful in programming. And everything will be ok for you.&lt;/p&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/perfect-code-and-real-projects-part-1/&quot;&gt;blogs.perpetuumsoft.com, Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/perfect-code-and-real-projects-part-2/&quot;&gt;blogs.perpetuumsoft.com, Part 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Комментировать или не комментировать?</title>
            <link>http://aakinshin.net/ru/posts/comments/</link> 
            <pubDate>Wed, 28 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/comments/</guid>
            <description>&lt;p&gt;&lt;em&gt;По-настоящему хороший комментарий — тот, без которого вам удалось обойтись. &#169; Дядюшка Боб&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dev/refactoring/front.png&quot; height=&quot;250px&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;В последнее время меня стали очень утомлять оживлённые дебаты о том, нужно ли комментировать код. Как правило, по одну сторону баррикад — самоуверенные джуниоры, имеющие непререкаемую позицию вида &lt;em&gt;&#171;А как же его не комментировать, ведь без комментариев непонятно будет!&#187;&lt;/em&gt;. По другую — умудрённые опытом сеньоры. Они понимают, что если возможно обойтись без комментариев, то &lt;em&gt;&#171;Лучше бы, чёрт возьми, так и сделать!&#187;&lt;/em&gt;. Наверное, у многих жажда комментировать идёт со студенческой скамьи, когда товарищи преподаватели заставляли комментировать каждую строчку,
&lt;em&gt;&#171;чтобы студент лучше разобрался&#187;&lt;/em&gt;. В реальном проекте не должно быть кучи комментариев, которые только и делают, что засоряют код. Впрочем, я не агитирую вообще не писать комментарии, но если вам удалось написать такой код, который не требует пояснений, то расценивайте это как свою маленькую победу. Сразу хотелось бы сослаться на несколько очень умных книжек, на основе которых формировалась моя позиция. Я люблю и уважаю авторов этих работ, полностью разделяя их мнение.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ozon.ru/context/detail/id/5508646/&quot;&gt;С. Макконнелл, &#171;Совершенный код. Мастер-класс&#187;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ozon.ru/context/detail/id/20216991/&quot;&gt;Р. Мартин, &#171;Чистый код. Создание, анализ и рефакторинг&#187;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ozon.ru/context/detail/id/8466390/&quot;&gt;Д. Босуэлл, Т. Фаучер, &#171;Читаемый код, или Программирование как искусство&#187;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;Итак, что же меня так раздражает в комментариях? Приведу несколько основных тезисов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Комментарии захламляют непосредственный код, ухудшают его читаемость&lt;/li&gt;
&lt;li&gt;Комментарии требуют время на написание и поддержку&lt;/li&gt;
&lt;li&gt;Комментарии лгут (начинаем от криво написанных, заканчиваем устаревшими)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;В принципе, я согласен с тем, что в некоторых случаях комментарии всё-таки нужны. Но ваш код будет тем прекраснее, чем будет меньше таких случаев. Кроме того, написание хорошего комментария — это тоже искусство. Увы, им обладают не так много программистов, большинство пишут комментарии абы как. Польза от этого зачастую сомнительная. А чем тратить время и силы на написание хорошего грамотного комментария, не лучше ли потратиться на переписывание кода, чтобы он больше не требовал комментария?&lt;/p&gt;
&lt;p&gt;Давайте обсудим некоторые типичные сценарии, в которых можно сказать что-нибудь определённое про надобность комментария. Примеры кода я привожу на C#, но для данной темы это не принципиально.&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;Когда без комментариев можно обойтись&lt;/h2&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Комментарии, которые повторяют код&lt;/h3&gt;
&lt;p&gt;Давайте взглянем на код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Этот метод отвечает за подсчёт суммы элементов массива
public int CalcSumOfElement(int[] elements) // Метод принимает на вход массив элементов
{
  int result = 0; // Заводим специальную переменную под результат
  int n = elements.Length; // Узнаём длину массива, т.е. количество элементов
  for (int i = 0; i &amp;lt; n; i++) // Запускаем цикл по всем элементам
    result += elements[i]; // Прибавляем к результату очередной элемент
  return result; // Возвращаем результат
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот пример, конечно, искусственный, но, увы, я не утрирую. Я действительно не раз встречал подобный код. В данном примере комментарии не несут нам ничего нового — абсолютно всё и так понятно из кода. Но при этом прочитать этот код без захламляющего комментирования намного проще. Я уж не говорю про развитие кода: поддерживать такой уровень комментирования очень утомительно. Скорее всего при усложнении функционала половина кода останется вообще без комментариев, а другая — с кривыми устаревшими комментариями.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Комментарии, которые поясняют синтаксис&lt;/h3&gt;
&lt;p&gt;Ну, а вот такой пример:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Item
{
  private int value; // Это приватное поле, извне оно не доступно

  // Это конструктор
  public Item(int twoValue)
  {
    value = twoValue &amp;gt;&amp;gt; 1; // Два знака больше означают побитовый сдвиг вправо
    // таким образом мы делим число на два
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если это лабораторная работа первокурсника, то всё нормально. А вот если это продакшн код, и ваши программисты нуждаются в таких комментариях, то у меня для вас плохие новости. Наверное, эта статья не для вас.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Комментарии, которые поясняют стандартные классы&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;HashSet&amp;lt;int&amp;gt; set; // Это структура данных, которая называется Хеш-Сет
// Она представляет собой множество элементов
// Мы очень быстро можем узнать, есть ли элемент в этом множестве или нет
// Подробнее про хеш-таблицы можно почитать в википедии: http://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если программист действительно не знает назначение какого-то стандартного класса или метода, то он всегда может погуглить / почитать документацию / спросить у товарища. А большинство нормальных программистов скорее всего и так всё знает. Поэтому польза таких комментариев ну очень сомнительна.&lt;/p&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Комментарии, которые компенсируют плохие наименования&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Устанавливаем соединение с сервером
// public void DoIt()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Я согласен, что далеко не всегда удаётся придумать хорошее название для класса/метода/свойства/переменной. А если проект сдавать вчера, то времени на придумывание красивого названия просто нет. А давайте возьмём какое-нибудь произвольное название, а в комментарии объясним то, что происходит. Это же намного проще и быстрее! Или же всё-таки вы найдёте минутку-другую на придумывание понятного названия?&lt;/p&gt;
&lt;h3 id=&quot;section-5&quot;&gt;Комментарии, которые объясняют абзац&lt;/h3&gt;
&lt;p&gt;Часто приходится слышать подобные заявления: &lt;em&gt;&#171;Не, ну этот метод занимает 300 строк, он очень много всего делает. Без комментариев в нём не разобраться. Сейчас я напишу перед каждыми 10-строчками о том, что в них делается&#187;&lt;/em&gt;. Если действительно дела обстоят так, то, возможно, что-то вы делаете не так. Возможно, стоит разбить большой 300-строчный метод на несколько маленьких методов. И каждому маленькому методу дать понятное название — тогда и комментарии будут не нужны.&lt;/p&gt;
&lt;h3 id=&quot;section-6&quot;&gt;Комментарии, которые поясняют константы&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public int GetSeconds(int hours)
{
  return hours * 3600; // 3600 - это количество секунд, образующих час
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, в таком варианте, наличие комментария — это более адекватный вариант, чем просто магическое число, которое закралось в код и непонятно что обозначает. Но ещё лучше бы было сделать именованную константу, из названия которой всё было бы понятно. Например, так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int SecondsInHour = 3600;
public int GetSeconds(int hours)
{
  return hours * SecondsInHour;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-7&quot;&gt;Комментарии, которые не относятся к программированию&lt;/h3&gt;
&lt;p&gt;Мне очень нравится байка из &#171;Совершенного кода&#187; про то, как один программист всю ночь пытался расшифровать вот такой комментарий.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;MOV AX, 723h ; R. I. P. L. V. В. 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А несколько месяцев спустя он встретился с автором этого кода и узнал, что комментарий расшифровывается следующим образом: &#171;Rest in peace, Ludwig van Beethoven&#187;, т.к. 723 — это шестнадцатеричное представление года смерти Бетховена.&lt;/p&gt;
&lt;p&gt;Увы, некоторые программисты считают программный код своеобразным форумом, в котором можно общаться. Некоторые пытаются проявить своё остроумие (чуть ли не анекдоты рассказывают), другие пытаются нам что-то рассказать о себе (типа &lt;em&gt;&#171;Сейчас уже три часа ночи, но я всё равно пишу этот класс, ведь я так люблю программировать&#187;&lt;/em&gt;). Не нужно так делать, для общения есть сотни других способов. Если комментарий вставлен в код, то он должен нести в себе что-то полезное для проекта.&lt;/p&gt;
&lt;h3 id=&quot;section-8&quot;&gt;Комментарии, которые содержат мысли&lt;/h3&gt;
&lt;p&gt;Бывает, что в комментарии содержатся очень умные мысли, от которых много проку. Но в большинстве случаев это совсем не так.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Main()
{
  // Ну, это очень полезный метод.
  // Он выполняет основную логику этого класса.
  // Сначала я хотел назвать его Run.
  // Но потом подумал, Run переводится &#171;бежать&#187;.
  // А этот метод никуда не бежит, он очень медленный.
  // Я думал об этом, пока мыл посуду.
  // И когда я её домыл, я вернулся к компьютеру и переименовал метод в Main.
  // Ведь это главный метод данного класса, пусть он называется Main.
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-9&quot;&gt;Комментарии, которые содержат примеры использования&lt;/h3&gt;
&lt;p&gt;Иногда автор метода не уверен, что все правильно поймут, как пользоваться его методом. И тогда он приводит примеры использования, которые как бы говорят, что вернёт метод на определённых входных данных.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Sum(1, 2) == 3
// Sum(2, 1) == 3
// Sum(2, 2) == 4
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А я так считаю — для каждой задачи должен быть свой инструмент. Для этой задачи люди давно придумали удобный инструмент, он называется Unit-тесты. Очень толковая штука. Нужны ли на самом деле Unit-тесты или нет — также дискуссионная тема. Но если в проекте всё-таки возникла потребность описать для метода примеры возвращаемых результатов, то почему бы просто не сделать соответствующий Unit-тест?&lt;/p&gt;
&lt;h3 id=&quot;section-10&quot;&gt;Комментарии, которые содержат историю написания&lt;/h3&gt;
&lt;p&gt;К счастью, давненько я подобного не видел, но иногда доводится встречать комментарии вида:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// 11.06.13: Исправил багу в методе. Раньше он работал так-то так-то, а теперь работает иначе. // 12.06.13: Ой, та бага — была не бага. Вернул всё обратно.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Повторю ещё раз свою мысль: для каждой задачи — свой инструмент. Системы контроля версий прекрасно умеют хранить историю изменений. Не нужно нагружать исходники никому не нужной историей того, как вы что писали. Если кого-то будет это интересовать, то он всегда может посмотреть в репозитории.&lt;/p&gt;
&lt;h3 id=&quot;section-11&quot;&gt;Комментарии, которые содержат код&lt;/h3&gt;
&lt;p&gt;Эти комментарии меня особенно печалят. Читаешь, скажем, код какого-нибудь хорошего класса. И тут:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// int number = GetNumber()
// int number = 4;
// int number = 5;
int number = 4;
// double number = 4.5;
// decimal number = 4.5;
// string number = &amp;quot;Это число&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот что этим хотел сказать автор? Некоторые авторы хотят этим сказать: я провожу эксперименты по изменению кода, но при этом не хочу терять старые версии этих строчек, вдруг к ним придётся вернуться. Этот тезис возвращает нас к мысли про репозиторий, который умеет хранить все промежуточные версии вашей писанины — никуда они не пропадут. Пожалейте других разработчиков, которые будут читать ваш код. А хуже всего, что этот код в проекте теперь надолго. Автор после кучки экспериментов забывает удалить плохие версии, а его коллеги опасаются бездумно удалять то, назначение чего непонятно: &lt;em&gt;&#171;я вот сейчас всё удалю, а потом окажется, что оно было ну очень нужно, тут был великий замысел, а я всё испортил&#187;.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;section-12&quot;&gt;Комментарии, которые непонятны&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;bool flagA = true;
bool flagB = false;
bool flagC = true;
if (Condition(flagA, flagB, flagC))
  Foo();
// else флаг равен true, выключение сервера
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В подобных случаях никогда нельзя догадаться, что хотел сказать автор. Какой флаг равен true? Он всегда равен true в else-ветке или тут нужно дописать код, в котором нужно присвоить флагу значение true. А что за сервер, почему он выключается? Он выключится сам или нам нужно самим его выключить?&lt;/p&gt;
&lt;p&gt;От подобных комментариев вреда больше, чем пользы. Сведений он в себе по факту не несёт, а вместо этого только смущает читателя. Не смущайте читателя вашего кода! Или не пишите ничего вовсе, или потратьте время на написание доходчивого сообщения, которое всем будет понятно.&lt;/p&gt;
&lt;h3 id=&quot;section-13&quot;&gt;Комментарии, которые содержат ну очень много текста&lt;/h3&gt;
&lt;p&gt;Некоторые комментаторы очень боятся быть непонятыми. Ну, или написать слишком мало. Поэтому комментарий к методу из трёх строчек может занимать несколько экранов. В этом обширном сочинении вы узнаете об используемых алгоритмах, их временной сложности, почитаете псевдокод метода, блок-схему в ASCII-графике, обоснование именования переменных, соображения общего характера. Причём всё будет расписано настолько подробно, чтобы даже первоклассник понял.&lt;/p&gt;
&lt;p&gt;Это плохой подход, он заставляет тратить читателя очень много времени на изучение вашего сочинения. Если вы уж решили писать комментарий, то вам следует озаботиться его лаконичностью (разумеется, не в ущерб понятности или информативности).&lt;/p&gt;
&lt;h3 id=&quot;section-14&quot;&gt;Комментарии, которые врут&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;// Произведение двух чисел
public int Sum(int a, int b)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вы опять смущаете вашего читателя. Что тут происходит? Возможно, метод когда-то считал произведение, а потом его переделали в сумму, комментарий стал устаревшим. А может, наоборот: комментарий обновили, а про название метода забыли. А может, метод с самого начала считал сумму, а программист ошибся при комментировании. Но как бы то ни было, если метод на самом деле очень сложный, придётся потратить много времени, чтобы разобраться, какая из черепашек обманывает.&lt;/p&gt;
&lt;h2 id=&quot;section-15&quot;&gt;Когда можно и прокомментировать&lt;/h2&gt;
&lt;h3 id=&quot;section-16&quot;&gt;Комментарии, которые повышают уровень абстракции&lt;/h3&gt;
&lt;p&gt;Предметная область может быть очень сложна, не всегда возможно подобрать краткие названия для классов, из которых сразу будет понятно, чему они соответствуют. Поэтому вполне нормально подобрать какой-нибудь ёмкий термин для обозначения сложной сущности предметной области. Основные программисты команды и так его наизусть знают, а вот для новичков можно составить краткий комментарий, из которого всё сразу станет понятно.&lt;/p&gt;
&lt;h3 id=&quot;section-17&quot;&gt;Комментарии, которые объясняют необъяснимое&lt;/h3&gt;
&lt;p&gt;Увы, не всегда удаётся написать код, который понятен сам по себе. Возможно, используется очень хитрый алгоритм. Возможно, из-за требований к скорости пришлось написать быстрый, но не очень понятный код. Возможно, проект нужно сдавать вчера, и у вас просто нет времени &#171;причёсывать&#187; код. Не важно как, но в вашем проекте появился код, который ну очень трудно понять. Если с комментарием код становится более читаемым, то пусть этот комментарий действительно присутствует в проекте.&lt;/p&gt;
&lt;h3 id=&quot;todo&quot;&gt;Комментарии, которые TODO&lt;/h3&gt;
&lt;p&gt;Вопрос опять-таки дискуссионный. Одни скажут, что есть IssueTacker, давайте все задачи хранить там. Другие скажут, что зачем нам создавать много мелких Issue, когда можно просто расставить комментарии специального вида, которые будут обращать внимание разработчиков на то, что тут надо бы дописать функционал. Благо, современные IDE умеют находить все TODO-комментарии и выдавать их большим красивым списком, так что не нужно бояться потерять подобные инструкции на будущее. Нужно сразу договориться в команде о том, какая методология будет использоваться. Многие программисты считают TODO-комментарии очень удобными, ничего особо криминального в их использовании нет.&lt;/p&gt;
&lt;h3 id=&quot;section-18&quot;&gt;Комментарии, которые обращают внимание&lt;/h3&gt;
&lt;p&gt;Иногда в коде появляются какие-то важные моменты, на которые обязательно нужно обратить внимание читателя, но средствами кода это сделать не удаётся. Например, нужно предупредить читателя, что метод выполняется очень долго. Или, класс сейчас активно разрабатывается и рефакторится несколькими людьми, в нём есть какой-то невзрачный кусок кода, который так и хочется удалить или переписать. Но лучше бы этого не делать, т.к. на самом деле он очень важный, без него всё сломается. В общем, если есть какие-то важные, но не особо очевидные аспекты вашего кода — можно и прокомментировать, лишним такой комментарий не назовёшь.&lt;/p&gt;
&lt;h3 id=&quot;section-19&quot;&gt;Комментарии, которые документируют&lt;/h3&gt;
&lt;p&gt;Многие генерируют документацию на основе комментариев специального вида (такой подход используется во многих языках). Есть и другие инструменты по созданию документации без комментариев, но в силу разных обстоятельств в некоторых проектах принципиально использовать именно комментарии для документирования, тут уж никуда не деться. Но тут речь идёт скорее о публичном API, а не о private-методе во внутреннем проекте. В команде должна быть договорённость о том, когда и где будет использоваться подобный подход к документации. Ваше время очень ценно, не следует его тратить на создание такой документации, которая никогда никем не будет использоваться.&lt;/p&gt;
&lt;h3 id=&quot;section-20&quot;&gt;Комментарии, которые содержат юридическую информацию&lt;/h3&gt;
&lt;p&gt;В ряде проектов необходимо в каждый файл с кодом вставлять шапку-комментарий с информацией о копирайте, лицензии и т.п. Ну, если надо — то надо, обсуждения тут излишни.&lt;/p&gt;
&lt;h2 id=&quot;section-21&quot;&gt;Резюме&lt;/h2&gt;
&lt;p&gt;Ещё раз хотелось бы акцентировать внимание на основной мысли: хоть я и настаиваю на уменьшении количества комментариев, это вовсе не означает, что комментарии — абсолютное зло, которое никак не должно появляться в проекте. Если вы можете обосновать необходимость комментария в данном месте, если без него не обойтись, если вы можете его составить грамотно и лаконично — то пожалуйста, пишите комментарий, ведь вы делаете исходный код более информативным. Но, увы, в реальности большинство комментариев не несут в себе особой пользы, а лишь захламляют исходники. Если ваши руки потянулись к написанию ещё одного &lt;em&gt;отличного&lt;/em&gt; комментария, то сначала дайте себе немного времени на раздумье — а действительно ли этот комментарий такой &lt;em&gt;отличный&lt;/em&gt;, а нельзя ли без него как-нибудь обойтись.&lt;/p&gt;
&lt;p&gt;Хочется заметить, что в реальных условиях многое зависит от языка программирования, от проекта, от стадии разработки, от соглашений в команде. Возможно, конкретно в вашей ситуации есть необходимость писать много комментариев (это может быть сложный алгоритм, низкоуровневый код, хитрые оптимизации и т.п.). Возможно, вы сейчас пишете локальный код, а с комментариями вам намного удобнее работать над кодом (впрочем, никто не заставляет вас коммитить комментарии в общий репозиторий). Возможно, у вас весь проект на 100 строк, и намного проще поставить несколько комментариев, чем создавать сложную расширяемую архитектуру. В статье я изложил некоторые общие рекомендации для большого проекта на языке высокого уровня, которые могут в будущем избавить вас и ваших коллег от лишней головной боли. Но не нужно относиться к предложенным практикам как к абсолютным правилам: всегда нужно смотреть по ситуации — уместно ли поставить очередной комментарий, нужен ли он тут, или же лучше будет без него. Старайтесь уделять внимание таким моментам — и ваш код будет намного лучше.&lt;/p&gt;
&lt;h2 id=&quot;section-22&quot;&gt;Кросс-посты&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/182574/&quot;&gt;Хабрахабр&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Совершенный код и реальные проекты</title>
            <link>http://aakinshin.net/ru/posts/perfect-code-and-real-projects/</link> 
            <pubDate>Wed, 28 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/perfect-code-and-real-projects/</guid>
            <description>&lt;p&gt;У меня есть проблема — я перфекционист. Я люблю совершенный код. Ведь это не только правильный подход к написанию программ, но и настоящее искусство. От чтения хорошего листинга я получаю не меньше удовольствия, чем от чтения хорошей книги. Проектировать архитектуру большого проекта ничуть не легче, чем проектировать архитектуру большого здания, а в случае хорошей работы — результат не менее прекрасен. Порой меня завораживает то, как изящно переплелись паттерны проектирования в создании совершенной программной системы. Меня восхищает внимание к деталям, когда абсолютно каждый метод настолько прост и понятен, что претендует на место классического примера совершенного кода.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dev/perfect-code-and-real-projects/front.png&quot; height=&quot;200px&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Но, увы, всё это великолепие разбивается о суровую действительность и реальные проекты. Если мы говорим о продакшн-проекте, то пользователей не волнует, насколько красив ваш код и насколько хороша архитектура, их волнует, чтобы проект хорошо работал. Но я всё равно считаю, что в любом случае нужно стремиться писать правильно, просто при этом фанатизма быть не должно. После чтения различных холиваров на тему правильных подходов к написанию кода мне в глаза бросилась одна тенденция: каждый пытается применить означенные подходы не в целом к программированию, а только к своему опыту разработки, к своим проектам. Многие не осознают, что хорошие практики — это не абсолютные правила, которые должны строго соблюдаться в 100% сценариев, это лишь советы о том, как следовало бы поступать в большинстве ситуаций. На каждую хорошую практику всегда можно придумать несколько дюжин примеров, в которых она работать не будет. Но это вовсе не означает, что хорошая практика не такая уж и хорошая, просто её применили не к месту.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Есть и другая проблема — некоторые программисты не настолько хороши, как им кажется. Часто приходится видеть такую ситуацию: подобный разработчик увидел в большой статье про совершенный код какое-то одно соображение (не вникая в контекст) и начал его повсюду применять, отчего код этого разработчика стал значительно хуже. А потом приходится слышать: &lt;em&gt;&#171;вот начитаются тут статей про такие-то подходы, а потом начинают так-то писать&#187;&lt;/em&gt;. А может, виноваты тут вовсе не статьи? Если некоторые программисты криво и не по месту применяют где-то услышанные хорошие практики, то это не значит, что правильные подходы к программированию не нужно обсуждать. Стремление писать хорошо — это похвально, но при этом нужно трезво оценивать свои способности. Для пилотов самолётов описано много манёвров из разряда &#171;высшего пилотажа&#187;, но это вовсе не значит, что каждый начинающий пилот должен все их попробовать в свой первый же полёт. Так и джуниор-программист после прочтения книги банды четырёх не должен в свой следующий проект лепить все несколько десятков паттернов, которые он теперь &#171;знает&#187;.&lt;/p&gt;
&lt;p&gt;Но вернёмся к обсуждению совершенного кода. Подходы к правильной разработке зависят от очень многих факторов: от целей, сроков, команды и т.п. Мне хотелось бы рассмотреть вместе с вами несколько типов проектов, которые резко отличаются друг от друга по своим задачам. Давайте вместе подумаем, насколько код должен быть чистым и насколько должна быть проработана архитектура в каждом из случаев. В одних проектах будут находиться практики, которые в других проектах применять явно не уместно. Когда вы в следующий раз возмутитесь советами в очередной статье про программирование, то подумайте перед вступлением в холивар, а какие именно задачи были у автора. Может, это не советы плохие, а просто проекты автора отличаются от ваших. Итак, приступим.&lt;/p&gt;
&lt;h2 id=&quot;section&quot;&gt;Размер проектов&lt;/h2&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Маленькие проекты&lt;/h3&gt;
&lt;p&gt;Например, имеется 1 человек, который пишет проект несколько дней. Это какая-нибудь мелкая утилита для решения какой-нибудь небольшой отдельно взятой задачи. Скорее всего, она не будет особо развиваться и превращаться в нечто большое. В таких проектах все элементы системы (а может и все переменные) можно удержать в уме. В таком проекте вам не нужна крутая архитектура: если появилась какая-то подзадача, которую можно решить костылём на две строчки, то лучше так и сделать. Конечно же, можно потратить пару дней на выработку сложной архитектуры, которую будет очень удобно использовать при появлении новых сложных подзадач. Но есть нюанс: эти подзадачи вряд ли появятся в маленьком проекте, а время уже будет потрачено. В данной ситуации не стоит особо заморачиваться на написании сверхчистого кода. Быдлокодить тоже не следует, просто старайтесь писать нормально.&lt;/p&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Средние проекты&lt;/h3&gt;
&lt;p&gt;Допустим, у нас уже 5-6 человек и проект на несколько месяцев. Тут уже особо похалтурить не получится, нужно более или менее продумать систему, структурировать весь код. Лучше бы следить, чтобы костыли особо не накапливались. Можно потратить какое-то время на предварительный анализ и проектирование, но не сильно много. Это похвально, если до дедлайна вы успеете составить идеальный план построения идеальной системы, но лучше бы вы успели написать не особо идеальную, но работающую систему. На худой конец, если всё пошло не так, то за несколько дней совместными усилиями не так уж и сложно всю архитектуру переделать. ( &lt;i&gt;Мне приходилось несколько раз поступать подобным образом, это не так страшно.&lt;/i&gt;
) Если это, скажем, проект на заказ, то заказчик будет вам платить не за чудесный код, а за рабочий функционал, реализованный в срок. Не стоит об этом забывать.&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Большие проекты&lt;/h3&gt;
&lt;p&gt;А теперь у нас несколько десятков человек и проект, который будет писаться несколько лет. Вот тут бы лучше бы нам очень хорошо продумать архитектуру с самого начала. И если появилась потребность вставить костыль, то, возможно, стоит на ранних этапах переделать архитектуру так, чтобы новая функциональность красиво в неё вписалась. Каждая халтура, сделанная сейчас, обернётся ужасными страданиями через год-другой. Читайте книги про чистый код и правильную архитектуру — там много советов, которые вам пригодятся. Только их нужно применять по месту, а не везде подряд.&lt;/p&gt;
&lt;p&gt;Мне очень нравится байка из &lt;a href=&quot;http://www.ozon.ru/context/detail/id/1308678/&quot;&gt;книжки Мартина Фаулера&lt;/a&gt;: Фаулер занимался консультированием одной фирмы по разработке достаточно большого проекта. Проект был написан ужасно, и Мартин настоял на небольшом рефакторинге. После пары дней работы удалось удалить половину кода без какого-либо ущерба для функциональности системы. Программисты очень радовались, а вот начальство не было довольно — ведь эта работа не привела к появлению нового функционала. Старый код прекрасно работал, деятельность по его &#171;чистке&#187; не казалась экономически оправданной. Поэтому последующим советам руководство не вняло, настаивая на скорейшем появлении нового функционала без какой-либо дополнительной работы над кодом. Через полгода проект закрылся, т.к. код стал слишком сложным для поддержки.&lt;/p&gt;
&lt;h2 id=&quot;section-4&quot;&gt;Поддержка проекта&lt;/h2&gt;
&lt;h3 id=&quot;section-5&quot;&gt;Проекты без поддержки&lt;/h3&gt;
&lt;p&gt;Деятельность, хорошая знакомая фрилансерам и аутсорсерам. После сдачи проекта вам больше никогда не придётся вспоминать про весь этот ужас, который таится под капотом. В глубине души вы надеетесь, что проектом будут просто пользоваться, а исходники никто никогда не откроет. И это допустимый подход, ведь от нас требуется не замечательный код, а рабочее приложение. В начале проекта вы ещё можете позволить себе попроектировать архитектуру, пописать чистый код, но когда до дедлайна останется два дня, а функционал реализован лишь наполовину, то тут не до высоких материй. Позволительно вбивать любые костыли, нарушать мыслимые и немыслимые подходы к хорошему коду. И в данном случае это нормально. Я не говорю, что это хорошо, я не агитирую всех всегда так поступать. Но это нормально. Тут не идёт речь о программировании как об искусстве, тут идёт речь о проекте, который нужно сдать в срок и не нужно поддерживать. Если вы начнёте писать всё идеальным образом, то вы просто рискуете не уложиться в сроки — вы подведёте заказчика, не получите денег, потратите своё время, а код всё равно окажется никому не нужным. Всегда помните о своих непосредственных целях.&lt;/p&gt;
&lt;h3 id=&quot;section-6&quot;&gt;Проекты с поддержкой&lt;/h3&gt;
&lt;p&gt;А вот тут я бы постарался писать нормально. Чтобы и архитектура нормальная была, и код был чистенький. Это такое прекрасное ощущение, когда заказчик просит добавить какую-нибудь нетривиальную функциональность, а вы справляетесь с задачей за час — ведь новый код добавить легко, поскольку он прекрасно ложится на существующую архитектуру. С уже готовой кодовой базой очень легко работать, код весьма понятен, в нём просто ориентироваться. А есть и другое ощущение, когда заказчик просит сделать какую-нибудь мелочь (а заказчику-то безумно очевидно, что это действительно мелочь, сделать её должно быть очень-очень просто), а вы смотрите на сложившуюся какофонию классов, прикидываете сколько дней нужно потратить на эту мелочь, но к клавиатуре прикасаться уже почему-то не хочется. Да и смотреть на этот код просто противно.&lt;/p&gt;
&lt;h2 id=&quot;section-7&quot;&gt;Масштаб проекта&lt;/h2&gt;
&lt;h3 id=&quot;section-8&quot;&gt;Внутренние проекты&lt;/h3&gt;
&lt;p&gt;Вы пишете проект для себя или своей команды, не собираясь его никому показывать. В этом случае вам позволено очень много вольностей. Никто, конечно, не заставляет вас отклоняться от идеалов к подходам разработки ПО, но если очень хочется, то можно — ничего предосудительного в этом нет. Нет нужды разрабатывать грамотную документацию, комментарии можно писать на родном языке (если его понимают все вовлечённые в разработку лица), а какие-то нетривиальные архитектурные решения (совсем не очевидные из кода) можно на словах объяснить товарищам по команде. Я не говорю, что обязательно нужно так делать. Но если, скажем, вы куда-то очень торопитесь, то некоторыми хорошими практиками можно пренебречь.&lt;/p&gt;
&lt;h3 id=&quot;section-9&quot;&gt;Публичные проекты&lt;/h3&gt;
&lt;p&gt;Тут у нас уже совсем другая ситуация. Лучше бы вам нормально документировать ваш проект, чтобы по нему не возникало каждый день по сотне вопросов от ваших любимых пользователей. И лучше бы писать документацию на английском (как, впрочем, и комментарии). Да и код лучше бы писать почище, чтобы человеку со стороны было легко в нём разобраться. Если же у вас есть API, то хорошо бы его &lt;em&gt;продумать&lt;/em&gt;, а не просто налепить какой-то интерфейс, из которого при большом желании как-то можно вытащить все нужные данные. Помните, что проект принадлежит уже не только вам, но и сторонним программистам — уважайте тех, кто будет работать с вашим кодом. Пишите программу так, чтобы вас потом не хотели поймать в тёмной подворотне и сделать с вами плохие вещи.&lt;/p&gt;
&lt;h2 id=&quot;section-10&quot;&gt;Проекты со спецификой&lt;/h2&gt;
&lt;h3 id=&quot;section-11&quot;&gt;Проекты с высокой нагрузкой&lt;/h3&gt;
&lt;p&gt;Highload — это отдельный разговор. На практике в жертву высокой производительности приходится приносить очень многое, включая хорошую архитектуру и читаемый код. Порой хочется плакать кровавыми слезами, глядя на то, во что превратился ваш уютненький проект после оптимизации. Но что поделать? Зато время работы программы сократилось вдвое. Порой выбирать особо не приходится.&lt;/p&gt;
&lt;h3 id=&quot;section-12&quot;&gt;Проекты с использованием сторонних библиотек&lt;/h3&gt;
&lt;p&gt;Когда я начинаю говорить о сторонних библиотеках, то некоторые мои коллеги начинают смотреть на меня понимающим взглядом. И я вижу по их лицам — они испытали те же страдания, что и я. В реальных условиях большого проекта вы редко будете писать сами абсолютно весь функционал. Обычно попадаются весьма распространённые задачи, которые уже кто-то решал. В данной ситуации намного разумней будет взять готовое решение, чем самому изобретать велосипед. Так-то оно так, но порой оказывается, что авторы этого готового решения не очень хорошие программисты. Их проект справляется со своей основной задачей, но написан он... Ну, не совсем профессионально. И интегрировать его в ваш проект... Ну, несколько сложновато. Это обстоятельство в очередной раз заставляет вас писать ужасные костыли, уродующие вашу милую архитектуру. Но это очередная производственная необходимость, ведь реализовывать этот функционал самостоятельно зачастую бывает нерентабельно. (&lt;em&gt;Скажу по секрету, несколько раз я не выдерживал и писал свою библиотеку вместо сторонней. Но это скорее исключение, чем правило.&lt;/em&gt;)&lt;/p&gt;
&lt;h3 id=&quot;section-13&quot;&gt;Проект команды новичков&lt;/h3&gt;
&lt;p&gt;Часто можно слышать заявление, что любой средний разработчик должен знать то, сё и это. Предполагается, что разработчик неплохо владеет языком (скажем, если речь идёт об ООП-языке, то нужно хотя бы знать что такое полиморфизм и наследование), может без проблем воспринимать сложные синтаксические конструкции, понимает основные механизмы платформы, знает элементарные паттерны проектирования (увидев класс с названием Visitor, он сразу поймёт определённый фрагмент системы), легко читает комментарии на английском и ещё много чего умеет. Но до становления хотя бы средним разработчиком все в своё время были новичками. И на сегодняшний день в мире программирования существует много людей, которые только начинают постигать это ремесло. Вполне нормально, что они не знают и не умеют многих вещей. Вполне нормальна ситуация, когда собираются несколько начинающих программистов и пишут небольшой проект. В процессе разработки они многому научатся. Разумеется, они будут делать многие вещи не совсем правильно. Но от них и не стоит этого ожидать. Хорошо бы, чтобы старшие коллеги подсказывали разные моменты: как переписать код получше, какие книжки почитать. Но именно предъявлять к ним требования наравне с сеньорами не следует. В проекте новичков позволительны очень многие отступления от того &#171;как надо&#187;, ведь они только учатся. Советы и рекомендации — это хорошо, а требование написать с первого раза идеальную архитектуру с идеально чистым кодом — это не совсем хорошо.&lt;/p&gt;
&lt;h2 id=&quot;section-14&quot;&gt;Не-продакшн проекты&lt;/h2&gt;
&lt;h3 id=&quot;section-15&quot;&gt;Демонстрационные проекты&lt;/h3&gt;
&lt;p&gt;Порой мне приходится писать демо-проекты, чтобы показать своим коллегам какие-то клёвые штуки. Это может быть язык, движок, библиотека или ещё что-нибудь, с чем эти люди раньше не сталкивались. Как правило, демо-проект приходится писать очень подробно и просто, обильно снабжая код комментариями. В некоторых отдельных случаях на одну строчку кода может приходиться несколько десятков строк комментариев — и это нормально. Вы не пишите совершенный проект, вы просто используете код, как иллюстрацию. А сам код при этом может быть очень кривым и долго работать, но всё это не важно — ведь главная цель в демонстрации публике некоторой технологии.&lt;/p&gt;
&lt;h3 id=&quot;section-16&quot;&gt;Академические проекты&lt;/h3&gt;
&lt;p&gt;В этом проекте мы уже особо ничего никому не показываем, а сами разбираемся с какой-нибудь интересной штукой. Скажем, изучаем какой-нибудь алгоритм. Вполне нормально написать рядышком 10 версий алгоритма. Возможно, версии будут на разных языках. Вполне нормально будет наплевать на соглашения об именованиях (которые хорошо бы соблюдать при разработке реального проекта) и назвать одинаковые вещи одинаковыми именами — такими, которые указаны в книжке. Да какая разница, как там в каком языке принято писать? Мы тут с алгоритмом разбираемся, сейчас нас не должны волновать такие вещи. Если вы собираетесь показывать кому-то результат, то тут над кодом можно уже поработать, но это будет совсем другая история. А пока вы находитесь в стадии изучения, ваша основная цель — это именно изучение, а не написание совершенного кода. Конечно, эти вещи можно совместить, можно постараться написать самую идеальную реализацию алгоритма, но это вовсе не обязательно. Главное — не подменять основную академическую цель целью совершенного кода.&lt;/p&gt;
&lt;h3 id=&quot;section-17&quot;&gt;Локальные проекты&lt;/h3&gt;
&lt;p&gt;Ну, многие скажут, что нужно сразу привыкать везде писать правильно. Но локальный код обладает своей спецификой — его не нужно никому показывать, нет нужды ни перед кем отчитываться, можно руководствоваться какими-то своими соображениями при разработке. Во время рабочего процесса может возникать много промежуточного плохого кода. Можно поиграться с платформой, провести несколько экспериментов. Можно вести разработку так, как нам удобно. Скажем, можно сделать какой-нибудь дамп данных, не считаясь с общей архитектурой, просто сделав сохранение в локальный файл из самого неподходящего места. В процессе работы можно писать любое количество комментариев на любом языке — если так нам удобней работать.&lt;/p&gt;
&lt;p&gt;Но помните, что ситуация совершенно меняется, когда творческий процесс заканчивается и нужно будет показать свои результаты другим (скажем, отправить локальные наработки в центральный репозиторий). Перед этим код обязательно нужно &#171;причесать&#187;. Все наши эксперименты, костыли и лишние комментарии нужно убрать, оставшийся код сделать максимально понятным и читаемым. Уважайте тех, кто будет разбираться с вашей писаниной.&lt;/p&gt;
&lt;h3 id=&quot;section-18&quot;&gt;Проекты-прототипы&lt;/h3&gt;
&lt;p&gt;Задача таких проектов — по-быстрому накидать определённую функциональность, чтобы стало более понятно, как она будет выглядеть. Это весьма разумный подход. Скажем, есть у нас штук 5 вариантов реализации: мы пробуем кратко накидать общий концепт каждого варианта. После этого можно посмотреть все подходы на живых примерах и выбрать тот, на основе которого будет строиться основной проект. Очень важно правильно понимать задачи прототипирования. Вам не нужно вычитывать такой код, вам не нужно пытаться написать его идеально. Меня всегда печалят люди, которые ругаются на прототип с заявлениями вида &lt;em&gt;&#171;вот эту переменную можно назвать немного понятнее&#187;&lt;/em&gt; или &lt;em&gt;&#171;а вот эту кнопку в интерфейсе хорошо бы подвинуть на 1 пиксель влево&#187;&lt;/em&gt;. Да какая тебе разница, как там переменная названа, это прототип, отстань от него. Такие обсуждения можно проводить уже на готовом проекте, но на уровне прототипа это делать бессмысленно.&lt;/p&gt;
&lt;h3 id=&quot;section-19&quot;&gt;Увеселительные проекты&lt;/h3&gt;
&lt;p&gt;Помню, как-то раз мы с друзьями решили сделать одному хорошему человеку подарок на день рождения. Мы сделали Java-проект, который в ООП-виде представлял его жизнь, его друзей и разные интересности, с которыми он взаимодействует. Причём программа действительно работала, из консоли можно было выполнять разные весёлые команды. Что касается исходного кода, то абсолютно все именования (классы, методы, переменные и т.п.) были написаны на русском (добрая Java позволяет так делать). Javadoc был также написан на русском и не нёс в себе никакой полезной информации. Логика была реализована самым простым способом. Вместо быстрых сложных алгоритмов мы использовали самые простые. Архитектура была не особо красива, ведь мы её даже не пытались продумывать.&lt;/p&gt;
&lt;p&gt;А подарок удался, хоть мы и не использовали ни одной хорошей практики по написанию совершенного кода. А всё дело в том, что цели у проекта были совершенно иные.&lt;/p&gt;
&lt;h2 id=&quot;section-20&quot;&gt;Резюме&lt;/h2&gt;
&lt;p&gt;Хотелось бы ещё раз зафиксировать ваше внимание на некоторых основных мыслях. Если вы хотите стать хорошим программистом, то вы постоянно должны развиваться, учиться писать лучше, расти над собой. Вы всегда должны стараться писать максимально чисто и хорошо. Но нужно понимать, что в большом проекте у вас код никогда не будет совершенным. С говнокодом не следует мириться, пишите так, чтобы вам не было стыдно. Но при этом не забывайте о целях вашего текущего проекта, ведь стремление к совершенному коду в большинстве случаев — это не цель, а только способ её достижения. Намеренно быдлокодить, правда, не нужно, старайтесь всегда писать грамотно, но особого фанатизма тоже проявлять не следует. Помните о своих целях, помните о ситуации, в которой вы находитесь. Написать совершенный код — не так просто. Соизмеряйте усилия на улучшение кода и эффект, который эти улучшения дадут. Если вы прочитали какую-то статью про хороший код, то не нужно вырывать отдельные советы, которые вы всюду ринетесь принимать без лишних раздумий. Обращайте внимание на контекст, в котором эти советы приводятся. Думайте, о какой именно ситуации идёт речь. Думайте, в каких случаях уместно применять известные хорошие в практики, а в каких — не очень. Да и вообще, побольше думайте, в программировании это полезно. И всё у вас будет хорошо.&lt;/p&gt;
&lt;h2 id=&quot;section-21&quot;&gt;Кросс-посты&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/topic/edit/183360/&quot;&gt;Хабрахабр&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Недокументированные ключевые слова C# или превращаем объект в тыкву</title>
            <link>http://aakinshin.net/ru/posts/undocumented-keywords-in-cs/</link> 
            <pubDate>Mon, 26 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/undocumented-keywords-in-cs/</guid>
            <description>&lt;p&gt;Стандартный компилятор C# поддерживает 4 недокументированных ключевых слова: &lt;code&gt;__makeref&lt;/code&gt;, &lt;code&gt;__reftype&lt;/code&gt;, &lt;code&gt;__refvalue&lt;/code&gt;, &lt;code&gt;__arglist&lt;/code&gt;. Эти слова даже успешно распознаются в Visual Studio (хотя, ReSharper на них ругается). Они не даром исключены из стандарта — их использование может повлечь серьёзные проблемы с безопасностью. Поэтому не нужно их использовать везде подряд, но в отдельных исключительных случаях они могут пригодиться. В этом посте я обсужу предназначение недокументированных команд, рассмотрю вопросы их производительности и научусь превращать объект в тыкву.&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Описание ключевых слов&lt;/h3&gt;
&lt;p&gt;Все рассматриваемые слова связаны со структурой &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.aspx&quot;&gt;TypedReference&lt;/a&gt;. Она хранит в себе два поля: указатель на область памяти и тип данных объекта, который расположен по этому указателю. Помимо рассмотренных ниже ключевых слов для операций над этой структурой могут пригодиться методы
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.gettargettype.aspx&quot;&gt;GetTargetType&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.maketypedreference.aspx&quot;&gt;MakeTypedReference&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.settypedreference.aspx&quot;&gt;SetTypedReference&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.targettypetoken.aspx&quot;&gt;TargetTypeToken&lt;/a&gt;,
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.typedreference.toobject.aspx&quot;&gt;ToObject&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Теперь перейдём непосредственно к ключевым словам. &lt;code&gt;__makeref&lt;/code&gt; принимает на входе объект и возвращает &lt;code&gt;TypedReference&lt;/code&gt; ссылку на него. &lt;code&gt;__reftype&lt;/code&gt; и &lt;code&gt;__refvalue&lt;/code&gt;
способны достать из &lt;code&gt;TypedReference&lt;/code&gt; значения двух его полей: тип и значение. Посмотрим простой пример, который поясняет использование ключевых слов:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double value = 10;
TypedReference typedReference = __makeref(value); // typedReference = &amp;amp;value;
Console.WriteLine( __refvalue(typedReference, double)); // 10
__refvalue(typedReference, double) = 11; // *typedReference = 11
Console.WriteLine( __refvalue(typedReference, double)); // 11
Type type = __reftype(typedReference); // value.GetType()
Console.WriteLine(type.Name); // Double
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данный пример развернётся в IL-код, который представлен ниже. Как можно понять, рассмотренные ключевые слова транслируются в IL-команды &lt;code&gt;mkrefany&lt;/code&gt; , &lt;code&gt;refanyval&lt;/code&gt; ,
&lt;code&gt;refanytype&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.maxstack 2
.locals init (
    [0] float64 &#39;value&#39;,
    [1] valuetype [mscorlib]System.TypedReference typedReference,
    [2] class [mscorlib]System.Type &#39;type&#39;)
L_0000: ldc.r8 10
L_0009: stloc.0 
L_000a: ldloca.s &#39;value&#39;
L_000c: mkrefany float64
L_0011: stloc.1 
L_0012: ldloc.1 
L_0013: refanyval float64
L_0018: ldind.r8 
L_0019: call void [mscorlib]System.Console::WriteLine(float64)
L_001e: ldloc.1 
L_001f: refanyval float64
L_0024: ldc.r8 11
L_002d: stind.r8 
L_002e: ldloc.1 
L_002f: refanyval float64
L_0034: ldind.r8 
L_0035: call void [mscorlib]System.Console::WriteLine(float64)
L_003a: ldloc.1 
L_003b: refanytype 
L_003d: call class [mscorlib]System.Type 
          [mscorlib]System.Type::GetTypeFromHandle
          (valuetype [mscorlib]System.RuntimeTypeHandle)
L_0042: stloc.2 
L_0043: ldloc.2 
L_0044: callvirt instance string 
          [mscorlib]System.Reflection.MemberInfo::get_Name()
L_0049: call void [mscorlib]System.Console::WriteLine(string)
L_004e: ret 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__arglist&lt;/code&gt; позволяет создать метод с переменным количеством параметров. Причём это не передача массива объектов через &lt;code&gt;params&lt;/code&gt;, а в чистом виде переменное количество параметров. Получить переданные значения можно через структуру &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.argiterator.aspx&quot;&gt;ArgIterator&lt;/a&gt;. Ниже приведён пример, который иллюстрирует использование команды.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
    Foo(__arglist(1, 2.0, &amp;quot;3&amp;quot;, new int[0]));
}

public void Foo(__arglist)
{
    var iterator = new ArgIterator(__arglist);
    while (iterator.GetRemainingCount() &amp;gt; 0)
    {
        TypedReference typedReference = iterator.GetNextArg();
        Console.WriteLine(&amp;quot;{0} / {1}&amp;quot;, 
            TypedReference.ToObject(typedReference), 
            TypedReference.GetTargetType(typedReference));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И соответствующий IL-код, в котором можно познакомиться с командой &lt;code&gt;arglist&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.method public hidebysig instance void Run() cil managed
{
.maxstack 8
L_0000: ldarg.0 
L_0001: ldc.i4.1 
L_0002: ldc.r8 2
L_000b: ldstr &amp;quot;3&amp;quot;
L_0010: ldc.i4.0 
L_0011: newarr int32
L_0016: call instance vararg void Program::Foo(..., int32, float64, string)
L_001b: ret 
}

.method public hidebysig instance vararg void Foo() cil managed
{
.maxstack 3
.locals init (
    [0] valuetype [mscorlib]System.ArgIterator iterator,
    [1] valuetype [mscorlib]System.TypedReference typedReference)
L_0000: ldloca.s iterator
L_0002: arglist 
L_0004: call instance void 
          [mscorlib]System.ArgIterator::.ctor
          (valuetype [mscorlib]System.RuntimeArgumentHandle)
L_0009: br.s L_0029
L_000b: ldloca.s iterator
L_000d: call instance valuetype 
          [mscorlib]System.TypedReference 
          [mscorlib]System.ArgIterator::GetNextArg()
L_0012: stloc.1 
L_0013: ldstr &amp;quot;{0} / {1}&amp;quot;
L_0018: ldloc.1 
L_0019: call object [mscorlib]System.TypedReference::ToObject
          (valuetype [mscorlib]System.TypedReference)
L_001e: ldloc.1 
L_001f: call class [mscorlib]System.Type 
          [mscorlib]System.TypedReference::GetTargetType
          (valuetype [mscorlib]System.TypedReference)
L_0024: call void [mscorlib]System.Console::WriteLine(string, object, object)
L_0029: ldloca.s iterator
L_002b: call instance int32 [mscorlib]System.ArgIterator::GetRemainingCount()
L_0030: ldc.i4.0 
L_0031: bgt.s L_000b
L_0033: ret 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Поговорим о производительности&lt;/h3&gt;
&lt;p&gt;На StackOverflow есть &lt;a href=&quot;http://stackoverflow.com/questions/4764573/why-is-typedreference-behind-the-scenes-its-so-fast-and-safe-almost-magical&quot;&gt;обсуждение&lt;/a&gt;, в котором утверждается, что якобы работа с &lt;code&gt;TypedReference&lt;/code&gt; осуществляется быстрее, чем упаковка/распаковка. Но бенчмарк у автора очень странный. Плюс, как мне кажется, автор запускал его в Debug mode with debugging — в этом случае действительно могут получиться такие результаты. Но некоторые люди писали в комментариях, что на самом деле упаковка/распаковка работает намного быстрее. Я решил проверить это, составив бенчмарк с помощью &lt;a href=&quot;https://github.com/dotnet/BenchmarkDotNet&quot;&gt;BenchmarkDotNet&lt;/a&gt; v0.5.1 (&lt;strong&gt;Update:&lt;/strong&gt; данный пост был написан в 2013 году, в ту пору BenchmarkDotNet только начинал развиваться. С тех пор библиотека была значительно доработана, API был изменён.):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private const int IterationCount = 10000000;
private int[] array;

public void Run()
{
    array = new int[5];

    var competition = new BenchmarkCompetition();
    competition.AddTask(&amp;quot;MakeRef&amp;quot;, MakeRef);
    competition.AddTask(&amp;quot;Boxing&amp;quot;, Boxing);
    competition.Run();
}

public void MakeRef()
{
    for (int i = 0; i &amp;lt; IterationCount; i++)
        Set1(array, 0, i);
}

public void Boxing()
{
    for (int i = 0; i &amp;lt; IterationCount; i++)
        Set2(array, 0, i);
}

public void Set1(T[] a, int i, int v)
{
    __refvalue(__makeref(a[i]), int) = v;
}

public void Set2(T[] a, int i, int v)
{
    a[i] = (T)(object)v;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Не забывайте, что бенчмарки нужно запускать только в &lt;strong&gt;Release mode without debugging&lt;/strong&gt;. Результаты, которые получились на моём ноутбуке:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;MakeRef : 313ms
Boxing  :  34ms
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У нас имеются классы &lt;code&gt;MyObject&lt;/code&gt;, который содержит одно поле на 64 бита, и &lt;code&gt;Pumpkin&lt;/code&gt;, который содержит два поля по 32 бита. В методе Run выполняются следующие вещи: мы создаём объект &lt;code&gt;myObject&lt;/code&gt;, инициализируем его поле, получаем на него ссылку, а затем создаём &lt;code&gt;pumpkin&lt;/code&gt;, который ссылается на ту же область памяти. В качестве теста мы пробуем поменять значение 64-х битного поля изначально объекта и смотрим на изменение соответствующих полей в тыкве.&lt;/p&gt;
&lt;p&gt;Особый интерес представляют методы &lt;code&gt;GetAddress&lt;/code&gt; и &lt;code&gt;Convert&amp;lt;T&amp;gt;&lt;/code&gt; . Начнём с первого: он получает указатель &lt;code&gt;IntPtr&lt;/code&gt; на переданный объект. В первой строчке всё просто: мы получаем &lt;code&gt;TypedReference&lt;/code&gt; на переданный объект, а вот во второй строчке происходит немного магии. Первое поле &lt;code&gt;TypedReference&lt;/code&gt; хранит &lt;code&gt;IntPtr&lt;/code&gt; -ссылку на наш объект, но явно мы получить эту ссылку не можем. Поэтому мы получаем указатель на наш &lt;code&gt;TypedReference&lt;/code&gt; (который также является указателем на его первое поле), приводим его к указателю на &lt;code&gt;IntPtr&lt;/code&gt; , а потом разыменовываем. В итоге имеем своего рода неуправляемое получение адреса объекта.&lt;/p&gt;
&lt;p&gt;А теперь переходим к методу &lt;code&gt;Convert&amp;lt;T&amp;gt;&lt;/code&gt;. Этот метод должен нам создать объект типа &lt;code&gt;T&lt;/code&gt;, который ссылается на заданную область памяти. В первой строке мы создаём дефолтный экземпляр типа &lt;code&gt;T&lt;/code&gt; . Единственное его предназначение — это получить соответствующий &lt;code&gt;typedReference&lt;/code&gt;, который создаётся во второй строчке. Второе поле полученной структуры указывает на нужный нам тип. Третьей строчкой мы записываем переданный нам адрес в первое поле структуры с помощью уже знакомой нам конструкции
&lt;code&gt;*(IntPtr*)(&amp;amp;typedReference)&lt;/code&gt; . И в последней четвёртой строчке мы собираем из нашей &lt;code&gt;typedReference&lt;/code&gt; структуры готовый объект целевого типа с помощью &lt;code&gt;__refvalue&lt;/code&gt;
. Вуаля: тыква готова.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. Приведённый пример имеет чисто академическое предназначение, он приведён как демонстрация использования заявленных ключевых слов. В продакшн-коде нужно несколько раз подумать, прежде чем решить, что вам действительно необходимы подобные конструкции.&lt;/strong&gt;&lt;/p&gt;</description>
        </item>
        <item>
            <title>Unexpected area to collect garbage in .NET</title>
            <link>http://aakinshin.net/posts/gc-native/</link> 
            <pubDate>Thu, 08 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/gc-native/</guid>
            <description>&lt;p&gt;The .NET framework provides an intelligent garbage collector that saves us a trouble of manual memory management. And in 95% of cases you can forget about memory and related issues. But the remaining 5% have some specific aspects connected to unmanaged resources, too big objects, etc. And it’s better to know how the garbage is collected. Otherwise, you can get surprises.&lt;/p&gt;
&lt;p&gt;Do you think GC is able to collect an object till its last method is complete? It appears it is. But it is necessary to run an application in release mode without debugging. In this case JIT compiler will perform optimizations that will make this situation possible. Of course, JIT compiler does it when the remaining method body doesn’t contain references to the object or its fields. It should seem a very harmless optimization. But it can lead to the problems if you work with the unmanaged resources: object compilation can be executed before the operation over the unmanaged resource is finished. And most likely it will result in the application crash. &lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Let’s reproduce the situation. For a beginning, we will need something unmanaged, for example &lt;a href=&quot;https://code.google.com/p/opencvsharp/&quot;&gt;OpenCvSharp&lt;/a&gt; that is a wrapper for &lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;, a computer vision and image processing library.&lt;/p&gt;
&lt;p&gt;I am talking about this library since I got this irritating issue using it. Have a look the following class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ImageWithCircle
{
  private const int Size = 10000;
  private readonly IplImage image;

  public ImageWithCircle()
  {            
    image = Cv.CreateImage(new CvSize(Size, Size), BitDepth.U8, 3);
    DrawCircle();
  }

  ~ImageWithCircle()
  {
    Console.WriteLine(&amp;quot;~ImageWithCircle&amp;quot;);
    Cv.ReleaseImage(image);
  }

  public void Save()
  {
    Console.WriteLine(&amp;quot;Save start&amp;quot;);
    image.SaveImage(&amp;quot;image.tif&amp;quot;);
    Console.WriteLine(&amp;quot;Save end&amp;quot;);
  }

  public void DrawCircle()
  {
    image.FloodFill(new CvPoint(Size / 2, Size / 2), CvColor.White);
    image.Circle(new CvPoint(Size / 2, Size / 2), Size / 4, 
                 CvColor.Random(), 10);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is quite a simple class responsible for drawing a very big picture with a circle. There is a &lt;code&gt;Save()&lt;/code&gt; method that saves a picture to a file. Logic of the work with a picture is stored in the &lt;code&gt;IplImage&lt;/code&gt; class from OpenCvSharp. Run this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;static void Main()
{
  new ImageWithCircle().Save();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The console will show an expected variant: we started &lt;code&gt;Save()&lt;/code&gt; method and ended it. Only after it garbage was collected and the corresponding finalizer is invoked.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Save start
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now let’s call garbage collection while the picture is being saved. This is just a sample; that is why we won’t invent anything complicated and just enable &lt;code&gt;Timer&lt;/code&gt; that will call &lt;code&gt;GC.Collect()&lt;/code&gt; quite frequently. The picture is very big and we will call garbage collector at least once before it is saved to a file. So, the executable code now looks in the following way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;private static void Main()
{
  var timer = new Timer(100);
  timer.Elapsed += RunGc;
  timer.Start();
  new ImageWithCircle().Save();
}

private static void RunGc(object sender, ElapsedEventArgs e)
{
  Console.WriteLine(&amp;quot;Gc.Collect();&amp;quot;);
  GC.Collect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Probably, you expect to see something of this kind:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if you run the application in release mode without debugging the app will crash:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
~ImageWithCircle

Unhandled Exception: System.AccessViolationException: Attempted to read or write
 protected memory. This is often an indication that other memory is corrupt.
   at OpenCvSharp.CvInvoke.cvSaveImage(String filename, IntPtr image, Int32[] pa
rams)
   at OpenCvSharp.Cv.SaveImage(String filename, CvArr image, ImageEncodingParam[
] prms)
   at ConsoleApplication.ImageWithCircle.Save() in d:\Tests\ConsoleApplica
tion\ConsoleApplication\ImageWithCircle.cs:line 28
   at ConsoleApplication.Program.Main() in d:\Tests\ConsoleApplication\Co
nsoleApplication\Program.cs:line 18
Gc.Collect();
Gc.Collect();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem is that JIT executed its insidious optimization: our object was subject to garbage collection before the picture is completely saved to a file. Unfortunately, OpenCvSharp couldn’t stand it and threw an exception.&lt;/p&gt;
&lt;p&gt;The issue can be easily fixed: it’s just necessary to keep reference to the current picture till the method completes its work. For example, you can use some static object to which the picture will write reference to itself in the beginning of the &lt;code&gt;Save()&lt;/code&gt; method. But I prefer to use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.gc.keepalive.aspx&quot;&gt;GC.KeepAlive&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Save()
{
  Console.WriteLine(&amp;quot;Save start&amp;quot;);
  image.SaveImage(&amp;quot;image.tif&amp;quot;);
  Console.WriteLine(&amp;quot;Save end&amp;quot;);
  GC.KeepAlive(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Actually, it’s not important in what way you will fix the issue; the main thing is to understand how garbage collector works to foresee such problems. They are hard to discover: the application in the sample crashes only with definite start configuration, in case if the garbage collector is able to run while some time-consuming unmanaged method is executed. And if you occasionally get such application crash you will spend much time trying to reproduce it. To avoid such issues it is necessary to carefully design interaction with any native objects trying to foresee probable troubles before the code is written.&lt;/p&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/unexpected-area-to-collect-garbage-in-net/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Неожиданное место для сборки мусора в .NET</title>
            <link>http://aakinshin.net/ru/posts/gc-native/</link> 
            <pubDate>Thu, 08 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/gc-native/</guid>
            <description>&lt;p&gt;Платформа .NET обеспечивает нас высокоинтеллектуальным сборщиком мусора, который избавляет от рутины ручного управления памятью. И в 95% случаев можно действительно забыть про память и связанные с ней нюансы. Но вот оставшиеся 5% обладают своей спецификой, связанной с неуправляемыми ресурсами, слишком большими объектами и т.д. И тут лучше бы хорошо разбираться в том, как производится сборка мусора. В противном случае вас могут ждать очень неприятные сюрпризы.&lt;/p&gt;
&lt;p&gt;Как вы думаете, может ли GC собрать объект до того, как выполнится последний из его методов? Оказывается, может. Правда, для этого необходимо запустить приложение в Release mode и отдельно от студии (without debugging). В этом случае JIT-компилятор сделает определённые оптимизации, в результате которых такая ситуация возможна. Разумеется, делает он это только тогда, когда в оставшемся теле метода нет ссылок на сам объект или его поля. Казалось бы, достаточно невинная оптимизация. Но она может привести к проблемам, если мы имеем дело с неуправляемыми ресурсами: сборка объекта может произойти &lt;em&gt;до того&lt;/em&gt;, как закончится операция над неуправляемым объектом, что вполне вероятно повлечёт падение приложения.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Давайте воспроизведём ситуацию. Для начала нам понадобится что-нибудь неуправляемое, скажем библиотека &lt;a href=&quot;https://code.google.com/p/opencvsharp/&quot;&gt;OpenCvSharp&lt;/a&gt;
, которая представляет собой обёртку над &lt;a href=&quot;http://opencv.org/&quot;&gt;OpenCV&lt;/a&gt; — библиотекой компьютерного зрения и обработки изображений. Взята именно эта библиотека, т.к. на ней и была обнаружена неприятная ситуация. Рассмотрим следующий класс:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class ImageWithCircle
{
  private const int Size = 10000;
  private readonly IplImage image;

  public ImageWithCircle()
  {            
    image = Cv.CreateImage(new CvSize(Size, Size), BitDepth.U8, 3);
    DrawCircle();
  }

  ~ImageWithCircle()
  {
    Console.WriteLine(&amp;quot;~ImageWithCircle&amp;quot;);
    Cv.ReleaseImage(image);
  }

  public void Save()
  {
    Console.WriteLine(&amp;quot;Save start&amp;quot;);
    image.SaveImage(&amp;quot;image.tif&amp;quot;);
    Console.WriteLine(&amp;quot;Save end&amp;quot;);
  }

  public void DrawCircle()
  {
    image.FloodFill(new CvPoint(Size / 2, Size / 2), CvColor.White);
    image.Circle(new CvPoint(Size / 2, Size / 2), Size / 4, 
                 CvColor.Random(), 10);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Это весьма простой класс, который отвечает за рисование очень большой картинки с кружочком. Имеется метод &lt;code&gt;Save()&lt;/code&gt;, который сохраняет картинку в файл. Логика работы с изображением заключена в классе &lt;code&gt;IplImage&lt;/code&gt; из библиотеки OpenCvSharp. Запустим этот код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void Main()
{
  new ImageWithCircle().Save();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На консоли появится ожидаемый вариант: мы зашли в метод &lt;code&gt;Save()&lt;/code&gt;, мы вышли из него, а только потом выполнилась сборка мусора и был вызван соответствующий финализатор.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Save start
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь вызовем сборку мусора &lt;em&gt;во время сохранения картинки&lt;/em&gt;. Это всего лишь пример, поэтому не будет изобретать что-то умное, а просто включим &lt;code&gt;Timer&lt;/code&gt;, который будет весьма часто запускать &lt;code&gt;GC.Collect()&lt;/code&gt;. Картинка очень большая, и мы навярника запустим сборку мусора хотя бы раз до окончания её сохранения. Итак, исполняемый код теперь выглядит следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private static void Main()
{
  var timer = new Timer(100);
  timer.Elapsed += RunGc;
  timer.Start();
  new ImageWithCircle().Save();
}

private static void RunGc(object sender, ElapsedEventArgs e)
{
  Console.WriteLine(&amp;quot;Gc.Collect();&amp;quot;);
  GC.Collect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Наверное, вы ожидаете увидеть что-нибудь вроде:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Gc.Collect();
Save end
~ImageWithCircle
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но если выполнить запуск в Release mode without debugging, то приложение упадёт:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gc.Collect();
Gc.Collect();
Gc.Collect();
Save start
Gc.Collect();
~ImageWithCircle

Unhandled Exception: System.AccessViolationException: Attempted to read or write
 protected memory. This is often an indication that other memory is corrupt.
   at OpenCvSharp.CvInvoke.cvSaveImage(String filename, IntPtr image, Int32[] pa
rams)
   at OpenCvSharp.Cv.SaveImage(String filename, CvArr image, ImageEncodingParam[
] prms)
   at ConsoleApplication.ImageWithCircle.Save() in d:\Tests\ConsoleApplica
tion\ConsoleApplication\ImageWithCircle.cs:line 28
   at ConsoleApplication.Program.Main() in d:\Tests\ConsoleApplication\Co
nsoleApplication\Program.cs:line 18
Gc.Collect();
Gc.Collect();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Проблема в том, что JIT всё-таки выполнил свою коварную оптимизацию: наш объект подвергся сборке мусора прежде, чем картинка полностью успела сохраниться в файл. Увы, OpenCvSharp не смог такого пережить и выбросил исключение.&lt;/p&gt;
&lt;p&gt;Ситуацию исправить очень легко: достаточно удерживать ссылку на текущую картинку до окончания работы метода. Например, можно воспользоваться каким-нибудь статическим объектом, в который картинка будет записывать ссылку на себя в начале метода &lt;code&gt;Save()&lt;/code&gt;. Но я предпочитаю использовать метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.gc.keepalive.aspx&quot;&gt;GC.KeepAlive&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Save()
{
  Console.WriteLine(&amp;quot;Save start&amp;quot;);
  image.SaveImage(&amp;quot;image.tif&amp;quot;);
  Console.WriteLine(&amp;quot;Save end&amp;quot;);
  GC.KeepAlive(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Собственно говоря, не так важно, как именно вы исправите ситуацию, главное — понимать нюансы работы сборщика мусора, чтобы предвидеть подобные проблемы, ведь их очень сложно обнаружить: падение приложения в примере возникает только при определённой конфигурации запуска в случае, если сборщику мусора доведётся запуститься во время исполнения какого-то достаточно продолжительного выполнения неуправляемого метода. И если вы случайно натолкнётесь на такое падение приложения, то потом будете ещё долго ломать голову над тем, как же его теперь воспроизвести. Для избежания таких ситуаций необходимо тщательно проектировать взаимодействие с любыми нативными объектами, стараясь предвидеть возможные проблемы до этапа написания кода.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Unobviousness in use of C# closures</title>
            <link>http://aakinshin.net/posts/closures/</link> 
            <pubDate>Wed, 07 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/closures/</guid>
            <description>&lt;p&gt;C# gives us an ability to use closures. This is a powerful tool that allows anonymous methods and lambda-functions to capture unbound variables in their lexical scope. And many programmers in .NET world like using closures very much, but only few of them understand how they really work. Let’s start with a simple sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  int e = 1;
  Foo(x =&amp;gt; x + e);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nothing complicated happens here: we just captured a local variable &lt;code&gt;e&lt;/code&gt; in its lambda that is passed to some &lt;code&gt;Foo&lt;/code&gt; method. Let’s see how the compiler will expand such construction.*&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  DisplayClass c = new DisplayClass();
  c.e = 1;  
  Foo(c.Action);
}
private sealed class DisplayClass
{
  public int e;
  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;As you see from the sample, an additional class containing the captured variable and the target method is created for our closure. This knowledge will help us understand how closures behave in different situations.&lt;/p&gt;
&lt;h3 id=&quot;the-for-loop&quot;&gt;The for loop&lt;/h3&gt;
&lt;p&gt;Probably, this is the most classic sample cited by everyone:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  for (int i = 0; i &amp;lt; 3; i++)
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The sample contains a typical error. Newbie developers think that this code will output &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;, but in fact it will output &lt;code&gt;&amp;quot;3 3 3&amp;quot;&lt;/code&gt;. Such strange behavior is easy to understand if you look on the expanded version of this method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  DisplayClass c = new DisplayClass();
  for (c.i = 0; c.i &amp;lt; 3; c.i++)
    list.Add(c.Action);
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case they say that the variable is cycled by reference, not by value. Many programmers criticize this peculiarity of closures. They think it’s unclear though it’s quite logical for those who get a clear idea what’s inside the closures.&lt;/p&gt;
&lt;h3 id=&quot;the-foreach-loop&quot;&gt;The foreach loop&lt;/h3&gt;
&lt;p&gt;Let’s review a more interesting sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (var i in Enumerable.Range(0, 3))
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What will the code output? Sorry to say that there is no simple answer to this question. The matter is that earlier versions of C#, behavior of foreach was equal to behavior of for: variable of the cycle was created once and was captured in all lambdas. Starting from C# 5.0 this behavior has changed (&lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx&quot;&gt;here&lt;/a&gt; Eric Lippert admits that Microsoft made the breaking change). Now this code outputs &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;. Note that this is a peculiarity of language, not of the platform. If you work in Visual Studio 2012 and change target framework to 3.5, nothing will change. And you will be able to see the old behavior in Visual Studio 2010. John Skit &lt;a href=&quot;http://stackoverflow.com/questions/16264289/captured-closure-loop-variable-in-c-sharp-5-0&quot;&gt;explains&lt;/a&gt; why it was decided to make different behavior for &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;. Let’s have a look at a new variant of the expanded version of the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (int i in Enumerable.Range(0, 3))
  {
    DisplayClass c = new DisplayClass();
    с.i = i;    
    list.Add(c1.Action);
  }
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can easily see the difference: in C# 5.0, for every iteration of the foreach cycle, we get a new instance of the generated class providing closure logic.&lt;/p&gt;
&lt;h3 id=&quot;closure-of-multiple-variables&quot;&gt;Closure of multiple variables&lt;/h3&gt;
&lt;p&gt;Let’s review a case when we get multiple variables that are captured in different variables:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  int x = 1, y = 2;
  Foo(u =&amp;gt; u + x, u =&amp;gt; u + y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One can think that in this case two additional classes are generated and each of them will be responsible for a single variable. Actually, a single class will be generated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  DisplayClass с = new DisplayClass();
  с.x = 1;
  с.y = 2;
  Foo(с.ActionX, c.ActionY);
}

private sealed class DisplayClass
{
  public int x;
  public int y;

  public int ActionX(int u)
  {
    return u + x;
  }

  public int ActionY(int u)
  {
    return u + y;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Thus, lambdas are bound; garbage collector will access them when no reference to either of them will remain. Imagine the situation when the first lambda is used when initiating a long-living object, the second one is used when completing the work with it. And let there be many such objects. In this case initializing lambdas will stay in memory for quite a long time, though no one will ever invoke them.&lt;/p&gt;
&lt;h3 id=&quot;scope&quot;&gt;Scope&lt;/h3&gt;
&lt;p&gt;There is one more peculiarity of closures that you need to know. Let’s review a sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
  {
    var e = element;
    if (Condition(e))
      Foo(x =&amp;gt; x + e);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here is the question: where the closure object will be created? In spite the lambda is created inside &lt;code&gt;if&lt;/code&gt;, the object will be created in the same scope the captured variable is located in.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
  {
    DisplayClass c = new DisplayClass();
    c.e = element;
    if (Condition(c.e))
      Foo(c.Action);
  }
}

private sealed class DisplayClass
{
  public int e;

  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This peculiarity is important when the &lt;code&gt;list&lt;/code&gt; is quite big and the &lt;code&gt;Condition(e)&lt;/code&gt; is executed quite rarely. &lt;code&gt;DisplayClass&lt;/code&gt; instances will be created uselessly. It will affect memory and performance. We can fix the situation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
    if (Condition(element))
    {
      var e = element;
      Foo(x =&amp;gt; x + e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method will be deployed in a more optimal manner since &lt;code&gt;DisplayClass&lt;/code&gt; constructor will be invoked when it is really necessary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
    if (Condition(element))
    {
      DisplayClass c = new DisplayClass();
      c.e = element;
      Foo(c.Action);
    }  
}

private sealed class DisplayClass
{
  public int e;
 
  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;problems&quot;&gt;Problems&lt;/h3&gt;
&lt;p&gt;You can find problems about the subject in &lt;a href=&quot;http://problembook.net&quot;&gt;ProblemBook.NET&lt;/a&gt;:
&lt;a href=&quot;http://problembook.net/content/en/Linq/ClosureAndForeach-P.html&quot;&gt;ClosureAndForeach&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/en/Linq/ClosureAndFor-P.html&quot;&gt;ClosureAndFor&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/en/Linq/ClosureAndVariable-P.html&quot;&gt;ClosureAndVariable&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;It’s very convenient to use the following utility: &lt;a href=&quot;http://www.jetbrains.com/decompiler/&quot;&gt;dotPeek&lt;/a&gt; from &lt;a href=&quot;http://www.jetbrains.com/&quot;&gt;JetBrains&lt;/a&gt; with enabled option &lt;em&gt;Show compiler-generated code&lt;/em&gt;. Code included in the article is simplified in comparison with the disassembled version to make it easy to read.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Неочевидности в использовании C#-замыканий</title>
            <link>http://aakinshin.net/ru/posts/closures/</link> 
            <pubDate>Wed, 07 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/closures/</guid>
            <description>&lt;p&gt;Язык C# даёт нам возможность пользоваться замыканиями — мощным механизмом, который позволяет анонимным методам и лямбдам захватывать свободные переменные в своём лексическом контексте. И в .NET-мире многие программисты очень любят использовать замыкания, но немногие понимают, как они действительно работают. Начнём с простого примера:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  int e = 1;
  Foo(x =&amp;gt; x + e);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ничего сложного тут не происходит: мы просто &#171;захватили&#187; локальную переменную &lt;code&gt;e&lt;/code&gt; в лямбду, которая передаётся в некоторый метод &lt;code&gt;Foo&lt;/code&gt;. Посмотрим, во что компилятор развернёт такую конструкцию:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  DisplayClass c = new DisplayClass();
  c.e = 1;  
  Foo(c.Action);
}
private sealed class DisplayClass
{
  public int e;
  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Как видно из примера, для нашего замыкания создаётся дополнительный класс, который содержит захватываемую переменную  и целевой метод. Это знание поможет нам осознать поведение замыканий в различных ситуациях.&lt;/p&gt;
&lt;h3 id=&quot;for&quot;&gt;Цикл for&lt;/h3&gt;
&lt;p&gt;Наверное, это самый классический пример, который приводят все:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  for (int i = 0; i &amp;lt; 3; i++)
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В этом примере сделана типичная ошибка. Начинающие программисты думаю, что этот код выведет &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;, но на самом деле он выведет &lt;code&gt;&amp;quot;3 3 3&amp;quot;&lt;/code&gt;. Такое странное поведение легко понять, если взглянуть на развёрнутую версию этого метода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  DisplayClass c = new DisplayClass();
  for (c.i = 0; c.i &amp;lt; 3; c.i++)
    list.Add(c.Action);
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В таком случае часто говорят, что переменная замыкается по ссылке, а не по значению. Эту особенность замыканий многие осуждают, как непонятную, хотя она является достаточно логичной для тех, кто хорошо представляет, что скрыто под капотом замыканий. Эту тему очень подробно обсуждает Эрик Липперт в постах &lt;a href=&quot;http://blogs.msdn.com/b/ruericlippert/archive/2009/11/12/9983705.aspx&quot;&gt;О вреде замыканий на переменных цикла&lt;/a&gt; и &lt;a href=&quot;http://blogs.msdn.com/b/ruericlippert/archive/2009/11/16/9984832.aspx&quot;&gt;Замыкания на переменных цикла. Часть 2&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;foreach&quot;&gt;Цикл foreach&lt;/h3&gt;
&lt;p&gt;Посмотрим более интересный пример:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (var i in Enumerable.Range(0, 3))
    actions.Add(() =&amp;gt; Console.WriteLine(i));
  foreach (var action in actions)
    action();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Что выведет это код? Увы, однозначного ответа на этот вопрос нету. Дело в том, что в ранних версиях C# поведение foreach было подобно поведению for: переменная цикла создавалась один раз и захватывалась во всех лямбдах. А в C# 5.0 это поведение поменяли (&lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2009/11/12/closing-over-the-loop-variable-considered-harmful.aspx&quot;&gt;тут&lt;/a&gt; Эрик Липперт признаётся, что Microsoft всё-таки сделали breaking change). Теперь этот код выводит &lt;code&gt;&amp;quot;0 1 2&amp;quot;&lt;/code&gt;
. Заметьте, что это особенность именно языка, а не платформы. Если вы работаете из VisualStuido 2012 и меняете TargetFramework на 3.5, то ничего не поменяется, а вот из VisualStudio 2010 вы сможете пронаблюдать старое поведение. На Stackoverflow Джон Скит &lt;a href=&quot;http://stackoverflow.com/questions/16264289/captured-closure-loop-variable-in-c-sharp-5-0&quot;&gt;объясняет&lt;/a&gt; почему было решено сделать различное поведение для &lt;code&gt;for&lt;/code&gt; и &lt;code&gt;foreach&lt;/code&gt;. Взглянем на новый вариант развёрнутой версии кода:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  var actions = new List&amp;lt;Action&amp;gt;();
  foreach (int i in Enumerable.Range(0, 3))
  {
    DisplayClass c = new DisplayClass();
    с.i = i;    
    list.Add(c1.Action);
  }
  foreach (Action action in list)
    action();
}

private sealed class DisplayClass
{
  public int i;

  public void Action()
  {
    Console.WriteLine(i);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Легко можно заметить разницу: в C# 5.0 на каждую итерацию цикла &lt;code&gt;foreach&lt;/code&gt; мы имеем новый экземпляр сгенерированного класса, обеспечивающего логику замыкания. На Хабре можно &lt;a href=&quot;http://habrahabr.ru/post/141270/&quot;&gt;почитать&lt;/a&gt; поподробнее про замыкания в новой версии C#.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Замыкание нескольких переменных&lt;/h3&gt;
&lt;p&gt;Рассмотрим ситуацию в которой у нас есть несколько переменных, которые замыкаются в различных переменных:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public void Run()
{
  int x = 1, y = 2;
  Foo(u =&amp;gt; u + x, u =&amp;gt; u + y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Можно подумать, что в этом случае у нас сгенерируется два дополнительных класса, каждый из которых будет отвечать за единственную переменную. Но на самом деле будет только один сгенерированный класс:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run()
{
  DisplayClass с = new DisplayClass();
  с.x = 1;
  с.y = 2;
  Foo(с.ActionX, c.ActionY);
}

private sealed class DisplayClass
{
  public int x;
  public int y;

  public int ActionX(int u)
  {
    return u + x;
  }

  public int ActionY(int u)
  {
    return u + y;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, лямбды оказываются &#171;связаны&#187;: сборщик мусора доберётся до них только после того, как не останется ссылок ни на одну из них. Представьте ситуацию, в которой первая лямбда используется при инициализации долгоживущего объекта, а вторая — по окончанию работы с ним. И пусть таких объектов будет много. В этом случае инициализирующие лямбды будут болтаться в памяти очень долго, хотя никто их больше никогда не будет вызывать.&lt;/p&gt;
&lt;h3 id=&quot;scope&quot;&gt;Scope&lt;/h3&gt;
&lt;p&gt;Есть ещё одна особенность работы замыканий, о которой полезно знать. Рассмотрим пример:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
  {
    var e = element;
    if (Condition(e))
      Foo(x =&amp;gt; x + e);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь вопрос: в каком месте будет создан объект замыкания? Не смотря на то, что лямбда создаётся внутри &lt;code&gt;if&lt;/code&gt;-а, объект будет создаваться в том же &lt;code&gt;scope&lt;/code&gt;
-е, что и захватываемая переменная:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
  {
    DisplayClass c = new DisplayClass();
    c.e = element;
    if (Condition(c.e))
      Foo(c.Action);
  }
}

private sealed class DisplayClass
{
  public int e;

  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Такая особенность может иметь значение в случае, если &lt;code&gt;list&lt;/code&gt; очень большой, а условие &lt;code&gt;Condition(e)&lt;/code&gt; выполняется весьма редко. Ведь будет происходить бесполезное создание экземпляров класса &lt;code&gt;DisplayClass&lt;/code&gt; , что негативно скажется на памяти и производительности. Мы можем исправить эту ситуацию:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (var element in list)
    if (Condition(element))
    {
      var e = element;
      Foo(x =&amp;gt; x + e);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Данный метод будет разворачиваться более оптимально, ведь теперь конструктор &lt;code&gt;DisplayClass&lt;/code&gt; будет вызываться только тогда, когда он действительно нужен:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void Run(List&amp;lt;int&amp;gt; list)
{
  foreach (int element in list)
    if (Condition(element))
    {
      DisplayClass c = new DisplayClass();
      c.e = element;
      Foo(c.Action);
    }  
}

private sealed class DisplayClass
{
  public int e;
 
  public int Action(int x)
  {
    return x + e;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Задачи&lt;/h3&gt;
&lt;p&gt;На приведённую тему есть три задачки в
&lt;a href=&quot;http://problembook.net&quot;&gt;ProblemBook.NET&lt;/a&gt;:
&lt;a href=&quot;http://problembook.net/content/ru/Linq/ClosureAndForeach-P.html&quot;&gt;ClosureAndForeach&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/ru/Linq/ClosureAndFor-P.html&quot;&gt;ClosureAndFor&lt;/a&gt;,
&lt;a href=&quot;http://problembook.net/content/ru/Linq/ClosureAndVariable-P.html&quot;&gt;ClosureAndVariable&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Для дизассемблирования удобно пользоваться утилитой &lt;a href=&quot;http://www.jetbrains.com/decompiler/&quot;&gt;dotPeek&lt;/a&gt; от &lt;a href=&quot;http://www.jetbrains.com/&quot;&gt;JetBrains&lt;/a&gt;
с включённой опцией &lt;code&gt;Show compiler-generated code&lt;/code&gt;. Приведённый в статье код немного причёсан по сравнению с дизассемблированной версией для повышения читаемости.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Проблема с FPU при вызове .NET-логики из Delphi</title>
            <link>http://aakinshin.net/ru/posts/delphi-fpu-issue/</link> 
            <pubDate>Tue, 06 Aug 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/delphi-fpu-issue/</guid>
            <description>&lt;p&gt;&lt;strong&gt;Ситуация:&lt;/strong&gt; мы пишем основную логику приложения на C#, но есть необходимость использовать её из Delphi. Для этих целей пользуемся COM-обёрткой, которая успешно справляется с поставленной задачей. Целевая функция перед возвращением результата показывает диалоговое WPF-окно, с которым можно сделать что-нибудь полезное. Проверяем на простом примере — всё отлично работает.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Проблема:&lt;/strong&gt; в некоторых Delphi приложений окно выбрасывает исключение. Но исключение странное: при формировании WPF-окна падает, скажем, выставление ширины некоторого элемента. Но это только в некоторых приложениях. А в остальных — тот же самый код на тех же самых данных отлично работает.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;В чём же дело?&lt;/strong&gt;&lt;!--more--&gt; Оставив в стороне увлекательную историю о проведённом исследовании, перейду сразу к решению: виновником был бит в FPU-регистре &lt;a href=&quot;http://www.club155.ru/x86internalreg-fpucw&quot;&gt;CW&lt;/a&gt;. Определённые функции некоторых версий Delphi любят менять его на такое значение, что бедный математический сопроцессор перестаёт переваривать &lt;code&gt;double.NaN&lt;/code&gt;, начиная плеваться на него исключениями. А в WPF, как известно, у доброй половины свойств &lt;code&gt;FrameworkElement&lt;/code&gt;-а значение по умолчанию выставлено именно в &lt;code&gt;NaN&lt;/code&gt;. При малейших манипуляциях над этими свойствами приложение начинает падать.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Что же делать?&lt;/strong&gt;
Имеется два метода решения проблемы. В первом варианте необходимо выставить правильное значение плохого бита в Delphi перед вызовом WPF-окна. Например так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;procedure Foo;
var 
  saved8087CW : Word; 
begin 
  saved8087CW := Default8087CW; 
  Set8087CW($133F); 
  // Вызываем нужный метод
  Set8087CW(saved8087CW); 
end; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этот способ не всегда подходит, т.к. возможно .NET-логика будет использоваться в различных Delphi-приложениях, и у нас нет возможности обернуть все вызовы WPF-окна во всех приложениях. С этих позиций разумно установить бит на стороне .NET-а. В этом нам поможет функция &lt;code&gt;_controlfp&lt;/code&gt; из &lt;code&gt;msvcrt.dll&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[DllImport(&amp;quot;msvcrt.dll&amp;quot;, CallingConvention = CallingConvention.Cdecl)]
public static extern int _controlfp(int newControl, int mask);
 
const int _RC_NEAR = 0x00000000;
const int _PC_53 = 0x00010000;
const int _EM_INVALID = 0x00000010;
const int _EM_UNDERFLOW = 0x00000002;
const int _EM_ZERODIVIDE = 0x00000008;
const int _EM_OVERFLOW = 0x00000004;
const int _EM_INEXACT = 0x00000001;
const int _EM_DENORMAL = 0x00080000;
const int _CW_DEFAULT = 
  _RC_NEAR + _PC_53 + _EM_INVALID + _EM_ZERODIVIDE +
  _EM_OVERFLOW + _EM_UNDERFLOW + _EM_INEXACT + _EM_DENORMAL;
 
public Foo()
{
  _controlfp(_CW_DEFAULT, 0xfffff);
  // Нужная нам логика 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.neslekkim.net/2008/10/fpu-issues-when-interoping-delphi-and.html&quot;&gt;FPU issues when interoping Delphi and .net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.msdn.com/b/dsvc/archive/2009/06/25/floating-point-exceptions-in-managed-code-resulting-in-access-violation-crash.aspx&quot;&gt;Floating point exception in managed code results in Access Violation crash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://support.microsoft.com/kb/326219&quot;&gt;PRB: System.Arithmetic Exception Error When You Change the Floating-Point Control Register in a Managed Application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/191368/how-can-i-set-and-restore-fpu-ctrl-registers&quot;&gt;SO — How can I set and restore FPU CTRL registers?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://digital.ni.com/public.nsf/allkb/E6A73825E57FCD9F862570DD005E594F&quot;&gt;Floating Point Exception When Calling Borland C++Builder or Delphi DLL or Executable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://valera.asf.ru/delphi/help/name.php?name=Set8087CW&quot;&gt;Delphi: Set8087CW&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.club155.ru/x86internalreg-fpucw&quot;&gt;Внутренние регистры: Регистр управления FPU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>FastColoredTextBox — божественный RichTextBox для .NET</title>
            <link>http://aakinshin.net/ru/posts/fastcoloredtextbox/</link> 
            <pubDate>Wed, 17 Jul 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/fastcoloredtextbox/</guid>
            <description>&lt;p&gt;Появилась у меня недавно задачка сделать в WPF-приложении красивый редактор форматированного текста с определённой логикой обработки. И решил я использовать для этой задачи стандартный &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/system.windows.controls.richtextbox.aspx&quot;&gt;RichTextBox&lt;/a&gt;. Увы, практика показала, что этот контрол &lt;a href=&quot;https://www.google.ru/search?q=wpf+richtextbox+performance&quot;&gt;ужасно медленный&lt;/a&gt;. Можно было, конечно, написать свою реализацию, но это занятие долгое, а функционал нужно было прикрутить побыстрее. Первая мысль была &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms751761.aspx&quot;&gt;захостить&lt;/a&gt; стандартный &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/system.windows.forms.richtextbox.aspx&quot;&gt;RichTextBox&lt;/a&gt; из WinForms. Он работает достаточно быстро, но его функционала мне не хватило. И тогда я пустился в поиск сторонних контролов. Каким же счастливым я стал, когда наткнулся на FastColoredTextBox! Изучение контрола лучше всего начать со &lt;a href=&quot;http://www.codeproject.com/Articles/161871/Fast-Colored-TextBox-for-syntax-highlighting&quot;&gt;статьи&lt;/a&gt; на CodeProject. Увы, NuGet-пакет автор &lt;a href=&quot;https://github.com/PavelTorgashov/FastColoredTextBox/issues/10&quot;&gt;по каким-то причинам&lt;/a&gt; делать не хочет, но зато есть &lt;a href=&quot;https://github.com/PavelTorgashov/FastColoredTextBox&quot;&gt;исходники&lt;/a&gt; на GitHub. Итак, небольшой обзор.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/fastcoloredtextbox/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;Главным образом, автор библиотеки (&lt;a href=&quot;https://github.com/PavelTorgashov&quot;&gt;Павел Торгашов&lt;/a&gt;) ориентировал его на работу с программным кодом, но разработанный контрол прекрасно подходит для любых других задач. В WinForms его можно использовать в чистом виде, а в WPF приложение его легко добавить &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms742875.aspx&quot;&gt;даже прямо через XAML&lt;/a&gt;. Скорость работы впечатляет (отличный performance был основной задачей автора), рендеринг происходит на основе GDI+. В рамках одного контрола поддерживается 16 стилей, но, как &lt;a href=&quot;https://github.com/PavelTorgashov/FastColoredTextBox/issues/18&quot;&gt;говорит автор&lt;/a&gt;, если вам нужно больше, то вы делаете что-то не так. Распространяется под &lt;a href=&quot;http://opensource.org/licenses/lgpl-3.0.html&quot;&gt;LGPLv3&lt;/a&gt;, а значит можно использовать в проприетарном софте. Есть &lt;a href=&quot;http://www.codeproject.com/script/articles/download.aspx?file=/KB/edit/FastColoredTextBox_/FastColoredTextBox_Help.zip&amp;amp;rp=http://www.codeproject.com/Articles/161871/Fast-Colored-TextBox-for-syntax-highlighting&quot;&gt;chm-документация&lt;/a&gt;, но больше толку от оригинальной статьи и demo-проекта Tester из репозитория, который содержит большое количество примеров на все случаи жизни:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/fastcoloredtextbox/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Выводы&lt;/h3&gt;
&lt;p&gt;За свою жизнь я поработал с очень большим количеством разных контролов и могу авторитетно заявить: FastColoredTextBox реализован очень грамотно. В большинстве случаев, когда мне нужно было какое-нибудь свойство, то я задавал себе простой вопрос: &lt;em&gt;&#171;Если бы я был этим свойством, то как бы я назывался?&#187;&lt;/em&gt;. Первый пришедший в голову ответ вместе с intellisense помогали быстро найти нужную функциональность. Некоторые особенности, которые понравились лично мне:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Контрол работает ну очень быстро&lt;/li&gt;
&lt;li&gt;Отличное API, XML-документация и demo-приложение&lt;/li&gt;
&lt;li&gt;Продвинутая подсветка любого синтаксиса на основе регулярных выражений&lt;/li&gt;
&lt;li&gt;Интерактивное выделение некоторых частей, в зависимости от позиции курсора&lt;/li&gt;
&lt;li&gt;Возможность определять свои стили, в которых можно написать собственную отрисовку каждого символа через обычный Graphics&lt;/li&gt;
&lt;li&gt;Свёртка блоков текста&lt;/li&gt;
&lt;li&gt;Навигация по тексту, закладки&lt;/li&gt;
&lt;li&gt;Autocomplete&lt;/li&gt;
&lt;li&gt;Встроенные в тело документа Hint-ы и всплывающие ToolTip-ы&lt;/li&gt;
&lt;li&gt;Запись макросов&lt;/li&gt;
&lt;li&gt;Поддержка стандартных горячих клавиш (с возможностью назначить свои) и работы с буфером&lt;/li&gt;
&lt;li&gt;Хранение истории, нормальный ChangeTracker с операциями Undo/Redo&lt;/li&gt;
&lt;li&gt;Экспорт в HTML&lt;/li&gt;
&lt;li&gt;.NET Framework 2.0 и поддержка Compact Framework&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Материалы по Git</title>
            <link>http://aakinshin.net/ru/posts/git-links/</link> 
            <pubDate>Wed, 19 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/git-links/</guid>
            <description>&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/links/front.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Основные:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://git-scm.com/book&quot;&gt;Pro Git [EN]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://git-scm.com/book/ru&quot;&gt;Pro Git [RU]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-ru.html&quot;&gt;Git: наглядная справка [RU]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://marklodato.github.io/visual-git-guide/index-en.html&quot;&gt;Git: наглядная справка [EN]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;Git User’s Manual [EN]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/index.html&quot;&gt;Git magic [EN]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/ru/&quot;&gt;Волшебство Git [RU]&lt;/a&gt;
	&lt;/li&gt;
&lt;/ul&gt;
Интерактивные обучалки:
&lt;ul&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://githowto.com/ru&quot;&gt;Git How To [RU]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://githowto.com&quot;&gt;Git How To [EN]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://try.github.io/&quot;&gt;Try Git [EN]&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://pcottle.github.io/learnGitBranching/&quot;&gt;LearnGitBranching [EN]&lt;/a&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;Видеокурсы:&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://vimeo.com/14629850&quot;&gt;Getting Git [EN]&lt;/a&gt;
	&lt;/li&gt;
&lt;/ul&gt;
GitHub
&lt;ul&gt;
	&lt;li&gt;
		&lt;a href=&quot;https://github.com&quot;&gt;GitHub — самый популярный Git-хостинг&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://gitfm.com/&quot;&gt;gitfm — персональные рекомендации пользователям GitHub&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://gitrec.mortardata.com/&quot;&gt;GitRec — ещё один сервис персональных рекомендаций&lt;/a&gt;
	&lt;/li&gt;
&lt;/ul&gt;
Хорошие посты на Хабре:
&lt;ul&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/157175/&quot;&gt;Машина времени в git&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/179123/&quot;&gt;Чем опасен rebase, или как получилось, что 2*3=5&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/179673/&quot;&gt;Чем опасен rebase-2, или как rebase мешал баг искать&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/hub/Git/posts/&quot;&gt;Ежедневная работа с Git&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/181924/&quot;&gt;FeatureBranch&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/company/microsoft/blog/175261/&quot;&gt;Работа с Git в Visual Studio 2012&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/161009/&quot;&gt;Git Rebase: руководство по использованию&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/147260/&quot;&gt;Почему вы до сих пор не используете git-flow? перевод&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/hub/Git/posts/&quot;&gt;Переезд проекта с SVN на Git&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/143079/&quot;&gt;Что скрывает от нас директория .git&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/141160/&quot;&gt;Постигаем Git&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/123111/&quot;&gt;Пара приемов работы с git&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/post/106912/&quot;&gt;Удачная модель ветвления для Git&lt;/a&gt;
	&lt;/li&gt;
	&lt;li&gt;
		&lt;a href=&quot;http://habrahabr.ru/company/badoo/blog/163853/&quot;&gt;Внутреннее устройство Git: хранение данных и merge&lt;/a&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;!--&lt;blockquote&gt;Test test test&lt;/blockquote&gt;
--&gt;</description>
        </item>
        <item>
            <title>Просмотр истории коммитов в Git</title>
            <link>http://aakinshin.net/ru/posts/git-log/</link> 
            <pubDate>Tue, 18 Jun 2013 17:38:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/git-log/</guid>
            <description>&lt;p&gt;Изучение истории коммитов — важная составляющая работы с репозиторием. Увы, ввиду ветвления с этой историей не всегда просто разобраться. Обычно я для этой цели пользуюсь различными визуальными оболочками, но не всегда есть такая возможность. Временами приходится пользоваться средствами консоли, а именно командой
&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-log.html&quot;&gt;git log&lt;/a&gt;. Основы работы с этой командой можно почитать в чудесной книге
&lt;a href=&quot;http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2&quot;&gt;ProGit&lt;/a&gt;
.
&lt;code&gt;git log&lt;/code&gt;
имеет множество различных полезных параметров. Рассмотрим несколько примеров их использования.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Древовидный вид&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --abbrev-commit --decorate --date=relative --format=format:&#39;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)&#39; --all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов c сокращёнными хешами, ссылками на коммиты и относительной датой. Используемый формат: синий сокращённый хеш коммита, зелёная дата, белые сообщение и автор, жёлтые ссылки на коммит.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log1.png&quot; /&gt;
&lt;/p&gt;
&lt;!--more--&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --abbrev-commit --decorate --format=format:&#39;%C(bold blue)%h%C(reset) - %C(bold cyan)%aD%C(reset) %C(bold green)(%ar)%C(reset)%C(bold yellow)%d%C(reset)%n&#39;&#39;          %C(white)%s%C(reset) %C(dim white)- %an%C(reset)&#39; --all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов c сокращёнными хешами, ссылками на коммиты и абсолютной датой. Используемый формат: синий сокращённый хеш коммита, голубая абсолютная дата, зелёная относительная дата, жёлтые ссылки на коммит, перевод строки, белые сообщение и автор.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log2.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --oneline --all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов, отводя по одной строке на коммит.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log3.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --graph --date-order --pretty=format:&amp;quot;&amp;lt;%h&amp;gt; %ad [%an] %Cgreen%d%Creset %s&amp;quot; --all --date=short
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим полный граф коммитов c сортировкой по дате, отображаемой в краткой форме. Используемый формат: сокращённый хеш, дата, автор, зелёные ссылки на коммит, сообщение.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log4.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Линейный вид&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вывод списка коммитов с параметрами по умолчанию.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log5.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log -p
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов и показываем diff для каждого.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log6.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --stat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов и показываем статистику по каждому.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log7.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --pretty=oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов по одному на строчке.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log8.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выводим список коммитов с использованием следуюещго формата: сокращённый хеш коммита, автор, относительная дата, сообщение.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log9.png&quot; /&gt;
&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Визуальный интерфейс&lt;/h3&gt;
&lt;p&gt;Если есть возможность, то всё таки коммиты приятнее изучать через специализированный интерфейс, а не из консоли. Лично я очень люблю
&lt;a href=&quot;https://code.google.com/p/gitextensions/&quot;&gt;GitExtensions&lt;/a&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log10.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Также удобно использовать встроенную утилиту &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gitk.html&quot;&gt;gitk&lt;/a&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/git/log/git-log11.png&quot; /&gt;
&lt;/p&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Полезные параметры&lt;/h3&gt;
&lt;p&gt;Все параметры команды &lt;code&gt;git log&lt;/code&gt; не нужны, но некоторые самые полезные хорошо бы помнить. Приведу несколько примеров использования ходовых параметров.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--graph&lt;/code&gt; Показывать древовидную структуру графа истории в ASCII-виде&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-5&lt;/code&gt; Посмотреть последних пять коммитов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--skip=3&lt;/code&gt; Пропустить три коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--pretty=oneline&lt;/code&gt; Отводить по одной строчке на коммит&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--since=&amp;quot;today&amp;quot;&lt;/code&gt; Показать коммиты за сегодня&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--since=2.weeks&lt;/code&gt; Показать коммиты за последние две недели&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; Показывать diff каждого коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--decorate&lt;/code&gt; Показывать ссылки на этот коммит&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--stat&lt;/code&gt; Показывать подробную статистику по каждому коммиту&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--shortstat&lt;/code&gt; Показывать краткую статистику по каждому коммиту&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name-only&lt;/code&gt; Показывать список изменённых файлов&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--name-status&lt;/code&gt; Показывать список изменённых файлов с информацией о них&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--abbrev-commit&lt;/code&gt; Показывать только несколько первых цифр SHA-1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--relative-date&lt;/code&gt; Показывать дату в относительной форме&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C помощью замечательного параметра &lt;code&gt;--pretty=format:&amp;quot;&amp;quot;&lt;/code&gt; можно указать, какие именно данные о коммите нужно выводить, определив внутри кавычек общий паттерн, используя следующие обозначения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%H&lt;/code&gt; Хеш коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%h&lt;/code&gt; Сокращённый хеш коммита&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%d&lt;/code&gt; Имена ссылок на коммит&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%s&lt;/code&gt; Сообщение к коммиту&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%an&lt;/code&gt; Автор&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%ad&lt;/code&gt; Дата автора&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%cn&lt;/code&gt; Коммитер&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%cd&lt;/code&gt; Дата коммитера&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Cred&lt;/code&gt; Переключить цвет на красный&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Cgreen&lt;/code&gt; Переключить цвет на зелёный&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Cblue&lt;/code&gt; Переключить цвет на синий&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%Creset&lt;/code&gt; Сбросить цвет&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Полный список обозначений можно найти в &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-log.html&quot;&gt;мануале&lt;/a&gt; , в разделе &#171;PRETTY FORMATS&#187;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-log.html&quot;&gt;Официальный мануал&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://git-scm.com/book/ru/%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git-%D0%9F%D1%80%D0%BE%D1%81%D0%BC%D0%BE%D1%82%D1%80-%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D0%BE%D0%B2&quot;&gt;ProGit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/1057564/pretty-git-branch-graphs&quot;&gt;Советы со Stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/twitter/bootstrap&quot;&gt;Репозиторий Twitter bootstrap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Использование изменяемых структур в свойствах классов</title>
            <link>http://aakinshin.net/ru/posts/mutable-structures-as-property/</link> 
            <pubDate>Thu, 06 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/mutable-structures-as-property/</guid>
            <description>&lt;div style=&quot;text-align: right;&quot;&gt;&lt;i&gt;Названия всех классов вымышленные,&lt;br /&gt;все совпадения абсолютно случайны.&lt;/i&gt;&lt;/div&gt;
&lt;p&gt;Занимался я как-то раз улучшением кода проекта. И наткнулся вот на такие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Image
{
  public Rectangle Bounds;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&#171;Ай-яй-яй! Публичное поле в классе, как же нехорошо-то! Нужно срочно превратить его в свойство!&#187;&lt;/em&gt; — подумал я. И превратил:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Image
{
  public Rectangle Bounds { get; set; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Сделал я такое невинное изменение и сразу пошёл дальше рефакторить — ведь ещё такое количество кода нуждалось в улучшении! Ну а в конце решил я запустить на всякий случай Unit-тесты. Какого же было моё удивление, когда половина тестов упала. &lt;em&gt;&#171;Да как же так! Ведь я особо-то ничего и не менял!&#187;&lt;/em&gt; Ну, поехали разбираться.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Прежде всего взглянем на пресловутый &lt;code&gt;Rectangle&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public struct Rectangle
{
  public int X, Y, Width, Height;

  public void Inflate(int value) // &#171;Раздуваем&#187; наш прямоугольник
  {
    X -= value;
    Y -= value;
    Width += 2 * value;
    Height += 2 * value;
  }

  public override string ToString()
  {
    return string.Format(&amp;quot;[{0}, {1}, {2}, {3}]&amp;quot;, X, Y, Width, Height);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну, а теперь сценарий использования:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var image = new Image();
image.Bounds = new Rectangle { X = 0, Y = 0, Width = 10, Height = 10 };
image.Bounds.Inflate(5);
Console.WriteLine(image.Bounds);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&#171;Ах, ну зачем же так писать-то&#187;&lt;/em&gt; — подумал я, ведь внезапно мне всё стало понятно. Давайте разбираться подробнее.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Случай до рефакторинга: Bounds — поле.&lt;/strong&gt; В этом случае метод &lt;code&gt;Inflate&lt;/code&gt; будет работать с прямоугольником &lt;code&gt;Bounds&lt;/code&gt; , непосредственно относящимся к нашей картинке. Он успешно отработает, а метод &lt;code&gt;Console.WriteLine&lt;/code&gt; покажет нам &#171;раздутую&#187; версию границ: &lt;code&gt;&amp;quot;-5 -5 20 20&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Случай после рефакторинга: Bounds — свойство.&lt;/strong&gt; В этом случае настоящие границы хранятся в приватном сгенерированном поле, а при обращении к свойству
&lt;code&gt;Bounds&lt;/code&gt; на самом деле вызывается метод &lt;code&gt;get_Bounds()&lt;/code&gt; , который вернёт нам только копию прямоугольника. И раздувать мы будем уже копию, а не оригинал. Поэтому
&lt;code&gt;Console.WriteLine&lt;/code&gt; вернёт нам исходный прямоугольник: &lt;code&gt;&amp;quot;0 0 10 10&amp;quot;&lt;/code&gt;. Если уж нам так уж хочется сделать побольше оригинальный прямоугольник, то правильным способом будет являться следующий путь: достаём прямоугольник в локальную переменную, выполняем над ней необходимые манипуляции, а результат записываем обратно:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var bounds = image.Bounds;
bounds.Inflate(5);
image.Bounds = bounds;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но если говорить более глобально, то архитектурная ошибка появилась в классе &lt;code&gt;Rectangle&lt;/code&gt;: нужно стараться не допускать в проекте изменяемых структур, их наличие может повлечь вышеописанные проблемы. &lt;em&gt;&#171;Но как же быть с публичными данными структуры, ведь до них я могу добраться явно и поменять их!&#187;&lt;/em&gt; — спросите вы. На этот случай беспокоиться не стоит, компилятор C# — умный, он не будет даже компилировать строки вида&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;image.Bounds.X += 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вы хотите сделать методы, которые выполняют над структурой какие-то преобразования, то лучше бы этим методам создавать новый экземпляр структуры и возвращать его. Перепишем метод раздутия прямоугольника &#171;правильным способом&#187;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public Rectangle Inflate(int value)
{
  return new Rectangle
    {
      X = X - value,
      Y = Y - value,
      Width = Width + 2 * value,
      Height = Height + 2 * value
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот с таким методом заиметь проблемы по неосмотрительности уже намного сложнее. Мораль: если вы по каким-то причинам решили использовать в своём проекте структуры, то лучше бы вам не писать методов, которые изменяют их состояние.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/441309/why-are-mutable-structs-evil&quot;&gt;StackOverflow — Why are mutable structs evil?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[http://habrahabr.ru/post/124404/&amp;quot;](Хабр — О вреде изменяемых значимых типов)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sergeyteplyakov.blogspot.ru/2012/12/2.html&quot;&gt;О вреде изменяемых значимых типов. Часть 2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Wrapping C# class for use in COM</title>
            <link>http://aakinshin.net/posts/wrap-cs-in-com/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/posts/wrap-cs-in-com/</guid>
            <description>&lt;p&gt;Let us have a C# class that makes something useful, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Calculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s create a &lt;a href=&quot;http://ru.wikipedia.org/wiki/Component_Object_Model&quot;&gt;COM&lt;/a&gt; interface for this class to make it possible to use its functionality in other areas. At the end we will see how this class is used in Delphi environment.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;For a beginning, we proceed to the project properties and check &lt;em&gt;Register for COM interop&lt;/em&gt; on the &lt;em&gt;Build&lt;/em&gt; tab.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Create an interface for our class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public interface ICalculator
{
    int Sum(int a, int b);
}

public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s necessary to mark the class and the interface with a set of attributes: it’s necessary to specify unique &lt;a href=&quot;http://ru.wikipedia.org/wiki/GUID&quot;&gt;GUID&lt;/a&gt;’s for them, set &lt;code&gt;ComVisible(true)&lt;/code&gt;,and add the &lt;code&gt;ClassInterface(ClassInterfaceType.None)&lt;/code&gt; attribute to the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Guid(&amp;quot;364C5E66-4412-48E3-8BD8-7B2BF09E8922&amp;quot;)]
[ComVisible(true)]
public interface ICalculator
{
    int Sum(int a, int b);
}

[Guid(&amp;quot;8C034F6A-1D3F-4DB8-BC99-B73873D8C297&amp;quot;)]
[ClassInterface(ClassInterfaceType.None)]
[ComVisible(true)]
public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re almost done! Now we can build the assembly. Since we checked &lt;em&gt;Register for COM interop&lt;/em&gt;, the COM component will be registered in the system automatically. It’s also possible to register it manually. You can do it with the &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/tzat5yw6.aspx&quot;&gt;RegAsm&lt;/a&gt; utility located here: &lt;code&gt;C:\Windows\Microsoft.NET\Framework\v &amp;lt; necessary version number &amp;gt;\&lt;/code&gt;. The corresponding tlb file can be created with the help of the &lt;code&gt;/tlb&lt;/code&gt; argument. The &lt;code&gt;/u&lt;/code&gt; argument will &lt;a href=&quot;http://stackoverflow.com/questions/7841428/how-to-unregister-the-assembly-registered-using-regasm&quot;&gt;cancel&lt;/a&gt; assembly registration. So, let’s execute the command (assume that name of the project and the corresponding dll is ComCalculator):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RegAsm.exe Calculator.dll /tlb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! The component is registered! Run Delphi and try to use it. After a new project is created (a common WinForms project), it’s necessary to import ComCalculator to it. Select &lt;code&gt;Import Type Library&lt;/code&gt; from the &lt;code&gt;Project&lt;/code&gt; menu. Look for &lt;code&gt;ComCalculator&lt;/code&gt; and click &lt;code&gt;Install&lt;/code&gt;.&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;You need to add &lt;code&gt;ComCalculator_TLB&lt;/code&gt; to the &lt;code&gt;uses&lt;/code&gt; section in the &lt;code&gt;Unit1.pas&lt;/code&gt; file. After that you &lt;a href=&quot;http://stackoverflow.com/questions/7196769/what-is-this-error-mscorlib-tlb-pas&quot;&gt;can get some issues&lt;/a&gt; with compilation of &lt;code&gt;mscorlib_TBL.pas&lt;/code&gt;. If that’s the case, you just need to delete reference to it from the &lt;code&gt;uses&lt;/code&gt; section of the &lt;code&gt;ComCalculator_TLB.pas&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Now let’s try to use our COM component. We will do it directly in the form constructor. The constructor body will contain two simple lines of code: the first one will contain instance of the &lt;code&gt;TCalculator&lt;/code&gt; class, in the second one, we will call the &lt;code&gt;Sum&lt;/code&gt; method. Calculation result will be shown with the help of the &lt;code&gt;ShowMessage&lt;/code&gt; procedure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-delphi&quot;&gt;procedure TForm1.FormCreate(Sender: TObject);
var
  calculator : TCalculator;
begin
  calculator := TCalculator.Create(Self);
  ShowMessage(IntToStr(calculator.Sum(1, 2)));
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the application you will see the window with figure 3.&lt;/p&gt;
&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;
&lt;p&gt;I recommend reading the following article for more complicated variants of the creation of COM objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/c3fd4a20.aspx&quot;&gt;MSDN: Example COM Class (C# Programming Guide)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;cross-posts&quot;&gt;Cross-posts&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://blogs.perpetuumsoft.com/dotnet/wrapping-c-class-for-use-in-com/&quot;&gt;blogs.perpetuumsoft.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Занимательное о шрифтах в .NET</title>
            <link>http://aakinshin.net/ru/posts/dotnet-fonts/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/dotnet-fonts/</guid>
            <description>&lt;p&gt;Сегодня мы поговорим о замечательном классе &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.font(v=vs.90).aspx&quot;&gt;Font&lt;/a&gt;. Иногда при работе с шрифтами возникают некоторые вопросы, которые не настолько очевидны, как хотелось бы. Рассмотрим несколько из них.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Как опознать моноширинный шрифт?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Это не такой простой вопрос. Если немного погуглить, то можно найти следующий совет: описываем у себя в проекте класс &lt;a href=&quot;http://www.pinvoke.net/default.aspx/Structures/LOGFONT.html&quot;&gt;LOGFONT&lt;/a&gt; и используем метод &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/9a240xh2.aspx&quot;&gt;ToLogFont&lt;/a&gt; для конвертации шрифта в соответствующий объект. После этого (согласно легенде) в поле &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/microsoft.visualstudio.shell.interop.uidlglogfont.lfpitchandfamily(v=vs.80).aspx&quot;&gt;lfPitchAndFamily&lt;/a&gt; первый бит должен определять моноширинность шрифта. Так вот, это враньё, в современном мире поле &lt;a href=&quot;http://social.msdn.microsoft.com/Forums/en-US/netfxbcl/thread/1bc0166b-8a68-4067-a44b-e11ff7d55720&quot;&gt;всегда будет равно нулю&lt;/a&gt;. Когда-то где-то этот способ работал, но сейчас не работает. В реальности приходится использовать не очень красивое, но весьма эффективное решение типа такого:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// graphics — заранее созданный экземпляр класса Graphics
public static bool IsMonospace(Font font)
{
    return Math.Abs(graphics.MeasureString(&amp;quot;iii&amp;quot;, font).Width - 
                    graphics.MeasureString(&amp;quot;WWW&amp;quot;, font).Width) &amp;lt; 1e-3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; А как узнать размеры, которые будет занимать строчка при рисовании данным шрифтом?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Нам понадобится &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.graphics.aspx&quot;&gt;Graphics&lt;/a&gt;, с помощью которого мы собираемся рисовать, а именно — его метод
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/6xe5hazb.aspx&quot;&gt;MeasureString&lt;/a&gt;. Передаём ему рисуемый текст и используемый шрифт — а он нам в ответ отдаёт его размеры.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; А если мне нужен размер не всей строчки, а только заданных её частей?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Это можно сделать с помощью метода &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.graphics.measurecharacterranges.aspx&quot;&gt;Graphics.MeasureCharacterRanges&lt;/a&gt;. Но сначала (в msdn есть хороший пример) нужно задать целевые интервалы символов с помощью метода &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/system.drawing.stringformat.setmeasurablecharacterranges.aspx&quot;&gt;StringFormat.SetMeasurableCharacterRanges&lt;/a&gt;. Это метод обладает занимательным ограничением — ему нельзя передавать более 32-х интервалов.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Этот метод выдаёт какие-то слишком большие границы. В них попадают не только сами символы, но и немного пространства около них. Что делать?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Действительно, возвращаемые регионы содержат интересующие нас символы так, как они идут в исходном шрифте — вместе с небольшой пустотой около них. Красивого способа получить точные границы нет. Придётся явно создавать картинку с целевыми символами, попиксельно её просмотреть (только не используйте метод
&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.bitmap.getpixel.aspx&quot;&gt;Bitmap.GetPixel&lt;/a&gt;, он очень долгий, есть &lt;a href=&quot;http://stackoverflow.com/questions/1563038/fast-work-with-bitmaps-in-c-sharp&quot;&gt;более быстрые способы&lt;/a&gt;) и найти крайние нарисованные символы нашей строки.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Q:&lt;/strong&gt; Я создал шрифт, используя его строковое название, никаких исключений не вылетело. А этот шрифт точно есть в системе?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A:&lt;/strong&gt; Не обязательно. Конструктор класса Font попытается подобрать самый подходящий (по его мнению) шрифт для данного названия. Лучше проверить, что создался правильный шрифт:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var font = new Font(fontName, 12);
vat exists = font.Name == fontName;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А ещё не помешает проверить, поддерживает ли используемое вами семейство шрифтов ваш &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.drawing.fontstyle.aspx&quot;&gt;FontStyle&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;var fontFamily = new FontFamily(fontName);
exists &amp;amp;= fontFamily.IsStyleAvailable(fontStyle);
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>Шаблон диссертации в LaTeX</title>
            <link>http://aakinshin.net/ru/posts/phd-template/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/phd-template/</guid>
            <description>&lt;p&gt;Написать диссертацию — дело нелёгкое. А оформить её ещё сложнее. Благо, есть LaTeX, который может нам в этом помочь. Но для начала было бы здорово обзавестись шаблоном, на основе которого можно было бы сразу приступить к написанию научной работы. Я такого шаблона не нашёл, поэтому решил сделать его сам, возможно кому-то пригодится: &lt;a href=&quot;https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template&quot;&gt;https://github.com/AndreyAkinshin/Russian-Phd-LaTeX-Dissertation-Template&lt;/a&gt;. В шаблоне используется моя любимая кодировка UTF-8. Список литературы генерируется BibTeX-ом, а в отдельной папке аккуратно сложены всевозможные библиографические UTF-8-стили. Используются красивые PSCyr-шрифты, все наиболее часто используемые пакеты подключены. Помимо шаблона диссертации, проект также включает шаблоны автореферата, презентации и черновика для промежуточных наработок.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Cairo — делаем графики гладкими</title>
            <link>http://aakinshin.net/ru/posts/r-cairo/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-cairo/</guid>
            <description>&lt;p&gt;R обладает богатейшим функционалом по формированию различных графиков. К сожалению, иногда графики получается не настолько красивыми, как бы нам хотелось. Давайте нарисуем график синуса:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
x ← seq(0, 10, by = 0.1)
y ← sin(x)
plot(x, y, type=&amp;quot;l&amp;quot;)
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Если вы хорошо вглядитесь в это изображение, то увидите, что функция получилась не совсем гладкой. Дело в том, что стандартное графическое устройство не поддерживает &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%A1%D0%B3%D0%BB%D0%B0%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5&quot;&gt;anti-aliasing&lt;/a&gt;. Но не стоит грустить! Нам поможет &lt;em&gt;Cairo&lt;/em&gt;!  &lt;a href=&quot;http://ru.wikipedia.org/wiki/Cairo&quot;&gt;Cairo&lt;/a&gt; — это программная библиотека, предназначенная для рендеринга векторной графики с не зависящим от оборудования API. А для языка R есть &lt;a href=&quot;http://cran.r-project.org/web/packages/Cairo/index.html&quot;&gt;одноимённый пакет&lt;/a&gt;. Вы можете почитать &lt;a href=&quot;http://cran.r-project.org/web/packages/Cairo/Cairo.pdf&quot;&gt;документацию&lt;/a&gt; к этому пакету, но пока что мы посмотрим работу на примере. Для начала установим пакет и подключим его:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
install.packages(&amp;quot;Cairo&amp;quot;)
library(&amp;quot;Cairo&amp;quot;)
{% endhighlight %}&lt;/p&gt;
&lt;p&gt;Допустим, я работаю под операционной системой Windows и хочу просто посмотреть на гладкий график функции. Нет ничего проще:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
CairoWin()
plot(x, y, type=&amp;quot;l&amp;quot;)
{% endhighlight %}&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/cairo/sin.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;А теперь давайте ещё раз нарисуем наш график, но результат получим в виде png-файла:&lt;/p&gt;
&lt;p&gt;{% highlight r %}
CairoPNG(&amp;quot;sin.png&amp;quot;)
plot(x, y, type=&amp;quot;l&amp;quot;)
dev.off() # Завершаем формирование файла
{% endhighlight %}&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/cairo/sin-antialiasing.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;В Cairo-функциях можно указывать множество дополнительных параметров, таких как ширина и высота изображения, тип файла, его качество, цвет фона и многое другое. Конечно, для рабочего процесса Cairo не так уж и нужен, но при формировании отчётов о проделанной работе он поможет сделать ваши графики более привлекательными.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Операторы +=, -= в R</title>
            <link>http://aakinshin.net/ru/posts/r-compound-assignment/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-compound-assignment/</guid>
            <description>&lt;p&gt;Продолжаем писать полезные операторы для языка R. В большинстве современных языков есть операторы +=, -= и т.п., они делают синтаксис более лаконичным. А давайте и в R определим подобные операторы, чтобы вместо&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;x &amp;lt;- x + 3
y &amp;lt;- y - 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;мы могли бы писать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;x %+=% 3
y %-=% 2
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Да ведь это очень просто. Новые операторы можно определить буквально в пару строк:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&#39;%+=%&#39; &amp;lt;- function(x, y) {
  mapply(assign, as.character(substitute(x)), x + y, MoreArgs = list(envir = parent.frame()))
  invisible()
}
&#39;%-=%&#39; &amp;lt;- function(x, y) {
  mapply(assign, as.character(substitute(x)), x - y, MoreArgs = list(envir = parent.frame()))
  invisible()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь можно писать такой вот код:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a &amp;lt;- 3
a %+=% 2 # a &amp;lt;- a + 2
a # 5
a %-=% 1 # a &amp;lt;- a - 1
a # 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Разумеется, ничего не мешает определить по аналогии %*=%, %/=% и тому подобные замечательные операторы.&lt;/p&gt;</description>
        </item>
        <item>
            <title>Функции в R</title>
            <link>http://aakinshin.net/ru/posts/r-functions/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-functions/</guid>
            <description>&lt;p&gt;В R очень много разных полезных функций. И многие большие вещи можно сделать весьма быстро, написав очень мало кода. На официальном сайте есть замечательная шпаргалка на английском языке: &lt;a href=&quot;http://cran.r-project.org/doc/contrib/Short-refcard.pdf&quot;&gt;R reference card&lt;/a&gt;. В сети есть несколько вольных урезанных переводов, но они не очень удобные. Ниже вашему вниманию представляется русифицированная модифицированная версия обзора основных функций R. Команды снабжены ссылками на &lt;a href=&quot;http://stat.ethz.ch/R-manual/&quot;&gt;online-мануал&lt;/a&gt;.&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id=&quot;section&quot;&gt;Оглавление&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#section-help&quot;&gt;Помощь&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-environment&quot;&gt;Текущее окружение&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-objects-common&quot;&gt;Общая работа с объектами&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-io&quot;&gt;Ввод и вывод&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-objects-creation&quot;&gt;Создание объектов&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-indexers&quot;&gt;Индексирование&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-variables&quot;&gt;Работа с переменными&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-data-manipulation&quot;&gt;Манипуляция данными&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-math&quot;&gt;Математика&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-math&quot;&gt;Матрицы&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-data-processing&quot;&gt;Обработка данных&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-strings&quot;&gt;Строки&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-date&quot;&gt;Дата и время&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-plots&quot;&gt;Рисование графиков&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-plots-lowlevel&quot;&gt;Рисование графиков на низком уровне&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-plots-lattice&quot;&gt;Lattice-графика&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-optimization&quot;&gt;Оптимизация и подбор параметров&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-statistic&quot;&gt;Статистика&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-distributions&quot;&gt;Распределения&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#section-programming&quot;&gt;Программирование&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-help&quot;&gt;Помощь&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.html&quot;&gt;help(topic)&lt;/a&gt;, &lt;code&gt;?topic&lt;/code&gt; — справка про &lt;code&gt;topic&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.search.html&quot;&gt;help.search(&amp;quot;pattern&amp;quot;)&lt;/a&gt;, &lt;code&gt;??pattern&lt;/code&gt; — глобальный поиск &lt;code&gt;pattern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.html&quot;&gt;help(package = )&lt;/a&gt; — справка о заданном пакете&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/help.start.html&quot;&gt;help.start()&lt;/a&gt; — запустить помощь в браузере&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/utils/html/apropos.html&quot;&gt;apropos(what)&lt;/a&gt; — имена объектов, которые соответствуют &lt;code&gt;what&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/base/html/args.html&quot;&gt;args(name)&lt;/a&gt; — аргументы команды &lt;code&gt;name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/utils/html/example.html&quot;&gt;example(topic)&lt;/a&gt; — примеры использования &lt;code&gt;topic&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-environment&quot;&gt;Текущее окружение&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-devel/library/base/html/ls.html&quot;&gt;ls()&lt;/a&gt; — список всех объектов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rm.html&quot;&gt;rm(x)&lt;/a&gt; — удалить объект&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/list.files.html&quot;&gt;dir()&lt;/a&gt; — показать все файлы в текущей директории&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/getwd.html&quot;&gt;getwd()&lt;/a&gt; — получить текущую директорию&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/getwd.html&quot;&gt;setwd(dir)&lt;/a&gt; — поменять текущую директорию на &lt;code&gt;dir&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-objects-common&quot;&gt;Общая работа с объектами&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/str.html&quot;&gt;str(object)&lt;/a&gt; — внутренняя структура объекта &lt;code&gt;object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/summary.html&quot;&gt;summary(object)&lt;/a&gt; — общая информация об объекте &lt;code&gt;object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/dput.html&quot;&gt;dput(x)&lt;/a&gt; — получить представление объекта в R-синтаксисе&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/head.html&quot;&gt;head(x)&lt;/a&gt; — посмотреть начальные строки объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/head.html&quot;&gt;tail(x)&lt;/a&gt; — посмотреть последние строки объекта&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-io&quot;&gt;Ввод и вывод&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/library.html&quot;&gt;library(package)&lt;/a&gt; — подключить пакет &lt;code&gt;package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/save.html&quot;&gt;save(file, ...)&lt;/a&gt; — сохраняет указанные объекты в двочином XDR-формате, который не зависит от платформы&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/load.html&quot;&gt;load()&lt;/a&gt; — загружает данные, сохранённые ранее с помощью команды &lt;code&gt;save()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/read.table.html&quot;&gt;read.table&lt;/a&gt; — считывает таблицу данных и создаёт по ним &lt;code&gt;data.frame&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/write.table.html&quot;&gt;write.table&lt;/a&gt; — печатает объект, конвертируя его в &lt;code&gt;data.frame&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/read.table.html&quot;&gt;read.csv&lt;/a&gt; — считывает &lt;code&gt;csv&lt;/code&gt;-файл&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/read.table.html&quot;&gt;read.delim&lt;/a&gt; — считывание данных, разделённых знаками табуляции&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/save.html&quot;&gt;save.image&lt;/a&gt; — сохраняет все объекты в файл&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cat.html&quot;&gt;cat(..., file= , sep= )&lt;/a&gt; — сохраняет аргументы, конкатенируя их через &lt;code&gt;sep&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sink.html&quot;&gt;sink(file)&lt;/a&gt; — выводит результаты выполнения других команд в файл в режиме реального времени до момента вызова этой же команды без аргументов&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-objects-creation&quot;&gt;Создание объектов&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;from:to&lt;/code&gt; — генерирует последовательность чисел от &lt;code&gt;from&lt;/code&gt; до &lt;code&gt;to&lt;/code&gt; с шагом &lt;code&gt;1&lt;/code&gt;, например &lt;code&gt;1:3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/c.html&quot;&gt;с(...)&lt;/a&gt; — объединяет аргументы в вектор, например &lt;code&gt;c(1, 2, 3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/seq.html&quot;&gt;seq(from, to, by = )&lt;/a&gt; — генерирует последовательность числел от &lt;code&gt;from&lt;/code&gt; до &lt;code&gt;to&lt;/code&gt; с шагом &lt;code&gt;by&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/seq.html&quot;&gt;seq(from, to, len = )&lt;/a&gt; — генерирует последовательность числел от &lt;code&gt;from&lt;/code&gt; до &lt;code&gt;to&lt;/code&gt; длины &lt;code&gt;len&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rep.html&quot;&gt;rep(x, times)&lt;/a&gt; — повторяет &lt;code&gt;x&lt;/code&gt; ровно &lt;code&gt;times&lt;/code&gt; раз&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/list.html&quot;&gt;list(...)&lt;/a&gt; — создаёт список объектов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/data.frame.html&quot;&gt;data.frame(...)&lt;/a&gt; — создаёт фрейм данных&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;array(data, dims)&lt;/a&gt; — создаёт из &lt;code&gt;data&lt;/code&gt; многомерные массив размерностей &lt;code&gt;dim&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/matrix.html&quot;&gt;matrix(data, nrow = , ncol = , byrow = )&lt;/a&gt; — создаёт из &lt;code&gt;data&lt;/code&gt; матрицу &lt;code&gt;nrow&lt;/code&gt; на &lt;code&gt;ncol&lt;/code&gt;, порядок заполнения определяется &lt;code&gt;byrow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/factor.html&quot;&gt;factor(x, levels = )&lt;/a&gt; — создаёт из &lt;code&gt;x&lt;/code&gt; фактор с уровнями &lt;code&gt;levels&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/gl.html&quot;&gt;gl(n, k, length = n*k, labels = 1:n)&lt;/a&gt; — создаёт фактор из &lt;code&gt;n&lt;/code&gt; уровней, каждый из которых повторяется &lt;code&gt;k&lt;/code&gt; раз длины
&lt;code&gt;length&lt;/code&gt; с именами &lt;code&gt;labels&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cbind.html&quot;&gt;rbind(...)&lt;/a&gt; — объединяет аргументы по строкам&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cbind.html&quot;&gt;cbind(...)&lt;/a&gt; — объединяет аргументы по столбцам&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-indexers&quot;&gt;Индексирование&lt;/h3&gt;&lt;/p&gt;
&lt;h4 id=&quot;section-1&quot;&gt;Векторы&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;&lt;code&gt;x[n]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;&lt;code&gt;n&lt;/code&gt;-ый элемент&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[-n]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;все элементы, кроме &lt;code&gt;n&lt;/code&gt;-го&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[1:n]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;первые &lt;code&gt;n&lt;/code&gt; элементов&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[-(1:n)]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;все элементы, кроме первых &lt;code&gt;n&lt;/code&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[c(1,4,2)]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;элементы с заданными индексами&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[&quot;name&quot;]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;элемент с заданным именем&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[x &gt; 3]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;все элементы, большие 3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;code&gt;x[x &gt; 3 &amp; x &lt; 5]&lt;/code&gt;
		&lt;/td&gt;
		&lt;td&gt;все элементы между 3 и 5&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[x %in% c(&quot;a&quot;,&quot;and&quot;,&quot;the&quot;)]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;все элементы из заданного множества&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;h4 id=&quot;section-2&quot;&gt;Списки&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;&lt;code&gt;x[n]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;список, состоящий из элемента &lt;code&gt;n&lt;/code&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[[n]]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;&lt;code&gt;n&lt;/code&gt;-ый элемент списка&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[[&quot;name&quot;]]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;элемент списка с именем &lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x$name&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;элемент списка с именем &lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;h4 id=&quot;section-3&quot;&gt;Матрицы&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;&lt;code&gt;x[i, j]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;элемент на пересечении &lt;code&gt;i&lt;/code&gt;-ой строки и &lt;code&gt;j&lt;/code&gt;-го столбца&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[i,]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;&lt;code&gt;i&lt;/code&gt;-ая строка&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[,j]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;&lt;code&gt;j&lt;/code&gt;-ый столбец&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[,c(1,3)]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;заданное подмножество столбцов&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x[&quot;name&quot;, ]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;строка с именем &lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;h4 id=&quot;section-4&quot;&gt;Фреймы&lt;/h4&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td width=&quot;40%&quot;&gt;&lt;code&gt;x[[&quot;name&quot;]]&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;столбец с именем &lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;&lt;code&gt;x$name&lt;/code&gt;&lt;/td&gt;
		&lt;td&gt;столбец с именем &lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;&lt;h3 id=&quot;section-variables&quot;&gt;Работа с переменными&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;as.array(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/as.data.frame.html&quot;&gt;as.data.frame(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/numeric.html&quot;&gt;as.numeric(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/logical.html&quot;&gt;as.logical(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/complex.html&quot;&gt;as.complex(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/character.html&quot;&gt;as.character(x)&lt;/a&gt; — преобразование переменной к заданному типу &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/NA.html&quot;&gt;is.na(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/NULL.html&quot;&gt;is.null(x)&lt;/a&gt;,
&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;is.array(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/array.html&quot;&gt;is.data.frame(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/numeric.html&quot;&gt;is.numeric(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/complex.html&quot;&gt;is.complex(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/character.html&quot;&gt;is.character(x)&lt;/a&gt; — проверка на то, что данный объект обладает указанным типом&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/length.html&quot;&gt;length(x)&lt;/a&gt; — число элементов в &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/dim.html&quot;&gt;dim(x)&lt;/a&gt; — размерности объекта &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/dimnames.html&quot;&gt;dimnames(x)&lt;/a&gt; — имена размерностей объекта &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/names.html&quot;&gt;names(x)&lt;/a&gt; — имена объекта &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/nrow.html&quot;&gt;nrow(x)&lt;/a&gt; — число строк &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/nrow.html&quot;&gt;ncol(x)&lt;/a&gt; — число столбцов &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/class.html&quot;&gt;class(x)&lt;/a&gt; — класс объекта &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/class.html&quot;&gt;unclass(x)&lt;/a&gt; — удаляет атрибут класса у объекта &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/attr.html&quot;&gt;attr(x,which)&lt;/a&gt; — атрибут &lt;code&gt;which&lt;/code&gt; объекта &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/attributes.html&quot;&gt;attributes(obj)&lt;/a&gt; — список атрибутов объекта &lt;code&gt;obj&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-data-manipulation&quot;&gt;Манипуляция данными&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.min.html&quot;&gt;which.max(x)&lt;/a&gt; — индекс элемента с максимальным значением&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.min.html&quot;&gt;which.min(x)&lt;/a&gt; — индекс элемента с минимальным значением&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rev.html&quot;&gt;rev(x)&lt;/a&gt; — реверсирует порядок элементов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sort.html&quot;&gt;sort(x)&lt;/a&gt; — сортирует элементы объекта по возрастанию&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cut.html&quot;&gt;cut(x,breaks)&lt;/a&gt; — делит вектор на равные интервалы&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html&quot;&gt;match(x, y)&lt;/a&gt; — ищет элементы &lt;code&gt;x&lt;/code&gt;, которые есть в &lt;code&gt;y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.html&quot;&gt;which(x == a)&lt;/a&gt; — возвращает порядковые элементы &lt;code&gt;x&lt;/code&gt;, которые равны &lt;code&gt;a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html&quot;&gt;na.omit(x)&lt;/a&gt; — исключает отсутствующие значения объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/na.fail.html&quot;&gt;na.fail(x)&lt;/a&gt; — бросает исключение, если объект содержит отсутствующие значения&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/unique.html&quot;&gt;unique(x)&lt;/a&gt; — исключает из объекта повторяющиеся элементы&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/unique.html&quot;&gt;table(x)&lt;/a&gt; — создаёт таблицу с количеством повторений каждого уникального элемента&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/subset.html&quot;&gt;subset(x, ...)&lt;/a&gt; — возвращает подмножество элемента, которое соответствует заданному условию&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sample.html&quot;&gt;sample(x, size)&lt;/a&gt; — возвращает случайный набор размера &lt;code&gt;size&lt;/code&gt; из элементов &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/replace.html&quot;&gt;replace(x, list, values)&lt;/a&gt; — заменяет значения &lt;code&gt;x&lt;/code&gt; c индексами из &lt;code&gt;list&lt;/code&gt; значениями из &lt;code&gt;values&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/append.html&quot;&gt;append(x, values)&lt;/a&gt; — добавляет элементы &lt;code&gt;values&lt;/code&gt; в вектор &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-math&quot;&gt;Математика&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Trig.html&quot;&gt;sin(x), cos(x), tan(x), asin(x), acos(x), atan(x), atan2(y, x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Log.html&quot;&gt;log(x), log(x, base), log10(x), exp(x)&lt;/a&gt; — элементарные математические функции&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html&quot;&gt;min(x), max(x)&lt;/a&gt; — минимальный и максимальный элементы объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/range.html&quot;&gt;range(x)&lt;/a&gt; — вектор из минимального и максимального элемента объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Extremes.html&quot;&gt;pmin(x, y), pmax(x, y)&lt;/a&gt; — возвращают вектор с минимальными (максимальными) для каждой пары &lt;code&gt;x[i]&lt;/code&gt;, &lt;code&gt;y[i]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sum.html&quot;&gt;sum(x)&lt;/a&gt; — сумма элементов объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/prod.html&quot;&gt;prod(x)&lt;/a&gt; — произведение элементов объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/diff.html&quot;&gt;diff(x)&lt;/a&gt; — возвращает вектор из разниц между соседними элементами&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/mean.html&quot;&gt;mean(x)&lt;/a&gt; — среднее арифметическое элементов объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/median.html&quot;&gt;median(x)&lt;/a&gt; — медиана (средний элемент) объекта&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/weighted.mean.html&quot;&gt;weighted.mean(x, w)&lt;/a&gt; — средневзвешенное объекта &lt;code&gt;x&lt;/code&gt; (&lt;code&gt;w&lt;/code&gt; определяет веса)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Round.html&quot;&gt;round(x, n)&lt;/a&gt; — округляет &lt;code&gt;x&lt;/code&gt; до &lt;code&gt;n&lt;/code&gt; знаков после запятой&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/cumsum.html&quot;&gt;cumsum(x), cumprod(x), cummin(x), cummax(x)&lt;/a&gt; — кумулятивные суммы, произведения, минимумы и максимумы вектора &lt;code&gt;x&lt;/code&gt; (i-ый элемент содержит статистику по элементам &lt;code&gt;x[1:i]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sets.html&quot;&gt;union(x, y), intersect(x, y), setdiff(x,y), setequal(x,y), is.element(el,set)&lt;/a&gt; — операции над множествами: объединение, пересечение, разность, сравнение, принадлежность&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/complex.html&quot;&gt;Re(x), Im(x), Mod(x), Arg(x), Conj(x)&lt;/a&gt; — операции над комплексными числами: целая часть, мнимая часть, модуль, аргумент, сопряжённое число&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/fft.html&quot;&gt;fft(x), mvfft(x)&lt;/a&gt; — быстрое преобразование Фурье&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/which.html&quot;&gt;choose(n, k)&lt;/a&gt; — количество сочетаний&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/rank.html&quot;&gt;rank(x)&lt;/a&gt; — ранжирует элементы объекта&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-math&quot;&gt;Матрицы&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%*%&lt;/code&gt; — матричное умножение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/t.html&quot;&gt;t(x)&lt;/a&gt; — транспонированная матрица&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/diag.html&quot;&gt;diag(x)&lt;/a&gt; — диагональ матрицы&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/solve.html&quot;&gt;solve(a, b)&lt;/a&gt; — решает систему уравнений &lt;code&gt;a %*% x = b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/solve.html&quot;&gt;solve(a)&lt;/a&gt; — обратная матрица&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/colSums.html&quot;&gt;colSums, rowSums, colMeans, rowMeans&lt;/a&gt; — суммы и средние по столбцам и по строкам&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-data-processing&quot;&gt;Обработка данных&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/apply.html&quot;&gt;apply(X,INDEX,FUN=)&lt;/a&gt; — возвращает вектор, массив или список значений, полученных путем применения функции &lt;code&gt;FUN&lt;/code&gt; к определенным элементам массива или матрицы &lt;code&gt;x&lt;/code&gt;; подлежащие обработке элементы &lt;code&gt;х&lt;/code&gt; указываются при помощи аргумента &lt;code&gt;MARGIN&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/lapply.html&quot;&gt;lapply(X,FUN)&lt;/a&gt; — возвращает список той же длины, что и &lt;code&gt;х&lt;/code&gt;; при этом значения в новом списке будут результатом применения функции &lt;code&gt;FUN&lt;/code&gt; к элементам исходного объекта &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/tapply.html&quot;&gt;tapply(X,INDEX,FUN=)&lt;/a&gt; —  применяет функцию &lt;code&gt;FUN&lt;/code&gt; к каждой совокупности значений х, созданной в соответствии с уровнями определенного фактора; перечень факторов указывается при помощи аргумента &lt;code&gt;INDEX&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/by.html&quot;&gt;by(data,INDEX,FUN)&lt;/a&gt; — аналог &lt;code&gt;tapply()&lt;/code&gt;, применяемый к таблицам данных&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/merge.html&quot;&gt;merge(a,b)&lt;/a&gt; — объединяет две таблицы данных (&lt;code&gt;а&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt;) по общим столбцами или строкам&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/aggregate.html&quot;&gt;aggregate(x,by,FUN)&lt;/a&gt; — разбивает таблицу данных &lt;code&gt;х&lt;/code&gt; на отдельные наборы данных, применяет к этим наборам определенную функцию &lt;code&gt;FUN&lt;/code&gt; и возвращает результат в удобном для чтения формате&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/stack.html&quot;&gt;stack(x, ...)&lt;/a&gt; — преобразует данные, представленные в объекте &lt;code&gt;х&lt;/code&gt; в виде отдельных столбцов, в таблицу данных&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/utils/html/stack.html&quot;&gt;unstack(x, ...)&lt;/a&gt; —  выполняет операцию, обратную действию функции &lt;code&gt;stack()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/reshape.html&quot;&gt;reshape(x, ...)&lt;/a&gt; — преобразует таблицу данных из &#171;широкого формата&#187; (повторные измерения какой-либо величины записаны в отдельных столбцах таблицы) в таблицу &amp;quot;узкого формата&amp;quot; (повторные измерения идут одно под одним в пределах одного столбца)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-strings&quot;&gt;Строки&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/print.html&quot;&gt;print(x)&lt;/a&gt; — выводит на экран &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/sprintf.html&quot;&gt;sprintf(fmt, ...)&lt;/a&gt; — форматирование текста в &lt;code&gt;C-style&lt;/code&gt; (можно использовать &lt;code&gt;%s, %.5f&lt;/code&gt; и т.п.)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/format.html&quot;&gt;format(x)&lt;/a&gt; — форматирует объект &lt;code&gt;x&lt;/code&gt; так, чтобы он выглядел красиво при выводе на экран&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/paste.html&quot;&gt;paste(...)&lt;/a&gt; — конвертирует векторы в текстовые переменные и объединяет их в одно текстовое выражение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/substr.html&quot;&gt;substr(x,start,stop)&lt;/a&gt; — получение подстроки&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/strsplit.html&quot;&gt;strsplit(x,split)&lt;/a&gt; — разбивает строку &lt;code&gt;х&lt;/code&gt; на подстроки в соответствии с &lt;code&gt;split&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/grep.html&quot;&gt;grep(pattern,x)&lt;/a&gt; (а также &lt;code&gt;grepl&lt;/code&gt;, &lt;code&gt;regexpr&lt;/code&gt;, &lt;code&gt;gregexpr&lt;/code&gt;, &lt;code&gt;regexec&lt;/code&gt;) — поиск по регулярному выражению&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/grep.html&quot;&gt;gsub(pattern,replacement,x)&lt;/a&gt; (а также &lt;code&gt;sub&lt;/code&gt;) — замена по регулярному выражению&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/chartr.html&quot;&gt;tolower(x)&lt;/a&gt; — привести строку к нижнему регистру&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/chartr.html&quot;&gt;toupper(x)&lt;/a&gt; — привести строку к верхнему регистру&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/match.html&quot;&gt;match(x,table)&lt;/a&gt;, &lt;code&gt;x %in% table&lt;/code&gt; — выполняет поиск элементов в векторе &lt;code&gt;table&lt;/code&gt;, которые совпадают со значениями из вектора &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/pmatch.html&quot;&gt;pmatch(x,table)&lt;/a&gt; — выполняет поиск элементов в векторе &lt;code&gt;table&lt;/code&gt;, которые частично совпадают с элементами вектора х&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/nchar.html&quot;&gt;nchar(x)&lt;/a&gt; — возвращает количество знаков в строке &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-date&quot;&gt;Дата и время&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/as.Date.html&quot;&gt;as.Date(s)&lt;/a&gt; — конвертирует вектор &lt;code&gt;s&lt;/code&gt; в объект класса &lt;code&gt;Date&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/as.POSIXlt.html&quot;&gt;as.POSIXct(s)&lt;/a&gt; — конвертирует вектор &lt;code&gt;s&lt;/code&gt; в объект класса POSIXct&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-plots&quot;&gt;Рисование графиков&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/plot.html&quot;&gt;plot(x)&lt;/a&gt; — график &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/plot.html&quot;&gt;plot(x, y)&lt;/a&gt; — график зависимости &lt;code&gt;y&lt;/code&gt; от &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/hist.html&quot;&gt;hist(x)&lt;/a&gt; — гистограмма&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/barplot.html&quot;&gt;barplot(x)&lt;/a&gt; — столбчатая диаграмма&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/dotchart.html&quot;&gt;dotchart(x)&lt;/a&gt; — диаграмма Кливленда&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/pie.html&quot;&gt;pie(x)&lt;/a&gt; — круговая диаграмма&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/boxplot.html&quot;&gt;boxplot(x)&lt;/a&gt; — график типа &amp;quot;коробочки с усами&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/sunflowerplot.html&quot;&gt;sunflowerplot(x, y)&lt;/a&gt; — то же, что и &lt;code&gt;plot()&lt;/code&gt;, однако точки с одинаковыми координатами изображаются в виде &amp;quot;ромашек&amp;quot;, количество лепестков у которых пропорционально количеству таких точек&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/coplot.html&quot;&gt;coplot(x˜y | z)&lt;/a&gt; — график зависимости y от x для каждого интервала значений &lt;code&gt;z&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/interaction.plot.html&quot;&gt;interaction.plot(f1, f2, y)&lt;/a&gt; — если &lt;code&gt;f1&lt;/code&gt; и &lt;code&gt;f2&lt;/code&gt; — факторы, эта фукнция создаст график со средними значениями &lt;code&gt;y&lt;/code&gt; в соответствии со значениями &lt;code&gt;f1&lt;/code&gt; (по оси &lt;code&gt;х&lt;/code&gt;) и &lt;code&gt;f2&lt;/code&gt; (по оси &lt;code&gt;у&lt;/code&gt;, разные кривые)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/matplot.html&quot;&gt;matplot(x, y)&lt;/a&gt; — график зависимости столбцов y от столбцов &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/fourfoldplot.html&quot;&gt;fourfoldplot(x)&lt;/a&gt; — изображает (в виде частей окружности) связь между двумя бинарными переменными в разных совокупностях&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/assocplot.html&quot;&gt;assocplot(x)&lt;/a&gt; — график Кохена-Френдли&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/mosaicplot.html&quot;&gt;mosaicplot(x)&lt;/a&gt; — мозаичный график остатков лог-линейной регрессии&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/pairs.html&quot;&gt;pairs(x)&lt;/a&gt; —  если х - матрица или таблица данных, эта функция изобразит диаграммы рассеяния для всех возможных пар переменных из &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/plot.ts.html&quot;&gt;plot.ts(x)&lt;/a&gt;, &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/ts.plot.html&quot;&gt;ts.plot(x)&lt;/a&gt; — изображает временной ряд&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/qqnorm.html&quot;&gt;qqnorm(x)&lt;/a&gt; — квантили&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/qqnorm.html&quot;&gt;qqplot(x, y)&lt;/a&gt; — график зависимости квантилей y от квантилей &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/contour.html&quot;&gt;contour(x, y, z)&lt;/a&gt; — выполняет интерполяцию данных и создает контурный график&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/filled.contour.html&quot;&gt;filled.contour(x, y, z)&lt;/a&gt; —  то же, что &lt;code&gt;contour()&lt;/code&gt;, но заполняет области между контурами определёнными цветами&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/image.html&quot;&gt;image(x, y, z)&lt;/a&gt; — изображает исходные данные в виде квадратов, цвет которых определяется значениями &lt;code&gt;х&lt;/code&gt; и &lt;code&gt;у&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/persp.html&quot;&gt;persp(x, y, z)&lt;/a&gt; — то же, что и &lt;code&gt;image()&lt;/code&gt;, но в виде трехмерного графика&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/stars.html&quot;&gt;stars(x)&lt;/a&gt; — если &lt;code&gt;x&lt;/code&gt; — матрица или таблица данных, изображает график в виде &amp;quot;звезд&amp;quot; так, что каждая строка представлена &amp;quot;звездой&amp;quot;, а столбцы задают длину сегментов этих &amp;quot;звезд&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/symbols.html&quot;&gt;symbols(x, y, ...)&lt;/a&gt; —  изображает различные символы в соответствии с координатами&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/termplot.html&quot;&gt;termplot(mod.obj)&lt;/a&gt; — зображает частные эффекты переменных из регрессионной модели&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-plots-lowlevel&quot;&gt;Рисование графиков на низком уровне&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/points.html&quot;&gt;points(x, y)&lt;/a&gt; — рисование точек&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/lines.html&quot;&gt;lines(x, y)&lt;/a&gt; — рисование линии&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/text.html&quot;&gt;text(x, y, labels, ...)&lt;/a&gt; — добавление текстовой надписи&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/mtext.html&quot;&gt;mtext(text, side=3, line=0, ...)&lt;/a&gt; — добавление текстовой надписи&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/segments.html&quot;&gt;segments(x0, y0, x1, y1)&lt;/a&gt; — рисование отрезка&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/arrows.html&quot;&gt;arrows(x0, y0, x1, y1, angle= 30, code=2)&lt;/a&gt; — рисование стрелочки&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(a,b)&lt;/a&gt; — рисование наклонной прямой&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(h=y)&lt;/a&gt; — рисование вертикальной прямой&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(v=x)&lt;/a&gt; — рисование горизонтальной прямой&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/abline.html&quot;&gt;abline(lm.obj)&lt;/a&gt; — рисование регрессионной прямой&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/rect.html&quot;&gt;rect(x1, y1, x2, y2)&lt;/a&gt; — рисование прямоугольника&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/polygon.html&quot;&gt;polygon(x, y)&lt;/a&gt; — рисование многоугольника&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/legend.html&quot;&gt;legend(x, y, legend)&lt;/a&gt; — добавление легенды&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/title.html&quot;&gt;title()&lt;/a&gt; — добавление заголовка&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/axis.html&quot;&gt;axis(side, vect)&lt;/a&gt; — добавление осей&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/rug.html&quot;&gt;rug(x)&lt;/a&gt; — рисование засечек на оси &lt;code&gt;X&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/graphics/html/locator.html&quot;&gt;locator(n, type = &amp;quot;n&amp;quot;, ...)&lt;/a&gt; — возвращает координаты на графике, в которые кликнул пользователь&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-plots-lattice&quot;&gt;Lattice-графика&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;xyplot(y˜x)&lt;/a&gt; — график зависимости &lt;code&gt;у&lt;/code&gt; от &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;barchart(y˜x)&lt;/a&gt; — столбчатая диаграмма&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;dotplot(y˜x)&lt;/a&gt; — диаграмма Кливленда&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/histogram.html&quot;&gt;densityplot(˜x)&lt;/a&gt; — график плотности распределения значений &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/histogram.html&quot;&gt;histogram(˜x)&lt;/a&gt; — гистограмма значений &lt;code&gt;х&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;bwplot(y˜x)&lt;/a&gt; — график типа &amp;quot;коробочки с усами&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/qqmath.html&quot;&gt;qqmath(˜x)&lt;/a&gt; — аналог функции &lt;code&gt;qqnorm()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/xyplot.html&quot;&gt;stripplot(y˜x)&lt;/a&gt; — аналог функции &lt;code&gt;stripplot(x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/qq.html&quot;&gt;qq(y˜x)&lt;/a&gt; — изображает квантили распределений &lt;code&gt;х&lt;/code&gt; и &lt;code&gt;у&lt;/code&gt; для визуального сравнения этих распределений; переменная &lt;code&gt;х&lt;/code&gt; должна быть числовой, переменная &lt;code&gt;у&lt;/code&gt; - числовой, текстовой, или фактором с двумя уровнями&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/splom.html&quot;&gt;splom(˜x)&lt;/a&gt; — матрица диаграмм рассеяния (аналог функции &lt;code&gt;pairs()&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/levelplot.html&quot;&gt;levelplot(z˜x&lt;em&gt;y|g1&lt;/em&gt;g2)&lt;/a&gt; —  цветной график значений &lt;code&gt;z&lt;/code&gt;, координаты которых заданы переменными &lt;code&gt;х&lt;/code&gt; и &lt;code&gt;у&lt;/code&gt; (очевидно, что &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; и &lt;code&gt;z&lt;/code&gt; должны иметь одинаковую длину); &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;... (если присутствуют) —  факторы или числовые переменные, чьи значения автоматически разбиваются на равномерные отрезки&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/cloud.html&quot;&gt;wireframe(z˜x&lt;em&gt;y|g1&lt;/em&gt;g2)&lt;/a&gt; — функция для построения трехмерных диаграмм рассеяния и плоскостей; &lt;code&gt;z&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;у&lt;/code&gt; - числовые векторы; &lt;code&gt;g1&lt;/code&gt;, &lt;code&gt;g2&lt;/code&gt;... (если присутствуют) - факторы или числовые переменные, чьи значения автоматически разбиваются на равномерные отрезки&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/lattice/html/cloud.html&quot;&gt;cloud(z˜x&lt;em&gt;y|g1&lt;/em&gt;g2)&lt;/a&gt; — трёхмерная диаграмма рассеяния&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-optimization&quot;&gt;Оптимизация и подбор параметров&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/optim.html&quot;&gt;optim(par, fn, method = )&lt;/a&gt; — оптимизация общего назначения&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/nlm.html&quot;&gt;nlm(f,p)&lt;/a&gt; — минимизация функции &lt;code&gt;f&lt;/code&gt; алгоритмом Ньютона&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/lm.html&quot;&gt;lm(formula)&lt;/a&gt; — подгонка линейной модели&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/glm.html&quot;&gt;glm(formula,family=)&lt;/a&gt; — подгонка обобщённой линейной модели&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/nls.html&quot;&gt;nls(formula)&lt;/a&gt; — нелинейный метод наименьших квадратов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/approxfun.html&quot;&gt;approx(x,y=)&lt;/a&gt; — линейная интерполяция&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/splinefun.html&quot;&gt;spline(x,y=)&lt;/a&gt; — интерполяция кубическими сплайнами&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/loess.html&quot;&gt;loess(formula)&lt;/a&gt; — подгонка полиномиальной поверхности&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/predict.html&quot;&gt;predict(fit,...)&lt;/a&gt; — построение прогнозов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/coef.html&quot;&gt;coef(fit)&lt;/a&gt; — расчётные коэффициенты&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-statistic&quot;&gt;Статистика&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/sd.html&quot;&gt;sd(x)&lt;/a&gt; — стандартное отклонение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;var(x)&lt;/a&gt; — дисперсия&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;cor(x)&lt;/a&gt; — корреляционная матрица&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;var(x, y)&lt;/a&gt; — ковариация между &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/cor.html&quot;&gt;cor(x, y)&lt;/a&gt; — линейная корреляция между &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/aov.html&quot;&gt;aov(formula)&lt;/a&gt; — дисперсионный анализ&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/anova.html&quot;&gt;anova(fit,...)&lt;/a&gt; — дисперсионный анализ для подогнанных моделей &lt;code&gt;fit&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/density.html&quot;&gt;density(x)&lt;/a&gt; — ядерные плотности вероятностей&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/binom.test.html&quot;&gt;binom.test()&lt;/a&gt; — точный тест простой гипотезы о вероятности успеха в испытаниях Бернулли&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/pairwise.t.test.html&quot;&gt;pairwise.t.test()&lt;/a&gt; — попарные сравнения нескольки независимых или зависимых выборок&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/prop.test.html&quot;&gt;prop.test()&lt;/a&gt; —  проверка гипотезы о том, что частоты какого-либо признака равны во всех анализируемых группах&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/t.test.html&quot;&gt;t.test()&lt;/a&gt; — тест Стьюдента&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-distributions&quot;&gt;Распределения&lt;/h3&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Normal.html&quot;&gt;rnorm(n, mean=0, sd=1)&lt;/a&gt; — нормальное распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Exponential.html&quot;&gt;rexp(n, rate=1)&lt;/a&gt; — экспоненциальное распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/GammaDist.html&quot;&gt;rgamma(n, shape, scale=1)&lt;/a&gt; — гамма-распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Poisson.html&quot;&gt;rpois(n, lambda)&lt;/a&gt; — распределение Пуассона&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Weibull.html&quot;&gt;rweibull(n, shape, scale=1)&lt;/a&gt; — распределение Вейбулла&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Cauchy.html&quot;&gt;rcauchy(n, location=0, scale=1)&lt;/a&gt; — распределение Коши&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Beta.html&quot;&gt;rbeta(n, shape1, shape2)&lt;/a&gt; — бета-распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/TDist.html&quot;&gt;rt(n, df)&lt;/a&gt; — распределение Стьюдента&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Fdist.html&quot;&gt;rf(n, df1, df2)&lt;/a&gt; — распределение Фишера&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Chisquare.html&quot;&gt;rchisq(n, df)&lt;/a&gt; — распределение Пирсона&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Binomial.html&quot;&gt;rbinom(n, size, prob)&lt;/a&gt; — биномиальное распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Geometric.html&quot;&gt;rgeom(n, prob)&lt;/a&gt; — геометрическое распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Hypergeometric.html&quot;&gt;rhyper(nn, m, n, k)&lt;/a&gt; — гипергеометрическое распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Logistic.html&quot;&gt;rlogis(n, location=0, scale=1)&lt;/a&gt; — логистическое распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Lognormal.html&quot;&gt;rlnorm(n, meanlog=0, sdlog=1)&lt;/a&gt; — логнормальное распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/NegBinomial.html&quot;&gt;rnbinom(n, size, prob)&lt;/a&gt; — отрицательное биномиальное распределение&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/stats/html/Uniform.html&quot;&gt;runif(n, min=0, max=1)&lt;/a&gt; — равномерное распределение&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;h3 id=&quot;section-programming&quot;&gt;Программирование&lt;/h3&gt;&lt;/p&gt;
&lt;p&gt;Работа с функциями:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function(arglist) { expr }&lt;/code&gt; — создание пользовательской функции&lt;/li&gt;
&lt;li&gt;&lt;code&gt;return(value)&lt;/code&gt; — возвращение значения&lt;/li&gt;
&lt;li&gt;&lt;code&gt;do.call(funname, args)&lt;/code&gt; — вызывает функцию по имени&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Условные операторы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if(cond) expr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if(cond) cons.expr else alt.expr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ifelse(test, yes, no)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Циклы:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for(var in seq) expr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while(cond) expr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;repeat expr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;break&lt;/code&gt; — остановка цикла&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>R-ссылки</title>
            <link>http://aakinshin.net/ru/posts/r-links/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-links/</guid>
            <description>&lt;h3 id=&quot;r&quot;&gt;Английские полезные R-ресурсы&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.r-project.org/&quot;&gt;R-project&lt;/a&gt; — официальный сайт&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt; — официальный репозиторий пакетов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.bioconductor.org/&quot;&gt;Bioconductor&lt;/a&gt; — ещё один репозиторий пакетов&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gallery.r-enthusiasts.com/&quot;&gt;R graph gallery&lt;/a&gt; — графическая галерея R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.inside-r.org/&quot;&gt;Inside-R&lt;/a&gt; — замечательно R-сообщество&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lib.stat.cmu.edu/R/CRAN/doc/manuals/fullrefman.pdf&quot;&gt;Full manual&lt;/a&gt; — полные оригинальные спецификации&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cookbook-r.com/&quot;&gt;R Cookbook&lt;/a&gt; — разные полезные R-сниппеты для решения типовых задач&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.statmethods.net/index.html&quot;&gt;Quick-R&lt;/a&gt; — краткий обзор языка&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://tryr.codeschool.com/&quot;&gt;Try R&lt;/a&gt; — online-обучалка основам языка&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rwiki.sciviews.org/doku.php&quot;&gt;R Wiki&lt;/a&gt; — небольшая вики про язык R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rseek.org/&quot;&gt;R Seek&lt;/a&gt; — поиск информации про R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://journal.r-project.org/&quot;&gt;R Journal&lt;/a&gt; — журнал про R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://google.github.io/styleguide/Rguide.xml&quot;&gt;Google&#39;s R Style Guide&lt;/a&gt; — стандарты оформления R-кода от Google&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.mayin.org/ajayshah/KB/R/index.html&quot;&gt;R by example&lt;/a&gt; — подборка примеров использования R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://cran.r-project.org/doc/FAQ/R-FAQ.html&quot;&gt;R FAQ&lt;/a&gt; — официальный FAQ&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hadley/devtools/wiki/Functional-programming&quot;&gt;Functional programming&lt;/a&gt; — учимся функциональному программированию на R&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://crantastic.org/&quot;&gt;crantastic&lt;/a&gt; — ещё одно R-сообщество&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.omegahat.org/&quot;&gt;omegahat&lt;/a&gt; — ещё один R-репозиторий&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.programmingr.com&quot;&gt;ProgrammingR.com&lt;/a&gt; — и ещё один полезный сайт&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://fractalswithr.blogspot.ru/&quot;&gt;fractalswithr&lt;/a&gt; — фракталы на R&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&#160;&lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Английские блоги&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.r-bloggers.com&quot;&gt;R-bloggers.com&lt;/a&gt; — агрегатор блогов про R.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.revolutionanalytics.com/&quot;&gt;Revolutions&lt;/a&gt; — Learn more about using open source R for big data analysis, predictive modeling, data science and more from the staff of Revolution Analytics&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://learnr.wordpress.com/&quot;&gt;Learning R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zvfak.blogspot.ru/&quot;&gt;Recipes, scripts and genomics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ryouready.wordpress.com/&quot;&gt;&amp;quot;R&amp;quot; you ready?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.decisionsciencenews.com/&quot;&gt;decisionsciencenews.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;r-1&quot;&gt;Русские полезные R-ресурсы&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.r-bloggers.com/lang/-/russian&quot;&gt;R-bloggers.com/lang/-/russian&lt;/a&gt; — агрегатор русских блогов про R.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://r-statistics.livejournal.com/&quot;&gt;Язык и среда R. Статистическое программное обеспечение&lt;/a&gt; — русскоязычное сообщество в ЖЖ про R.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://r-analytics.blogspot.ru/&quot;&gt;R: Анализ и визуализация данных&lt;/a&gt; — блог Сергея Мастицкого о языке программирования и системе статистических вычислений R, с вкраплениями более общих размышлений о прикладной статистике и моделировании.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://voliadis.ru/taxonomy/term/18&quot;&gt;Научный блог Волиадиса&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://quantviews.blogspot.ru/&quot;&gt;quantviews&lt;/a&gt; — про анализ и обработку экономических данных и все, что с этим может быть связано&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;stackoverflow&quot;&gt;Полезные вопросы на &lt;a href=&quot;http://stackoverflow.com/questions/tagged/r&quot;&gt;Stackoverflow&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/3505701/r-grouping-functions-sapply-vs-lapply-vs-apply-vs-tapply-vs-by-vs-aggrega&quot;&gt;R Grouping functions: sapply vs. lapply vs. apply. vs. tapply vs. by vs. aggregate vs&lt;/a&gt; — apply и его друзья&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/12675147/how-can-we-make-xkcd-style-graphs-in-r?goback=.gmp_77616.gde_77616_member_177069747&quot;&gt;How can we make xkcd style graphs in R?&lt;/a&gt; — рисуем графики от руки в стиле веб-комиска&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/192369/books-for-learning-the-r-language&quot;&gt;Books for learning the R language&lt;/a&gt; — хорошие книжки про R&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Хорошие посты на &lt;a href=&quot;http://habrahabr.ru/hub/r/&quot;&gt;Хабре&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/160373/&quot;&gt;Введение в R-project&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/168817/&quot;&gt;Мой опыт введения в R или &#171;I Love R&#187;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/165337/&quot;&gt;Визуализация статистики использования компьютера с R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/163277/&quot;&gt;Параллелим R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/168399/&quot;&gt;Пример ускорения расчётов в R путём многопоточности&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/162583/&quot;&gt;Язык R в помощь хабра-статисту&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/140093/&quot;&gt;Анализируем Twitter при помощи R&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://habrahabr.ru/post/165305/R&quot;&gt;Динамическая визуализация геокодированных данных&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Интересные русские посты&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://quantviews.blogspot.ru/2013/02/choropleth-maps-rworldmap-r.html&quot;&gt;Построение страновых хороплет-карт (choropleth maps) с помощью пакета rworldmap в статистическом пакете R&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Интересные английские посты&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://vis.supstat.com/2013/04/mathematical-annotation-in-r/&quot;&gt;LaTeX-подобные подписи к графикам&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://vis.supstat.com/2013/04/plotting-symbols-and-color-palettes/&quot;&gt;Шпаргалка по значкам для графиков и цветовым палитрам&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Множественное присваивание в R</title>
            <link>http://aakinshin.net/ru/posts/r-multiple-assignment/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-multiple-assignment/</guid>
            <description>&lt;p&gt;R — мощный и лаконичный язык. С помощью коротких инструкций можно сделать очень многое. Но давайте сделаем R ещё лаконичнее.&lt;/p&gt;
&lt;p&gt;Чего мне всегда не хватало в R — так это множественного присваивания. Из-за отсутствия этой возможности приходится иногда писать не совсем красивый код для получения результата функции, который должен распределиться по нескольким переменным:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;x &amp;lt;- solve(matrix(c(2, 0, 0, 3), ncol=2), c(1, 1))
x1 &amp;lt;- x[1]
x2 &amp;lt;- x[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А вот было бы здорово если бы такие вещи можно было записывать в одну строчку, например так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;с(x1, x2) %=% solve(matrix(c(2, 0, 0, 3), ncol=2), c(1, 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Нет ничего проще!&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Определим следующий бинарный оператор множественного присваивания:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&#39;%=%&#39; &amp;lt;- function(x, y) {
  x &amp;lt;- as.character(substitute(x)[-1])
  if (length(y) &amp;lt; length(x))
    y &amp;lt;- rep(y, ceiling(length(x) / length(y)))
  if (length(y) &amp;gt; length(x))
    y &amp;lt;- y[1:length(x)]
  mapply(assign, x, y, MoreArgs = list(envir = parent.frame()))
  invisible()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В лучших традициях R этот оператор устойчив к различным типам аргументов и к различной их длине. Все следующие инструкции будут прекрасно выполняться:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;c(u1, u2) %=% c(1, 2)
c(u3, u4) %=% c(3, 4, 5)
c(u5, u6) %=% list(&amp;quot;a&amp;quot;, 6)
c(u7, u8, u9) %=% list(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;)
list(u10, u11, u12) %=% list(7, &amp;quot;second&amp;quot;, c(8, 9))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А чтобы не объявлять этот замечательный оператор каждый раз заново, вы можете один раз прописать его в &lt;a href=&quot;http://r-language.ru/articles/rprofile&quot;&gt;rprofile&lt;/a&gt;-файле и пользоваться им повсеместно в своих вычислениях!&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7519790/assign-multiple-new-variables-in-a-single-line-in-r&quot;&gt;Stackoverflow&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Progress bar в R</title>
            <link>http://aakinshin.net/ru/posts/r-progress-bar/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-progress-bar/</guid>
            <description>&lt;p&gt;Давайте поговорим о долгих расчётах, ведь они не так редко встречаются в мире вычислений. Когда вы запускаете скрипт, который будет заведомо долго работать, то приятно смотреть на состояние прогресса. Эта информация поможет прикинуть время до конца вычислений (&lt;em&gt;&#171;осталось ещё 30%, я успею выпить чашку кофе&#187;&lt;/em&gt;
) или просигнализировать о бесконечном цикле (&lt;i&gt;&lt;em&gt;1438% выполнено, что-то пошло не так...&lt;/em&gt;&lt;/i&gt;
). Давайте научим наш скрипт сообщать пользователю о проценте выполненных работ.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Пусть у нас есть очень полезная функция, которая делает что-то очень важное некоторое время:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;foo &amp;lt;- function() {
  Sys.sleep(0.1)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И эта функция запускается несколько раз:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (i in 1:10) {
  foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Казалось бы, самое простое решение — выводить на экран количество выполненных операцией:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (i in 1:10) {
  foo()
  print(i)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но такой фокус не всегда будет работать. Дело в том, что R любит буфферезировать вывод на консоль, т.е. не обязательно мы увидим вывод команды сразу после её выполнения. К счастью, &lt;a href=&quot;http://cran.r-project.org/bin/windows/rw-FAQ.html#The-output-to-the-console-seems-to-be-delayed&quot;&gt;есть способ&lt;/a&gt;, победить эту проблему — нам поможет строчка для обновления консоли: &lt;em&gt;flush.console()&lt;/em&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;for (i in 1:10) {
  foo()
  print(i)
  flush.console()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Решение работает, но оно не такое уж и красивое. Давайте сделаем настоящий progress bar. Для начала простенький, текстовый. Сделать это весьма просто:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;pb &amp;lt;- txtProgressBar(min = 0, max = 10, style = 3) # Создаём progress bar
for(i in 1:10){
   foo()
   setTxtProgressBar(pb, i) # Обновляем progress bar
}
close(pb) # Закрываем progress bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но можно пойти ещё дальше по пути к созданию прекраснейшего progress bar-а. А поможет нам в этом пакет tcltk:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;pb &amp;lt;- tkProgressBar(title = &amp;quot;progress bar&amp;quot;, min = 0,
                    max = 10, width = 300) # Создаём progress bar
 
for(i in 1:10){
   foo()
   setTkProgressBar(pb, i, label=paste(
                    round(i/10 * 100, 0), &amp;quot;% done&amp;quot;)) # Обновляем progress bar
}
close(pb) # Закрываем progress bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А для пользователей Windows можно предложить ещё один способ:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;pb &amp;lt;- winProgressBar(title = &amp;quot;progress bar&amp;quot;, min = 0,
                     max = 10, width = 300)  # Создаём progress bar
for(i in 1:10){
   foo()
   setWinProgressBar(pb, i, title=paste( 
                     round(i/10 * 100, 0), &amp;quot;% done&amp;quot;))  # Обновляем progress bar
}
close(pb)  # Закрываем progress bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/progress-bar/screen.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Ну вот и всё, теперь вы умеете создавать разнообразные progress bar-ы и делать процесс выполнения R-скрипта более информативным.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ryouready.wordpress.com/2009/03/16/r-monitor-function-progress-with-a-progress-bar/r-progress-bar.md&quot;&gt;R: Monitoring the function progress with a progress bar&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Rprofile — кастомизируем рабочее окружение</title>
            <link>http://aakinshin.net/ru/posts/r-rprofile/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-rprofile/</guid>
            <description>&lt;p&gt;Давайте поговорим о задании окружения в R. Для этой цели имеется два волшебных файла:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Rprofile.site&lt;/code&gt; — глобальный файл настроек для всех сессий. Путь в Windows: &lt;code&gt;c:\Program Files\R\R-x.y.z\etc\Rprofile.site&lt;/code&gt;, путь в Linux: &lt;code&gt;/etc/R/Rprofile.site&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Rprofile&lt;/code&gt; — локальный файл настроек для текущей сессии. Лежит в домашней директории пользователя.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Эти файлы строятся единообразно, в них можно задать глобальные настройки окружения и объявить две полезных функции:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.First &amp;lt;- function() { ... }&lt;/code&gt; — функция, которая запускается в начале R-сессии&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Last &amp;lt;- function() { ... }&lt;/code&gt; — функция, которая запускается в конце R-сессии&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;На Stackoverflow &lt;a href=&quot;http://stackoverflow.com/questions/1189759/expert-r-users-whats-in-your-rprofile&quot;&gt;можно посмотреть&lt;/a&gt; какие .Rprofile-файлы используют люди. Взглянем, что же можно полезного сделать в таком файле на небольших примерах. &lt;!--more--&gt;&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Подключение часто используемых пакетов&lt;/h3&gt;
&lt;p&gt;Есть ли у вас любимые пакеты, которые вы используете в каждой R-сессии? Вас утомляет каждый раз их импортировать? Так давай те же сделаем это единожды:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(ggplot2)
library(rgl)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-1&quot;&gt;Создание псевдонимов для часто используемых функций&lt;/h3&gt;
&lt;p&gt;А есть ли у вас любимые функции, которые вы вызываете очень часто? Их названия слишком длинные? Так давайте же создадим для них псевдонимы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;s &amp;lt;- base::summary; # используем s(obj) вместо summary(obj)
h &amp;lt;- utils::head;   # используем h(obj) вместо head(obj)
n &amp;lt;- base::names;   # используем n(obj) вместо names(obj)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-2&quot;&gt;Задание предпочитаемого репозитория&lt;/h3&gt;
&lt;p&gt;У стандартного репозитория &lt;a href=&quot;http://cran.r-project.org/&quot;&gt;CRAN&lt;/a&gt; есть много &lt;a href=&quot;http://cran.r-project.org/mirrors.html&quot;&gt;зеркал&lt;/a&gt;. Вы можете задать любимый репозиторий несколькими строчками кода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt; local({r &amp;lt;- getOption(&amp;quot;repos&amp;quot;)
       r[&amp;quot;CRAN&amp;quot;] &amp;lt;- &amp;quot;http://cran.gis-lab.info/&amp;quot;
       options(repos=r)})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-3&quot;&gt;Задание основного языка&lt;/h3&gt;
&lt;p&gt;А давайте сделаем так, чтобы по умолчанию язык был английский:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;Sys.setenv(lang = &amp;quot;en&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section-4&quot;&gt;Установка различных опций&lt;/h3&gt;
&lt;p&gt;Вы можете установить любые опции на свой вкус:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;options(papersize=&amp;quot;a4&amp;quot;)
options(editor=&amp;quot;notepad&amp;quot;)
options(pager=&amp;quot;internal&amp;quot;)
options(help_type=&amp;quot;html&amp;quot;)
options(&amp;quot;width&amp;quot;=160)
options(&amp;quot;digits.secs&amp;quot;=3)
options(prompt=&amp;quot;R&amp;gt; &amp;quot;, digits=4, show.signif.stars=FALSE)
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>Конкатенация строк в R</title>
            <link>http://aakinshin.net/ru/posts/r-string-concatenation/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-string-concatenation/</guid>
            <description>&lt;p&gt;Давайте поговорим о конкатенации строк. Новички в R пытаются пробовать стандартную конструкцию&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;a&amp;quot; + &amp;quot;b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но их постигает неудача — R так не работает. Оператор плюс — это &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/Arithmetic.html&quot;&gt;арифметическая операция&lt;/a&gt;, её нельзя применять к строкам. В R полагается использовать функцию &lt;a href=&quot;http://stat.ethz.ch/R-manual/R-patched/library/base/html/paste.html&quot;&gt;paste&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;paste (..., sep = &amp;quot; &amp;quot;, collapse = NULL)
paste0(..., collapse = NULL)
&lt;/code&gt;&lt;/pre&gt;
&lt;!--more--&gt;
&lt;p&gt;Функция paste соединяет строки, разделяя их некоторым сепаратором sep (который по умолчанию равен пробелу), а paste0 — это её аналог с пустым оператором. Поясним примером:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;paste(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;) # &amp;quot;a b c&amp;quot;
paste0(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;) # &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Такой способ является стандартным, но многим он не по душе. Хочется иметь какой-нибудь бинарный оператор. Но ведь не обязательно это должен быть плюс (например, в PHP для конкатенации строк &lt;a href=&quot;http://php.net/manual/ru/language.operators.string.php&quot;&gt;используется точка&lt;/a&gt;). Но давайте будем придерживаться R-стилистики и создадим свой оператор &amp;quot;%+%&amp;quot;, который будет складывать строки. Сделать это очень просто:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;%+%&amp;quot; &amp;lt;- function(...){
  paste0(...)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь мы можем складывать строки, используя наш новый бинарный оператор:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;a&amp;quot; %+% &amp;quot;b&amp;quot; %+% &amp;quot;c&amp;quot; # &amp;quot;abc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Кроме того, этот оператор будет прекрасно работать и с векторами в лучших традициях R:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;&amp;quot;a&amp;quot; %+% &amp;quot;b&amp;quot; %+% 1:3 # &amp;quot;ab1&amp;quot; &amp;quot;ab2&amp;quot; &amp;quot;ab3&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://ctszkin.com/2013/02/12/a-handy-concatenatio-operator/&quot;&gt;A handy concatenation operator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
        <item>
            <title>Вызов R-скрипта с аргументами из консоли</title>
            <link>http://aakinshin.net/ru/posts/r-terminal-arguments/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-terminal-arguments/</guid>
            <description>&lt;p&gt;Для выполнения R-скрипта из консоли нам понадобится помощь утилит &lt;code&gt;Rscript.exe&lt;/code&gt; и &lt;code&gt;Rterm.exe&lt;/code&gt;. Разница между ними состоит в том, что &lt;code&gt;Rscript.exe&lt;/code&gt;
в результате выполнения выдаст нам только результат работы R-скрипта, а &lt;code&gt;Rterm.exe&lt;/code&gt; выдаст полный лог R-сессии (включая стартовое приглашение к работе и все исполняемые команды). Если быть до конца честными, то &lt;code&gt;Rscript.exe&lt;/code&gt; по сути вызывает &lt;code&gt;Rterm.exe&lt;/code&gt; с специальными аргументами (об этом немного ниже). Рассмотрим пример запуска скрипта с аргументами командной строки:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rterm.exe --no-restore --no-save --args 100 image &amp;lt;script.R &amp;gt;output.txt
Rscript.exe script.R 100 image &amp;gt;output.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Разберём эти команды чуть подробней.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для начала напишем скрипт под названием &lt;code&gt;script.R&lt;/code&gt; для рисования случайных точек, который будет принимать два аргумента: количество точек и имя файла, в который мы будем сохранять итоговую картинку. Код скрипта будет следующим:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;args &amp;lt;- commandArgs(trailingOnly = T) # Получаем аргументы из командной строки
print(args)                           # Выводим их
n &amp;lt;- as.integer(args[1])              # Первый аргумент — количество точек
name &amp;lt;- args[2]                       # Второй аргумент — имя картинки
x &amp;lt;- rnorm(n)                         # Генерируем точки
png(paste0(name, &amp;quot;.png&amp;quot;))             # Создаём png-картинку
plot(1:n, x)                          # Рисуем картинку
dev.off()                             # Заканчиваем рисовать
summary(x)                            # И немного статистики напоследок
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Особый интерес для нас представляет только первая строчка (остальной код приведён для иллюстрации). Для получения аргументов используется функция &lt;code&gt;commandArgs&lt;/code&gt;
, принимающая единственный параметр — &lt;code&gt;trailingOnly&lt;/code&gt;. Если &lt;code&gt;trailingOnly&lt;/code&gt; выставлен в &lt;code&gt;FALSE&lt;/code&gt; , то функция вернёт список вообще всех аргументов, которые были переданы исполняемому файлу &lt;code&gt;Rterm.exe&lt;/code&gt; . В случае значения &lt;code&gt;TRUE&lt;/code&gt; будут возвращены только аргументы, указанные после аргумента &lt;code&gt;--args&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;Вернёмся к двум строчкам запуска скрипта из консоли. Аргументы &lt;code&gt;--no-restore --no-save&lt;/code&gt; в первой строчке означают, что перед выполнением скрипта нам не нужно восстанавливать никакое рабочее окружение, а после его выполнения — не нужно сохранять. &lt;code&gt;&amp;amp;gt;output&lt;/code&gt; в самом конце каждой строчке означает, что вывод с консоли будет перенаправлен в файл &lt;code&gt;output.txt&lt;/code&gt;. В конце работы скрипта в каждом случае будет создан файл &lt;code&gt;image.png&lt;/code&gt; с распределением наших случайных точек. Разница будет заключаться в выводе &lt;code&gt;output.txt&lt;/code&gt;. В первом случае мы получим примерно следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;R version 3.0.0 (2013-04-03) -- &amp;quot;Masked Marvel&amp;quot;
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R -- это свободное ПО, и оно поставляется безо всяких гарантий.
Вы вольны распространять его при соблюдении некоторых условий.
Введите &#39;license()&#39; для получения более подробной информации.

R -- это проект, в котором сотрудничает множество разработчиков.
Введите &#39;contributors()&#39; для получения дополнительной информации и
&#39;citation()&#39; для ознакомления с правилами упоминания R и его пакетов
в публикациях.

Введите &#39;demo()&#39; для запуска демонстрационных программ, &#39;help()&#39; -- для
получения справки, &#39;help.start()&#39; -- для доступа к справке через браузер.
Введите &#39;q()&#39;, чтобы выйти из R.

&amp;gt; args &amp;lt;- commandArgs(trailingOnly = T)
&amp;gt; print(args)
[1] &amp;quot;100&amp;quot;   &amp;quot;image&amp;quot;
&amp;gt; n &amp;lt;- as.integer(args[1])
&amp;gt; name &amp;lt;- args[2]
&amp;gt; 
&amp;gt; x &amp;lt;- rnorm(n)
&amp;gt; png(paste0(name, &amp;quot;.png&amp;quot;))
&amp;gt; plot(1:n, x)
&amp;gt; dev.off()
null device 
          1 
&amp;gt; summary(x)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
-2.3830 -0.5616  0.0813 -0.0322  0.5742  2.1000 
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А во втором случае:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;[1] &amp;quot;100&amp;quot;   &amp;quot;image&amp;quot;
null device 
          1 
    Min.  1st Qu.   Median     Mean  3rd Qu.     Max. 
-2.58000 -0.61260 -0.03309  0.05922  0.87230  1.72800 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь вернёмся к параметру
&lt;code&gt;trailingOnly&lt;/code&gt;
. Напишем ещё один скрипт (под названием
&lt;code&gt;printArgs.R&lt;/code&gt;
) для иллюстрации его работы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;print(commandArgs(trailingOnly = F))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И вызовем его уже знакомыми нам инструментами (на этот раз вывод будет осуществляться на консоль):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Rterm.exe --no-restore --no-save --args 100 image &amp;lt;printArgs.R
Rscript.exe printArgs.R 100 image
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Первая команда даст нам:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;c:\\Program Files\\R\\R-3.0.0\\bin\\x64\\Rterm.exe&amp;quot;
[2] &amp;quot;--no-restore&amp;quot;                                      
[3] &amp;quot;--no-save&amp;quot;                                         
[4] &amp;quot;--args&amp;quot;                                            
[5] &amp;quot;100&amp;quot;                                               
[6] &amp;quot;image&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как можно видеть, помимо наших основных аргументов &lt;code&gt;100&lt;/code&gt; и &lt;code&gt;image&lt;/code&gt; в список также попали исполняемый файл &lt;code&gt;Rterm&lt;/code&gt; и передаваемые в него аргументы. Ниже представлен вывод второй команды:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1] &amp;quot;c:\\Program Files\\R\\R-3.0.0\\bin\\x64\\Rterm.exe&amp;quot;
[2] &amp;quot;--slave&amp;quot;                                           
[3] &amp;quot;--no-restore&amp;quot;                                      
[4] &amp;quot;--file=printArgs.R&amp;quot;                                
[5] &amp;quot;--args&amp;quot;                                            
[6] &amp;quot;100&amp;quot;                                               
[7] &amp;quot;image&amp;quot;                                             
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отсюда становится понятно, что &lt;code&gt;Rscript&lt;/code&gt; только и делает-то, что запускает &lt;code&gt;Rterm&lt;/code&gt; с параметрами &lt;code&gt;--slave&lt;/code&gt; (отключает приглашение и вывод текста выполняемых команд),
&lt;code&gt;--no-restore&lt;/code&gt; не нужно восстанавливать рабочее окружение), &lt;code&gt;--file&lt;/code&gt; (указывает выполняемый файл) и &lt;code&gt;--args&lt;/code&gt; (означает, что далее следуют настоящие аргументы для основного скрипта; если бы мы выставили &lt;code&gt;trailingOnly = T&lt;/code&gt;, то получили бы только их).&lt;/p&gt;
&lt;p&gt;Ниже представлена полная справка по использованию &lt;code&gt;Rterm&lt;/code&gt; и &lt;code&gt;Rscript&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;Rterm.exe --help
Usage: Rterm [options] [&amp;lt; infile] [&amp;gt; outfile] [EnvVars]

Start R, a system for statistical computation and graphics, with the
specified options

EnvVars: Environmental variables can be set by NAME=value strings

Options:
  -h, --help            Print usage message and exit
  --version             Print version info and exit
  --encoding=enc        Specify encoding to be used for stdin
  --encoding enc        ditto
  --save                Do save workspace at the end of the session
  --no-save             Don&#39;t save it
  --no-environ          Don&#39;t read the site and user environment files
  --no-site-file        Don&#39;t read the site-wide Rprofile
  --no-init-file        Don&#39;t read the .Rprofile or ~/.Rprofile files
  --restore             Do restore previously saved objects at startup
  --no-restore-data     Don&#39;t restore previously saved objects
  --no-restore-history  Don&#39;t restore the R history file
  --no-restore          Don&#39;t restore anything
  --vanilla             Combine --no-save, --no-restore, --no-site-file,
                          --no-init-file and --no-environ
  --max-mem-size=N      Set limit for memory to be used by R
  --max-ppsize=N        Set max size of protect stack to N
  -q, --quiet           Don&#39;t print startup message
  --silent              Same as --quiet
  --slave               Make R run as quietly as possible
  --verbose             Print more information about progress
  --internet2           Use Internet Explorer for proxies etc.
  --args                Skip the rest of the command line
  --ess                 Don&#39;t use getline for command-line editing
                          and assert interactive use
  -f file               Take input from &#39;file&#39;
  --file=file           ditto
  -e expression         Use &#39;expression&#39; as input

One or more -e options can be used, but not together with -f or --file

An argument ending in .RData (in any case) is taken as the path
to the workspace to be restored (and implies --restore)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;Rscript.exe -- help
Usage: /path/to/Rscript [--options] [-e expr] file [args]

--options accepted are
  --help              Print usage and exit
  --version           Print version and exit
  --verbose           Print information on progress
  --default-packages=list
                      Where &#39;list&#39; is a comma-separated set
                        of package names, or &#39;NULL&#39;
or options to R, in addition to --slave --no-restore, such as
  --save              Do save workspace at the end of the session
  --no-environ        Don&#39;t read the site and user environment files
  --no-site-file      Don&#39;t read the site-wide Rprofile
  --no-init-file      Don&#39;t read the user R profile
  --restore           Do restore previously saved objects at startup
  --vanilla           Combine --no-save, --no-restore, --no-site-file
                        --no-init-file and --no-environ

&#39;file&#39; may contain spaces but not shell metacharacters
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>Рисуем комиксы в стиле xkcd</title>
            <link>http://aakinshin.net/ru/posts/r-xkcd/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/r-xkcd/</guid>
            <description>&lt;p&gt;Многие слышали о таком замечательном комиксе, как &lt;a href=&quot;http://www.xkcd.com/r-xkcd.md&quot;&gt;xkcd&lt;/a&gt;. Это веб-комикс от &lt;a href=&quot;http://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D0%BD%D1%80%D0%BE,_%D0%A0%D1%8D%D0%BD%D0%B4%D0%B5%D0%BB&quot;&gt;Рэндела Манро&lt;/a&gt; о романтике, сарказме, математике и языке. Для некоторых комиксов есть
&lt;a href=&quot;http://www.xkcd.ru/r-xkcd.md&quot;&gt;переводы на русский&lt;/a&gt;. Для поиска и просмотра ваших любимых комиксов в R есть отдельный пакет:
&lt;a href=&quot;http://cran.r-project.org/web/packages/RXKCD/index.html&quot;&gt;RXKCD&lt;/a&gt;. Давайте установим этот пакет и подключим его:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;install.packages(&amp;quot;RXKCD&amp;quot;)
library(&amp;quot;RXKCD&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Давайте поищем какой-нибудь комикс, а затем нарисуем его. Функция &lt;i&gt;searchXKCD&lt;/i&gt;
выдаст нам список всех комиксов, в описании которых встречается заданная фраза. А &lt;i&gt;getXKCD&lt;/i&gt;
выдаст нам полную информацию о комиксе по заданному номеру (включая рисование картинки).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;searchXKCD(&amp;quot;someone is wrong&amp;quot;)
getXKCD(386)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;А теперь помимо стандартных комиксов научимся рисовать свои! &lt;!--more--&gt; Но только вот нарисовать целиком комикс будет не так просто, но вот график в стиле xkcd — проще простого. На Stackoverflow однажды был &lt;a href=&quot;http://stackoverflow.com/questions/12675147/how-can-we-make-xkcd-style-graphs-in-r&quot;&gt;вопрос&lt;/a&gt; о том, как это сделать. Прежде всего, нам понадобится основной шрифт комиксов xkcd — &lt;a href=&quot;http://r-language.ru/wp-admin/post.php?post=104&amp;amp;action=edit&amp;amp;message=10&quot;&gt;Humor-Sans&lt;/a&gt;. Чтобы работать с разными клёвыми шрифтами, нужно прописать следующие строчки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(extrafont)
loadfonts()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но в некоторых случаях конкретно с Humor-Sans у вас могут быть проблемы (подробнее можно почитать &lt;a href=&quot;http://www.r-bloggers.com/change-fonts-in-ggplot2-and-create-xkcd-style-graphs/r-xkcd.md&quot;&gt;тут&lt;/a&gt;). Если, например, &lt;a href=&quot;http://stackoverflow.com/questions/13989644/xkcd-style-graph-error-with-registered-fonts&quot;&gt;вы работаете на ОС Windows&lt;/a&gt;, то вам необходимо вручную &lt;a href=&quot;http://antiyawn.com/uploads/Humor-Sans.ttf&quot;&gt;скачать&lt;/a&gt; этот шрифт, а затем подключить его:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;font_import(paths = c(&amp;quot;path/to/humor-sans&amp;quot;))
loadfonts(device = &amp;quot;win&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь мы готовы нарисовать график. Для начала посмотрим способ через &lt;a href=&quot;http://ggplot2.org/&quot;&gt;ggplot2&lt;/a&gt;. Подготовим данные для рисования:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;data &amp;lt;- NULL
data$x &amp;lt;- seq(1, 10, 0.1)
data$y1 &amp;lt;- sin(data$x)
data$y2 &amp;lt;- cos(data$x)
data$xaxis &amp;lt;- -1.5
data &amp;lt;- as.data.frame(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь подключим ggplot2, подготовим тему для рисования xkcd-комиксов, нарисуем график и сохраним его в картинку:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;library(&amp;quot;ggplot2&amp;quot;)
 
# XKCD theme
theme_xkcd &amp;lt;- theme(
  panel.background = element_rect(fill=&amp;quot;white&amp;quot;), 
  axis.ticks = element_line(colour=NA),
  panel.grid = element_line(colour=&amp;quot;white&amp;quot;),
  axis.text.y = element_text(colour=NA), 
  axis.text.x = element_text(colour=&amp;quot;black&amp;quot;),
  text = element_text(size=16, family=&amp;quot;Humor Sans&amp;quot;)
)
 
# Plot the chart
p &amp;lt;- ggplot(data=data, aes(x=x, y=y1))+
  geom_line(aes(y=y2), position=&amp;quot;jitter&amp;quot;)+
  geom_line(colour=&amp;quot;white&amp;quot;, size=3, position=&amp;quot;jitter&amp;quot;)+
  geom_line(colour=&amp;quot;red&amp;quot;, size=1, position=&amp;quot;jitter&amp;quot;)+
  geom_text(family=&amp;quot;Humor Sans&amp;quot;, x=6, y=-1.2, label=&amp;quot;A SIN AND COS CURVE&amp;quot;)+
  geom_line(aes(y=xaxis), position = position_jitter(h = 0.005), colour=&amp;quot;black&amp;quot;)+
  scale_x_continuous(breaks=c(2, 5, 6, 9), 
                     labels = c(&amp;quot;YARD&amp;quot;, &amp;quot;STEPS&amp;quot;, &amp;quot;DOOR&amp;quot;, &amp;quot;INSIDE&amp;quot;))+labs(x=&amp;quot;&amp;quot;, y=&amp;quot;&amp;quot;)+
  theme_xkcd
 
# Save to png
ggsave(&amp;quot;xkcd_ggplot.jpg&amp;quot;, plot=p, width=8, height=5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;br /&gt;
&lt;p&gt;Мы рассмотрели способ рисования графика через jitter-функциональность пакета ggplot2. А &lt;a href=&quot;http://stackoverflow.com/a/12680841/184842&quot;&gt;в другом ответе&lt;/a&gt; предлагается способ эмуляции рисования &amp;quot;от руки&amp;quot; вручную. Создаётся функция рисования линии:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;xkcd_line &amp;lt;- function(x, y, color) {
  len &amp;lt;- length(x);
  rg &amp;lt;- par(&amp;quot;usr&amp;quot;);
  yjitter &amp;lt;- (rg[4] - rg[3]) / 1000;
  xjitter &amp;lt;- (rg[2] - rg[1]) / 1000;
  x_mod &amp;lt;- x + rnorm(len) * xjitter;
  y_mod &amp;lt;- y + rnorm(len) * yjitter;
  lines(x_mod, y_mod, col=&#39;white&#39;, lwd=10);
  lines(x_mod, y_mod, col=color, lwd=5);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И функция рисования осей:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;xkcd_axis &amp;lt;- function() {
  rg &amp;lt;- par(&amp;quot;usr&amp;quot;);
  yaxis &amp;lt;- 1:100 / 100 * (rg[4] - rg[3]) + rg[3];
  xaxis &amp;lt;- 1:100 / 100 * (rg[2] - rg[1]) + rg[1];
  xkcd_line(1:100 * 0 + rg[1] + (rg[2]-rg[1])/100, yaxis,&#39;black&#39;)
  xkcd_line(xaxis, 1:100 * 0 + rg[3] + (rg[4]-rg[3])/100, &#39;black&#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А теперь давайте нарисуем простенький график:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;data &amp;lt;- data.frame(x=1:100)
data$one &amp;lt;- exp(-((data$x - 50)/10)^2)
data$two &amp;lt;- sin(data$x/10)
plot.new()
plot.window(
    c(min(data$x),max(data$x)),
    c(min(c(data$one,data$two)),max(c(data$one,data$two))))
xkcd_axis()
xkcd_line(data$x, data$one, &#39;red&#39;)
xkcd_line(data$x, data$two, &#39;blue&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В результате получим следующее изображение:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen3.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Есть и другие варианты рисования картинок в стилистике xkcd. &lt;a href=&quot;http://blog.phytools.org/2012/10/actual-xkcd-tree.html&quot;&gt;Например&lt;/a&gt;, можно рисовать древовидные структуры следующего вида:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen4.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;А поможет нам в этом пакет &lt;a href=&quot;http://cran.r-project.org/web/packages/phytools/index.html&quot;&gt;phytools&lt;/a&gt;. Пользоваться им достаточно просто. К примеру, вот такой код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-r&quot;&gt;require(phytools)
require(&amp;quot;extrafont&amp;quot;)
tree&amp;lt;-read.tree(text=&amp;quot;((mammals,(birds,reptiles)),amphibians);&amp;quot;)
tree&amp;lt;-compute.brlen(tree)
xkcdTree(tree,file=&amp;quot;herpetology.pdf&amp;quot;,lwd=2,color=&amp;quot;black&amp;quot;, 
         dim=c(4,4),jitter=0.001,waver=c(0.03,0.03))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;даст нам такую вот замечательную картинку:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/r/xkcd/screen5.png&quot; /&gt;
&lt;/p&gt;</description>
        </item>
        <item>
            <title>Заворачиваем C#-класс в COM</title>
            <link>http://aakinshin.net/ru/posts/wrap-cs-in-com/</link> 
            <pubDate>Mon, 03 Jun 2013 00:00:00 GMT</pubDate>
            <author>Андрей Акиньшин</author>
            <guid>http://aakinshin.net/ru/posts/wrap-cs-in-com/</guid>
            <description>&lt;p&gt;Пусть у нас имеется C#-класс, который делает что-нибудь полезное, например:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public class Calculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Давайте создадим для этого класса &lt;a href=&quot;http://ru.wikipedia.org/wiki/Component_Object_Model&quot;&gt;COM&lt;/a&gt;-интерфейс, чтобы его функциональность можно было использовать в других местах. В конце посмотрим на использование этого класса в среде Delphi.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Для начала нужно пойти в свойства проекта и на вкладке &lt;em&gt;Build&lt;/em&gt; поставить галочку напротив &lt;em&gt;Register for COM interop&lt;/em&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen1.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;Далее создаём интерфейс для нашего класса:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;public interface ICalculator
{
    int Sum(int a, int b);
}

public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Класс и интерфейс нужно пометить рядом атрибутов: следует указать для них уникальные &lt;a href=&quot;http://ru.wikipedia.org/wiki/GUID&quot;&gt;GUID&lt;/a&gt;-ы, указать &lt;code&gt;ComVisible(true)&lt;/code&gt;
, а для класса также добавить атрибут &lt;code&gt;ClassInterface(ClassInterfaceType.None)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-cs&quot;&gt;[Guid(&amp;quot;364C5E66-4412-48E3-8BD8-7B2BF09E8922&amp;quot;)]
[ComVisible(true)]
public interface ICalculator
{
    int Sum(int a, int b);
}

[Guid(&amp;quot;8C034F6A-1D3F-4DB8-BC99-B73873D8C297&amp;quot;)]
[ClassInterface(ClassInterfaceType.None)]
[ComVisible(true)]
public class Calculator : ICalculator
{
    public int Sum(int a, int b)
    {
        return a + b;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Уже почти всё готово! Можно собирать готовый вариант нашей сборки. Благодаря галочке &lt;em&gt;Register for COM interop&lt;/em&gt; COM-компнент сам зарегистрируется в системе, но регистрацию можно провести и руками. Делается это с помощью утилиты &lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/tzat5yw6.aspx&quot;&gt;RegAsm&lt;/a&gt;, которую можно найти в &amp;quot;C:\Windows\Microsoft.NET\Framework\v&amp;lt;номер нужной версии&amp;gt;&amp;quot;. С помощью аргумента &lt;code&gt;/tlb&lt;/code&gt; можно попутно создать сопутствующий tlb-файл. Отменить регистрацию сборки
&lt;a href=&quot;http://stackoverflow.com/questions/7841428/how-to-unregister-the-assembly-registered-using-regasm&quot;&gt;поможет&lt;/a&gt; атрибут &lt;code&gt;/u&lt;/code&gt;. Итак, выполним команду (будем считать, что название проекта и соответствующей dll — ComCalculator):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RegAsm.exe Calculator.dll /tlb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отлично, теперь наш компонент зарегистрирован! Давайте откроем Delphi и попробуем его использовать. После создания нового проекта (пусть это будет обычный WinForms-проект) нужно импортировать в него ComCalculator. Выбираем из меню &lt;em&gt;Project&lt;/em&gt; пункт &lt;em&gt;Import Type Library&lt;/em&gt; . В списке находим &lt;em&gt;ComCalculator&lt;/em&gt; и жмём &lt;em&gt;Install&lt;/em&gt;:&lt;/p&gt;
&lt;p class=&quot;center&quot;&gt;
  &lt;img src=&quot;/img/posts/dotnet/wrap-cs-in-com/screen2.png&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;В файле &lt;code&gt;Unit1.pas&lt;/code&gt; необходимо добавить &lt;code&gt;ComCalculator_TLB&lt;/code&gt; в раздел &lt;code&gt;uses&lt;/code&gt;. После этого у вас &lt;a href=&quot;http://stackoverflow.com/questions/7196769/what-is-this-error-mscorlib-tlb-pas&quot;&gt;могут быть проблемы&lt;/a&gt; с компиляцией &lt;code&gt;mscorlib_TBL.pas&lt;/code&gt;. Если это так, то просто удалите ссылку на него из раздела &lt;code&gt;uses&lt;/code&gt; файла &lt;code&gt;ComCalculator_TLB.pas&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Теперь попробуем использовать наш COM-компонент. Будем это делать прямо в конструкторе формы. Тело конструктора будет содержать две незамысловатые строчки: в первой мы создадим экземпляр класса &lt;code&gt;TCalculator&lt;/code&gt; , а во второй вызовем метод &lt;code&gt;Sum&lt;/code&gt; , результат вычислений покажем с помощью процедуры &lt;code&gt;ShowMessage&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-delphi&quot;&gt;procedure TForm1.FormCreate(Sender: TObject);
var
  calculator : TCalculator;
begin
  calculator := TCalculator.Create(Self);
  ShowMessage(IntToStr(calculator.Sum(1, 2)));
end;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Запустив приложение, вы сможете увидеть появившееся окошечко с цифрой 3 и порадоваться.&lt;/p&gt;
&lt;h3 id=&quot;section&quot;&gt;Ссылки&lt;/h3&gt;
&lt;p&gt;Для более сложных вариантов создания COM-объектов рекомендуются к изучению следующие статьи:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://msdn.microsoft.com/ru-ru/library/c3fd4a20.aspx&quot;&gt;Пример COM-класса / msdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://rsdn.ru/forum/info/FAQ.dotnet.complusplus&quot;&gt;Как создавать COM+-компоненты на .NET-е / rsdn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cyberforum.ru/csharp-net/thread153051.html&quot;&gt;Создание COM в C# NET / CyberForum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
        </item>
  </channel> 
</rss>