<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.103.0-DEV"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Programming,.NET,PerformanceExercise,Benchmarking,Math"><title>Performance exercise: Minimum | Andrey Akinshin</title><meta name=description content="Performance is tricky. Especially, if you are working with very fast operations. In today benchmarking exercise, we will try to measure performance of two ..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><link href=https://aakinshin.net/sass/bootstrap-light.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=https://aakinshin.net/sass/bootstrap-dark.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.d7f6578e23ad3f0c33c589f9bcb34f995b45121f1f3ce888869c86b26826c845.js></script>
<script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.9e68d431432744c07a43381a8a833ffe0921cc0e006d84ad97f0b0d43c5cd82d.mjs></script>
<link href=https://aakinshin.net/css/main.min.d3894e60e337fa8d9f2c81dcda5dcb9144502462aaabed3c6bad2fcf178a8410.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body class="d-flex flex-column min-vh-100"><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-sm navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><svg class="fai"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></li><li class=nav-item><a class=nav-link id=nav-link-posts href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li></ul><ul class="navbar-nav ms-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class="blog-post table-sm"><h1 class=blog-post-title id=post-title>Performance exercise: Minimum</h1><span class=blog-post-meta><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2016-12-20>December 20, 2016</time>
&nbsp;&nbsp;<svg class="fai"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a href=https://aakinshin.net/tags/programming/ class="badge badge-info">Programming</a>
<a href=https://aakinshin.net/tags/dotnet/ class="badge badge-info">.NET</a>
<a href=https://aakinshin.net/tags/performanceexercise/ class="badge badge-info">PerformanceExercise</a>
<a href=https://aakinshin.net/tags/benchmarking/ class="badge badge-info">Benchmarking</a>
<a href=https://aakinshin.net/tags/math/ class="badge badge-info">Math</a></span><br><br><p>Performance is tricky. Especially, if you are working with very fast operations. In today benchmarking exercise, we will try to measure performance of two simple methods which calculate minimum of two numbers. Sounds easy? Ok, let&rsquo;s do it, here are our guinea pigs for today:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span> <span class=n>MinTernary</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span>  <span class=p>=&gt;</span> <span class=n>x</span> <span class=p>&lt;</span> <span class=n>y</span> <span class=p>?</span> <span class=n>x</span> <span class=p>:</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>MinBitHacks</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>x</span> <span class=p>&amp;</span> <span class=p>((</span><span class=n>x</span> <span class=p>-</span> <span class=n>y</span><span class=p>)</span> <span class=p>&gt;&gt;</span> <span class=m>31</span><span class=p>)</span> <span class=p>|</span> <span class=n>y</span> <span class=p>&amp;</span> <span class=p>(~(</span><span class=n>x</span> <span class=p>-</span> <span class=n>y</span><span class=p>)</span> <span class=p>&gt;&gt;</span> <span class=m>31</span><span class=p>);</span>
</span></span></code></pre></div><p>And here are some results:</p><table class="table table-sm"><style type=text/css scoped>td.slow{color:#f44}td.fast{color:#00c851}</style><tr><th></th><th colspan=2>Random</th><th colspan=2>Const</th></tr><tr><th></th><th>Ternary</th><th>BitHacks</th><th>Ternary</th><th>BitHacks</th></tr><tr><th>LegacyJIT-x86</th><td class=slow>≈643µs</td><td class=fast>≈227µs</td><td class=fast>≈160µs</td><td class=slow>≈226µs</td></tr><tr><th>LegacyJIT-x64</th><td class=slow>≈450µs</td><td class=fast>≈123µs</td><td class=fast>≈68µs</td><td class=slow>≈123µs</td></tr><tr><th>RyuJIT-x64</th><td class=slow>≈594µs</td><td class=fast>≈241µs</td><td class=fast>≈180µs</td><td class=slow>≈241µs</td></tr><tr><th>Mono-x64</th><td class=fast>≈203µs</td><td class=slow>≈283µs</td><td class=fast>≈204µs</td><td class=slow>≈282µs</td></tr></table><p>What&rsquo;s going on here? Let&rsquo;s discuss it in detail.</p><h3 id=bit-hacks>Bit hacks</h3><p>The first implementation looks obvious, but it has one significant problem: it could suffer from branch mispredictions because of a condition in the expression. Fortunately, it is possible to rewrite it without a branch with the help of bit hacks:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span> <span class=n>MinBitHacks</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>x</span> <span class=p>&amp;</span> <span class=p>((</span><span class=n>x</span> <span class=p>-</span> <span class=n>y</span><span class=p>)</span> <span class=p>&gt;&gt;</span> <span class=m>31</span><span class=p>)</span> <span class=p>|</span> <span class=n>y</span> <span class=p>&amp;</span> <span class=p>(~(</span><span class=n>x</span> <span class=p>-</span> <span class=n>y</span><span class=p>)</span> <span class=p>&gt;&gt;</span> <span class=m>31</span><span class=p>);</span>
</span></span></code></pre></div><p>Here we calculate <code>(x-y)</code>, the sign of this expression depends on which number is less. Then, <code>(x-y) >> 31</code> gives a bit mask which contains only zeros or ones. Next, we calculate an inverted mask: <code>~(x - y) >> 31</code>. Now we <code>and</code> our operands and the corresponded bit masks (the minimum number get the <code>11...11</code> mask). That&rsquo;s all: the <code>or</code> operator returns the correct result.</p><p>Here is an example for <code>x=8</code> and <code>y=3</code>:</p><div class=mx-auto><img class="mx-auto d-block" width=400 src=/img/posts/dotnet/perfex-min/hacks.png></div><p>As you can see, here is no a branch here: we compute the minimum using only bit operations.</p><h3 id=performance-spaces>Performance spaces</h3><p>It&rsquo;s wrong to discuss the performance of some operations in general; we always should think about a space of the performance results (I call it <em>performance space</em>). Simplifying, you have to consider the following:</p><ul><li><strong>Source code:</strong> there are different ways to write a benchmark which includes the <code>Min</code> methods. Today we will take two <code>int</code> arrays <code>a</code> and <code>b</code> with some data and calculate the third array <code>int[] c</code> where <code>c[i] = Min(a[i], b[i])</code> for each <code>i</code>.</li><li><strong>Data:</strong> we always should check different data patterns. In our case, we are analyzing the branch predictor, so it makes sense to check const and random input patterns.</li><li><strong>Environment:</strong> there are many different environments, today we will check only Full .NET Framework 4.6.2 (with 3 main JIT compilers: <code>LegacyJIT-x86</code>, <code>LegacyJIT-x64</code>, <code>RyuJIT-x64</code>) and Mono 4.6.2 on Windows.</li></ul><h3 id=benchmarks>Benchmarks</h3><p>Here the source code of my benchmarks (based on <a href=https://github.com/dotnet/BenchmarkDotNet>BenchmarkDotNet</a> v0.10.1):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=na>[LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job, MonoJob]</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>MinBench</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>int</span> <span class=n>N</span> <span class=p>=</span> <span class=m>100001</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>enum</span> <span class=n>StrategyKind</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Const</span><span class=p>,</span> <span class=n>Random</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>    [Params(StrategyKind.Const, StrategyKind.Random)]</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>StrategyKind</span> <span class=n>Strategy</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>    [Setup]</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>void</span> <span class=n>Setup</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>rnd</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Random</span><span class=p>(</span><span class=m>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>switch</span> <span class=p>(</span><span class=n>Strategy</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=n>StrategyKind</span><span class=p>.</span><span class=n>Const</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=m>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=m>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=n>StrategyKind</span><span class=p>.</span><span class=n>Random</span><span class=p>:</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=n>rnd</span><span class=p>.</span><span class=n>Next</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=n>rnd</span><span class=p>.</span><span class=n>Next</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>    [Benchmark]</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>void</span> <span class=n>Ternary</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>x</span> <span class=p>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>y</span> <span class=p>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=n>x</span> <span class=p>&lt;</span> <span class=n>y</span> <span class=p>?</span> <span class=n>x</span> <span class=p>:</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=na>
</span></span></span><span class=line><span class=cl><span class=na>    [Benchmark]</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>void</span> <span class=n>BitHacks</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>x</span> <span class=p>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>y</span> <span class=p>=</span> <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>=</span> <span class=n>x</span> <span class=p>&amp;</span> <span class=p>((</span><span class=n>x</span> <span class=p>-</span> <span class=n>y</span><span class=p>)</span> <span class=p>&gt;&gt;</span> <span class=m>31</span><span class=p>)</span> <span class=p>|</span> <span class=n>y</span> <span class=p>&amp;</span> <span class=p>(~(</span><span class=n>x</span> <span class=p>-</span> <span class=n>y</span><span class=p>)</span> <span class=p>&gt;&gt;</span> <span class=m>31</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Raw results:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ini data-lang=ini><span class=line><span class=cl><span class=na>BenchmarkDotNet</span><span class=o>=</span><span class=s>v0.10.1, OS=Microsoft Windows NT 6.2.9200.0</span>
</span></span><span class=line><span class=cl><span class=na>Processor</span><span class=o>=</span><span class=s>Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8</span>
</span></span><span class=line><span class=cl><span class=na>Frequency</span><span class=o>=</span><span class=s>2143475 Hz, Resolution=466.5321 ns, Timer=TSC
</span></span></span><span class=line><span class=cl><span class=s>  [Host]       : Clr 4.0.30319.42000, 32bit LegacyJIT-v4.6.1586.0
</span></span></span><span class=line><span class=cl><span class=s>  LegacyJitX64 : Clr 4.0.30319.42000, 64bit LegacyJIT/clrjit-v4.6.1586.0;compatjit-v4.6.1586.0
</span></span></span><span class=line><span class=cl><span class=s>  LegacyJitX86 : Clr 4.0.30319.42000, 32bit LegacyJIT-v4.6.1586.0
</span></span></span><span class=line><span class=cl><span class=s>  Mono         : Mono 4.6.2 (Visual Studio built mono), 64bit
</span></span></span><span class=line><span class=cl><span class=s>  RyuJitX64    : Clr 4.0.30319.42000, 64bit RyuJIT-v4.6.1586.0</span>
</span></span></code></pre></div><table><thead><tr><th>Method</th><th>Job</th><th>Strategy</th><th>Mean</th><th>StdDev</th></tr></thead><tbody><tr><td>Ternary</td><td>LegacyJitX86</td><td>Random</td><td>643.9113 us</td><td>2.8095 us</td></tr><tr><td>BitHacks</td><td>LegacyJitX86</td><td>Random</td><td>227.1344 us</td><td>1.3270 us</td></tr><tr><td>Ternary</td><td>LegacyJitX86</td><td>Const</td><td>160.0779 us</td><td>0.9276 us</td></tr><tr><td>BitHacks</td><td>LegacyJitX86</td><td>Const</td><td>225.7077 us</td><td>0.7597 us</td></tr><tr><td>Ternary</td><td>LegacyJitX64</td><td>Random</td><td>450.7977 us</td><td>1.1618 us</td></tr><tr><td>BitHacks</td><td>LegacyJitX64</td><td>Random</td><td>123.3894 us</td><td>0.3052 us</td></tr><tr><td>Ternary</td><td>LegacyJitX64</td><td>Const</td><td>68.6997 us</td><td>0.7440 us</td></tr><tr><td>BitHacks</td><td>LegacyJitX64</td><td>Const</td><td>123.0449 us</td><td>0.7931 us</td></tr><tr><td>Ternary</td><td>RyuJitX64</td><td>Random</td><td>594.5310 us</td><td>1.1537 us</td></tr><tr><td>BitHacks</td><td>RyuJitX64</td><td>Random</td><td>241.1466 us</td><td>1.1446 us</td></tr><tr><td>Ternary</td><td>RyuJitX64</td><td>Const</td><td>179.7262 us</td><td>0.4236 us</td></tr><tr><td>BitHacks</td><td>RyuJitX64</td><td>Const</td><td>240.8385 us</td><td>0.7296 us</td></tr><tr><td>Ternary</td><td>Mono</td><td>Random</td><td>203.6173 us</td><td>1.7580 us</td></tr><tr><td>BitHacks</td><td>Mono</td><td>Random</td><td>283.5624 us</td><td>2.2254 us</td></tr><tr><td>Ternary</td><td>Mono</td><td>Const</td><td>204.5277 us</td><td>1.5814 us</td></tr><tr><td>BitHacks</td><td>Mono</td><td>Const</td><td>282.5178 us</td><td>1.9491 us</td></tr></tbody></table><p>Results in a nice form:</p><table class="table table-sm"><style type=text/css scoped>td.slow{color:#f44}td.fast{color:#00c851}</style><tr><th></th><th colspan=2>Random</th><th colspan=2>Const</th></tr><tr><th></th><th>Ternary</th><th>BitHacks</th><th>Ternary</th><th>BitHacks</th></tr><tr><th>LegacyJIT-x86</th><td class=slow>≈643µs</td><td class=fast>≈227µs</td><td class=fast>≈160µs</td><td class=slow>≈226µs</td></tr><tr><th>LegacyJIT-x64</th><td class=slow>≈450µs</td><td class=fast>≈123µs</td><td class=fast>≈68µs</td><td class=slow>≈123µs</td></tr><tr><th>RyuJIT-x64</th><td class=slow>≈594µs</td><td class=fast>≈241µs</td><td class=fast>≈180µs</td><td class=slow>≈241µs</td></tr><tr><th>Mono-x64</th><td class=fast>≈203µs</td><td class=slow>≈283µs</td><td class=fast>≈204µs</td><td class=slow>≈282µs</td></tr></table><h3 id=analysis>Analysis</h3><p>First, let&rsquo;s look at the right part of the table with const input. Here <code>Ternary</code> is always faster than <code>BitHacks</code> because it takes a small amount of instruction and the branch predictor works perfectly. For the random input on Full .NET Framework the <code>BitHacks</code> is faster for all JIT compilers. And there is an explanation for this: <code>Ternary</code> has a big performance penalty because it&rsquo;s hard to predict the correct branch. Performance of <code>BitHacks</code> is the same for both input patterns and it also makes sense: this method doesn&rsquo;t depend on branch predictor. However, we could also make a few interesting observation about Mono:</p><ul><li><code>Ternary</code> works faster than <code>BitHacks</code> even on the random input.</li><li>Mono version of <code>Ternary</code> on the random input works much quicker than the same code on Full .NET Framework.</li><li>Mono shows the same performance for <code>Ternary</code> and <code>BitHacks</code> for both input arrays.</li></ul><p>How is it possible? Let&rsquo;s look at the asm. Here is the asm code for <code>RyuJIT-x64</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c>; RyuJIT-x64
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>cmp</span>       <span class=no>ecx</span><span class=p>,</span><span class=no>edx</span>         <span class=c>; check x &lt; y
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>jl</span>        <span class=no>LESS</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=no>eax</span><span class=p>,</span><span class=no>edx</span>         <span class=c>; return y
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>ret</span>
</span></span><span class=line><span class=cl><span class=nl>LESS:</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=no>eax</span><span class=p>,</span><span class=no>ecx</span>         <span class=c>; return x
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>ret</span>
</span></span></code></pre></div><p>It looks very simple. How does it possible to rewrite this code and make it faster? Let&rsquo;s think. The bottleneck here is the <code>jl</code> instruction which has a significant penalty because of the high-value misprediction rate. Is it possible to rewrite it without conditional jumps? Yes! <a href=http://x86.renejeschke.de/html/file_module_x86_id_34.html>Conditional move</a> to the rescue!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=c>; Mono4.6.2-x64
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>sub</span>       <span class=no>$0x18</span><span class=p>,</span><span class=nv>%rsp</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=nv>%rsi</span><span class=p>,(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=nv>%rdi</span><span class=p>,</span><span class=mi>0x8</span><span class=p>(</span><span class=nv>%rsp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=nv>%rcx</span><span class=p>,</span><span class=nv>%rdi</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=nv>%rdx</span><span class=p>,</span><span class=nv>%rsi</span>
</span></span><span class=line><span class=cl><span class=nf>cmp</span>       <span class=nv>%esi</span><span class=p>,</span><span class=nv>%edi</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=nv>%rsi</span><span class=p>,</span><span class=nv>%rax</span>
</span></span><span class=line><span class=cl><span class=nf>cmovl</span>     <span class=nv>%rdi</span><span class=p>,</span><span class=nv>%rax</span>       <span class=c>; Move if less (SF&lt;&gt;OF).
</span></span></span><span class=line><span class=cl><span class=c></span><span class=no>mov</span>       <span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%rsi</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>       <span class=mi>0x8</span><span class=p>(</span><span class=nv>%rsp</span><span class=p>),</span><span class=nv>%rdi</span>
</span></span><span class=line><span class=cl><span class=nf>add</span>       <span class=no>$0x18</span><span class=p>,</span><span class=nv>%rsp</span>
</span></span><span class=line><span class=cl><span class=nf>retq</span>
</span></span></code></pre></div><p>Here Mono uses the <code>cmovl</code> instruction (<code>0F4C</code>). So, it will not suffer from branch mispredictions because there is no branch on the asm level (despite we have a condition in the source C# code).</p><h3 id=conclusion>Conclusion</h3><p>Thus, we can&rsquo;t make a conclusion about <code>MinTernary</code> and <code>MinBitHacks</code> performance <em>in general</em>. It&rsquo;s impossible to say which implementation is better <em>for your problem</em> without additional measurements because it depends on different conditions (like input data pattern and target runtime).</p><p>Is it a complete performance investigation? Of course, it&rsquo;s not. We miss something in each component of our performance space:</p><ul><li><strong>Source:</strong> We considered <em>synthetic methods</em> which calculate minimums in a special way. We easily can do small changes which significantly affect results.</li><li><strong>Data:</strong> We checked only <em>two input patterns</em>: a const pattern and a random pattern with a particular seed. If we take another input array (e.g. some data from real life), we get another performance picture.</li><li><strong>Environment:</strong> We didn&rsquo;t check Linux and MacOS, CoreCLR, different versions of Mono, and so on. Also, we checked only Intel Core i7 Haswell; another processor micro-architectures have own characteristics of the branch predictor which is the bottleneck in this benchmark.</li></ul><p>However, we get a good result: we have shown a part of performance space for target operations, and we have found relevant conditions which could affect the speed of our program. Note that it was just a benchmarking exercise, I wanted to show that there are a lot of troubles with benchmarking even in this simple case. Be careful with your performance measurements.</p><br><br><div class=row><div class="justify-content-center share-block"><div class=share-title>Share:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fperfex-min%2f&title=Performance%20exercise%3a%20Minimum" target=_blank title="Share on Reddit"><svg class="fai"><use xlink:href="/img/fa/all.svg#reddit"/></svg></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=Performance%20exercise%3a%20Minimum&url=https%3a%2f%2faakinshin.net%2fposts%2fperfex-min%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><svg class="fai"><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fperfex-min%2f" target=_blank title="Share on HackerNews"><svg class="fai"><use xlink:href="/img/fa/all.svg#hacker-news"/></svg></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fperfex-min%2f&title=Performance%20exercise%3a%20Minimum" target=_blank title="Add to Pocket"><svg class="fai"><use xlink:href="/img/fa/all.svg#get-pocket"/></svg></a></div></div></div></div><hr></div></div></main></div><footer class="blog-footer mt-auto"><div class=container><p>&copy; 2013&mdash;2022 Andrey Akinshin
|
<a href=https://github.com/AndreyAkinshin><svg class="fai"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a><a href=https://twitter.com/andrey_akinshin><svg class="fai"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a><a href=https://aakinshin.net/posts/index.xml><svg class="fai"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js integrity="sha512-zPB79j2C+3sFS9zcA3vg/z6bVKzJVEyu9pY5w89akQRys76zpAT2t6S3wZKla3QQ14O5l/Yt0RUQ/DHXx82Y5g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://aakinshin.net/js/theme-after.min.29520a8e1176193da7ea4e6cb56cf9b3e634b867c9979234d8dafb5ab61dd494.js></script></body></html>