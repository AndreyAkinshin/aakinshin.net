<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Statistics,Quantile,Moving Quantile"><title>Better moving quantile estimations using the partitioning heaps | Andrey Akinshin</title><meta name=description content="Improvements of the Hardle-Steiger method that allows estimating moving quantiles using linear interpolation"><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.882998740b9c4c24677576b997bde5a487246e2e3bd72128a0e922eaa59db029.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.50da8736f05b35aac9691de67fe993cbe01b7d88fcf0cb682c3a8f39933fe4a3.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.ae812fc71daf5160d927febda5a991cee6c361345e3f685d3736931ed7537986.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41419012-5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41419012-5');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-sm navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-posts href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-pdnb href=https://aakinshin.net/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class="blog-post table-sm"><h1 class=blog-post-title id=post-title>Better moving quantile estimations using the partitioning heaps</h1><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2021-01-19>January 19, 2021</time>
&nbsp;&nbsp;
<i class="fas fa-tag"></i>&nbsp;
<a href=https://aakinshin.net/tags/statistics/ class="badge badge-info">Statistics</a>
<a href=https://aakinshin.net/tags/quantile/ class="badge badge-info">Quantile</a>
<a href=https://aakinshin.net/tags/moving-quantile/ class="badge badge-info">Moving Quantile</a></span><br><br><p>In one of the previous posts, I <a href=https://aakinshin.net/posts/partitioning-heaps-quantile-estimator/>have discussed</a> the Hardle-Steiger method.
This algorithm allows estimating <a href=https://en.wikipedia.org/wiki/Moving_average#Moving_median>the moving median</a>
using <span class="math inline">\(O(L)\)</span> memory and <span class="math inline">\(O(log(L))\)</span> element processing complexity (where <span class="math inline">\(L\)</span> is the window size).
Also, I have shown how to adapt this approach to estimate <em>any</em> moving quantile.</p><p>In this post, I&rsquo;m going to present further improvements.
The Hardle-Steiger method always returns the <a href=https://en.wikipedia.org/wiki/Order_statistic>order statistics</a>
which is the <span class="math inline">\(k\textrm{th}\)</span> smallest element from the sample.
It means that the estimated quantile value always equals one of the last <span class="math inline">\(L\)</span> observed numbers.
However, many of the classic quantile estimators use two elements.
For example, if we want to estimate the median for <span class="math inline">\(x = \{4, 5, 6, 7\}\)</span>,
some estimators return <span class="math inline">\(5.5\)</span> (which is the arithmetical mean of <span class="math inline">\(5\)</span> and <span class="math inline">\(6\)</span>)
instead of <span class="math inline">\(5\)</span> or <span class="math inline">\(6\)</span> (which are order statistics).</p><p>Let&rsquo;s learn how to implement a moving version of such estimators using
the partitioning heaps from the Hardle-Steiger method.</p><h3 id=the-hyndman-fan-classification>The Hyndman-Fan classification</h3><p>There are many different quantile estimators.
In <a href=#Hyndman1996>[Hyndman1996]</a>, Rob Hyndman and Yanan Fan have described
nine estimators that are used in popular statistical packages.
They are based on a single order statistic or on linear interpolation
of two subsequent order statistics.
Below you can see equations for each type that
estimate <span class="math inline">\(p^\textrm{th}\)</span> quantile for a sorted sample <span class="math inline">\(x\)</span> of size <span class="math inline">\(N\)</span>.</p><table><thead><tr><th>Type</th><th>h</th><th>Equation</th></tr></thead><tbody><tr><td>1</td><td><span class="math inline">\(Np+1/2\)</span></td><td><span class="math inline">\(x_{\lceil h - 1/2 \rceil}\)</span></td></tr><tr><td>2</td><td><span class="math inline">\(Np+1/2\)</span></td><td><span class="math inline">\((x_{\lceil h - 1/2 \rceil} + x_{\lceil h + 1/2 \rceil})/2\)</span></td></tr><tr><td>3</td><td><span class="math inline">\(Np\)</span></td><td><span class="math inline">\(x_{\lfloor h \rceil}\)</span></td></tr><tr><td>4</td><td><span class="math inline">\(Np\)</span></td><td><span class="math inline">\(x_{\lfloor h \rfloor}+(h-\lfloor h \rfloor)(x_{\lfloor h \rfloor+1})-x_{\lfloor h \rfloor}\)</span></td></tr><tr><td>6</td><td><span class="math inline">\((N+1)p\)</span></td><td><span class="math inline">\(x_{\lfloor h \rfloor}+(h-\lfloor h \rfloor)(x_{\lfloor h \rfloor+1})-x_{\lfloor h \rfloor}\)</span></td></tr><tr><td>5</td><td><span class="math inline">\(Np+1/2\)</span></td><td><span class="math inline">\(x_{\lfloor h \rfloor}+(h-\lfloor h \rfloor)(x_{\lfloor h \rfloor+1})-x_{\lfloor h \rfloor}\)</span></td></tr><tr><td>7</td><td><span class="math inline">\((N-1)p+1\)</span></td><td><span class="math inline">\(x_{\lfloor h \rfloor}+(h-\lfloor h \rfloor)(x_{\lfloor h \rfloor+1})-x_{\lfloor h \rfloor}\)</span></td></tr><tr><td>8</td><td><span class="math inline">\((N+1/3)p+1/3\)</span></td><td><span class="math inline">\(x_{\lfloor h \rfloor}+(h-\lfloor h \rfloor)(x_{\lfloor h \rfloor+1})-x_{\lfloor h \rfloor}\)</span></td></tr><tr><td>9</td><td><span class="math inline">\((N+1/4)p+3/8\)</span></td><td><span class="math inline">\(x_{\lfloor h \rfloor}+(h-\lfloor h \rfloor)(x_{\lfloor h \rfloor+1})-x_{\lfloor h \rfloor}\)</span></td></tr></tbody></table><p>As you can see, only Type 1 and Type 3 estimators use a single order statistic.
The other types use an equation based on linear interpolation.</p><p>Type 7 is the most popular quantile estimator which is used by default in
R, Julia, NumPy, Excel (<code>PERCENTILE</code>, <code>PERCENTILE.INC</code>), Python (<code>inclusive</code> method).</p><h3 id=the-partitioning-heaps-data-structure>The partitioning heaps data structure</h3><p>In <a href=#Hardle1995>[Hardle1995]</a>, W. Hardle and W. Steiger have described a method
of estimating the moving median.
Their approach uses a data structure based on two <a href=https://en.wikipedia.org/wiki/Heap_(data_structure)>heaps</a>
which they call <em>partitioning heaps</em>:</p><div class=row><div class=mx-auto><a href=/posts/partitioning-heaps-quantile-estimator2/img/double-heap.svg target=_blank alt=double-heap><img class="mx-auto d-block img-fluid" width=400 src=/posts/partitioning-heaps-quantile-estimator2/img/double-heap.svg></a></div></div><br><p>In this figure, you see an example for <span class="math inline">\(L=21\)</span> (<span class="math inline">\(L\)</span> is the window size).
It contains:</p><ul><li><span class="math inline">\(H_1 .. H_{10}\)</span>: min heap</li><li><span class="math inline">\(H_{-1} .. H_{-10}\)</span>: max heap</li><li><span class="math inline">\(H_0\)</span>: a node that joins two heaps</li></ul><p>The <span class="math inline">\(H\)</span> array contain the last <span class="math inline">\(L\)</span> elements of the time series and satisfy the following conditions:</p><ul><li><span class="math inline">\(\max(H_{-2i},\; H_{-2i-1}) \leq H_{-i} \leq H_0\)</span></li><li><span class="math inline">\(\min(H_{2i},\; H_{2i+1}) \geq H_{i} \geq H_0\)</span></li></ul><p>Thus, <span class="math inline">\(H_0\)</span> is
less than all elements in the upper heap (positive indexes) and
greater than all elements in the lower heap (negative indexes).
Since we have an equal number of elements in both heaps,
<span class="math inline">\(H_0\)</span> represents the median value.</p><p>Once we get a new number in our stream,
we should replace the &ldquo;oldest&rdquo; number in this data structure with the new one.
Next, we should normalize the heaps to satisfy the above conditions.
This operation&rsquo;s algorithmic complexity is <span class="math inline">\(O(log(L))\)</span>.</p><p>If we modify the number of elements in the min heap or the max heap,
we can get any quantile value instead of the median
(see <a href=https://aakinshin.net/posts/partitioning-heaps-quantile-estimator/>previous post</a> for details).</p><h3 id=applying-the-hyndman-fan-equations-for-the-partitioning-heaps>Applying the Hyndman-Fan equations for the partitioning heaps</h3><p>All of the equations described by Rob Hyndman and Yanan Fan use
no more than two subsequent order statistics.
Let&rsquo;s look closely at the figure with the partitioning heaps.
We may notice that we already have values of the required elements.
If <span class="math inline">\(H_0\)</span> is the <span class="math inline">\(k^\textrm{th}\)</span> smallest element,
<span class="math inline">\(H_{-1}\)</span> is the <span class="math inline">\((k-1)^\textrm{th}\)</span> smallest element!
Indeed, <span class="math inline">\(H_{-1} \leq H_0 \leq H_i\)</span> for <span class="math inline">\(i>0\)</span>
and <span class="math inline">\(H_{-1} \geq H_i\)</span> for <span class="math inline">\(i < -1\)</span>.
By analogy, <span class="math inline">\(H_1\)</span> is the <span class="math inline">\((k+1)^\textrm{th}\)</span> smallest element.</p><p>Since we already have both required element values,
we can apply the Hyndman-Fan equations without any changes in the data structure.
It&rsquo;s a super-simple improvement, but it allows achieving consistency between
the moving quantile estimator based on the partitioning heaps
and the classic quantile estimators from the Hyndman-Fan classification.</p><h3 id=reference-implementation>Reference implementation</h3><p>If you use C#, you can take an implementation from
the latest nightly version (0.3.0-nightly.86+) of <a href=https://github.com/AndreyAkinshin/perfolizer>Perfolizer</a>
(you need <code>PartitioningHeapsMovingQuantileEstimator</code>).</p><h3 id=conclusion>Conclusion</h3><p>In this post, we improved the Hardle-Steiger method (<a href=#Hardle1995>[Hardle1995]</a>).
Now it&rsquo;s able to estimate any moving quantiles
using any of the equations described in the Hyndman-Fan classification (<a href=#Hyndman1996>[Hyndman1996]</a>).
The suggested approach has the following characteristics (<span class="math inline">\(L\)</span> is the window size):</p><ul><li>Memory: <span class="math inline">\(O(L)\)</span></li><li>Element processing complexity: <span class="math inline">\(O(log(L))\)</span></li><li>Quantile estimating complexity: <span class="math inline">\(O(1)\)</span></li></ul><h3 id=references>References</h3><ul><li><b id=Hyndman1996>[Hyndman1996]</b><br>Hyndman, R. J. and Fan, Y. 1996. Sample quantiles in statistical packages, <em>American Statistician</em> 50, 361â€“365.<br><a href=https://doi.org/10.2307/2684934>https://doi.org/10.2307/2684934</a></li><li><b id=Hardle1995>[Hardle1995]</b><br>Hardle, W., and William Steiger. &ldquo;Algorithm AS 296: Optimal median smoothing.&rdquo; Journal of the Royal Statistical Society. Series C (Applied Statistics) 44, no. 2 (1995): 258-264.<br><a href=https://doi.org/10.2307/2986349>https://doi.org/10.2307/2986349</a></li></ul><br><br><div class=row><div class="mx-auto share-block"><div class=share-title>Share:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator2%2f&title=Better%20moving%20quantile%20estimations%20using%20the%20partitioning%20heaps" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=Better%20moving%20quantile%20estimations%20using%20the%20partitioning%20heaps&url=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator2%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x"></i></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator2%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator2%2f&title=Better%20moving%20quantile%20estimations%20using%20the%20partitioning%20heaps" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013&mdash;2022 Andrey Akinshin
|
<a href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub></i></a><a href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter></i></a><a href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS></i></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.082780cb948cc57eabbc0d80172a7a5347d5572b599938b4c9876dfd7978b424.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true,},options:{skipHtmlTags:['script','noscript','style','textarea','pre'],ignoreHtmlClass:'tex2jax_ignore',processHtmlClass:'tex2jax_process'}};</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>