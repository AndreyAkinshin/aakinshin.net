<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.103.0-DEV"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Mathematics,Statistics,Performance,PerformanceTesting,Rider,BenchmarkDotNet"><title>Reflecting on performance testing | Andrey Akinshin</title><meta name=description content="Performance is an important feature for many projects. Unfortunately, it&amp;rsquo;s an all too common situation when a developer accidentally spoils the performance adding some new code. After a series of such incidents, people often start to think about perfo..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.fe1c45a5bb1462c47792274eba884723afa28a87c7a92405ed21b423927e7fbf.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/posts/>Posts</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/research/>Research</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/about/>About</a></div></div><button id=theme-toggle type=button title="Alt+Click to match OS color theme" class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><div class=main-post><h1 class=blog-post-title id=post-title>Reflecting on performance testing</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai text-accent-l dark:text-front-d"><title>Date</title><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2017-08-01>August 1, 2017</time><svg class="fai ml-3 text-accent-l dark:text-front-d"><title>Tags</title><use xlink:href="/img/fa/all.svg#tag"/></svg><div class="flex flex-wrap gap-y-1"><a class=label-link href=https://aakinshin.net/tags/mathematics/>Mathematics</a>
<a class=label-link href=https://aakinshin.net/tags/statistics/>Statistics</a>
<a class=label-link href=https://aakinshin.net/tags/performance/>Performance</a>
<a class=label-link href=https://aakinshin.net/tags/performancetesting/>PerformanceTesting</a>
<a class=label-link href=https://aakinshin.net/tags/rider/>Rider</a>
<a class=label-link href=https://aakinshin.net/tags/benchmarkdotnet/>BenchmarkDotNet</a></div></div><br><div class=main-content><p>Performance is an important feature for many projects.
Unfortunately, it&rsquo;s an all too common situation when a developer accidentally spoils the performance adding some new code.
After a series of such incidents, people often start to think about performance regression testing.</p><p>As developers, we write unit tests all the time.
These tests check that our business logic work as designed and that new features don&rsquo;t break existing code.
It looks like a good idea to write some perf tests as well, which will verify that we don&rsquo;t have any performance regressions.</p><p>Turns out this is harder than it sounds.
A lot of developers don&rsquo;t write perf tests at all.
Some teams write perf tests, but almost all of them use their own infrastructure for analysis
(which is not a bad thing in general because it&rsquo;s usually designed for specific projects and requirements).
There are a lot of books about test-driven development (TDD),
but there are no books about performance-driven development (PDD).
There are well-known libraries for unit-testing (like xUnit/NUnit/MSTest for .NET),
but there are almost no libraries for performance regression testing.
Yeah, of course, there are <em>some</em> libraries which you can use.
But there are troubles with <em>well-known all recognized</em> libraries, approaches, and tools.
Ask your colleagues about it: some of them will give you different answers, the rest of them will start Googling it.</p><p>There is no common understanding of what performance testing should look like.
This situation exists because it&rsquo;s really hard to develop a solution which solves <em>all problems</em> for <em>all kind of projects</em>.
However, it doesn&rsquo;t mean that we shouldn&rsquo;t try.
And we should try, we should share our experience and discuss best practices.</p><p>Probably some of you know that I&rsquo;m the maintainer of <a href=https://github.com/dotnet/BenchmarkDotNet>BenchmarkDotNet</a>
(a popular .NET library for benchmarking).
It was designed as a library for benchmarking (especially for microbenchmarking), but not for regression testing.
However, more and more people ask how they can use it as a part of continues integration systems.
And it&rsquo;s a good idea to have a way to automatically prevent performance degradations.
Unfortunately, it&rsquo;s not enough to just run code several times and collect some statistics (and other typical benchmarking stuff).
There are a lot of additional challenges which should be solved before I can recommend this library for perf tests.</p><p>At JetBrains, I&rsquo;m working on <a href=https://www.jetbrains.com/rider/>Rider</a>.
It&rsquo;s a cool cross-platform .NET IDE which is based on the IntelliJ platform and ReSharper.
It&rsquo;s a huge product with millions of lines of code and a crazy performance space.
Rider should be super-responsive and fast on any OS — performance is one of our best features.
It&rsquo;s so easy to write some code which spoils this for some people, and it&rsquo;s so hard to check it manually every time.
We already have some simple performance tests, but we feel like it&rsquo;s not enough.
Right now I&rsquo;m working on a new workflow for regression analysis and monitoring.
This system is not ready yet, but it already helped in finding some interesting performance anomalies.
However, I don&rsquo;t want to write another tool which can be used only for one project.
It would be nice to write a tool (and open source it) which can be easily adapted for a wide range of different projects.</p><p>I write this post because I want to get some feedback.
I&rsquo;m going to briefly describe some basic problems of performance regression testing and suggest some points of discussion.
I would like to hear any kind of information about performance regression testing.
Do you practice it?
What kind of problems do you have?
How you solve it?
What kind of tools and approaches do you use?</p><p>Ok, let&rsquo;s start a discussion with a short list of typical issues which can destroy all the fun of performance testing.</p><h3 id=problems>Problems</h3><p>Let&rsquo;s say we write a program which prints a number which somehow describes performance of our system.
It doesn&rsquo;t matter whether it is a super-reliable benchmark with many repetitions or a simple &ldquo;let&rsquo;s take a few timestamps&rdquo; approach.
The main point here is we have a program which provides a perf number (or a set of numbers), and we are completely satisfied with it.
Is our performance test ready when we have such number?
No!
We even didn&rsquo;t start to talk about testing.</p><h4 id=type-i-and-type-ii-errors>Type I and Type II errors</h4><p>The main point of performance testing (and any other kind of testing) is that it should be automatic.
We should be automatically notified if we have any kind of performance degradation.
The question then is: how should we define <em>a performance degradation</em>?
At this point, many developers start to read about confidence intervals, statistics tests, p-values, and so on.
Sometimes I hear sentences like &ldquo;The probability of performance degradation is 80%.&rdquo;
This doesn&rsquo;t make any sense!
You have a degradation, or you don&rsquo;t have a degradation.
Otherwise, you have problems with your definition of a degradation.
You can&rsquo;t say to a developer something like &ldquo;you must investigate this problem with 80% probability.&rdquo;
The outcome of your checking system should be binary.
And here we should talk about <a href=https://en.wikipedia.org/wiki/Type_I_and_type_II_errors>Type I and type II errors</a>.
Sometimes you will be notified about problems, but there aren&rsquo;t any problems.
When developers get a lot of such false alarms, they start to ignore it, and the whole idea stops making sense and loses value.
Sometimes, there are some critical performance problems, but you will not be notified.
In this case, you can miss the degradation and deploy a slow version of your software (the whole idea does not work).</p><p>We should implement such checking system which minimizes both kinds of errors.
Very often this a project-specific and a team-specific problem.
It&rsquo;s impossible to write one set of conditions which makes everyone happy.
But we can try to create presets which help to quickly choose a good solution for your business requirements.</p><h4 id=small-amount-of-data>Small amount of data</h4><p>In theory, we can do as many iterations as we like.
It allows getting a huge data sets,
apply some statistical magic,
calculate all possible statistical characteristics,
and answer all our question include the ultimate question of life, the universe, and everything.
In practice, performance data is expensive.
We pay for it by the time of our CI server and the time of developers which should wait for the results.
Some of the performance tests (especially integration tests) could take minutes or even hours.
It would be nice to get the sample size N=1000, but sometimes our N is 3..5 or even 1.
A single measurement (+plus some historical data),
no information about the distribution,
but we still have to answer: do we have a performance degradation or not?</p><h4 id=tricky-distributions>Tricky distributions</h4><p>Even if we have enough data about the performance distributions,
this distribution usually looks strange.
Don&rsquo;t expect to see a lot of normal distributions, when you are working with performance.
Here are typical problems which you can get:</p><ul><li>Huge standard deviation: the difference between sequential measurements (for the same codebase) can be huge</li><li>Outliers: sometimes you get extremely high durations because of some unknown reasons
(especially if you have many I/O or network operation; or just have another heavy processes on the same build agent).</li><li>Multimodal distribution: a distribution can have several local maximums
and you can&rsquo;t control which mode will be &ldquo;activated&rdquo; in each measurement</li></ul><p>Here is some historical data about duration of a single test from Rider:</p><div class=row><div class=mx-auto><a href=/posts/reflecting-on-performance-testing/img/plot1.png target=_blank alt=plot1><img class="mx-auto d-block img-fluid" width=800 src=/posts/reflecting-on-performance-testing/img/plot1.png></a></div></div><br><p>The blue points denote Windows, the purple denote Linux, the yellow denote MacOS.
On the Y axis, you can see the amount of milliseconds.
Yes, two sequential measurements can be 100 seconds and 900 seconds.
It&rsquo;s a normal situation for an integration test.
(To be honest, it&rsquo;s one of the worst our tests, everything is not so bad in general.)
And yes, I know that&rsquo;s it&rsquo;s not a good performance test, I know what should be improved here, and so on.
I don&rsquo;t want to discuss how it happens (it&rsquo;s a topic for another post), I just want to show what real performance data can look like.
What happens if we make a mistake and wrote <code>Thread.Sleep(20 * 1000)</code> somewhere?
Nothing!
No one will notice it (on this test at least).</p><p>So, we should understand what our performance data looks like and understand what kind of checks we can apply in each situation.</p><h4 id=different-hardware-and-many-environments>Different hardware and many environments</h4><p>As you probably noticed on the previous image, the performance on different operating systems is different.
The easiest thing to say here is something like &ldquo;Well, nothing special in this picture, .NET works well only on Windows&rdquo;.
Here is another image for you:</p><div class=row><div class=mx-auto><a href=/posts/reflecting-on-performance-testing/img/plot2.png target=_blank alt=plot2><img class="mx-auto d-block img-fluid" width=800 src=/posts/reflecting-on-performance-testing/img/plot2.png></a></div></div><br><p>In this test, Linux takes around 100ms all the time, MacOS takes 100—200ms, Windows takes 1000-1200ms.
Why? That&rsquo;s also a topic for another post (a hint: this test is socket-related).
The point here is we have different performance configurations on different tests.
And we can&rsquo;t mix measurements from different operation systems (in general).
There are a lot of other parameters which can be considered.
For example, some of the build agents have an HDD, and some of them have an SSD which definitely affects all I/O bound tests.
Some of the build agents can have a small amount of RAM which can affect tests with massive memory traffic.
<em>In general</em>, we can&rsquo;t compare absolute numbers from different machines if there are any differences in hardware configuration.
Even minor differences in the CPU model can play a vital role.
Sometimes, it&rsquo;s possible to analyze relative performance, but it&rsquo;s not always an option.</p><p>It&rsquo;s great if you can buy several dedicated machines which will execute performance tests 24/7.
(And if you can replace broken perf machines with machines that have exactly the same configuration.)
However, it&rsquo;s another trade-off question:
how many tests do you want to run,
how many times do you want to repeat them,
how long does it take,
how many performance machines can you afford?</p><h4 id=microbenchmarks-vs-integration-benchmarks>Microbenchmarks vs. integration benchmarks</h4><p>As I mentioned before, BenchmarkDotNet is designed for microbenchmarks.
It can measure a method even if it takes a few nanoseconds.
It not easy, but BenchmarkDotNet protects you from even super-tiny performance deviations.
For this purpose, it generates a separate project where it invokes the method billions of times.</p><p>But here is another situation.
Let&rsquo;s say we write Rider, and we want to measure how much does it take to debug a unit-test in a .NET Core project.
How many processes do we need?
Let&rsquo;s count.
We need a process for the <code>IntelliJ IDEA</code> platform (aka frontend), a process for the <code>ReSharper host</code> (aka backend).
Because of some infrastructure reasons,
we start tests on the frontend (we write it on Kotlin and run it on JVM),
but the benchmarking logic which should control the experiment is written in C#.
So, we have to add a process for the <code>BenchmarkDotNet host</code> (yeah, I want to support some kind of distributed benchmarks).
Next, we should load the project model with the help of <code>MSBuild</code> (another process for MSBuild),
discover tests with one <code>dotnet</code> process,
run tests with another <code>dotnet</code> process,
and attach to it from a <code>DebuggerWorker</code> process.
Thus, our small integration benchmark involves 7 processes.
There now are huge amount of cases where we can&rsquo;t get super-precision
(because of cross-process interaction, 3rd logic, etc.),
so standard deviation will be huge.
The total duration is several dozens of seconds, so we can&rsquo;t repeat it a billion times.
Because we are limited in time and have large variance,
we can&rsquo;t get a tiny confidence interval,
and it&rsquo;s hard to detect a small performance regression.</p><p>Another important point: if we write a tool for performance testing, we should keep in mind
that there are too many different cases and we can&rsquo;t cover all of them with a single approach.
At a minum, we need different approaches
for microbenchmarsk and for macrobenchmarks,
for single methods and for complicated integrated scenarios.</p><h3 id=perfect-place-for-performance-analysis>Perfect place for performance analysis</h3><p>How, where, and when we should do the performance analysis?
It&rsquo;s also a hard question, and it depends on the situation.
I can share my experience in Rider.
We have 3 places for performance analysis:</p><ul><li><strong>Each build.</strong>
A small set of tests which are running on each build.
<em>Pros:</em> commits with perf problems will not be merged into the master branch.
<em>Cons:</em> We should run all the tests quickly, so we can&rsquo;t run a lot of them.
We can&rsquo;t do many iterations, so data is small.
Only huge degradation can be detected (like 1 second -> 15 seconds, it happens).</li><li><strong>Daily tests.</strong>
A big set of tests which are running one time per day on dedicated machines.
<em>Pros:</em> we can do a lot of iterations, we can analyze historical data, we can detect even small performance problems.
<em>Cons:</em> we will know about a problem only <em>after</em> it&rsquo;s merged into master.</li><li><strong>Retrospective analysis.</strong>
A special system which analyzes <em>all</em> collected performance data from <em>all</em> build agents.
<em>Pros:</em> we have a huge data set, we can run a lot of cool analysis, we can detect problems which were not detected by first two options.
<em>Cons:</em> we will not know about a problem, unless it&rsquo;s too late (sometimes a week after a bad commit).</li></ul><p>We continue to develop these ways and think about what else we can do.
Of course, you may have own way to analyze the performance (and I will be happy to hear about it).</p><h4 id=one-big-degradation-vs-many-small-degradations>One big degradation vs. many small degradations.</h4><p>Ok, let&rsquo;s say we solved all of the previous problems.
Let&rsquo;s also say that our test takes 10–15 seconds and the build is green if the total time is less than 20 seconds.
We are interested only in huge performance degradation (5 seconds or more),
so it should work well, and the big variance is not a problem for us anymore.
Next, Developer1 adds a new feature which takes 1 second.
It&rsquo;s a very good feature, the test takes 11–16 seconds which is fine, the build is green, everyone is happy.
Next, Developer2 adds another awesome feature which also takes 1 second.
Now test takes 12–17 seconds which also is fine.</p><p>After another 4 iterations, the test will take 16–21 seconds and become flaky: it will fail the build <em>sometimes</em>.
After another iteration, the test will take 17–22 seconds and become more flaky.
Developers will be angry because even a very simple typo fix can&rsquo;t be merged because some tests with strange names are suddenly red.</p><h4 id=technical-issues-vs-management-issues>Technical issues vs. management issues</h4><p>Here we meet another problem: what should we do if our super-system has detected some performance problems?
Especially if there are 10 developers, who are responsible for problems with performance.
Especially if all the implemented features are super useful,
you can&rsquo;t drop it,
you don&rsquo;t know how to optimize it,
but you want to keep the good level of performance.
While you are thinking, the developers suffer because tests are flaky and it slows down the development process.</p><p>One day you decided that you are ready for this trade-off and you increase the timeout.
Then someone asks you: &ldquo;So, we can change timeouts in such situations, yeah?&rdquo;
Next, you will get a situation where every performance problem will be solved via increased timeouts without further investigation.</p><p>Even if you have a perfect performance regression tests, they can be useless, if you don&rsquo;t have the performance culture in your company.
You should solve it somehow: find very responsible developers, assign special people for performance investigation, and so on.
If you are going to write performance tests, you should think about such things in advance.</p><h3 id=points-of-discussion>Points of discussion</h3><p>I named only a few main problems, there are too many of them.
I know how to solve some of them, but I don&rsquo;t know what I can do with others.
I&rsquo;m going to continue my research, implement best practices in BenchmarkDotNet, and share final results.
I would be really happy to hear any feedback from you.
How do you analyze performance?
How do you avoid performance degradation?
How do you solve management issues and find trade-offs between new features and performance?
What kind of other problems do you have which should be solved in a good performance testing library?</p></div><br><br></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}));function toggleTheme(e){e?(document.documentElement.classList.add("dark"),themeToggleLightIcon.classList.remove("hidden"),themeToggleDarkIcon.classList.add("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")}),imagesLight.forEach(e=>{e.classList.add("hidden")})):(document.documentElement.classList.remove("dark"),themeToggleDarkIcon.classList.remove("hidden"),themeToggleLightIcon.classList.add("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}),imagesDark.forEach(e=>{e.classList.add("hidden")}))}themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),event.altKey?(localStorage.removeItem("color-theme"),toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches)):localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{if(localStorage.getItem("color-theme")===null){const t=e.matches?"dark":"light";toggleTheme(t==="dark")}})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2024 <span class=whitespace-nowrap>Andrey Akinshin</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer></body></html>