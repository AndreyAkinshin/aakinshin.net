<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><title>How Sorting Order Depends on Runtime and Operating System | Andrey Akinshin</title><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://googlechromelabs.github.io/dark-mode-toggle/src/dark-mode-toggle.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.e78467baec0179d7ccd2ef995e0c94f25b4a63a3191a93c3547e22bdf590ef5d.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.a9ad336a30411929ac042537ef03ddbe3b2b28af5aa50655711f870419408467.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/pages/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li><li class=nav-item></li><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class=blog-post><h2 class=blog-post-title id=post-title>How Sorting Order Depends on Runtime and Operating System</h2><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2020-05-13>May 13, 2020</time>
&nbsp;&nbsp;
<a href=https://aakinshin.net/tags/dotnet/ class="badge badge-info">.NET</a>
<a href=https://aakinshin.net/tags/cs/ class="badge badge-info">C#</a>
<a href=https://aakinshin.net/tags/rider/ class="badge badge-info">Rider</a>
<a href=https://aakinshin.net/tags/mono/ class="badge badge-info">Mono</a>
<a href=https://aakinshin.net/tags/.net-core/ class="badge badge-info">.NET Core</a></span><br><br><p><em>This blog post was <a href=https://blog.jetbrains.com/dotnet/2020/05/13/sorting-order-depends-runtime-operating-system/>originally posted</a> on <a href=https://blog.jetbrains.com/dotnet/>JetBrains .NET blog</a>.</em></p><p>In <a href=https://www.jetbrains.com/rider/>Rider</a>, we have unit tests that enumerate files in your project and dump a sorted list of these files. In one of our test projects, we had the following files: <code>jquery-1.4.1.js</code>, <code>jquery-1.4.1.min.js</code>, <code>jquery-1.4.1-vsdoc.js</code>. On Windows, .NET Framework, .NET Core, and Mono produce the same sorted list:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>jquery-1.4.1.js
jquery-1.4.1.min.js
jquery-1.4.1-vsdoc.js
</code></pre></div><p>On Unix, Mono also produces the same list, so we had a consistent list of files across all environments. However, once we migrated to .NET Core, we discovered that the sorting order had changed to:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>jquery-1.4.1-vsdoc.js
jquery-1.4.1.js
jquery-1.4.1.min.js
</code></pre></div><p>After a quick investigation, we realized that the problem was related to the <code>.</code> and <code>-</code> symbols. The example above can be simplified to the following minimal repro:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=kt>var</span> <span class=n>list</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>string</span><span class=p>&gt;</span> <span class=p>{</span> <span class=s>&#34;a.b&#34;</span><span class=p>,</span> <span class=s>&#34;a-b&#34;</span> <span class=p>};</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=kt>string</span><span class=p>.</span><span class=n>Join</span><span class=p>(</span><span class=s>&#34; &#34;</span><span class=p>,</span> <span class=n>list</span><span class=p>.</span><span class=n>OrderBy</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>x</span><span class=p>)));</span>
</code></pre></div><p>.NET Framework, Mono, and .NET Core+Windows print <code>a.b a-b</code> to the output. However, .NET Core on Unix thinks that <code>a-b</code> is smaller than <code>a.b</code>, and prints <code>a-b a.b</code>. Thus, the sorting order depends on the runtime and operating system that you use.
In our codebase, we fixed this problem with the help of <code>StringComparer.Ordinal</code>. Instead of <code>list.OrderBy(x => x)</code>, in the example above we would write <code>list.OrderBy(x => x, StringComparer.Ordinal)</code>. This guarantees a consistent string order that doesn&rsquo;t depend on the environment.
We also started to wonder about the other kinds of string sorting &ldquo;phenomena&rdquo; we might find by switching between runtimes and operating systems. Let&rsquo;s find out!</p><h2><strong>Collecting more data</strong></h2>We took a simple set of characters <code>.-'!a</code> and built all possible two-character combinations from them:<div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=kt>var</span> <span class=n>chars</span> <span class=p>=</span> <span class=s>&#34;.-&#39;!a&#34;</span><span class=p>.</span><span class=n>ToCharArray</span><span class=p>();</span>
<span class=kt>var</span> <span class=n>strings</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&amp;</span><span class=n>lt</span><span class=p>;</span><span class=kt>string</span><span class=p>&amp;</span><span class=n>gt</span><span class=p>;();</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&amp;</span><span class=n>lt</span><span class=p>;</span> <span class=n>chars</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>j</span> <span class=p>&amp;</span><span class=n>lt</span><span class=p>;</span> <span class=n>chars</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span> <span class=n>j</span><span class=p>++)</span>
        <span class=n>strings</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>chars</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ToString</span><span class=p>()</span> <span class=p>+</span> <span class=n>chars</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</code></pre></div><p>Next, we compared these combinations to each other on different combinations of runtimes (.NET Framework, .NET Core, Mono) and operating systems (Windows, Linux, macOS):</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>using</span> <span class=p>(</span><span class=kt>var</span> <span class=n>writer</span> <span class=p>=</span> <span class=k>new</span> <span class=n>StreamWriter</span><span class=p>(</span><span class=n>filename</span><span class=p>))</span>
<span class=p>{</span>
    <span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=n>a</span> <span class=k>in</span> <span class=n>strings</span><span class=p>)</span>
        <span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=n>b</span> <span class=k>in</span> <span class=n>strings</span><span class=p>)</span>
             <span class=n>writer</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>CompareTo</span><span class=p>(</span><span class=n>b</span><span class=p>));</span>
<span class=p>}</span>
</code></pre></div><p>We discovered three different cases in which the <code>CompareTo</code> results are not consistent. To illustrate them, we took 4 string pairs from each group and built the following diagram for you:</p><div class=mx-auto><a href=/posts/how-sorting-order-depends-on-runtime-and-operating-system/img/dotnet-SortingTable-blog.png target=_blank><img class="mx-auto d-block img-fluid" width=800 src=/posts/how-sorting-order-depends-on-runtime-and-operating-system/img/dotnet-SortingTable-blog.png></a></div><br><p>In the <a href=https://blog.jetbrains.com/dotnet/2020/04/27/socket-error-codes-depend-runtime-operating-system/>previous post</a> where we discussed socket implementations in different environments, we showed the source code for all relevant cases. This time, we suggest you do this exercise yourself. Try digging into the source code of all runtimes to find explanations for the above picture. For a bonus challenge, do your own experiments with <code>CultureInfo.CurrentCulture</code> and learn more about how the sorting order depends on the system locale. It would be great if you could share your findings with the community! To give you further inspiration for this kind of research, we want to show you a few more interesting facts.</p><h2><strong>More tricky cases</strong></h2>Sorting order can be pretty tricky, even if you are only working within one environment. A great example of unexpected behavior can be found in this StackOverflow <a href=https://stackoverflow.com/q/2244480/184842>question</a>, where developers discuss the following code snippet:<div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>&#34;+&#34;.CompareTo(&#34;-&#34;)
Returns: 1

&#34;+1&#34;.CompareTo(&#34;-1&#34;)
Returns: -1
</code></pre></div><p>As you can see, <code>"+"</code> is greater than <code>&rdquo;-&ldquo;</code> while <code>"+1"</code> is lesser than <code>&rdquo;-1"</code>. The <a href=https://stackoverflow.com/a/2244615/184842>best answer</a> quotes the following paragraph from Microsoft Docs:</p><blockquote>The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.
For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</blockquote>If we continue to read the documentation, we will see that there are overloads of <code>string.Compare</code> that take <code>System.Globalization.CompareOptions </code>as one of the arguments. Here is the most common overload:<div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>public</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>Compare</span><span class=p>(</span><span class=kt>string</span> <span class=n>strA</span><span class=p>,</span> <span class=kt>string</span> <span class=n>strB</span><span class=p>,</span> <span class=n>CultureInfo</span> <span class=n>culture</span><span class=p>,</span> <span class=n>CompareOptions</span> <span class=n>options</span><span class=p>);</span>
</code></pre></div><p>The <a href=https://docs.microsoft.com/en-us/dotnet/api/system.globalization.compareoptions>CompareOptions</a> flag enum defines the string comparison rules. Here are the most interesting values:</p><ul><li><strong>IgnoreKanaType:</strong> Indicates that the string comparison must ignore the Kana type. Kana type refers to Japanese hiragana and katakana characters, which represent phonetic sounds in the Japanese language. Hiragana is used for native Japanese expressions and words, while katakana is used for words borrowed from other languages, such as "computer" or "Internet". A phonetic sound can be expressed in both hiragana and katakana. If this value is selected, the hiragana character for one sound is considered equal to the katakana character for the same sound.</li><li><strong>IgnoreNonSpace:</strong> Indicates that the string comparison must ignore non-spacing combining characters, such as diacritics. The Unicode Standard defines combining characters as characters that are combined with base characters to produce a new character. Non-spacing combining characters do not occupy a spacing position by themselves when rendered.</li><li><strong>IgnoreSymbols:</strong> Indicates that the string comparison must ignore symbols, such as white-space characters, punctuation, currency symbols, the percent sign, mathematical symbols, the ampersand, and so on.</li><li><strong>IgnoreWidth</strong>: Indicates that the string comparison must ignore character width. For example, Japanese katakana characters can be written as full-width or half-width. If this value is selected, the katakana characters written as full-width are considered equal to the same characters written as half-width.</li><li><strong>Ordinal:</strong> Indicates that the string comparison must use the successive Unicode UTF-16 encoded values of the string (code unit by code unit comparison), leading to a fast comparison, but one that is culture-insensitive. A string starting with a code unit XXXX16 comes before a string starting with YYYY16, if XXXX16 is less than YYYY16. This value cannot be combined with other CompareOptions values and must be used alone.</li><li><strong>StringSort:</strong> Indicates that the string comparison must use the string sort algorithm. In a string sort, the hyphen and the apostrophe, as well as other non-alphanumeric symbols, come before alphanumeric characters.</li></ul>Try to play with these values, and find examples of string lists that can be sorted differently depending on the above flags. This kind of experiment is a great way to learn more about runtime and to become more aware of pitfalls related to string sorting.
This is not the end of our adventure, however. There is one more global option that can completely change the behavior of string comparison!<h2><strong>Globalization invariant mode</strong></h2>In .NET Core 2.0+, there is a feature called <em>Globalization invariant mode</em>, which uses the <code>Ordinal</code> sorting rule for all string comparisons by default. It can be enabled if you set the <code>DOTNET_SYSTEM_GLOBALIZATION_INVARIANT</code> environment variable to <code>true</code> or <code>1</code>. Let's enable this mode and run examples from the previous section:<div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=kt>string</span><span class=p>.</span><span class=n>Compare</span><span class=p>(</span><span class=s>&#34;-&#34;</span><span class=p>,</span> <span class=s>&#34;+&#34;</span><span class=p>));</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=kt>string</span><span class=p>.</span><span class=n>Compare</span><span class=p>(</span><span class=s>&#34;-x&#34;</span><span class=p>,</span> <span class=s>&#34;+x&#34;</span><span class=p>));</span>
</code></pre></div><p>Now it prints a new result:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>2
2
</code></pre></div><p>Some developers may think that it&rsquo;s a good idea to always enable this by default to avoid problems with inconsistent sorting. Note that in this mode, you will get poor globalization support: a lot of features will be affected, including all <code>CultureInfo</code>-specific logic, string operations, internationalized domain names (IDN) support, and even time zone display names on Linux. If you want to enable it, carefully read the <a href=https://github.com/dotnet/runtime/blob/master/docs/design/features/globalization-invariant-mode.md>documentation</a> first.
It&rsquo;s worth mentioning that if you don&rsquo;t control the environment of your application, there is a chance that users will enable it manually. This could significantly affect any .NET Core application!</p><h2><strong>Conclusion</strong></h2>Here are a few practical recommendations that can help you avoid tricky and painful bugs in the future:<ul><li>If you want to achieve consistent string comparison across different runtimes and operating systems, always use <code>StringComparer.Ordinal</code>.</li><li>If you don't use <code>StringComparer.Ordinal</code>, always keep in mind that the sorting order may depend on runtime, operating system, current culture, and environment variables.</li><li>Try to do your own experiments and learn more about sorting rules in .NET. This time we decided to leave out the detailed explanations and instead encourage you to explore them for yourself. After all, this is the best way to learn something new and improve your programming skills!</li></ul><br><br><div class=mx-auto>Share:<div class=faicon><a href="https://twitter.com/intent/tweet?text=How%20Sorting%20Order%20Depends%20on%20Runtime%20and%20Operating%20System&url=https%3a%2f%2faakinshin.net%2fposts%2fhow-sorting-order-depends-on-runtime-and-operating-system%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x" title=Twitter></i></a></div><div class=faicon><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fhow-sorting-order-depends-on-runtime-and-operating-system%2f&title=How%20Sorting%20Order%20Depends%20on%20Runtime%20and%20Operating%20System" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=faicon><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fhow-sorting-order-depends-on-runtime-and-operating-system%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=faicon><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fposts%2fhow-sorting-order-depends-on-runtime-and-operating-system%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=faicon><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fposts%2fhow-sorting-order-depends-on-runtime-and-operating-system%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=faicon><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fhow-sorting-order-depends-on-runtime-and-operating-system%2f&title=How%20Sorting%20Order%20Depends%20on%20Runtime%20and%20Operating%20System" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2020 Andrey Akinshin | <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.ea4f51ac7f59c8e13f4df787df946eb1a447174ce2f1fc5349483de93a607ecb.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script></body></html>