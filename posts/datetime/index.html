<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content=".NET,Timers,Internals"><title>DateTime under the hood</title><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.882998740b9c4c24677576b997bde5a487246e2e3bd72128a0e922eaa59db029.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.e78467baec0179d7ccd2ef995e0c94f25b4a63a3191a93c3547e22bdf590ef5d.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.78ec57e430adfea699c8b75de41d2e13b5cb1a0f850513203cbe0903ae91d11b.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41419012-5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41419012-5');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/pages/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class=blog-post><h2 class=blog-post-title id=post-title>DateTime under the hood</h2><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2016-08-19>August 19, 2016</time>
&nbsp;&nbsp;
<i class="fas fa-tag"></i>&nbsp;
<a href=https://aakinshin.net/tags/dotnet/ class="badge badge-info">.NET</a>
<a href=https://aakinshin.net/tags/timers/ class="badge badge-info">Timers</a>
<a href=https://aakinshin.net/tags/internals/ class="badge badge-info">Internals</a></span><br><br><p><strong>Update:</strong>
You can find an updated and significantly improved version of this post in my book <a href=/prodotnetbenchmarking/>&ldquo;Pro .NET Benchmarking&rdquo;</a>.</p><p><a href=https://msdn.microsoft.com/library/system.datetime.aspx>DateTime</a> is a widely used .NET type. A lot of developers use it all the time, but not all of them really know how it works. In this post, I discuss <a href=https://msdn.microsoft.com/library/system.datetime.utcnow.aspx>DateTime.UtcNow</a>: how it&rsquo;s implemented, what the latency and the resolution of <code>DateTime</code> on Windows and Linux, how the resolution can be changed, and how it can affect your application. This post is an overview, so you probably will not see super detailed explanations of some topics, but you will find a lot of useful links for further reading.</p><hr><h3 id=source>Source</h3><p>In the .NET Framework, the <code>DateTime</code> struct is represented by a <code>long</code> value called <a href=https://msdn.microsoft.com/library/system.datetime.ticks.aspx>Ticks</a>. One tick equals to <code>100 ns</code>, ticks are counted starting from 12:00 AM January 1, year 1 A.D. (Gregorian Calendar).</p><p>In Windows, there is another structure for time called <a href=https://msdn.microsoft.com/library/windows/desktop/ms724284.aspx>FILETIME</a>. It also uses <code>100 ns</code>-ticks, but the starting point is January 1, 1601 (UTC). You can get current <code>FILETIME</code> via <a href=https://msdn.microsoft.com/en-us/library/windows/desktop/ms724397.aspx>GetSystemTimeAsFileTime</a>.</p><p>Now, let&rsquo;s look at the source code of <code>DateTime</code> in the coreclr repo: <a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs>DateTime.cs</a> (<a href=http://referencesource.microsoft.com/#mscorlib/system/datetime.cs>the corresponded class</a> in the Full .NET Framework looks almost the same; Mono uses code from the full framework directly). The implementation is based on <code>GetSystemTimeAsFileTime</code> and use <a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs#L93>FileTimeOffset</a> for conversion. A simplified version of <code>UtcNow</code> from <a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs#L915>DateTime.cs</a>:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>public</span> <span class=k>static</span> <span class=n>DateTime</span> <span class=n>UtcNow</span> <span class=p>{</span>
    <span class=k>get</span> <span class=p>{</span>
        <span class=kt>long</span> <span class=n>ticks</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
        <span class=n>ticks</span> <span class=p>=</span> <span class=n>GetSystemTimeAsFileTime</span><span class=p>();</span>
        <span class=k>return</span> <span class=k>new</span> <span class=n>DateTime</span><span class=p>(</span> <span class=p>((</span><span class=n>UInt64</span><span class=p>)(</span><span class=n>ticks</span> <span class=p>+</span> <span class=n>FileTimeOffset</span><span class=p>))</span> <span class=p>|</span> <span class=n>KindUtc</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=na>
</span><span class=na>[MethodImplAttribute(MethodImplOptions.InternalCall)]</span>
<span class=k>internal</span> <span class=k>static</span> <span class=k>extern</span> <span class=kt>long</span> <span class=n>GetSystemTimeAsFileTime</span><span class=p>();</span>
</code></pre></div><p>You may have noticed <code>KindUtc</code> in the constructor argument. In fact, <code>DateTime</code> keeps actual <code>Ticks</code> only in bits 01-62 of the <a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs#L137>dateData</a> field; bits 63-64 are used for <a href=https://msdn.microsoft.com/en-us/library/shx7s921.aspx>DateTimeKind</a> (<code>Local</code>, <code>Utc</code>, or <code>Unspecified</code>).</p><p><code>extern long GetSystemTimeAsFileTime()</code> is implemented as follows: on Windows, it uses the <a href=https://msdn.microsoft.com/library/windows/desktop/ms724397.aspx>GetSystemTimeAsFileTime</a> function from <a href=https://en.wikipedia.org/wiki/Windows.h>windows.h</a>, on Unix it uses <a href=http://man7.org/linux/man-pages/man2/gettimeofday.2.html>gettimeofday</a> and transforms the received value from the <a href=https://en.wikipedia.org/wiki/Unix_time>Unix epoch</a> (<em>January 1, 1970</em>) to the Win32 epoch (<em>January 1, 1601</em>).</p><p>Let&rsquo;s dive deeper into the source code for CoreCLR and Mono (you can skip the next two sections if you are not interested in the implementation details).</p><h4 id=coreclr-v100>CoreCLR v1.0.0</h4><p><a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/vm/ecalllist.h#L2219>src/vm/ecalllist.h</a>:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>FCClassElement</span><span class=p>(</span><span class=s>&#34;DateTime&#34;</span><span class=p>,</span> <span class=s>&#34;System&#34;</span><span class=p>,</span> <span class=n>gDateTimeFuncs</span><span class=p>)</span>
</code></pre></div><p><a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/vm/ecalllist.h#L279>src/vm/ecalllist.h</a>:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>FCFuncStart</span><span class=p>(</span><span class=n>gDateTimeFuncs</span><span class=p>)</span>
    <span class=n>FCFuncElement</span><span class=p>(</span><span class=s>&#34;GetSystemTimeAsFileTime&#34;</span><span class=p>,</span> <span class=n>SystemNative</span><span class=o>::</span><span class=n>__GetSystemTimeAsFileTime</span><span class=p>)</span>
</code></pre></div><p><a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/classlibnative/bcltype/system.cpp#L48>classlibnative/bcltype/system.cpp/system.cpp</a>:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>FCIMPL0</span><span class=p>(</span><span class=n>INT64</span><span class=p>,</span> <span class=n>SystemNative</span><span class=o>::</span><span class=n>__GetSystemTimeAsFileTime</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>FCALL_CONTRACT</span><span class=p>;</span>

    <span class=n>INT64</span> <span class=n>timestamp</span><span class=p>;</span>

    <span class=o>::</span><span class=n>GetSystemTimeAsFileTime</span><span class=p>((</span><span class=n>FILETIME</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>timestamp</span><span class=p>);</span>

<span class=cp>#if BIGENDIAN
</span><span class=cp></span>    <span class=n>timestamp</span> <span class=o>=</span> <span class=p>(</span><span class=n>INT64</span><span class=p>)(((</span><span class=n>UINT64</span><span class=p>)</span><span class=n>timestamp</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span><span class=p>)</span> <span class=o>|</span> <span class=p>((</span><span class=n>UINT64</span><span class=p>)</span><span class=n>timestamp</span> <span class=o>&lt;&lt;</span> <span class=mi>32</span><span class=p>));</span>
<span class=cp>#endif
</span><span class=cp></span>
    <span class=k>return</span> <span class=n>timestamp</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>FCIMPLEND</span><span class=p>;</span>
</code></pre></div><p>You can find the definition of <code>FCIMPL0</code> in <a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/vm/fcall.h>src/vm/fcall.h</a>.</p><p><a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/pal/src/file/filetime.cpp#L502>pal/src/file/filetime.cpp</a>:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>VOID</span>
<span class=n>PALAPI</span>
<span class=nf>GetSystemTimeAsFileTime</span><span class=p>(</span>
            <span class=n>OUT</span> <span class=n>LPFILETIME</span> <span class=n>lpSystemTimeAsFileTime</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>timeval</span> <span class=n>Time</span><span class=p>;</span>

    <span class=n>PERF_ENTRY</span><span class=p>(</span><span class=n>GetSystemTimeAsFileTime</span><span class=p>);</span>
    <span class=n>ENTRY</span><span class=p>(</span><span class=s>&#34;GetSystemTimeAsFileTime(lpSystemTimeAsFileTime=%p)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> 
          <span class=n>lpSystemTimeAsFileTime</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span> <span class=n>gettimeofday</span><span class=p>(</span> <span class=o>&amp;</span><span class=n>Time</span><span class=p>,</span> <span class=nb>NULL</span> <span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span> <span class=p>)</span>
    <span class=p>{</span>
        <span class=n>ASSERT</span><span class=p>(</span><span class=s>&#34;gettimeofday() failed&#34;</span><span class=p>);</span>
        <span class=cm>/* no way to indicate failure, so set time to zero */</span>
        <span class=o>*</span><span class=n>lpSystemTimeAsFileTime</span> <span class=o>=</span> <span class=n>FILEUnixTimeToFileTime</span><span class=p>(</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span> <span class=p>);</span>
    <span class=p>}</span>
    <span class=k>else</span>
    <span class=p>{</span>
        <span class=cm>/* use (tv_usec * 1000) because 2nd arg is in nanoseconds */</span>
        <span class=o>*</span><span class=n>lpSystemTimeAsFileTime</span> <span class=o>=</span> <span class=n>FILEUnixTimeToFileTime</span><span class=p>(</span> <span class=n>Time</span><span class=p>.</span><span class=n>tv_sec</span><span class=p>,</span>
                                                          <span class=n>Time</span><span class=p>.</span><span class=n>tv_usec</span> <span class=o>*</span> <span class=mi>1000</span> <span class=p>);</span>
    <span class=p>}</span>

    <span class=n>LOGEXIT</span><span class=p>(</span><span class=s>&#34;GetSystemTimeAsFileTime returns.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=n>PERF_EXIT</span><span class=p>(</span><span class=n>GetSystemTimeAsFileTime</span><span class=p>);</span>
<span class=p>}</span>

<span class=cm>/*++
</span><span class=cm>Convert a time_t value to a win32 FILETIME structure, as described in
</span><span class=cm>MSDN documentation. time_t is the number of seconds elapsed since 
</span><span class=cm>00:00 01 January 1970 UTC (Unix epoch), while FILETIME represents a 
</span><span class=cm>64-bit number of 100-nanosecond intervals that have passed since 00:00 
</span><span class=cm>01 January 1601 UTC (win32 epoch).
</span><span class=cm>--*/</span>
<span class=n>FILETIME</span> <span class=nf>FILEUnixTimeToFileTime</span><span class=p>(</span> <span class=n>time_t</span> <span class=n>sec</span><span class=p>,</span> <span class=kt>long</span> <span class=n>nsec</span> <span class=p>)</span>
<span class=p>{</span>
    <span class=kr>__int64</span> <span class=n>Result</span><span class=p>;</span>
    <span class=n>FILETIME</span> <span class=n>Ret</span><span class=p>;</span>

    <span class=n>Result</span> <span class=o>=</span> <span class=p>((</span><span class=kr>__int64</span><span class=p>)</span><span class=n>sec</span> <span class=o>+</span> <span class=n>SECS_BETWEEN_1601_AND_1970_EPOCHS</span><span class=p>)</span> <span class=o>*</span> <span class=n>SECS_TO_100NS</span> <span class=o>+</span>
        <span class=p>(</span><span class=n>nsec</span> <span class=o>/</span> <span class=mi>100</span><span class=p>);</span>

    <span class=n>Ret</span><span class=p>.</span><span class=n>dwLowDateTime</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=p>)</span><span class=n>Result</span><span class=p>;</span>
    <span class=n>Ret</span><span class=p>.</span><span class=n>dwHighDateTime</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD</span><span class=p>)(</span><span class=n>Result</span> <span class=o>&gt;&gt;</span> <span class=mi>32</span><span class=p>);</span>

    <span class=n>TRACE</span><span class=p>(</span><span class=s>&#34;Unix time = [%ld.%09ld] converts to Win32 FILETIME = [%#x:%#x]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> 
          <span class=n>sec</span><span class=p>,</span> <span class=n>nsec</span><span class=p>,</span> <span class=n>Ret</span><span class=p>.</span><span class=n>dwHighDateTime</span><span class=p>,</span> <span class=n>Ret</span><span class=p>.</span><span class=n>dwLowDateTime</span><span class=p>);</span>

    <span class=k>return</span> <span class=n>Ret</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><h4 id=mono-44211>Mono 4.4.2.11</h4><p><a href=https://github.com/mono/mono/blob/mono-4.4.2.11/mono/metadata/icall-def.h#L135>icall-def.h</a>:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=n>ICALL_TYPE</span><span class=p>(</span><span class=n>DTIME</span><span class=p>,</span> <span class=s>&#34;System.DateTime&#34;</span><span class=p>,</span> <span class=n>DTIME_1</span><span class=p>)</span>
<span class=n>ICALL</span><span class=p>(</span><span class=n>DTIME_1</span><span class=p>,</span> <span class=s>&#34;GetSystemTimeAsFileTime&#34;</span><span class=p>,</span> <span class=n>mono_100ns_datetime</span><span class=p>)</span>
</code></pre></div><p><a href=https://github.com/mono/mono/blob/mono-4.4.2.11/mono/utils/mono-time.c>mono-time.c</a>:</p><div class=highlight><pre class=chroma><code class=language-cpp data-lang=cpp><span class=cp>#ifdef HOST_WIN32
</span><span class=cp>#include</span> <span class=cpf>&lt;windows.h&gt;</span><span class=cp>
</span><span class=cp></span><span class=c1>//...
</span><span class=c1></span>
<span class=cm>/* Returns the number of 100ns ticks since Jan 1, 1601, UTC timezone */</span>
<span class=n>gint64</span>
<span class=nf>mono_100ns_datetime</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ULARGE_INTEGER</span> <span class=n>ft</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>ft</span><span class=p>)</span> <span class=o>!=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>FILETIME</span><span class=p>))</span>
        <span class=n>g_assert_not_reached</span> <span class=p>();</span>

    <span class=n>GetSystemTimeAsFileTime</span> <span class=p>((</span><span class=n>FILETIME</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>ft</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>ft</span><span class=p>.</span><span class=n>QuadPart</span><span class=p>;</span>
<span class=p>}</span>

<span class=cp>#else
</span><span class=cp></span>
<span class=c1>// ...
</span><span class=c1></span>
<span class=cm>/*
</span><span class=cm> * Magic number to convert unix epoch start to windows epoch start
</span><span class=cm> * Jan 1, 1970 into a value which is relative to Jan 1, 1601.
</span><span class=cm> */</span>
<span class=cp>#define EPOCH_ADJUST    ((guint64)11644473600LL)
</span><span class=cp></span>
<span class=cm>/* Returns the number of 100ns ticks since 1/1/1601, UTC timezone */</span>
<span class=n>gint64</span>
<span class=nf>mono_100ns_datetime</span> <span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>struct</span> <span class=nc>timeval</span> <span class=n>tv</span><span class=p>;</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>gettimeofday</span> <span class=p>(</span><span class=o>&amp;</span><span class=n>tv</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
        <span class=k>return</span> <span class=n>mono_100ns_datetime_from_timeval</span> <span class=p>(</span><span class=n>tv</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>

<span class=n>gint64</span>
<span class=nf>mono_100ns_datetime_from_timeval</span> <span class=p>(</span><span class=k>struct</span> <span class=nc>timeval</span> <span class=n>tv</span><span class=p>)</span>
<span class=p>{</span>
    <span class=k>return</span> <span class=p>(((</span><span class=n>gint64</span><span class=p>)</span><span class=n>tv</span><span class=p>.</span><span class=n>tv_sec</span> <span class=o>+</span> <span class=n>EPOCH_ADJUST</span><span class=p>)</span> <span class=o>*</span> <span class=mi>1000000</span> <span class=o>+</span> <span class=n>tv</span><span class=p>.</span><span class=n>tv_usec</span><span class=p>)</span> <span class=o>*</span> <span class=mi>10</span><span class=p>;</span>
<span class=p>}</span>

<span class=cp>#endif
</span></code></pre></div><hr><h3 id=resolution>Resolution</h3><h4 id=windows>Windows</h4><p>As I mentioned previously, the WinAPI function for getting current time is <code>GetSystemTimeAsFileTime</code>. If you want to get the <code>FILETIME</code> with with the highest possible level of precision, you should use <a href=https://msdn.microsoft.com/library/windows/desktop/hh706895.aspx>GetSystemTimePreciseAsFileTime</a>. There is also the <a href=https://msdn.microsoft.com/en-us/library/windows/desktop/ms724390.aspx>GetSystemTime</a> function which returns <a href=https://msdn.microsoft.com/en-us/library/windows/desktop/ms724950.aspx>SYSTEMTIME</a>: it works slowly but it returns current time in a well-suited format. You can convert <code>FILETIME</code> to <code>SYSTEMTIME</code> manually with help of the <a href=https://msdn.microsoft.com/en-us/library/windows/desktop/ms724280.aspx>FileTimeToSystemTime</a> function.</p><p>In this section, only <code>GetSystemTimeAsFileTime</code> will be discussed. The resolution of this function may take different values. You can easily get the configuration of your OS with the help of the <a href=https://technet.microsoft.com/en-us/sysinternals/bb897568.aspx>ClockRes</a> utility from the <a href=https://technet.microsoft.com/en-us/sysinternals/bb842062.aspx>Sysinternals Suite</a>. Here is a typical output on my laptop:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>&gt; Clockres.exe
Clockres v2.1 - Clock resolution display utility
Copyright (C) 2016 Mark Russinovich
Sysinternals

Maximum timer interval: 15.625 ms
Minimum timer interval: 0.500 ms
Current timer interval: 1.000 ms
</code></pre></div><p>First of all, look at the maximum timer interval: it equals to <code>15.625 ms</code> (this corresponds to a frequency of 64 <a href=https://en.wikipedia.org/wiki/Hertz>Hz</a>). It&rsquo;s my default DateTime resolution when I don&rsquo;t have any non-system running applications. This value can be changed programmatically by <em>any application</em>. For example, my current timer interval is <code>1 ms</code> (frequency = <code>1000 Hz</code>). However, there is a limit: my minimum timer interval equals to <code>0.5 ms</code> (frequency = <code>2000 Hz</code>). The current timer interval may only take value from the specified range.</p><p>It&rsquo;s a typical configuration for the modern version of Windows. However, you can observe other resolution values on the older version of Windows. For example, <a href=https://msdn.microsoft.com/library/system.datetime.utcnow.aspx#Anchor_1>according</a> to MSDN, default resolution of <code>DateTime</code> on Windows 98 is about <code>55ms</code>. You can also find a lot of useful information about different configuration here: <a href=http://www.windowstimestamp.com/description>The Windows Timestamp Project</a>.</p><h4 id=windows-resolution-api>Windows Resolution API</h4><p>So, how it can be changed? There are some Windows API which can be used: <a href=https://msdn.microsoft.com/en-us/library/dd757624.aspx>timeBeginPeriod</a>/<a href=https://msdn.microsoft.com/en-us/library/dd757626.aspx>timeEndPeriod</a> from <code>winmm.dll</code> and <code>NtQueryTimerResolution</code>/<code>NtSetTimerResolution</code> from <code>ntdll.dll</code>. You can use it directly from C#, here is a helper class for you:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>public</span> <span class=k>struct</span> <span class=nc>ResolutionInfo</span>
<span class=p>{</span>
  <span class=k>public</span> <span class=kt>uint</span> <span class=n>Min</span><span class=p>;</span>
  <span class=k>public</span> <span class=kt>uint</span> <span class=n>Max</span><span class=p>;</span>
  <span class=k>public</span> <span class=kt>uint</span> <span class=n>Current</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>public</span> <span class=k>static</span> <span class=k>class</span> <span class=nc>WinApi</span>
<span class=p>{</span>
<span class=na>  [DllImport(&#34;winmm.dll&#34;, EntryPoint = &#34;timeBeginPeriod&#34;, SetLastError = true)]</span>
  <span class=k>public</span> <span class=k>static</span> <span class=k>extern</span> <span class=kt>uint</span> <span class=n>TimeBeginPeriod</span><span class=p>(</span><span class=kt>uint</span> <span class=n>uMilliseconds</span><span class=p>);</span>
<span class=na>
</span><span class=na>  [DllImport(&#34;winmm.dll&#34;, EntryPoint = &#34;timeEndPeriod&#34;, SetLastError = true)]</span>
  <span class=k>public</span> <span class=k>static</span> <span class=k>extern</span> <span class=kt>uint</span> <span class=n>TimeEndPeriod</span><span class=p>(</span><span class=kt>uint</span> <span class=n>uMilliseconds</span><span class=p>);</span>
<span class=na>
</span><span class=na>  [DllImport(&#34;ntdll.dll&#34;, SetLastError = true)]</span>
  <span class=k>private</span> <span class=k>static</span> <span class=k>extern</span> <span class=kt>uint</span> <span class=n>NtQueryTimerResolution</span><span class=p>(</span><span class=k>out</span> <span class=kt>uint</span> <span class=n>min</span><span class=p>,</span> <span class=k>out</span> <span class=kt>uint</span> <span class=n>max</span><span class=p>,</span> <span class=k>out</span> <span class=kt>uint</span> <span class=n>current</span><span class=p>);</span>
<span class=na>
</span><span class=na>  [DllImport(&#34;ntdll.dll&#34;, SetLastError = true)]</span>
  <span class=k>private</span> <span class=k>static</span> <span class=k>extern</span> <span class=kt>uint</span> <span class=n>NtSetTimerResolution</span><span class=p>(</span><span class=kt>uint</span> <span class=n>desiredResolution</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>setResolution</span><span class=p>,</span>
    <span class=k>ref</span> <span class=kt>uint</span> <span class=n>currentResolution</span><span class=p>);</span>

  <span class=k>public</span> <span class=k>static</span> <span class=n>ResolutionInfo</span> <span class=n>QueryTimerResolution</span><span class=p>()</span>
  <span class=p>{</span>
    <span class=kt>var</span> <span class=n>info</span> <span class=p>=</span> <span class=k>new</span> <span class=n>ResolutionInfo</span><span class=p>();</span>
    <span class=n>NtQueryTimerResolution</span><span class=p>(</span><span class=k>out</span> <span class=n>info</span><span class=p>.</span><span class=n>Min</span><span class=p>,</span> <span class=k>out</span> <span class=n>info</span><span class=p>.</span><span class=n>Max</span><span class=p>,</span> <span class=k>out</span> <span class=n>info</span><span class=p>.</span><span class=n>Current</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>info</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=k>public</span> <span class=k>static</span> <span class=kt>ulong</span> <span class=n>SetTimerResolution</span><span class=p>(</span><span class=kt>uint</span> <span class=n>ticks</span><span class=p>)</span>
  <span class=p>{</span>
    <span class=kt>uint</span> <span class=n>currentRes</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
    <span class=n>NtSetTimerResolution</span><span class=p>(</span><span class=n>ticks</span><span class=p>,</span> <span class=k>true</span><span class=p>,</span> <span class=k>ref</span> <span class=n>currentRes</span><span class=p>);</span>
    <span class=k>return</span> <span class=n>currentRes</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Now let&rsquo;s play a little bit with this class. First of all, we can write own <code>ClockRes</code> based on the described API:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=kt>var</span> <span class=n>resolutioInfo</span> <span class=p>=</span> <span class=n>WinApi</span><span class=p>.</span><span class=n>QueryTimerResolution</span><span class=p>();</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Min     = {resolutioInfo.Min}&#34;</span><span class=p>);</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Max     = {resolutioInfo.Max}&#34;</span><span class=p>);</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=s>$&#34;Current = {resolutioInfo.Current}&#34;</span><span class=p>);</span>
</code></pre></div><p>Output (without any running apps):</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>Min     = 156250
Max     = 5000
Current = 156250
</code></pre></div><p>Now, let&rsquo;s manually check that <code>resolutioInfo.Current</code> is the actual resolution of <code>DateTime</code>. Here is a very simple code which shows observed <code>DateTime</code> behaviour:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>10</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
<span class=p>{</span>
  <span class=kt>var</span> <span class=n>current</span> <span class=p>=</span> <span class=n>DateTime</span><span class=p>.</span><span class=n>UtcNow</span><span class=p>;</span>
  <span class=kt>var</span> <span class=n>last</span> <span class=p>=</span> <span class=n>current</span><span class=p>;</span>
  <span class=k>while</span> <span class=p>(</span><span class=n>last</span> <span class=p>==</span> <span class=n>current</span><span class=p>)</span>
    <span class=n>current</span> <span class=p>=</span> <span class=n>DateTime</span><span class=p>.</span><span class=n>UtcNow</span><span class=p>;</span>
  <span class=kt>var</span> <span class=n>diff</span> <span class=p>=</span> <span class=n>current</span> <span class=p>-</span> <span class=n>last</span><span class=p>;</span>
  <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>diff</span><span class=p>.</span><span class=n>Ticks</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Typical output:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>155934
156101
156237
156256
156237
</code></pre></div><p>As you can see, the received numbers are not exactly equal to <code>156250</code>. So, the difference between two sequential different <code>DateTime</code> values is approximately equal to the current timer interval.</p><h4 id=powercfg>powercfg</h4><p>For example, your current timer interval is not the maximum timer interval. How do you know who&rsquo;s to blame? Which program increased the system timer frequency? You can check it with the help of <a href=https://en.wikipedia.org/wiki/Powercfg>powercfg</a>. For example, run the following command as administrator:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>powercfg -energy duration 10
</code></pre></div><p>This command will monitor you system for 10 seconds and generate an html report (<code>energy-report.html</code> in the current directory) with a lot of useful information include information about Platform Timer Resolution:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>Platform Timer Resolution:Platform Timer Resolution
The default platform timer resolution is 15.6ms (15625000ns) and should be used whenever the system is idle.
If the timer resolution is increased, processor power management technologies may not be effective.
The timer resolution may be increased due to multimedia playback or graphical animations.
  Current Timer Resolution (100ns units) 5003 
  Maximum Timer Period (100ns units) 156250 

Platform Timer Resolution:Outstanding Timer Request
A program or service has requested a timer resolution smaller than the platform maximum timer resolution.
  Requested Period 5000 
  Requesting Process ID 6676 
  Requesting Process Path \Device\HarddiskVolume4\Users\akinshin\ConsoleApplication1.exe 

Platform Timer Resolution:Outstanding Timer Request
A program or service has requested a timer resolution smaller than the platform maximum timer resolution.
  Requested Period 10000 
  Requesting Process ID 10860 
  Requesting Process Path \Device\HarddiskVolume4\Program Files (x86)\Mozilla Firefox\firefox.exe 
</code></pre></div><p>As you can see, default interval is 15.6ms, Firefox requires 1.0ms interval, and <code>ConsoleApplication1.exe</code> in my home directory (which just call <code>WinApi.SetTimerResolution(5000)</code>) requires 0.5ms interval. <code>ConsoleApplication1.exe</code> won, now I have the maximal possible platform timer frequency.</p><h4 id=threadsleep>Thread.Sleep</h4><p>Ok, it sounds interesting, but why we should care about the system timer resolution?
Here I want to ask you a question: what the following call does?</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>1</span><span class=p>);</span>
</code></pre></div><p>Somebody can answer: it suspend the current thread for <code>1 ms</code>. Unfortunately, it&rsquo;s a wrong answer. The documentation <a href=https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx>states</a> the following:</p><blockquote><p>The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</p></blockquote><p>In fact, the elapsed time depends on system timer resolution. Let&rsquo;s write another naive benchmark (we don&rsquo;t need any accuracy here, we just want to show the <code>Sleep</code> behavior in a simple way; so, we don&rsquo;t need usual benchmarking routine here like a warmup, statistics, and so on):</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>5</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
<span class=p>{</span>
  <span class=kt>var</span> <span class=n>sw</span> <span class=p>=</span> <span class=n>Stopwatch</span><span class=p>.</span><span class=n>StartNew</span><span class=p>();</span>
  <span class=n>Thread</span><span class=p>.</span><span class=n>Sleep</span><span class=p>(</span><span class=m>1</span><span class=p>);</span>
  <span class=n>sw</span><span class=p>.</span><span class=n>Stop</span><span class=p>();</span>
  <span class=kt>var</span> <span class=n>time</span> <span class=p>=</span> <span class=n>sw</span><span class=p>.</span><span class=n>ElapsedTicks</span> <span class=p>*</span> <span class=m>1000.0</span> <span class=p>/</span> <span class=n>Stopwatch</span><span class=p>.</span><span class=n>Frequency</span><span class=p>;</span>
  <span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>time</span> <span class=p>+</span> <span class=s>&#34; ms&#34;</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Typical output (for current timer interval = <code>15.625ms</code>):</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>14.8772437280584 ms
15.5369201880125 ms
18.6300283418281 ms
15.5728431635545 ms
15.6129649284456 ms
</code></pre></div><p>As you can see, the elapsed intervals are much more than <code>1 ms</code>. Now, let&rsquo;s run Firefox (which sets the interval to <code>1ms</code>) and repeat our stupid benchmark:</p><div class=highlight><pre class=chroma><code class=language-txt data-lang=txt>1.72057056881932 ms
1.48123957592228 ms
1.47983997947259 ms
1.47237546507424 ms
1.49756820116866 ms
</code></pre></div><p>Firefox affected the <code>Sleep</code> call and reduced elapsed interval by ~ten times. You can find a good explanation of the <code>Sleep</code> behavior in <a href=http://www.windowstimestamp.com/description>The Windows Timestamp Project</a>:</p><blockquote><p>Say the <em>ActualResolution</em> is set to 156250, the interrupt heartbeat of the system will run at 15.625 ms periods or 64 Hz, and a call to Sleep is made with the desired delay of 1 ms. Two scenarios are to be looked at:</p><ul><li>The call was made &lt; 1ms (ΔT) ahead of the next interrupt. The next interrupt will not confirm that the desired period of time has expired. Only the following interrupt will cause the call to return. The resulting sleep delay will be ΔT + 15.625ms.</li><li>The call was made ≥ 1ms (ΔT) ahead of the next interrupt. The next interrupt will force the call to return. The resulting sleep delay will be ΔT.</li></ul></blockquote><p>There are many others <code>Sleep</code> “features”, but they are beyond the scope of this post. You can read another interesting read about the subject here: <a href=https://randomascii.wordpress.com/2013/04/02/sleep-variation-investigated/>Random ASCII: Sleep Variation Investigated (2013)</a></p><p>Of course, there are another Windows API which depends on the system timer resolution (e.g. <a href=https://msdn.microsoft.com/en-us/library/windows/desktop/ms687012.aspx>Waitable Timer </a>). We will not discuss this class in detail, I just want to recommend you once again to read this great text: <a href=http://www.windowstimestamp.com/description>The Windows Timestamp Project</a></p><hr><h4 id=linux>Linux</h4><p>As I mentioned before, on Linux, <code>DateTime.UtcNow</code> uses the <a href=http://man7.org/linux/man-pages/man2/gettimeofday.2.html>gettimeofday</a> function. There are a lot of interesting posts on the internet about how it&rsquo;s work (see the <a href=#links>Links</a> section), so I will not repeat them, I will just put some short summary here.</p><p><code>gettimeofday</code> allows you to get time in microseconds. Thus, <code>1us</code> is the minimal possible resolution. The actual resolution depends on linux version and hardware, but nowadays <code>1us</code> is also your actual resolution (this is not guaranteed). Internally it&rsquo;s usually based on a high-precision hardware timer and use <a href=https://lwn.net/Articles/446528/>vsyscall/vDSO</a> to reduce latency (you can find some asm code <a href=http://stackoverflow.com/a/7269039/184842>here</a>).</p><hr><h3 id=benchmarks>Benchmarks</h3><p>Let&rsquo;s write simple benchmarks with the help of <a href=https://github.com/PerfDotNet/BenchmarkDotNet>BenchmarkDotNet</a> (<em>v0.9.9</em>):</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=na>[ClrJob, CoreJob, MonoJob]</span>
<span class=k>public</span> <span class=k>class</span> <span class=nc>DateTimeBenchmarks</span>
<span class=p>{</span>
<span class=na>  [Benchmark]</span>
  <span class=k>public</span> <span class=kt>long</span> <span class=n>Latency</span><span class=p>()</span> <span class=p>=&gt;</span> <span class=n>DateTime</span><span class=p>.</span><span class=n>UtcNow</span><span class=p>.</span><span class=n>Ticks</span><span class=p>;</span>
<span class=na>
</span><span class=na>  [Benchmark]</span>
  <span class=k>public</span> <span class=kt>long</span> <span class=n>Resolution</span><span class=p>()</span>
  <span class=p>{</span>
    <span class=kt>long</span> <span class=n>lastTicks</span> <span class=p>=</span> <span class=n>DateTime</span><span class=p>.</span><span class=n>UtcNow</span><span class=p>.</span><span class=n>Ticks</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>DateTime</span><span class=p>.</span><span class=n>UtcNow</span><span class=p>.</span><span class=n>Ticks</span> <span class=p>==</span> <span class=n>lastTicks</span><span class=p>)</span>
    <span class=p>{</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=n>lastTicks</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h4 id=windows-1>Windows</h4><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=na>BenchmarkDotNet</span><span class=o>=</span><span class=s>v0.9.9.0</span>
<span class=na>OS</span><span class=o>=</span><span class=s>Microsoft Windows NT 6.2.9200.0 (Windows 10 anniversary update)</span>
<span class=na>Processor</span><span class=o>=</span><span class=s>Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8</span>
<span class=na>Frequency</span><span class=o>=</span><span class=s>2143473 ticks, Resolution=466.5326 ns, Timer=TSC</span>
<span class=na>CLR1</span><span class=o>=</span><span class=s>CORE, Arch=64-bit ? [RyuJIT]</span>
<span class=na>CLR2</span><span class=o>=</span><span class=s>MS.NET 4.0.30319.42000</span>
<span class=na>CLR3</span><span class=o>=</span><span class=s>Mono JIT compiler version 4.2.3</span>
<span class=na>JitModules</span><span class=o>=</span><span class=s>clrjit-v4.6.1586.0</span>
<span class=na>dotnet cli version: 1.0.0-preview2-003121</span>
</code></pre></div><p>Current Timer Interval = <code>15.625ms</code>:</p><table><thead><tr><th>Method</th><th>Runtime</th><th align=right>Median</th><th align=right>StdDev</th></tr></thead><tbody><tr><td>Latency</td><td>Clr</td><td align=right>7.0471 ns</td><td align=right>0.0342 ns</td></tr><tr><td>Resolution</td><td>Clr</td><td align=right>15,599,814.5300 ns</td><td align=right>2,754.4628 ns</td></tr><tr><td>Latency</td><td>Core</td><td align=right>7.0481 ns</td><td align=right>0.0367 ns</td></tr><tr><td>Resolution</td><td>Core</td><td align=right>15,597,438.1294 ns</td><td align=right>2,655.8045 ns</td></tr><tr><td>Latency</td><td>Mono</td><td align=right>30.4011 ns</td><td align=right>0.2043 ns</td></tr><tr><td>Resolution</td><td>Mono</td><td align=right>15,550,311.0491 ns</td><td align=right>6,562.2114 ns</td></tr></tbody></table><p>Current Timer Interval = <code>0.5ms</code> (running AIMP):</p><table><thead><tr><th>Method</th><th>Runtime</th><th align=right>Median</th><th align=right>StdDev</th></tr></thead><tbody><tr><td>Latency</td><td>Clr</td><td align=right>7.3655 ns</td><td align=right>0.1102 ns</td></tr><tr><td>Resolution</td><td>Clr</td><td align=right>499,666.4219 ns</td><td align=right>811.5021 ns</td></tr><tr><td>Latency</td><td>Core</td><td align=right>7.3545 ns</td><td align=right>0.0602 ns</td></tr><tr><td>Resolution</td><td>Core</td><td align=right>499,357.0707 ns</td><td align=right>1,021.2058 ns</td></tr><tr><td>Latency</td><td>Mono</td><td align=right>31.5868 ns</td><td align=right>0.2685 ns</td></tr><tr><td>Resolution</td><td>Mono</td><td align=right>499,696.0358 ns</td><td align=right>673.2927 ns</td></tr></tbody></table><h4 id=linux-1>Linux</h4><p>Xubuntu 16.04.01, the same hardware:</p><div class=highlight><pre class=chroma><code class=language-ini data-lang=ini><span class=na>BenchmarkDotNet</span><span class=o>=</span><span class=s>v0.9.9.0</span>
<span class=na>OS</span><span class=o>=</span><span class=s>Unix 4.4.0.34</span>
<span class=na>Processor</span><span class=o>=</span><span class=s>Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz, ProcessorCount=8</span>
<span class=na>CLR1</span><span class=o>=</span><span class=s>CORE, Arch=64-bit ? [RyuJIT]</span>
<span class=na>CLR2</span><span class=o>=</span><span class=s>Mono 4.4.2 (Stable 4.4.2.11/f72fe45 Fri Jul 29 09:58:49 UTC 2016), Arch=64-bit RELEASE</span>
<span class=na>dotnet cli version: 1.0.0-preview2-003121</span>
</code></pre></div><table><thead><tr><th>Method</th><th>Runtime</th><th align=right>Median</th><th align=right>StdDev</th></tr></thead><tbody><tr><td>Latency</td><td>Core</td><td align=right>27.2925 ns</td><td align=right>0.4665 ns</td></tr><tr><td>Resolution</td><td>Core</td><td align=right>1,000.7250 ns</td><td align=right>0.5176 ns</td></tr><tr><td>Latency</td><td>Mono</td><td align=right>26.6243 ns</td><td align=right>1.3973 ns</td></tr><tr><td>Resolution</td><td>Mono</td><td align=right>998.2508 ns</td><td align=right>1.4941 ns</td></tr></tbody></table><hr><h3 id=summary>Summary</h3><p>Now we know that the resolution and the latency of <code>DateTime</code> may be tricky. On Windows, the resolutions depend on Windows System Timer; it can be changed programmatically by any application. Usually, it&rsquo;s about <code>0.5 ms</code>..<code>15.625 ms</code>. On Linux, the resolution is typical <code>1 us</code>. However, the latency on Windows is usually several times smaller that the latency on Linux (but you should not care about it in most cases).</p><p>Typically, <code>DateTime</code> is a good choice when you want to know the current time (e.g. for logging) and you don&rsquo;t need high precision. However, beware of DateTime-specific phenomena (see <a href=http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time>Falsehoods programmers believe about time</a> and <a href=http://infiniteundo.com/post/25509354022/more-falsehoods-programmers-believe-about-time>More falsehoods programmers believe about time</a>). If you need to measure some time interval (not just put an approximate timestamp into a log file), you probably need a better tool. In the next post, I will tell about <code>Stopwatch</code>: how it&rsquo;s implemented, what the latency and the resolution of <code>Stopwatch</code>, how it works on different operating systems and runtimes, and why we should use <code>Stopwatch</code> on .NET, rather than alternative measurements tools.</p><hr><h3 id=links>Links</h3><h4 id=msdn>MSDN</h4><ul><li><a href=https://msdn.microsoft.com/library/system.datetime.aspx>MSDN: DateTime</a></li><li><a href=https://msdn.microsoft.com/library/system.datetime.utcnow.aspx>MSDN: DateTime.UtcNow</a></li><li><a href=https://msdn.microsoft.com/library/system.datetime.ticks.aspx>MSDN: DateTime.Ticks</a></li><li><a href=https://msdn.microsoft.com/library/system.datetime.aspx#Resolution>MSDN: DateTime — Resolution</a></li><li><a href=https://msdn.microsoft.com/library/windows/desktop/hh706895.aspx>MSDN: GetSystemTimePreciseAsFileTime</a></li><li><a href=https://msdn.microsoft.com/en-us/library/dd757624.aspx>MSDN: timeBeginPeriod</a></li><li><a href=https://msdn.microsoft.com/en-us/library/dd757626.aspx>MSDN: timeEndPeriod</a></li><li><a href=https://msdn.microsoft.com/library/windows/desktop/dn553408.aspx>MSDN: Acquiring high-resolution time stamps</a></li></ul><h4 id=sources>Sources</h4><ul><li><a href=http://referencesource.microsoft.com/#mscorlib/system/datetime.cs>ReferenceSource: system/datetime.cs</a></li><li><a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/mscorlib/src/System/DateTime.cs>coreclr-v1.0.0: mscorlib/src/System/DateTime.cs</a></li><li><a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/pal/src/file/filetime.cpp>coreclr-v1.0.0: pal/src/file/filetime.cpp</a></li><li><a href=https://github.com/dotnet/coreclr/blob/v1.0.0/src/classlibnative/bcltype/system.cpp#L48>coreclr-v1.0.0: classlibnative/bcltype/system.cpp</a></li><li><a href=https://github.com/mono/mono/blob/mono-4.4.2.11/mono/utils/mono-time.c>mono-4.4.2.11: mono-time.c</a></li><li><a href=https://github.com/mono/mono/blob/mono-4.4.2.11/mono/metadata/icall-def.h>mono-4.4.2.11: icall-def.h</a></li></ul><h4 id=useful-software>Useful software</h4><ul><li><a href=https://technet.microsoft.com/en-us/sysinternals/bb897568.aspx>ClockRes</a></li><li><a href=https://technet.microsoft.com/en-us/sysinternals/bb842062.aspx>Sysinternals Suite</a></li></ul><h4 id=misc>Misc</h4><ul><li><a href=http://www.windowstimestamp.com/description>The Windows Timestamp Project</a></li><li><a href=https://en.wikipedia.org/wiki/System_time>Wiki: System time</a></li><li><a href=http://man7.org/linux/man-pages/man2/gettimeofday.2.html>man7.org: gettimeofday(2)</a></li><li><a href=https://lwn.net/Articles/446528/>lwn.net: On vsyscalls and the vDSO</a></li><li><a href=http://tldp.org/HOWTO/Clock.html>The Clock Mini-HOWTO (2000)</a></li></ul><h4 id=blog-posts>Blog posts</h4><ul><li><a href=http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time>Infinite Undo!: Falsehoods programmers believe about time (2012)</a></li><li><a href=http://infiniteundo.com/post/25509354022/more-falsehoods-programmers-believe-about-time>Infinite Undo!: More falsehoods programmers believe about time (2012)</a></li><li><a href=https://randomascii.wordpress.com/2013/07/08/windows-timer-resolution-megawatts-wasted/>Random ASCII: Windows Timer Resolution: Megawatts Wasted (2013)</a></li><li><a href=https://randomascii.wordpress.com/2013/04/02/sleep-variation-investigated/>Random ASCII: Sleep Variation Investigated (2013)</a></li><li><a href=http://www.mathpirate.net/log/2010/03/20/temporal-mechanics-changing-the-speed-of-time-part-ii/>MathPirate: Temporal Mechanics: Changing the Speed of Time, Part II (2010)</a></li><li><a href=http://www.programgo.com/article/91674336979/>The accuracy of gettimeofday in ARM architecture</a></li></ul><h4 id=stackoverflow>StackOverflow</h4><ul><li><a href=http://stackoverflow.com/q/7685762/184842>StackOverflow: Windows 7 timing functions - How to use GetSystemTimeAdjustment correctly?</a></li><li><a href=http://stackoverflow.com/q/307582/184842>StackOverflow: How frequent is DateTime.Now updated?</a></li><li><a href=http://stackoverflow.com/q/37898579/184842>StackOverflow: How is the CLR faster than me when calling Windows API</a></li><li><a href=http://stackoverflow.com/q/13230719/184842>StackOverflow: How is the microsecond time of linux gettimeofday() obtained and what is its accuracy?</a></li><li><a href=http://stackoverflow.com/q/12392278/184842>StackOverflow: Measure time in Linux - time vs clock vs getrusage vs clock_gettime vs gettimeofday vs timespec_get?</a></li><li><a href=http://stackoverflow.com/q/7266813/184842>StackOverflow: Anyone can understand how gettimeofday works?</a></li><li><a href=http://stackoverflow.com/q/19938324/184842>StackOverflow: What are vdso and vsyscall?</a></li></ul><br><br><div class=row><div class="mx-auto share-block"><div class=share-title>Share:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fdatetime%2f&title=DateTime%20under%20the%20hood" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=DateTime%20under%20the%20hood&url=https%3a%2f%2faakinshin.net%2fposts%2fdatetime%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x"></i></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fdatetime%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=share-button><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fposts%2fdatetime%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=share-button><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fposts%2fdatetime%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fdatetime%2f&title=DateTime%20under%20the%20hood" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2020 Andrey Akinshin
|
<a href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a><a href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a><a href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.082780cb948cc57eabbc0d80172a7a5347d5572b599938b4c9876dfd7978b424.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script></body></html>