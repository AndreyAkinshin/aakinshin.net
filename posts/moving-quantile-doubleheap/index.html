<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Statistics,Quantile,Moving Quantile"><title>Fast implementation of the moving quantile based on the double heap | Andrey Akinshin</title><meta name=description content="The Hardle-Steiger method to estimate the moving median and its generalization for the moving quantiles"><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.882998740b9c4c24677576b997bde5a487246e2e3bd72128a0e922eaa59db029.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.50da8736f05b35aac9691de67fe993cbe01b7d88fcf0cb682c3a8f39933fe4a3.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.ae812fc71daf5160d927febda5a991cee6c361345e3f685d3736931ed7537986.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41419012-5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41419012-5');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-sm navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-posts href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-pdnb href=https://aakinshin.net/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class="blog-post table-sm"><h1 class=blog-post-title id=post-title>Fast implementation of the moving quantile based on the double heap</h1><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2020-12-29>December 29, 2020</time>
&nbsp;&nbsp;
<i class="fas fa-tag"></i>&nbsp;
<a href=https://aakinshin.net/tags/statistics/ class="badge badge-info">Statistics</a>
<a href=https://aakinshin.net/tags/quantile/ class="badge badge-info">Quantile</a>
<a href=https://aakinshin.net/tags/moving-quantile/ class="badge badge-info">Moving Quantile</a></span><br><br><p>Imagine you have a time series.
Let&rsquo;s say, after each new observation, you want to know an &ldquo;average&rdquo; value across the last <span class="math inline">\(L\)</span> observations.
Such a metric is known as <a href=https://en.wikipedia.org/wiki/Moving_average>a moving average</a>
(or rolling/running average).</p><p>The most popular moving average example is <a href=https://en.wikipedia.org/wiki/Moving_average#Simple_moving_average>the moving mean</a>.
It&rsquo;s easy to efficiently implement this metric.
However, it has a major drawback: it&rsquo;s not robust.
Outliers can easily spoil the moving mean and transform it into a meaningless and untrustable metric.</p><p>Fortunately, we have a good alternative: <a href=https://en.wikipedia.org/wiki/Moving_average#Moving_median>the moving median</a>.
Typically, it generates a stable and smooth series of values.
In the below figure, you can see the difference between the moving mean and the moving median on noisy data.</p><div class=row><div class=mx-auto><a href=/posts/moving-quantile-doubleheap/img/example-light.png target=_blank class=imgldlink alt=example><picture>
<source theme=dark srcset=/posts/moving-quantile-doubleheap/img/example-dark.png media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/moving-quantile-doubleheap/img/example-light.png media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=800 src=/posts/moving-quantile-doubleheap/img/example-light.png></picture></a></div></div><br><p>The moving median also has a drawback: it&rsquo;s not easy to efficiently implement it.
Today we going to discuss the Hardle-Steiger method to estimate the median
(memory: <span class="math inline">\(O(L)\)</span>, element processing complexity: <span class="math inline">\(O(log(L))\)</span>, median estimating complexity: <span class="math inline">\(O(1)\)</span>).
Also, we will learn how to calculate <em>the moving quantiles</em> based on this method.</p><p>In this post, you will find the following:</p><ul><li>An overview of the Hardle-Steiger method</li><li>A simple way to implement the Hardle-Steiger method</li><li>Moving quantiles inspired by the Hardle-Steiger method</li><li>How to process initial elements</li><li>Reference C# implementation</li></ul><h3 id=an-overview-of-the-hardle-steiger-method>An overview of the Hardle-Steiger method</h3><p>This method is described in <a href=#Hardle1995>[Hardle1995]</a>.
The core idea is based on a data structure that contains two joined <a href>heaps</a>:</p><div class=row><div class=mx-auto><a href=/posts/moving-quantile-doubleheap/img/double-heap.svg target=_blank alt=double-heap><img class="mx-auto d-block img-fluid" width=400 src=/posts/moving-quantile-doubleheap/img/double-heap.svg></a></div></div><br><p>In this figure, you see an example for <span class="math inline">\(L=21\)</span>.
It contains:</p><ul><li><span class="math inline">\(H_1 .. H_{10}\)</span>: min heap</li><li><span class="math inline">\(H_{-1} .. H_{-10}\)</span>: max heap</li><li><span class="math inline">\(H_0\)</span>: a node that joins two heaps</li></ul><p>The <span class="math inline">\(H\)</span> array contain the last <span class="math inline">\(L\)</span> elements of the time series and satisfy the following conditions:</p><ul><li><span class="math inline">\(\max(H_{-2i},\; H_{-2i-1}) \leq H_{-i} \leq H_0\)</span></li><li><span class="math inline">\(\min(H_{2i},\; H_{2i+1}) \geq H_{i} \geq H_0\)</span></li></ul><p>Thus, <span class="math inline">\(H_0\)</span> is
less than all elements in the upper heap (positive indexes) and
greater than all elements in the lower heap (negative indexes).
Since we have an equal number of elements in both heaps,
<span class="math inline">\(H_0\)</span> represents the median value.</p><p>That&rsquo;s all!
If we want to know the current value of the moving median, we should just take the value of <span class="math inline">\(H_0\)</span>.
The suggested algorithm has the following characteristics:</p><ul><li>Amount of memory: <span class="math inline">\(O(L)\)</span></li><li>Element processing complexity: <span class="math inline">\(O(log(L))\)</span></li><li>Median estimating complexity: <span class="math inline">\(O(1)\)</span></li></ul><p>Now we should learn how to invalidate this data structure for new observations.</p><h3 id=a-simple-way-to-implement-the-hardle-steiger-method>A simple way to implement the Hardle-Steiger method</h3><p>The most famous implementation of the Hardle-Steiger method is the <a href=http://svn.r-project.org/R/trunk/src/library/stats/src/Trunmed.c>Turlach implementation</a> in C.
It&rsquo;s used in the R&rsquo;s function <a href=https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/runmed>runmed</a>.
This implementation doesn&rsquo;t look simple, so it&rsquo;s not easy to replicate it using another language
(you can find a few StackOverflow discussion about this implementation
<a href=https://stackoverflow.com/q/1309263/184842>here</a> and <a href=https://stackoverflow.com/q/5527437/184842>here</a>).
So, I looked at the above picture and came up with my own way to implement this algorithm
(you can find a reference C# implementation at the end of this post).
It differs from the Turlach implementation and from the suggested approach in the original paper,
but it still uses the same idea.</p><p>We are going to keep three array with numbers:</p><ul><li><code>double[] h</code>: the elements of the double-heap</li><li><code>int[] heapToElementIndex</code>: returns the original element index for the given heap element</li><li><code>int[] elementToHeapIndex</code>: returns the heap index for the given element index</li></ul><p>The swap routine is trivial:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>private</span> <span class=k>void</span> <span class=n>Swap</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapIndex2</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>elementIndex1</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
    <span class=kt>int</span> <span class=n>elementIndex2</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>
    <span class=kt>double</span> <span class=n>value1</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
    <span class=kt>double</span> <span class=n>value2</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>

    <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>value2</span><span class=p>;</span>
    <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>value1</span><span class=p>;</span>
    <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex2</span><span class=p>;</span>
    <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex1</span><span class=p>;</span>
    <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex2</span><span class=p>;</span>
    <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex1</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>To simplify the calculations, we take all the element indexes by modulo <span class="math inline">\(L\)</span>.
Since we have exactly <span class="math inline">\(L\)</span> subsequent indexes at each moment,
there are no index collisions.</p><p>When we get a new element <code>x[i]</code>, we should replace the <code>h[i % L]</code> value by <code>x[i]</code>.
Next, we should do a series of swaps to repair the heap conditions.
In the classic heap implementation, we usually have two <code>Sift</code> methods: <code>SiftUp</code> and <code>SiftDown</code>.
To reduce the number of cases, we are going to implement a generic <code>Sift</code> routine according to the following scheme:</p><ul><li>Consider the current heap node and lower neighbor nodes.
If we have any lower neighbor nodes that are larger than the current node,
we swap the current node with the node that has the maximum value (across considered nodes).</li><li>Otherwise, we consider the current heap node and the upper neighbor nodes.
Repeat the previous step with an opposite sign.</li><li>If we swapped the current node with a lower or upper neighbor node,
we repeat two previous steps with the new node location.
Otherwise, we stop.</li></ul><p>This logic still have a lot of cases that should be handled,
but it&rsquo;s not so hard to implement it.
See the reference implementation at the end of this post for details.</p><h3 id=moving-quantiles-inspired-by-the-hardle-steiger-method>Moving quantiles inspired by the Hardle-Steiger method</h3><p>The original algorithm was designed only for the moving median.
Let&rsquo;s generalize it to calculate any moving quantile.</p><p>We can express the Hardle-Steiger method in terms of order statistics.
For the given odd <span class="math inline">\(L\)</span>, we can define <span class="math inline">\(k = (L-1)/2\)</span>.
The median element across the last <span class="math inline">\(L\)</span> numbers is the <span class="math inline">\((k+1)^\textrm{th}\)</span> smallest element (assuming one-base indexing).
<span class="math inline">\(H_0\)</span> is the request number because it&rsquo;s larger than all of the elements in the lower heap (which contains exactly <span class="math inline">\(k\)</span> elements) and smaller than all of the elements in the upper heap (which also contains <span class="math inline">\(k\)</span> elements).</p><p>Now let&rsquo;s change the heap sizes!
For any <span class="math inline">\(k \in [0; L-1]\)</span>, we can consider the lower heap of size <span class="math inline">\(k\)</span> and the upper heap of size <span class="math inline">\(L-k-1\)</span>.
In this case, <span class="math inline">\(H_0\)</span> will represent the <span class="math inline">\((k+1)^\textrm{th}\)</span> smallest element.
The <span class="math inline">\(p^\textrm{th}\)</span> quantile (<span class="math inline">\(p \in [0; 1]\)</span>) can be estimated as the <span class="math inline">\(\lfloor p(L-1) \rfloor^\textrm{th}\)</span> smallest element!
Note that now the window size can be an arbitrary positive number
(unlike the original approach which supports only odd <span class="math inline">\(L\)</span> values).</p><p>It looks simple, so I was surprised that I didn&rsquo;t manage to find this idea anywhere.
If you find any references where this approach is explained, please let me know.</p><h3 id=how-to-process-initial-elements>How to process initial elements</h3><p>Let&rsquo;s say that the windows size <span class="math inline">\(L=21\)</span>, we estimate the median <span class="math inline">\(k=10\)</span>,
but we are at the beginning of our time series, and we have only 13 elements.
What should we return?
There two possible strategies here:</p><ul><li><strong>Order Statistics</strong><br>Since the <span class="math inline">\(k^\textrm{th}\)</span> smallest element was requested, we should return it.
In the above example, it would be the <span class="math inline">\(10^\textrm{th}\)</span> smallest element from the 13 observed numbers.</li><li><strong>Quantile Approximation</strong><br>Since the median was requested, we should return it.
In the above example, it would be <span class="math inline">\(7^\textrm{th}\)</span> smallest element from the 13 observed numbers.</li></ul><p>Also, there are other strategies (e.g., repeating the first element).
However, in my opinion, other approaches don&rsquo;t satisfy the
<a href=https://en.wikipedia.org/wiki/Principle_of_least_astonishment>principle of least astonishment</a>,
so we are not going to discuss them.</p><p>The two presented strategy define the way of the heap initialization (how we process <span class="math inline">\(x[i]\)</span> for <span class="math inline">\(i < L\)</span>).
We start with two empty heaps.
Once we got the first element, we always put it into <span class="math inline">\(H_0\)</span>.
Next, we should add subsequent elements to the lower or upper heap depending on the chosen strategy:</p><ul><li><strong>Order Statistics</strong><br>We add elements to the lower heap until it&rsquo;s full.
After that, we add elements to the upper heap.</li><li><strong>Quantile Approximation</strong><br>We choose the lower or upper heap trying to keep the ratio
<span class="math inline">\(\textrm{LowerHeapSize} / (\textrm{LowerHeapSize} + \textrm{UpperHeapSize})\)</span>
close to the target quantile.</li></ul><h3 id=reference-c-implementation>Reference C# implementation</h3><p>Below you can find a full C# implementation of the moving quantile according to the above approach.
You can also use it with
the latest nightly version (0.3.0-nightly.81+) of <a href=https://github.com/AndreyAkinshin/perfolizer>Perfolizer</a>
(you need <code>DoubleHeapMovingQuantileEstimator</code>).</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=c1>/// &lt;summary&gt;
</span><span class=c1>/// A moving selector based on a double heap data structure.
</span><span class=c1>/// Memory: O(windowSize).
</span><span class=c1>/// Add complexity: O(log(windowSize)).
</span><span class=c1>/// GetValue complexity: O(1).
</span><span class=c1>/// 
</span><span class=c1>/// &lt;remarks&gt;
</span><span class=c1>/// Based on the following paper:
</span><span class=c1>/// Hardle, W., and William Steiger. &#34;Algorithm AS 296: Optimal median smoothing.&#34; Journal of the Royal Statistical Society.
</span><span class=c1>/// Series C (Applied Statistics) 44, no. 2 (1995): 258-264.
</span><span class=c1>/// &lt;/remarks&gt;
</span><span class=c1>/// &lt;/summary&gt;
</span><span class=c1></span><span class=k>public</span> <span class=k>class</span> <span class=nc>DoubleHeapMovingQuantileEstimator</span>
<span class=p>{</span>
    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span> <span class=n>windowSize</span><span class=p>,</span> <span class=n>k</span><span class=p>;</span>
    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>double</span><span class=p>[]</span> <span class=n>h</span><span class=p>;</span>
    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>heapToElementIndex</span><span class=p>;</span>
    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>elementToHeapIndex</span><span class=p>;</span>
    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span> <span class=n>rootHeapIndex</span><span class=p>,</span> <span class=n>lowerHeapMaxSize</span><span class=p>;</span>
    <span class=k>private</span> <span class=k>readonly</span> <span class=n>MovingQuantileEstimatorInitStrategy</span> <span class=n>initStrategy</span><span class=p>;</span>
    <span class=k>private</span> <span class=kt>int</span> <span class=n>upperHeapSize</span><span class=p>,</span> <span class=n>lowerHeapSize</span><span class=p>,</span> <span class=n>totalElementCount</span><span class=p>;</span>

    <span class=k>public</span> <span class=n>DoubleHeapMovingQuantileEstimator</span><span class=p>(</span><span class=kt>int</span> <span class=n>windowSize</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span>
        <span class=n>MovingQuantileEstimatorInitStrategy</span> <span class=n>initStrategy</span> <span class=p>=</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>QuantileApproximation</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>this</span><span class=p>.</span><span class=n>windowSize</span> <span class=p>=</span> <span class=n>windowSize</span><span class=p>;</span>
        <span class=k>this</span><span class=p>.</span><span class=n>k</span> <span class=p>=</span> <span class=n>k</span><span class=p>;</span>
        <span class=n>h</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>double</span><span class=p>[</span><span class=n>windowSize</span><span class=p>];</span>
        <span class=n>heapToElementIndex</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>windowSize</span><span class=p>];</span>
        <span class=n>elementToHeapIndex</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>windowSize</span><span class=p>];</span>

        <span class=n>lowerHeapMaxSize</span> <span class=p>=</span> <span class=n>k</span><span class=p>;</span>
        <span class=k>this</span><span class=p>.</span><span class=n>initStrategy</span> <span class=p>=</span> <span class=n>initStrategy</span><span class=p>;</span>
        <span class=n>rootHeapIndex</span> <span class=p>=</span> <span class=n>k</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>private</span> <span class=k>void</span> <span class=n>Swap</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapIndex2</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=kt>int</span> <span class=n>elementIndex1</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
        <span class=kt>int</span> <span class=n>elementIndex2</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>
        <span class=kt>double</span> <span class=n>value1</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
        <span class=kt>double</span> <span class=n>value2</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>

        <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>value2</span><span class=p>;</span>
        <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>value1</span><span class=p>;</span>
        <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex2</span><span class=p>;</span>
        <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex1</span><span class=p>;</span>
        <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex2</span><span class=p>;</span>
        <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=k>private</span> <span class=k>void</span> <span class=n>Sift</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=kt>int</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapCurrentIndex</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapChildIndex1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapChildIndex2</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isUpperHeap</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=kt>bool</span> <span class=n>hasChild1</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>-</span> <span class=n>lowerHeapSize</span> <span class=p>&lt;=</span> <span class=n>heapChildIndex1</span> <span class=p>&amp;&amp;</span> <span class=n>heapChildIndex1</span> <span class=p>&lt;=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=n>upperHeapSize</span><span class=p>;</span>
            <span class=kt>bool</span> <span class=n>hasChild2</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>-</span> <span class=n>lowerHeapSize</span> <span class=p>&lt;=</span> <span class=n>heapChildIndex2</span> <span class=p>&amp;&amp;</span> <span class=n>heapChildIndex2</span> <span class=p>&lt;=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=n>upperHeapSize</span><span class=p>;</span>

            <span class=k>if</span> <span class=p>(!</span><span class=n>hasChild1</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>hasChild2</span><span class=p>)</span>
                <span class=k>return</span> <span class=n>heapCurrentIndex</span><span class=p>;</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>hasChild1</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>hasChild2</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpperHeap</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=n>isUpperHeap</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=n>Swap</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapChildIndex1</span><span class=p>);</span>
                    <span class=k>return</span> <span class=n>heapChildIndex1</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=k>return</span> <span class=n>heapCurrentIndex</span><span class=p>;</span>
            <span class=p>}</span>

            <span class=k>if</span> <span class=p>(</span><span class=n>hasChild1</span> <span class=p>&amp;&amp;</span> <span class=n>hasChild2</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=k>if</span> <span class=p>((</span><span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>])</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpperHeap</span> <span class=p>||</span>
                    <span class=p>(</span><span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>])</span> <span class=p>&amp;&amp;</span> <span class=n>isUpperHeap</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=kt>int</span> <span class=n>heapChildIndex0</span> <span class=p>=</span>
                        <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpperHeap</span> <span class=p>||</span>
                        <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=n>isUpperHeap</span>
                            <span class=p>?</span> <span class=n>heapChildIndex1</span>
                            <span class=p>:</span> <span class=n>heapChildIndex2</span><span class=p>;</span>
                    <span class=n>Swap</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapChildIndex0</span><span class=p>);</span>
                    <span class=k>return</span> <span class=n>heapChildIndex0</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=k>return</span> <span class=n>heapCurrentIndex</span><span class=p>;</span>
            <span class=p>}</span>

            <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>();</span>
        <span class=p>}</span>

        <span class=k>while</span> <span class=p>(</span><span class=k>true</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>!=</span> <span class=n>rootHeapIndex</span><span class=p>)</span>
            <span class=p>{</span>
                <span class=kt>bool</span> <span class=n>isUpHeap</span> <span class=p>=</span> <span class=n>heapIndex</span> <span class=p>&gt;</span> <span class=n>rootHeapIndex</span><span class=p>;</span>
                <span class=kt>int</span> <span class=n>heapParentIndex</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>)</span> <span class=p>/</span> <span class=m>2</span><span class=p>;</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>h</span><span class=p>[</span><span class=n>heapParentIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpHeap</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapParentIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=n>isUpHeap</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=n>Swap</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapParentIndex</span><span class=p>);</span>
                    <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>heapParentIndex</span><span class=p>;</span>
                    <span class=k>continue</span><span class=p>;</span>
                <span class=p>}</span>
                <span class=k>else</span>
                <span class=p>{</span>
                    <span class=kt>int</span> <span class=n>heapChildIndex1</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>)</span> <span class=p>*</span> <span class=m>2</span><span class=p>;</span>
                    <span class=kt>int</span> <span class=n>heapChildIndex2</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>)</span> <span class=p>*</span> <span class=m>2</span> <span class=p>+</span> <span class=n>Math</span><span class=p>.</span><span class=n>Sign</span><span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>);</span>
                    <span class=kt>int</span> <span class=n>newHeapIndex</span> <span class=p>=</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapChildIndex1</span><span class=p>,</span> <span class=n>heapChildIndex2</span><span class=p>,</span> <span class=n>isUpHeap</span><span class=p>);</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>newHeapIndex</span> <span class=p>!=</span> <span class=n>heapIndex</span><span class=p>)</span>
                    <span class=p>{</span>
                        <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>newHeapIndex</span><span class=p>;</span>
                        <span class=k>continue</span><span class=p>;</span>
                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>}</span>
            <span class=k>else</span> <span class=c1>// heapIndex == rootHeapIndex
</span><span class=c1></span>            <span class=p>{</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>lowerHeapSize</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=kt>int</span> <span class=n>newHeapIndex</span> <span class=p>=</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapIndex</span> <span class=p>-</span> <span class=m>1</span><span class=p>,</span> <span class=p>-</span><span class=m>1</span><span class=p>,</span> <span class=k>false</span><span class=p>);</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>newHeapIndex</span> <span class=p>!=</span> <span class=n>heapIndex</span><span class=p>)</span>
                    <span class=p>{</span>
                        <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>newHeapIndex</span><span class=p>;</span>
                        <span class=k>continue</span><span class=p>;</span>
                    <span class=p>}</span>
                <span class=p>}</span>

                <span class=k>if</span> <span class=p>(</span><span class=n>upperHeapSize</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=kt>int</span> <span class=n>newHeapIndex</span> <span class=p>=</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapIndex</span> <span class=p>+</span> <span class=m>1</span><span class=p>,</span> <span class=p>-</span><span class=m>1</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>
                    <span class=k>if</span> <span class=p>(</span><span class=n>newHeapIndex</span> <span class=p>!=</span> <span class=n>heapIndex</span><span class=p>)</span>
                    <span class=p>{</span>
                        <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>newHeapIndex</span><span class=p>;</span>
                        <span class=k>continue</span><span class=p>;</span>
                    <span class=p>}</span>
                <span class=p>}</span>
            <span class=p>}</span>

            <span class=k>break</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=k>void</span> <span class=n>Add</span><span class=p>(</span><span class=kt>double</span> <span class=k>value</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=kt>int</span> <span class=n>elementIndex</span> <span class=p>=</span> <span class=n>totalElementCount</span> <span class=p>%</span> <span class=n>windowSize</span><span class=p>;</span>

        <span class=kt>int</span> <span class=n>Insert</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>=</span> <span class=k>value</span><span class=p>;</span>
            <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex</span><span class=p>;</span>
            <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex</span><span class=p>;</span>
            <span class=k>return</span> <span class=n>heapIndex</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>totalElementCount</span><span class=p>++</span> <span class=p>&lt;</span> <span class=n>windowSize</span><span class=p>)</span> <span class=c1>// Heap is not full
</span><span class=c1></span>        <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>totalElementCount</span> <span class=p>==</span> <span class=m>1</span><span class=p>)</span> <span class=c1>// First element
</span><span class=c1></span>            <span class=p>{</span>
                <span class=n>Insert</span><span class=p>(</span><span class=n>rootHeapIndex</span><span class=p>);</span>
            <span class=p>}</span>
            <span class=k>else</span>
            <span class=p>{</span>
                <span class=kt>bool</span> <span class=n>quantileApproximationCondition</span> <span class=p>=</span>
                    <span class=n>initStrategy</span> <span class=p>==</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>QuantileApproximation</span> <span class=p>&amp;&amp;</span>
                    <span class=n>lowerHeapSize</span> <span class=p>&lt;</span> <span class=n>k</span> <span class=p>*</span> <span class=n>totalElementCount</span> <span class=p>/</span> <span class=n>windowSize</span> <span class=p>||</span>
                    <span class=n>initStrategy</span> <span class=p>==</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>OrderStatistics</span><span class=p>;</span>
                <span class=k>if</span> <span class=p>(</span><span class=n>lowerHeapSize</span> <span class=p>&lt;</span> <span class=n>lowerHeapMaxSize</span> <span class=p>&amp;&amp;</span> <span class=n>quantileApproximationCondition</span><span class=p>)</span>
                <span class=p>{</span>
                    <span class=n>lowerHeapSize</span><span class=p>++;</span>
                    <span class=kt>int</span> <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>rootHeapIndex</span> <span class=p>-</span> <span class=n>lowerHeapSize</span><span class=p>);</span>
                    <span class=n>Sift</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
                <span class=p>}</span>
                <span class=k>else</span>
                <span class=p>{</span>
                    <span class=n>upperHeapSize</span><span class=p>++;</span>
                    <span class=kt>int</span> <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=n>upperHeapSize</span><span class=p>);</span>
                    <span class=n>Sift</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
                <span class=p>}</span>
            <span class=p>}</span>
        <span class=p>}</span>
        <span class=k>else</span>
        <span class=p>{</span>
            <span class=c1>// Replace old element
</span><span class=c1></span>            <span class=kt>int</span> <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex</span><span class=p>];</span>
            <span class=n>Insert</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
            <span class=n>Sift</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
        <span class=p>}</span>
    <span class=p>}</span>

    <span class=k>public</span> <span class=kt>double</span> <span class=n>GetQuantile</span><span class=p>()</span>
    <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>totalElementCount</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfRangeException</span><span class=p>(</span><span class=s>&#34;There are no any values&#34;</span><span class=p>);</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>initStrategy</span> <span class=p>==</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>OrderStatistics</span> <span class=p>&amp;&amp;</span> <span class=n>k</span> <span class=p>&gt;=</span> <span class=n>totalElementCount</span><span class=p>)</span>
            <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfRangeException</span><span class=p>(</span><span class=s>$&#34;Not enough values (n = {totalElementCount}, k = {k})&#34;</span><span class=p>);</span>
        <span class=k>return</span> <span class=n>h</span><span class=p>[</span><span class=n>rootHeapIndex</span><span class=p>];</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=c1>/// &lt;summary&gt;
</span><span class=c1>/// Defines how a moving quantile estimator calculates the target quantile value
</span><span class=c1>/// when the total number of elements is less than the window size
</span><span class=c1>/// &lt;/summary&gt;
</span><span class=c1></span><span class=k>public</span> <span class=k>enum</span> <span class=n>MovingQuantileEstimatorInitStrategy</span>
<span class=p>{</span>
    <span class=c1>/// &lt;summary&gt;
</span><span class=c1></span>    <span class=c1>/// Approximate the target quantile.
</span><span class=c1></span>    <span class=c1>///
</span><span class=c1></span>    <span class=c1>/// &lt;example&gt;
</span><span class=c1></span>    <span class=c1>/// windowSize = 5, k = 2 (the median)
</span><span class=c1></span>    <span class=c1>/// If the total number of elements equals 3, the median (k = 1) will be returned 
</span><span class=c1></span>    <span class=c1>/// &lt;/example&gt; 
</span><span class=c1></span>    <span class=c1>/// &lt;/summary&gt;
</span><span class=c1></span>    <span class=n>QuantileApproximation</span><span class=p>,</span>

    <span class=c1>/// &lt;summary&gt;
</span><span class=c1></span>    <span class=c1>/// Return the requested order statistics
</span><span class=c1></span>    <span class=c1>///
</span><span class=c1></span>    <span class=c1>/// &lt;example&gt;
</span><span class=c1></span>    <span class=c1>/// windowSize = 5, k = 2
</span><span class=c1></span>    <span class=c1>/// If the total number of elements equals 3, the largest element (k = 2) will be returned 
</span><span class=c1></span>    <span class=c1>/// &lt;/example&gt; 
</span><span class=c1></span>    <span class=c1>/// &lt;/summary&gt;
</span><span class=c1></span>    <span class=n>OrderStatistics</span>
<span class=p>}</span>
</code></pre></div><h3 id=conclusion>Conclusion</h3><p>In this post, we discussed the Hardle-Steiger method to estimate the moving median.
Also, we built a generalization of this method to estimate any moving quantile.
This approach is useful in monitoring
when you want to get the average value of your time series using only recent elements.
It&rsquo;s optimal in terms of performance and memory footprint for medium-size windows.
In future blog posts, I will show other approaches that estimate the moving quantile
(that are optimal for small-size and big-size windows).</p><h3 id=references>References</h3><ul><li><b id=Hardle1995>[Hardle1995]</b><br>Hardle, W., and William Steiger. &ldquo;Algorithm AS 296: Optimal median smoothing.&rdquo; Journal of the Royal Statistical Society. Series C (Applied Statistics) 44, no. 2 (1995): 258-264.</li><li><a href=https://stackoverflow.com/q/1309263/184842>StackOverflow: Rolling median algorithm in C</a></li><li><a href=https://stackoverflow.com/q/5527437/184842>StackOverflow: Rolling median in C - Turlach implementation</a></li></ul><br><br><div class=row><div class="mx-auto share-block"><div class=share-title>Share:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fmoving-quantile-doubleheap%2f&title=Fast%20implementation%20of%20the%20moving%20quantile%20based%20on%20the%20double%20heap" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=Fast%20implementation%20of%20the%20moving%20quantile%20based%20on%20the%20double%20heap&url=https%3a%2f%2faakinshin.net%2fposts%2fmoving-quantile-doubleheap%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x"></i></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fmoving-quantile-doubleheap%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=share-button><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fposts%2fmoving-quantile-doubleheap%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=share-button><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fposts%2fmoving-quantile-doubleheap%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fmoving-quantile-doubleheap%2f&title=Fast%20implementation%20of%20the%20moving%20quantile%20based%20on%20the%20double%20heap" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2020 Andrey Akinshin
|
<a href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a><a href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a><a href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.082780cb948cc57eabbc0d80172a7a5347d5572b599938b4c9876dfd7978b424.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true,},options:{skipHtmlTags:['script','noscript','style','textarea','pre'],ignoreHtmlClass:'tex2jax_ignore',processHtmlClass:'tex2jax_process'}};</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>