<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.123.7"><meta name=author content='Andrey Akinshin'><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content='Mathematics,Statistics,Research,Density estimation,Discrete distributions,Ties,Jittering'><title>How to build a smooth density estimation for a discrete sample using jittering | Andrey Akinshin</title>
<meta name=description content="A simple technique that removes ties from samples without noticeable changes in density"><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.d6826f88345af20c0769a313557ec1355465a3091b1f9869b936f2504c4dfe26.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body class="flex flex-col min-h-screen"><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-2 xs:px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/posts/>Posts</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/research/>Research</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/library/>Library</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/about/>About</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/search/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#magnifying-glass"/></svg></a></div></div><button id=theme-toggle type=button title="Alt+Click to match OS color theme" class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6 flex-grow"><div class=main-post><h1 class=blog-post-title id=post-title>How to build a smooth density estimation for a discrete sample using jittering</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai text-accent-l dark:text-front-d"><title>Date</title><use xlink:href="/img/fa/all.svg#calendar-days"/></svg>
<time datetime=2021-04-20>April 20, 2021</time><svg class="fai ml-3 text-accent-l dark:text-front-d"><title>Tags</title><use xlink:href="/img/fa/all.svg#tag"/></svg><div class="flex flex-wrap gap-y-1"><a class=label-link href=https://aakinshin.net/tags/mathematics/><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#math"/></svg>
Mathematics
</a><a class=label-link href=https://aakinshin.net/tags/statistics/><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#statistics"/></svg>
Statistics
</a><a class=label-link href=https://aakinshin.net/tags/research/>Research
</a><a class=label-link href=https://aakinshin.net/tags/density-estimation/>Density estimation
</a><a class=label-link href=https://aakinshin.net/tags/discrete-distributions/>Discrete distributions
</a><a class=label-link href=https://aakinshin.net/tags/ties/>Ties
</a><a class=label-link href=https://aakinshin.net/tags/jittering/>Jittering</a></div></div><br><div class=main-content><p>Let&rsquo;s say you have a sample with tied values.
If you draw a kernel density estimation (KDE) for such a sample,
you may get a serrated pattern like this:</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/discrete-sample-jittering/img/intro-light.png target=_blank alt=intro><img src=/posts/discrete-sample-jittering/img/intro-light.png width=800>
</a><a class="img-dark hidden" href=/posts/discrete-sample-jittering/img/intro-dark.png target=_blank alt=intro><img src=/posts/discrete-sample-jittering/img/intro-dark.png width=800></a></div><p>KDE requires samples from continuous distributions
while tied values arise in discrete or mixture distributions.
Even if the original distribution is continuous,
you may observe artificial sample discretization due to a limited resolution of the measuring tool.
This effect may lead to distorted density plots like in the above picture.</p><p>The problem could be solved using a nice technique called <em>jittering</em>.
In the simplest case, jittering just adds random noise to each measurement.
Such a trick removes all ties from the sample and allows building a smooth density estimation.</p><p>However, there are many different ways to apply jittering.
The trickiest question here is how to choose proper noise values.
In this post, I want to share one of my favorite jittering approaches.
It generates a non-randomized noise pattern with a low risk of noticeable sample corruption.</p><h3 id=the-problem>The problem</h3><p>Let me show a small real-life example that illustrates the problem.
Imagine you collect some duration measurements, most of which are between 0 and 100 milliseconds.
You don&rsquo;t need excellent accuracy, so it&rsquo;s OK to round all observations to integer values.
Despite the continuous nature of time, you come up with a discrete sample.
If the sample size is &ldquo;not-so-big,&rdquo; the corresponding kernel density estimation may look pretty smooth:</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/discrete-sample-jittering/img/problem1-light.png target=_blank alt=problem1><img src=/posts/discrete-sample-jittering/img/problem1-light.png width=800>
</a><a class="img-dark hidden" href=/posts/discrete-sample-jittering/img/problem1-dark.png target=_blank alt=problem1><img src=/posts/discrete-sample-jittering/img/problem1-dark.png width=800></a></div><p>However, if you continue to collect more measurements,
the KDE &ldquo;will be able to guess&rdquo; that the non-integer values are not allowed in this sample.
Thus, the density between observed integer measurements should be zero.
It gives us the serrated pattern:</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/discrete-sample-jittering/img/problem2-light.png target=_blank alt=problem2><img src=/posts/discrete-sample-jittering/img/problem2-light.png width=800>
</a><a class="img-dark hidden" href=/posts/discrete-sample-jittering/img/problem2-dark.png target=_blank alt=problem2><img src=/posts/discrete-sample-jittering/img/problem2-dark.png width=800></a></div><p>You can also find a more detailed discussion about this problem in my <a href=https://aakinshin.net/posts/kde-discrete/>previous post</a>.</p><h3 id=random-jittering>Random jittering</h3><p>One of the easiest ways to resolve the problem is to add random noise to each sample element.
In simple cases, you can use the normal distribution to generate noise values.
If we apply this simple trick to the sample from the first picture,
it will instantly make the KDE plot smooth:</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/discrete-sample-jittering/img/comparison-light.png target=_blank alt=comparison><img src=/posts/discrete-sample-jittering/img/comparison-light.png width=800>
</a><a class="img-dark hidden" href=/posts/discrete-sample-jittering/img/comparison-dark.png target=_blank alt=comparison><img src=/posts/discrete-sample-jittering/img/comparison-dark.png width=800></a></div><p>If you are interested in a formal definition of the jittering kernel density estimator or a literature overview,
it&rsquo;s recommended to read <a href=/posts/discrete-sample-jittering/#Nagler2018>[Nagler2018]</a>.</p><h3 id=my-noise-pattern-preferences>My noise pattern preferences</h3><p>There are many different ways to introduce a noise pattern.
The normal or uniform distributions may be reasonable choices for simple single-shot experiments.
Note that you would need to tweak parameters for a while to get a reasonable density estimation in some cases.
Jittering is always a trade-off between two states:</p><ul><li>The noise is too small (the serrated pattern is not fixed, jittering had no effect)</li><li>The noise is too large (density estimation is inaccurate because the sample is corrupted)</li></ul><p>If we want to find a proper balance between these states, we should define requirements for the noise pattern
that improve our chances to get a nice density estimation.
I didn&rsquo;t find any bulletproof guidance on how to build a good noise distribution.
So, I came up with my own list of rules that I use during jittering to form the noise pattern:</p><ul><li><strong>Use stable noise pattern instead of random values</strong><br>One of the main goals of the density estimation is to discover the true distribution nature
based on a set of random measurements.
This goal is about <em>removing</em> the randomness, not <em>increasing</em> it.
Whenever it&rsquo;s possible, I prefer to avoid using additional random values.
It&rsquo;s better to define a fixed noise pattern in advance based on the configuration of the tied values.</li><li><strong>Modify only tied values</strong><br>One may experience a temptation to add noise to each sample element.
This approach is quite simple to implement because there is no need to actually detect ties.
However, the primary intention of jittering is to only eliminate ties from the sample.
What the point of modifying non-tied values?
It would just reduce the accuracy of the final density estimation.
I prefer to detect all groups of tied values and don&rsquo;t touch the other values.</li><li><strong>Maintain noise range within discretization step</strong><br>It&rsquo;s important to pay attention to the minimum and maximum noise values.
In the case of extreme noise values (which may happen if you generate noise based on the normal distribution),
one may corrupt the sample and reduce the reliability of the density estimation.
It&rsquo;s better to detect the discretization step and ensure that all noise values fit within a narrow band.
In the simplest case, we could define the discretization step as the minimum positive difference
between consequent order statistics.
In more complicated cases, the discretization step could be defined adaptively based on neighbor values.</li><li><strong>Preserve sample range</strong><br>If jittering spoils the minimum and the maximum value of the sample, it may introduce problems.
Let&rsquo;s say we work with the
<a href=https://aakinshin.net/posts/kde-discrete/#pdf-and-mixed-distributions>rectified Gaussian distribution</a>.
In this case, we probably have a lot of tied values that equal exactly zero.
If we add negative noise to some of the tied values, we will get negative sample values.
It will be a violation of the sample invariant for the rectified Gaussian distribution.
To avoid such a situation, it&rsquo;s better to preserve the minimum and the maximum value.</li><li><strong>Ensure high density near the original value</strong><br>Without jittering, the density estimation should probably use
<a href=https://en.wikipedia.org/wiki/Dirac_delta_function>the Dirac delta function</a> to express tied values.
With a smoother approximation, it should look like a sharp peak.
Sometimes, this peak is explained not by artificial discretization but by other distribution features.
For the rectified Gaussian distribution, the location of this peak is exactly zero.
If we add non-negative random noise to the tied zero values, in this case,
we may introduce a bias for this peak.
For example, the biased peak location may become 0.2 instead of 0.0, which distorts the density shape.
Whenever it&rsquo;s possible, I prefer preserving the peak location.</li></ul><p>Now let me show an example of such noise patterns that satisfy all of the above requirements.</p><h3 id=noise-pattern-example>Noise pattern example</h3><p>We are going to introduce an independent noise pattern for each group of tied values.
Let&rsquo;s say our sample contains $k$ tied values that equal $x^*$.
Let $l$ be the number of sample values lower than $x^*$, and $r$ be the number of sample values higher than $x^*$.
For the given $l$ and $r$,
we could define a beta distribution $\textrm{Beta}(\alpha, \beta)$ with the following $\alpha$ and $\beta$:</p>$$
\alpha = \frac{9l+r}{l+r}, \quad \beta = \frac{l+9r}{l+r}.
$$<p>This distributions satisfy the following properties:</p><ul><li>$\alpha + \beta = 10$</li><li>The mode of this distribution is always $l / (l + r)$.</li></ul><p>Here are examples of the corresponding density plots:</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/discrete-sample-jittering/img/noise-patterns-light.png target=_blank alt=noise-patterns><img src=/posts/discrete-sample-jittering/img/noise-patterns-light.png width=800>
</a><a class="img-dark hidden" href=/posts/discrete-sample-jittering/img/noise-patterns-dark.png target=_blank alt=noise-patterns><img src=/posts/discrete-sample-jittering/img/noise-patterns-dark.png width=800></a></div><p>Now let&rsquo;s define $k$ uniformly distributed numbers $p_i$ on $[0;1]$:</p>$$
p_i = i / (k + 1), \quad i = 1, \ldots, k.
$$<p>Let $p_0$ be equal to $p_i$ that is nearest to the mode value $l / (l + r)$.
If $Q(p)$ is the quantile function of $\textrm{Beta}(\alpha, \beta)$,
we could introduce the following noise vector:</p>$$
\xi_i = Q(p_i) - Q(p_0), \quad i = 1, \ldots, k.
$$<p>Now we could rescale the noise vector according to the discretization step and define jittered values $\hat{x}_i$:</p>$$
\hat{x}_i = x^* + s \cdot \xi_i
$$<p>where $s$ is the scale constant.
Based on my local experiments, I assume that $s = 1.5$ is usually enough to get a smooth approximation.</p><p>The above equation may look confusing, but they satisfy the requirements from the previous section.
Let me show a few examples (for this table, $s = 1.0$):</p><table><thead><tr><th align=right>$k$</th><th align=right>$l$</th><th align=right>$r$</th><th align=right>$\xi_i$</th></tr></thead><tbody><tr><td align=right>$1$</td><td align=right>$1$</td><td align=right>$1$</td><td align=right>$\{ 0.000 \} $</td></tr><tr><td align=right>$3$</td><td align=right>$1$</td><td align=right>$1$</td><td align=right>$\{ -0.108,\; 0.000,\; 0.108 \} $</td></tr><tr><td align=right>$5$</td><td align=right>$1$</td><td align=right>$1$</td><td align=right>$\{ -0.153,\; -0.069,\; 0.000,\; 0.069,\; 0.153 \} $</td></tr><tr><td align=right>$4$</td><td align=right>$5$</td><td align=right>$0$</td><td align=right>$\{-0.139,\; -0.072,\; -0.031,\; 0.000 \} $</td></tr><tr><td align=right>$4$</td><td align=right>$0$</td><td align=right>$5$</td><td align=right>$\{0.000,\; 0.031,\; 0.072,\; 0.139 \} $</td></tr></tbody></table><p>Thus, the suggested approach
preserves the sample range,
provides small bias,
and returns consistent non-randomized values.
In addition, one of the noise vector components is always zero (which is a lovely property for manual sample exploration).
The noise range can be controlled via the scale constant $s$.</p><p>Let&rsquo;s look at a few examples.
Here is two kernel density estimations (normal kernel, Sheather & Jones bandwidth selector)
for a sample of size 1000 from the binomial distribution $\textrm{B}(n = 30, p = 0.2)$
without and with jittering ($s = 1.5$):</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/discrete-sample-jittering/img/jittering-demo1-light.png target=_blank alt=jittering-demo1><img src=/posts/discrete-sample-jittering/img/jittering-demo1-light.png width=800>
</a><a class="img-dark hidden" href=/posts/discrete-sample-jittering/img/jittering-demo1-dark.png target=_blank alt=jittering-demo1><img src=/posts/discrete-sample-jittering/img/jittering-demo1-dark.png width=800></a></div><p>As you can see, the jittered version is much smoother.
The suggested approach works nicely with multimodal distribution as well.
Here is another two KDEs for a mixture of
a sample of size 1000 from $\textrm{B}(n = 20, p = 0.2)$ and
a sample of size 1000 from $\textrm{B}(n = 20, p = 0.8)$:</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/discrete-sample-jittering/img/jittering-demo2-light.png target=_blank alt=jittering-demo2><img src=/posts/discrete-sample-jittering/img/jittering-demo2-light.png width=800>
</a><a class="img-dark hidden" href=/posts/discrete-sample-jittering/img/jittering-demo2-dark.png target=_blank alt=jittering-demo2><img src=/posts/discrete-sample-jittering/img/jittering-demo2-dark.png width=800></a></div><h3 id=conclusion>Conclusion</h3><p>Jittering is an excellent technique that allows getting smooth density estimations for discrete samples.
In this post, I described an example of a non-randomized noise pattern with a low risk of noticeable sample corruption.</p><h3 id=references>References</h3><ul><li><b id=Nagler2018>[Nagler2018]</b><br>Nagler, Thomas.
&ldquo;A generic approach to nonparametric function estimation with mixed data.&rdquo;
Statistics & Probability Letters 137 (2018): 326-330.<br><a href=https://doi.org/10.1016/j.spl.2018.02.040>https://doi.org/10.1016/j.spl.2018.02.040</a><br><a href=https://arxiv.org/pdf/1704.07457.pdf>https://arxiv.org/pdf/1704.07457.pdf</a></li></ul></div><hr><h3 id=references>References (2)</h3><ol><li><a href=https://aakinshin.net/posts/ title="Library / posts"><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#note"/></svg>
</a><a href=https://aakinshin.net/posts/kde-discrete/>Kernel density estimation and discrete values
</a>(2021-04-13)
<span class=label title=References:2><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#reference"/></svg>2</span>
<span class=label title=Backlinks:3><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#backlink"/></svg>3</span>
<a href=https://aakinshin.net/tags/mathematics/><svg class="rating-icon"><title>Mathematics</title><use xlink:href="/img/fa/all.svg#math"/></svg>
</a><a href=https://aakinshin.net/tags/statistics/><svg class="rating-icon"><title>Statistics</title><use xlink:href="/img/fa/all.svg#statistics"/></svg></a></li></ol><h3 id=backlinks>Backlinks (1)</h3><ol><li><a href=https://aakinshin.net/posts/ title="Library / posts"><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#note"/></svg>
</a><a href=https://aakinshin.net/posts/discrete-performance-distributions/>Discrete performance distributions
</a>(2021-06-15)
<span class=label title=References:4><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#reference"/></svg>4</span>
<span class=label title=Backlinks:5><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#backlink"/></svg>5</span>
<a href=https://aakinshin.net/tags/mathematics/><svg class="rating-icon"><title>Mathematics</title><use xlink:href="/img/fa/all.svg#math"/></svg>
</a><a href=https://aakinshin.net/tags/statistics/><svg class="rating-icon"><title>Statistics</title><use xlink:href="/img/fa/all.svg#statistics"/></svg></a></li></ol></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}));function toggleTheme(e){e?(document.documentElement.classList.add("dark"),themeToggleLightIcon.classList.remove("hidden"),themeToggleDarkIcon.classList.add("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")}),imagesLight.forEach(e=>{e.classList.add("hidden")})):(document.documentElement.classList.remove("dark"),themeToggleDarkIcon.classList.remove("hidden"),themeToggleLightIcon.classList.add("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}),imagesDark.forEach(e=>{e.classList.add("hidden")}))}themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),event.altKey?(localStorage.removeItem("color-theme"),toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches)):localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{if(localStorage.getItem("color-theme")===null){const t=e.matches?"dark":"light";toggleTheme(t==="dark")}})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2024 <span class=whitespace-nowrap>Andrey Akinshin</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"],ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+=" has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></body></html>