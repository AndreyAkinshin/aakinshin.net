<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.103.0-DEV"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Mathematics,Statistics,Change point detection"><title>Implementation of efficient algorithm for changepoint detection: ED-PELT | Andrey Akinshin</title><meta name=description content="Changepoint detection is an important task that has a lot of applications. For example, I use it to detect changes in the Rider performance test suite. It&..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script src=https://cdn.tailwindcss.com/3.2.4></script>
<script>tailwind.config={darkMode:"class"}</script><style type=text/tailwindcss>
    @layer base {
       
      body {
        @apply bg-white dark:bg-zinc-800;
        @apply text-black dark:text-gray-400;
      }
      nav {
        @apply bg-sky-800 dark:bg-zinc-900;
      }
      a {
        @apply text-sky-600 dark:text-white;
        @apply no-underline;
      }
      .main-content a:not(.label-link) {
        @apply hover:underline;
      }
      hr {
        @apply h-px my-3 border-0 bg-gray-300 dark:bg-gray-600;
      }
      h1, h2, h3, h4, h5, h6 {
        @apply leading-tight;
      }
      h1, h2, h3 {
        @apply text-4xl py-4;
      }
      h4 {
        @apply text-3xl py-3;
      }
      h5, h6 {
        @apply text-2xl py-2;
      }
      table {
        @apply border self-center mx-auto;
      }
      th, td {
        @apply border p-2
      }
      blockquote {
        @apply border-l-8 border-gray-300 bg-gray-100 dark:border-zinc-600 dark:bg-zinc-700;
        @apply ml-4 my-4 px-4 py-2;
      }
       
      .main ul {
        @apply list-disc ml-10 my-2;
      }
      .main ol {
        @apply list-decimal ml-10 my-2;
      }
      .main p {
        @apply mb-3;
      }
       
      .label {
        @apply mx-1 px-1 py-0.5 whitespace-nowrap;
        @apply rounded border border-gray-400 dark:border-gray-500;
      }
      .label-link {
        @apply mx-1 px-1 py-0.5 whitespace-nowrap;
        @apply rounded border border-sky-600 dark:border-slate-400;
        @apply hover:bg-sky-200 dark:hover:bg-gray-500;
      }
      .nav-item {
        @apply text-white hover:bg-sky-700 dark:hover:bg-gray-700;
      }
       
      .paginator {
        @apply flex flex-wrap justify-center mb-4;
      }
      .paginator .page-item {
        @apply inline-flex border rounded px-3 py-1;
      }
      .paginator .page-item:not(.active):not(.disabled) {
        @apply border-gray-400 dark:border-gray-400;
      }
      .paginator .page-item.active {
        @apply border-sky-600 dark:border-white;
      }
      .paginator .page-item.disabled {
        @apply bg-gray-50 dark:bg-gray-500 dark:border-gray-400;
      }
      .paginator .page-item.disabled a {
        @apply text-gray-400 dark:text-gray-400;
      }
       
      .block-example {
        @apply my-4 pl-3;
        @apply border-l-8 border-gray-300 dark:border-zinc-600;
      }
       
      #about img {
        @apply inline-flex h-4;
      }
       
      .fai {
        @apply inline-flex h-[1.2em] w-[1.2em] pr-[0.4em] fill-current;
      }
      .fai-link {
        @apply hover:text-sky-400 dark:hover:text-blue-400;
      }
      .label-link .fai {
        @apply pl-1 pb-1 h-[1.5em] w-[1.5em];
      }
       
      .chroma {
        @apply my-5 overflow-y-scroll;
        @apply p-1 border rounded;
      }
    }
  </style><style>.block-example-title::before{counter-increment:example;content:"Example " counter(example)}body{counter-reset:example}code.has-jax{-webkit-font-smoothing:antialiased;background:inherit!important;border:none!important;font-size:100%}*:hover>.anchorjs-link{margin-left:-1.125em!important}.chroma{background-color:#fff}.chroma .x{}.chroma .err{color:#a61717;background-color:#e3d2d2}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#000;font-weight:700}.chroma .kc{color:#000;font-weight:700}.chroma .kd{color:#000;font-weight:700}.chroma .kn{color:#000;font-weight:700}.chroma .kp{color:#000;font-weight:700}.chroma .kr{color:#000;font-weight:700}.chroma .kt{color:#458;font-weight:700}.chroma .n{}.chroma .na{color:teal}.chroma .nb{color:#0086b3}.chroma .bp{color:#999}.chroma .nc{color:#458;font-weight:700}.chroma .no{color:teal}.chroma .nd{color:#3c5d5d;font-weight:700}.chroma .ni{color:purple}.chroma .ne{color:#900;font-weight:700}.chroma .nf{color:#900;font-weight:700}.chroma .fm{}.chroma .nl{color:#900;font-weight:700}.chroma .nn{color:#555}.chroma .nx{}.chroma .py{}.chroma .nt{color:navy}.chroma .nv{color:teal}.chroma .vc{color:teal}.chroma .vg{color:teal}.chroma .vi{color:teal}.chroma .vm{}.chroma .l{}.chroma .ld{}.chroma .s{color:#d14}.chroma .sa{color:#d14}.chroma .sb{color:#d14}.chroma .sc{color:#d14}.chroma .dl{color:#d14}.chroma .sd{color:#d14}.chroma .s2{color:#d14}.chroma .se{color:#d14}.chroma .sh{color:#d14}.chroma .si{color:#d14}.chroma .sx{color:#d14}.chroma .sr{color:#009926}.chroma .s1{color:#d14}.chroma .ss{color:#990073}.chroma .m{color:#099}.chroma .mb{color:#099}.chroma .mf{color:#099}.chroma .mh{color:#099}.chroma .mi{color:#099}.chroma .il{color:#099}.chroma .mo{color:#099}.chroma .o{color:#000;font-weight:700}.chroma .ow{color:#000;font-weight:700}.chroma .p{}.chroma .c{color:#998;font-style:italic}.chroma .ch{color:#998;font-style:italic}.chroma .cm{color:#998;font-style:italic}.chroma .c1{color:#998;font-style:italic}.chroma .cs{color:#999;font-weight:700;font-style:italic}.chroma .cp{color:#999;font-weight:700;font-style:italic}.chroma .cpf{color:#999;font-weight:700;font-style:italic}.chroma .g{}.chroma .gd{color:#000;background-color:#fdd}.chroma .ge{color:#000;font-style:italic}.chroma .gr{color:#a00}.chroma .gh{color:#999}.chroma .gi{color:#000;background-color:#dfd}.chroma .go{color:#888}.chroma .gp{color:#555}.chroma .gs{font-weight:700}.chroma .gu{color:#aaa}.chroma .gt{color:#a00}.chroma .gl{text-decoration:underline}.chroma .w{color:#bbb}.dark.chroma{color:#f8f8f2;background-color:#272822}.dark .chroma{color:#f8f8f2;background-color:#272822}.dark .chroma .x{}.dark .chroma .err{color:#960050;background-color:#1e0010}.dark .chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.dark .chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.dark .chroma .hl{display:block;width:100%;background-color:#ffc}.dark .chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.dark .chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.dark .chroma .k{color:#66d9ef}.dark .chroma .kc{color:#66d9ef}.dark .chroma .kd{color:#66d9ef}.dark .chroma .kn{color:#f92672}.dark .chroma .kp{color:#66d9ef}.dark .chroma .kr{color:#66d9ef}.dark .chroma .kt{color:#66d9ef}.dark .chroma .n{}.dark .chroma .na{color:#a6e22e}.dark .chroma .nb{}.dark .chroma .bp{}.dark .chroma .nc{color:#a6e22e}.dark .chroma .no{color:#66d9ef}.dark .chroma .nd{color:#a6e22e}.dark .chroma .ni{}.dark .chroma .ne{color:#a6e22e}.dark .chroma .nf{color:#a6e22e}.dark .chroma .fm{}.dark .chroma .nl{}.dark .chroma .nn{}.dark .chroma .nx{color:#a6e22e}.dark .chroma .py{}.dark .chroma .nt{color:#f92672}.dark .chroma .nv{}.dark .chroma .vc{}.dark .chroma .vg{}.dark .chroma .vi{}.dark .chroma .vm{}.dark .chroma .l{color:#ae81ff}.dark .chroma .ld{color:#e6db74}.dark .chroma .s{color:#e6db74}.dark .chroma .sa{color:#e6db74}.dark .chroma .sb{color:#e6db74}.dark .chroma .sc{color:#e6db74}.dark .chroma .dl{color:#e6db74}.dark .chroma .sd{color:#e6db74}.dark .chroma .s2{color:#e6db74}.dark .chroma .se{color:#ae81ff}.dark .chroma .sh{color:#e6db74}.dark .chroma .si{color:#e6db74}.dark .chroma .sx{color:#e6db74}.dark .chroma .sr{color:#e6db74}.dark .chroma .s1{color:#e6db74}.dark .chroma .ss{color:#e6db74}.dark .chroma .m{color:#ae81ff}.dark .chroma .mb{color:#ae81ff}.dark .chroma .mf{color:#ae81ff}.dark .chroma .mh{color:#ae81ff}.dark .chroma .mi{color:#ae81ff}.dark .chroma .il{color:#ae81ff}.dark .chroma .mo{color:#ae81ff}.dark .chroma .o{color:#f92672}.dark .chroma .ow{color:#f92672}.dark .chroma .p{}.dark .chroma .c{color:#75715e}.dark .chroma .ch{color:#75715e}.dark .chroma .cm{color:#75715e}.dark .chroma .c1{color:#75715e}.dark .chroma .cs{color:#75715e}.dark .chroma .cp{color:#75715e}.dark .chroma .cpf{color:#75715e}.dark .chroma .g{}.dark .chroma .gd{color:#f92672}.dark .chroma .ge{font-style:italic}.dark .chroma .gr{}.dark .chroma .gh{}.dark .chroma .gi{color:#a6e22e}.dark .chroma .go{}.dark .chroma .gp{}.dark .chroma .gs{font-weight:700}.dark .chroma .gu{color:#75715e}.dark .chroma .gt{}.dark .chroma .gl{}.dark .chroma .w{}</style><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/><svg class="fai w-6 h-6"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/posts/>Posts</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/about/>About</a></div></div><button id=theme-toggle type=button class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><div class=main-post><h1 class=blog-post-title id=post-title>Implementation of efficient algorithm for changepoint detection: ED-PELT</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai"><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2019-10-07>October 7, 2019</time><svg class="fai ml-3"><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/tags/mathematics/>Mathematics</a>
<a class=label-link href=https://aakinshin.net/tags/statistics/>Statistics</a>
<a class=label-link href=https://aakinshin.net/tags/cpd/>Change point detection</a></div><br><div class=main-content><p><a href=https://en.wikipedia.org/wiki/Change_detection>Changepoint detection</a> is an important task that has a lot of applications.
For example, I use it to detect changes in the <a href=https://www.jetbrains.com/rider/>Rider</a> performance test suite.
It&rsquo;s very important to detect not only performance degradations, but any kinds of performance changes
(e.g., the variance may increase, or a unimodal distribution may be split to several modes).
You can see examples of such changes on the following picture (we change the color when a changepoint is detected):</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/edpelt/img/edpelt-light.png target=_blank alt=edpelt><img src=/posts/edpelt/img/edpelt-light.png width=800></a>
<a class="img-dark hidden" href=/posts/edpelt/img/edpelt-dark.png target=_blank alt=edpelt><img src=/posts/edpelt/img/edpelt-dark.png width=800></a></div><p>Unfortunately, it&rsquo;s pretty hard to write a reliable and fast algorithm for changepoint detection.
Recently, I found a cool paper (<a href=https://link.springer.com/article/10.1007/s11222-016-9687-5>Haynes, K., Fearnhead, P. & Eckley, I.A. &ldquo;A computationally efficient nonparametric approach for changepoint detection,&rdquo; Stat Comput (2017) 27: 1293</a>) that describes the ED-PELT algorithm.
It has <code>O(N*log(N))</code> complexity and pretty good detection accuracy.
The reference implementation can be used via the <a href=https://cran.r-project.org/web/packages/changepoint.np/index.html>changepoint.np</a> R package.
However, I can&rsquo;t use <a href=https://www.r-project.org/>R</a> on our build server, so I decided to write my own C# implementation.</p><p>This implementation resolves the following problems:</p><ul><li><strong>Portability</strong><br>Below you can find a C# class which you can just copy-paste to your solution and play with it
(you don&rsquo;t have to install any NuGet packages and add other kinds of dependencies).
If you are using another programming language, it should be pretty easy to port this code
(let me know if you write another implementation, I will add it to this blog post).
I tried to comment all the important steps, so you can understand what&rsquo;s going on under the hood
(it&rsquo;s highly recommended to read the original paper first)
and customize the algorithm for your own needs.</li><li><strong>Performance</strong><br>Performance is one of the most important features of this algorithm.
I tried to make it as efficient as possible (keeping the code readability).
With the help of some simple optimizations, I got a C# implementation that works much faster than the original R package
(even though the ED-PELT core implementation in this package was written in C).</li><li><strong>Better default parameters</strong><br>The algorithm has a parameter called <code>nquantiles</code>.
The paper recommends to use <code>4 * log(n)</code> as the default value, but the <code>changepoint.np</code> always use <code>nquantiles = 10</code>.
It leads to unreliable results for huge and small n values.
When <code>n &lt; 10</code>, <code>changepoint.np</code> works incorrectly,
a PR with a bug fix can be found <a href=https://github.com/AndrewC1998/changepoint-new/pull/1>here</a>.
When <code>n >> 100</code>, <code>nquantiles = 10</code> may be not enough to detect changes in multimodal distributions.
All the examples in the <a href=https://cran.r-project.org/web/packages/changepoint.np/changepoint.np.pdf>official documentation</a>
override the default value with <code>4 * log(n)</code>, but it&rsquo;s not very convenient to do it each time.</li></ul><p>The ED-PELT algorithm will be available out of the box in the next version of <a href=https://github.com/dotnet/BenchmarkDotNet>BenchmarkDotNet</a>,
but you can check it right now using the below implementation.
I&rsquo;m still not happy with the detection quality in some corner cases, so I&rsquo;m going to improve it in the future.
If you also have some problems with the presented implementation, let me know (my contacts can be found <a href=/about/>here</a>).</p><h3 id=ed-pelt-implementation>ED-PELT implementation</h3><p>The actual version of the algorithm is available in <a href=https://gist.github.com/AndreyAkinshin/17c2211a8f0eee090670b80221f11761>this gist</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=c1>// Copyright (c) 2019 Andrey Akinshin</span>
</span></span><span class=line><span class=cl><span class=c1>// Licensed under The MIT License https://opensource.org/licenses/MIT</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>System</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Collections.Generic</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=nn>System.Linq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The ED-PELT algorithm for changepoint detection.</span>
</span></span><span class=line><span class=cl><span class=c1>///</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;remarks&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// The implementation is based on the following papers:</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;list type=&#34;bullet&#34;&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;item&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;b&gt;[Haynes2017]&lt;/b&gt; Haynes, Kaylea, Paul Fearnhead, and Idris A. Eckley.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &#34;A computationally efficient nonparametric approach for changepoint detection.&#34;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Statistics and Computing 27, no. 5 (2017): 1293-1305.</span>
</span></span><span class=line><span class=cl><span class=cs>/// https://doi.org/10.1007/s11222-016-9687-5</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/item&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;item&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;b&gt;[Killick2012]&lt;/b&gt; Killick, Rebecca, Paul Fearnhead, and Idris A. Eckley.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &#34;Optimal detection of changepoints with a linear computational cost.&#34;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Journal of the American Statistical Association 107, no. 500 (2012): 1590-1598.</span>
</span></span><span class=line><span class=cl><span class=cs>/// https://arxiv.org/pdf/1101.1438.pdf</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/item&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/list&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/remarks&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>EdPeltChangePointDetector</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>static</span> <span class=k>readonly</span> <span class=n>EdPeltChangePointDetector</span> <span class=n>Instance</span> <span class=p>=</span> <span class=k>new</span> <span class=n>EdPeltChangePointDetector</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// For given array of `double` values, detects locations of changepoints that</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// splits original series of values into &#34;statistically homogeneous&#34; segments.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Such points correspond to moments when statistical properties of the distribution are changing.</span>
</span></span><span class=line><span class=cl>    <span class=c1>///</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// This method supports nonparametric distributions and has O(N*log(N)) algorithmic complexity.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;param name=&#34;data&#34;&gt;An array of double values&lt;/param&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;param name=&#34;minDistance&#34;&gt;Minimum distance between changepoints&lt;/param&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Returns an `int[]` array with 0-based indexes of changepoint.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Changepoints correspond to the end of the detected segments.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// For example, changepoints for { 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2 } are { 5, 11 }.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/returns&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>GetChangePointIndexes</span><span class=p>(</span><span class=kt>double</span><span class=p>[]</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>minDistance</span> <span class=p>=</span> <span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// We will use `n` as the number of elements in the `data` array</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=p>=</span> <span class=n>data</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Checking corner cases</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=p>&lt;=</span> <span class=m>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=m>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>minDistance</span> <span class=p>&lt;</span> <span class=m>1</span> <span class=p>||</span> <span class=n>minDistance</span> <span class=p>&gt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>ArgumentOutOfRangeException</span><span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=n>nameof</span><span class=p>(</span><span class=n>minDistance</span><span class=p>),</span><span class=s>$&#34;{minDistance} should be in range from 1 to data.Length&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// The penalty which we add to the final cost for each additional changepoint</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Here we use the Modified Bayesian Information Criterion</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>penalty</span> <span class=p>=</span> <span class=m>3</span> <span class=p>*</span> <span class=n>Math</span><span class=p>.</span><span class=n>Log</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// `k` is the number of quantiles that we use to approximate an integral during the segment cost evaluation</span>
</span></span><span class=line><span class=cl>        <span class=c1>// We use `k=Ceiling(4*log(n))` as suggested in the Section 4.3 &#34;Choice of K in ED-PELT&#34; in [Haynes2017]</span>
</span></span><span class=line><span class=cl>        <span class=c1>// `k` can&#39;t be greater than `n`, so we should always use the `Min` function here (important for n &lt;= 8)</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>k</span> <span class=p>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>Min</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>Math</span><span class=p>.</span><span class=n>Ceiling</span><span class=p>(</span><span class=m>4</span> <span class=p>*</span> <span class=n>Math</span><span class=p>.</span><span class=n>Log</span><span class=p>(</span><span class=n>n</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We should precalculate sums for empirical CDF, it will allow fast evaluating of the segment cost</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>partialSums</span> <span class=p>=</span> <span class=n>GetPartialSums</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Since we use the same values of `partialSums`, `k`, `n` all the time,</span>
</span></span><span class=line><span class=cl>        <span class=c1>// we introduce a shortcut `Cost(tau1, tau2)` for segment cost evaluation.</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Hereinafter, we use `tau` to name variables that are changepoint candidates.</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>Cost</span><span class=p>(</span><span class=kt>int</span> <span class=n>tau1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>tau2</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>GetSegmentCost</span><span class=p>(</span><span class=n>partialSums</span><span class=p>,</span> <span class=n>tau1</span><span class=p>,</span> <span class=n>tau2</span><span class=p>,</span> <span class=n>k</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We will use dynamic programming to find the best solution; `bestCost` is the cost array.</span>
</span></span><span class=line><span class=cl>        <span class=c1>// `bestCost[i]` is the cost for subarray `data[0..i-1]`.</span>
</span></span><span class=line><span class=cl>        <span class=c1>// It&#39;s a 1-based array (`data[0]`..`data[n-1]` correspond to `bestCost[1]`..`bestCost[n]`)</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>bestCost</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>double</span><span class=p>[</span><span class=n>n</span> <span class=p>+</span> <span class=m>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>bestCost</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>=</span> <span class=p>-</span><span class=n>penalty</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>currentTau</span> <span class=p>=</span> <span class=n>minDistance</span><span class=p>;</span> <span class=n>currentTau</span> <span class=p>&lt;</span> <span class=m>2</span> <span class=p>*</span> <span class=n>minDistance</span><span class=p>;</span> <span class=n>currentTau</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>            <span class=n>bestCost</span><span class=p>[</span><span class=n>currentTau</span><span class=p>]</span> <span class=p>=</span> <span class=n>Cost</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>currentTau</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// `previousChangePointIndex` is an array of references to previous changepoints. If the current segment ends at</span>
</span></span><span class=line><span class=cl>        <span class=c1>// the position `i`, the previous segment ends at the position `previousChangePointIndex[i]`. It&#39;s a 1-based</span>
</span></span><span class=line><span class=cl>        <span class=c1>// array (`data[0]`..`data[n-1]` correspond to the `previousChangePointIndex[1]`..`previousChangePointIndex[n]`)</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>previousChangePointIndex</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>n</span> <span class=p>+</span> <span class=m>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We use PELT (Pruned Exact Linear Time) approach which means that instead of enumerating all possible previous</span>
</span></span><span class=line><span class=cl>        <span class=c1>// tau values, we use a whitelist of &#34;good&#34; tau values that can be used in the optimal solution. If we are 100%</span>
</span></span><span class=line><span class=cl>        <span class=c1>// sure that some of the tau values will not help us to form the optimal solution, such values should be</span>
</span></span><span class=line><span class=cl>        <span class=c1>// removed. See [Killick2012] for details.</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>previousTaus</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;(</span><span class=n>n</span> <span class=p>+</span> <span class=m>1</span><span class=p>)</span> <span class=p>{</span> <span class=m>0</span><span class=p>,</span> <span class=n>minDistance</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>costForPreviousTau</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>double</span><span class=p>&gt;(</span><span class=n>n</span> <span class=p>+</span> <span class=m>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Following the dynamic programming approach, we enumerate all tau positions. For each `currentTau`, we pretend</span>
</span></span><span class=line><span class=cl>        <span class=c1>// that it&#39;s the end of the last segment and trying to find the end of the previous segment.</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>currentTau</span> <span class=p>=</span> <span class=m>2</span> <span class=p>*</span> <span class=n>minDistance</span><span class=p>;</span> <span class=n>currentTau</span> <span class=p>&lt;</span> <span class=n>n</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span> <span class=n>currentTau</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// For each previous tau, we should calculate the cost of taking this tau as the end of the previous</span>
</span></span><span class=line><span class=cl>            <span class=c1>// segment. This cost equals the cost for the `previousTau` plus cost of the new segment (from `previousTau`</span>
</span></span><span class=line><span class=cl>            <span class=c1>// to `currentTau`) plus penalty for the new changepoint.</span>
</span></span><span class=line><span class=cl>            <span class=n>costForPreviousTau</span><span class=p>.</span><span class=n>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>foreach</span> <span class=p>(</span><span class=kt>int</span> <span class=n>previousTau</span> <span class=k>in</span> <span class=n>previousTaus</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>costForPreviousTau</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>bestCost</span><span class=p>[</span><span class=n>previousTau</span><span class=p>]</span> <span class=p>+</span> <span class=n>Cost</span><span class=p>(</span><span class=n>previousTau</span><span class=p>,</span> <span class=n>currentTau</span><span class=p>)</span> <span class=p>+</span> <span class=n>penalty</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// Now we should choose the tau that provides the minimum possible cost.</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>bestPreviousTauIndex</span> <span class=p>=</span> <span class=n>WhichMin</span><span class=p>(</span><span class=n>costForPreviousTau</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>bestCost</span><span class=p>[</span><span class=n>currentTau</span><span class=p>]</span> <span class=p>=</span> <span class=n>costForPreviousTau</span><span class=p>[</span><span class=n>bestPreviousTauIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>previousChangePointIndex</span><span class=p>[</span><span class=n>currentTau</span><span class=p>]</span> <span class=p>=</span> <span class=n>previousTaus</span><span class=p>[</span><span class=n>bestPreviousTauIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// Prune phase: we remove &#34;useless&#34; tau values that will not help to achieve minimum cost in the future</span>
</span></span><span class=line><span class=cl>            <span class=kt>double</span> <span class=n>currentBestCost</span> <span class=p>=</span> <span class=n>bestCost</span><span class=p>[</span><span class=n>currentTau</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>newPreviousTausSize</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>previousTaus</span><span class=p>.</span><span class=n>Count</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>costForPreviousTau</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>currentBestCost</span> <span class=p>+</span> <span class=n>penalty</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>previousTaus</span><span class=p>[</span><span class=n>newPreviousTausSize</span><span class=p>++]</span> <span class=p>=</span> <span class=n>previousTaus</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>previousTaus</span><span class=p>.</span><span class=n>RemoveRange</span><span class=p>(</span><span class=n>newPreviousTausSize</span><span class=p>,</span> <span class=n>previousTaus</span><span class=p>.</span><span class=n>Count</span> <span class=p>-</span> <span class=n>newPreviousTausSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// We add a new tau value that is located on the `minDistance` distance from the next `currentTau` value</span>
</span></span><span class=line><span class=cl>            <span class=n>previousTaus</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>currentTau</span> <span class=p>-</span> <span class=p>(</span><span class=n>minDistance</span> <span class=p>-</span> <span class=m>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Here we collect the result list of changepoint indexes `changePointIndexes` using `previousChangePointIndex`</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>changePointIndexes</span> <span class=p>=</span> <span class=k>new</span> <span class=n>List</span><span class=p>&lt;</span><span class=kt>int</span><span class=p>&gt;();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>currentIndex</span> <span class=p>=</span> <span class=n>previousChangePointIndex</span><span class=p>[</span><span class=n>n</span><span class=p>];</span> <span class=c1>// The index of the end of the last segment is `n`</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>currentIndex</span> <span class=p>!=</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>changePointIndexes</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>currentIndex</span> <span class=p>-</span> <span class=m>1</span><span class=p>);</span> <span class=c1>// 1-based indexes should be be transformed to 0-based indexes</span>
</span></span><span class=line><span class=cl>            <span class=n>currentIndex</span> <span class=p>=</span> <span class=n>previousChangePointIndex</span><span class=p>[</span><span class=n>currentIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>changePointIndexes</span><span class=p>.</span><span class=n>Reverse</span><span class=p>();</span> <span class=c1>// The result changepoints should be sorted in ascending order.</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>changePointIndexes</span><span class=p>.</span><span class=n>ToArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Partial sums for empirical CDF (formula (2.1) from Section 2.1 &#34;Model&#34; in [Haynes2017])</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;code&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// partialSums[i, tau] = (count(data[j] &amp;lt; t) * 2 + count(data[j] == t) * 1) for j=0..tau-1</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// where t is the i-th quantile value (see Section 3.1 &#34;Discrete approximation&#34; in [Haynes2017] for details)</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/code&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;remarks&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;list type=&#34;bullet&#34;&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;item&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// We use doubled sum values in order to use &lt;c&gt;int[,]&lt;/c&gt; instead of &lt;c&gt;double[,]&lt;/c&gt; (it provides noticeable</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// performance boost). Thus, multipliers for &lt;c&gt;count(data[j] &amp;lt; t)&lt;/c&gt; and &lt;c&gt;count(data[j] == t)&lt;/c&gt; are</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// 2 and 1 instead of 1 and 0.5 from the [Haynes2017].</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/item&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;item&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Note that these quantiles are not uniformly distributed: tails of the &lt;c&gt;data&lt;/c&gt; distribution contain more</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// quantile values than the center of the distribution</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/item&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/list&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/remarks&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>static</span> <span class=kt>int</span><span class=p>[,]</span> <span class=n>GetPartialSums</span><span class=p>(</span><span class=kt>double</span><span class=p>[]</span> <span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=p>=</span> <span class=n>data</span><span class=p>.</span><span class=n>Length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>partialSums</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>k</span><span class=p>,</span> <span class=n>n</span> <span class=p>+</span> <span class=m>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>sortedData</span> <span class=p>=</span> <span class=n>data</span><span class=p>.</span><span class=n>OrderBy</span><span class=p>(</span><span class=n>it</span> <span class=p>=&gt;</span> <span class=n>it</span><span class=p>).</span><span class=n>ToArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>k</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>double</span> <span class=n>z</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span> <span class=p>+</span> <span class=p>(</span><span class=m>2</span> <span class=p>*</span> <span class=n>i</span> <span class=p>+</span> <span class=m>1.0</span><span class=p>)</span> <span class=p>/</span> <span class=n>k</span><span class=p>;</span> <span class=c1>// Values from (-1+1/k) to (1-1/k) with step = 2/k</span>
</span></span><span class=line><span class=cl>            <span class=kt>double</span> <span class=n>p</span> <span class=p>=</span> <span class=m>1.0</span> <span class=p>/</span> <span class=p>(</span><span class=m>1</span> <span class=p>+</span> <span class=n>Math</span><span class=p>.</span><span class=n>Pow</span><span class=p>(</span><span class=m>2</span> <span class=p>*</span> <span class=n>n</span> <span class=p>-</span> <span class=m>1</span><span class=p>,</span> <span class=p>-</span><span class=n>z</span><span class=p>));</span> <span class=c1>// Values from 0.0 to 1.0</span>
</span></span><span class=line><span class=cl>            <span class=kt>double</span> <span class=n>t</span> <span class=p>=</span> <span class=n>sortedData</span><span class=p>[(</span><span class=kt>int</span><span class=p>)</span> <span class=n>Math</span><span class=p>.</span><span class=n>Truncate</span><span class=p>((</span><span class=n>n</span> <span class=p>-</span> <span class=m>1</span><span class=p>)</span> <span class=p>*</span> <span class=n>p</span><span class=p>)];</span> <span class=c1>// Quantile value, formula (2.1) in [Haynes2017]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>tau</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span> <span class=n>tau</span> <span class=p>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>tau</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>partialSums</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>tau</span><span class=p>]</span> <span class=p>=</span> <span class=n>partialSums</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>tau</span> <span class=p>-</span> <span class=m>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>tau</span> <span class=p>-</span> <span class=m>1</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>partialSums</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>tau</span><span class=p>]</span> <span class=p>+=</span> <span class=m>2</span><span class=p>;</span> <span class=c1>// We use doubled value (2) instead of original 1.0</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>data</span><span class=p>[</span><span class=n>tau</span> <span class=p>-</span> <span class=m>1</span><span class=p>]</span> <span class=p>==</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>partialSums</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>tau</span><span class=p>]</span> <span class=p>+=</span> <span class=m>1</span><span class=p>;</span> <span class=c1>// We use doubled value (1) instead of original 0.5</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>partialSums</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Calculates the cost of the (tau1; tau2] segment.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>static</span> <span class=kt>double</span> <span class=n>GetSegmentCost</span><span class=p>(</span><span class=kt>int</span><span class=p>[,]</span> <span class=n>partialSums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>tau1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>tau2</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>k</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// actualSum is (count(data[j] &lt; t) * 2 + count(data[j] == t) * 1) for j=tau1..tau2-1</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>actualSum</span> <span class=p>=</span> <span class=n>partialSums</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>tau2</span><span class=p>]</span> <span class=p>-</span> <span class=n>partialSums</span><span class=p>[</span><span class=n>i</span><span class=p>,</span> <span class=n>tau1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// We skip these two cases (correspond to fit = 0 or fit = 1) because of invalid Math.Log values</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>actualSum</span> <span class=p>!=</span> <span class=m>0</span> <span class=p>&amp;&amp;</span> <span class=n>actualSum</span> <span class=p>!=</span> <span class=p>(</span><span class=n>tau2</span> <span class=p>-</span> <span class=n>tau1</span><span class=p>)</span> <span class=p>*</span> <span class=m>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Empirical CDF $\hat{F}_i(t)$ (Section 2.1 &#34;Model&#34; in [Haynes2017])</span>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>fit</span> <span class=p>=</span> <span class=n>actualSum</span> <span class=p>*</span> <span class=m>0.5</span> <span class=p>/</span> <span class=p>(</span><span class=n>tau2</span> <span class=p>-</span> <span class=n>tau1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Segment cost $\mathcal{L}_{np}$ (Section 2.2 &#34;Nonparametric maximum likelihood&#34; in [Haynes2017])</span>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>lnp</span> <span class=p>=</span> <span class=p>(</span><span class=n>tau2</span> <span class=p>-</span> <span class=n>tau1</span><span class=p>)</span> <span class=p>*</span> <span class=p>(</span><span class=n>fit</span> <span class=p>*</span> <span class=n>Math</span><span class=p>.</span><span class=n>Log</span><span class=p>(</span><span class=n>fit</span><span class=p>)</span> <span class=p>+</span> <span class=p>(</span><span class=m>1</span> <span class=p>-</span> <span class=n>fit</span><span class=p>)</span> <span class=p>*</span> <span class=n>Math</span><span class=p>.</span><span class=n>Log</span><span class=p>(</span><span class=m>1</span> <span class=p>-</span> <span class=n>fit</span><span class=p>));</span>
</span></span><span class=line><span class=cl>                <span class=n>sum</span> <span class=p>+=</span> <span class=n>lnp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>c</span> <span class=p>=</span> <span class=p>-</span><span class=n>Math</span><span class=p>.</span><span class=n>Log</span><span class=p>(</span><span class=m>2</span> <span class=p>*</span> <span class=n>n</span> <span class=p>-</span> <span class=m>1</span><span class=p>);</span> <span class=c1>// Constant from Lemma 3.1 in [Haynes2017]</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=m>2.0</span> <span class=p>*</span> <span class=n>c</span> <span class=p>/</span> <span class=n>k</span> <span class=p>*</span> <span class=n>sum</span><span class=p>;</span> <span class=c1>// See Section 3.1 &#34;Discrete approximation&#34; in [Haynes2017]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Returns the index of the minimum element.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// In case if there are several minimum elements in the given list, the index of the first one will be returned.</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>static</span> <span class=kt>int</span> <span class=n>WhichMin</span><span class=p>(</span><span class=n>IList</span><span class=p>&lt;</span><span class=kt>double</span><span class=p>&gt;</span> <span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>values</span><span class=p>.</span><span class=n>Count</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>(</span><span class=s>&#34;Array should contain elements&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>minValue</span> <span class=p>=</span> <span class=n>values</span><span class=p>[</span><span class=m>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>minIndex</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>values</span><span class=p>.</span><span class=n>Count</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>minValue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>minValue</span> <span class=p>=</span> <span class=n>values</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>minIndex</span> <span class=p>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>minIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></div><br><br><div class="flex flex-wrap justify-center items-center mb-5"><span>Share:</span><div class="text-4xl pl-3"><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fedpelt%2f&title=Implementation%20of%20efficient%20algorithm%20for%20changepoint%20detection%3a%20ED-PELT" target=_blank title="Share on Reddit"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#reddit"/></svg></a></div><div class="text-4xl pl-3"><a href="https://twitter.com/intent/tweet?text=Implementation%20of%20efficient%20algorithm%20for%20changepoint%20detection%3a%20ED-PELT&url=https%3a%2f%2faakinshin.net%2fposts%2fedpelt%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></div><div class="text-4xl pl-3"><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fedpelt%2f" target=_blank title="Share on HackerNews"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#hacker-news"/></svg></a></div><div class="text-4xl pl-3"><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fedpelt%2f&title=Implementation%20of%20efficient%20algorithm%20for%20changepoint%20detection%3a%20ED-PELT" target=_blank title="Add to Pocket"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#get-pocket"/></svg></a></div></div></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")})),themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center"> 20132022 <span class=whitespace-nowrap>Andrey Akinshin</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js integrity="sha512-zPB79j2C+3sFS9zcA3vg/z6bVKzJVEyu9pY5w89akQRys76zpAT2t6S3wZKla3QQ14O5l/Yt0RUQ/DHXx82Y5g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>anchors.options={placement:"left",icon:""},anchors.add("h1"),anchors.add("h2"),anchors.add("h3")</script></body></html>