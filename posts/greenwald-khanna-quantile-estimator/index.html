<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.103.0-DEV"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Mathematics,Statistics"><title>Greenwald-Khanna quantile estimator | Andrey Akinshin</title><meta name=description content="The Greenwald-Khanna quantile estimator is a classic sequential quantile estimator which has the following features:
It allows estimating quantiles with respect to the given precision \(\epsilon\). It requires \(O(\frac{1}{\epsilon} log(\epsilon N))\) memor..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.fe1c45a5bb1462c47792274eba884723afa28a87c7a92405ed21b423927e7fbf.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/posts/>Posts</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/research/>Research</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/about/>About</a></div></div><button id=theme-toggle type=button title="Alt+Click to match OS color theme" class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><div class=main-post><h1 class=blog-post-title id=post-title>Greenwald-Khanna quantile estimator</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai text-accent-l dark:text-front-d"><title>Date</title><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2021-11-02>November 2, 2021</time><svg class="fai ml-3 text-accent-l dark:text-front-d"><title>Tags</title><use xlink:href="/img/fa/all.svg#tag"/></svg><div class="flex flex-wrap gap-y-1"><a class=label-link href=https://aakinshin.net/tags/mathematics/>Mathematics</a>
<a class=label-link href=https://aakinshin.net/tags/statistics/>Statistics</a></div></div><br><div class=main-content><p>The Greenwald-Khanna quantile estimator is a classic sequential quantile estimator
which has the following features:</p><ul><li>It allows estimating quantiles with respect to the given precision <span class="math inline">\(\epsilon\)</span>.</li><li>It requires <span class="math inline">\(O(\frac{1}{\epsilon} log(\epsilon N))\)</span> memory in the worst case.</li><li>It doesn&rsquo;t require knowledge of the total number of elements in the sequence
and the positions of the requested quantiles.</li></ul><p>In this post,
I briefly explain the basic idea of the underlying data structure,
and share a copy-pastable C# implementation.
At the end of the post, I discuss some important implementation decisions
that are unclear from the original paper,
but heavily affect the estimator accuracy.</p><h3 id=the-main-idea-of-the-greenwald-khanna-quantile-estimator>The main idea of the Greenwald-Khanna quantile estimator</h3><p>If you want to get a deep understanding of the algorithm
I highly recommend reading the original paper <a href=#Greenwald2001>[Greenwald2001]</a> first.
In this section, we just briefly recall the main idea to provide the context for further implementation.</p><p>The quantile estimator has a single parameter <span class="math inline">\(\epsilon\)</span> that defines its precision.
The suggested data structure supports two operations:</p><ol><li><code>Add(v)</code>: Add a new element <span class="math inline">\(v\)</span></li><li><code>GetQuantile(p)</code>: Get the estimation of the <span class="math inline">\(p^\textrm{th}\)</span> quantile</li></ol><p>If the number of currently observed elements is <span class="math inline">\(n\)</span>, the max error of <code>GetQuantile(p)</code> is <span class="math inline">\(\epsilon n\)</span>.
This means that <code>GetQuantile</code> returns an element that belongs to the interval
between elements with ranks <span class="math inline">\((p-\epsilon)n\)</span> and <span class="math inline">\((p+\epsilon)n\)</span> in the sorted list of observed elements.</p><p>The high-level internal representation assumes that we maintain a sorted subset of observed elements:
<span class="math inline">\(v_0 \leq v_1 \leq \ldots \leq v_{s-1}\)</span>.
For each element <span class="math inline">\(v_i\)</span>, we have values <span class="math inline">\(r_{\min}(v_i)\)</span> and <span class="math inline">\(r_{\max}(v_i)\)</span>
that denote the minimum and the maximum estimations of the <span class="math inline">\(v_i\)</span> rank across all observed elements.
However, maintaining of the actual <span class="math inline">\(r_{\min}(v_i)\)</span> and <span class="math inline">\(r_{\max}(v_i)\)</span> values is computationally inefficient
because each <code>Add</code> operation would require too many modifications.
That&rsquo;s why actually we keep a list of tuples <span class="math inline">\(t_i = (v_i, g_i, \Delta_i)\)</span>,
where <span class="math inline">\(g_i\)</span> and <span class="math inline">\(\Delta_i\)</span> should be interpreted as follows:</p><p><span class="math display">\[g_i = r_{\min}(v_i) - r_{\min}(v_{i-1}), \quad
\Delta_i = r_{\max}(v_i) - r_{\min}(v_i).
\]</span></p><p>The equations could also be described using the following scheme:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>rmax(v[0]) ←------→ rmax(v[1]) ←------→ rmax(v[2]) ←--...
</span></span><span class=line><span class=cl>   ↑                   ↑                   ↑
</span></span><span class=line><span class=cl>   | delta[0]          | delta[1]          | delta[2]
</span></span><span class=line><span class=cl>   ↓         g[1]      ↓         g[2]      ↓         g[3]
</span></span><span class=line><span class=cl>rmin(v[0]) ←------→ rmin(v[1]) ←------→ rmin(v[2]) ←--...
</span></span></code></pre></div><p>Such a representation makes the <code>Add</code> operation simple and fast.
This operation just inserts a new tuple in a proper place.
Since <span class="math inline">\(\{v_i\}\)</span> is sorted,
we could find position for the new element using binary search (it requires <span class="math inline">\(O(log(s))\)</span>) operations).
The value of the corresponding <span class="math inline">\(g\)</span> is always <span class="math inline">\(1\)</span>.
Thus, we &ldquo;increment&rdquo; values of <span class="math inline">\(r_{\min}(v)\)</span> and <span class="math inline">\(r_{\max}(v)\)</span> without any actual modifications.
The value of the corresponding <span class="math inline">\(\Delta\)</span> is <span class="math inline">\(\lfloor 2\epsilon n \rfloor\)</span> for the central elements,
and <span class="math inline">\(0\)</span> for the border cases (when the new element is the new minimum or the new maximum).</p><p>The authors suggest the following invariant for this data structure (assuming we have processed n elements):</p><p><span class="math display">\[g_i + \Delta_i \leq 2 \epsilon n
\]</span></p><p>Such an invariant allow us to get a simple implementation of <code>GetQuantile(p)</code>.
As an estimation of the <span class="math inline">\(p^\textrm{th}\)</span> quantile, we could use the element with rank <span class="math inline">\(r = \lceil pn \rceil\)</span>.
In <a href=#Greenwald2001>[Greenwald2001]</a>, the authors show that it&rsquo;s always possible to find such a tuple <span class="math inline">\(i\)</span> so that</p><p><span class="math display">\[r - \epsilon n \leq r_\min(v_i), \quad r_\max(v_i) \leq r + \epsilon n.
\]</span></p><p>Since the true rank of <span class="math inline">\(v_i\)</span> across observed elements is inside <span class="math inline">\([r_\min(v_i); r_\max(v_i)]\)</span>,
the difference between the actual rank of <span class="math inline">\(v_i\)</span> and the requested rank <span class="math inline">\(r\)</span> is less than <span class="math inline">\(\epsilon n\)</span>.
Thus, we could use <span class="math inline">\(v_i\)</span> as the estimation of the requested quantile
because it satisfies the precision requirements.</p><p>The last important aspect of the suggested approach is about maintaining a low number of tuples.
Once in a while (after each <span class="math inline">\(\lfloor 1/(2\epsilon) \rfloor\)</span> observed elements), we should perform
the <code>Compress</code> operation and merge some of the sequential tuple pairs.
If we want to merge tuples <span class="math inline">\(t_i\)</span> and <span class="math inline">\(t_{i+1}\)</span>, the following conditions should be satisfied:</p><ul><li><span class="math inline">\(g_i + g_{i+1} + \Delta_{i+1} < 2 \epsilon n\)</span> (so to maintain the main invariant)</li><li><span class="math inline">\(\Delta_{i+1} \geq \Delta_i\)</span></li></ul><p>If we decide to merge <span class="math inline">\(t_i\)</span> and <span class="math inline">\(t_{i+1}\)</span>, we replace them with a new tuple <span class="math inline">\(t_* = (v_*, g_*, \Delta_*)\)</span>
with the following values:</p><p><span class="math display">\[v_* = v_{i+1},\quad g_* = g_i + g_{i+1},\quad \Delta_* = \Delta_{i + 1}.
\]</span></p><p>To get additional details about the Greenwald-Khanna quantile estimator,
read the original paper <a href=#Greenwald2001>[Greenwald2001]</a>.</p><h3 id=reference-copy-pastable-implementation>Reference copy-pastable implementation</h3><p>Based on the suggested description, I came up with the following implementation
(it&rsquo;s also available in <a href=https://github.com/AndreyAkinshin/perfolizer>perfolizer</a> 0.3.0-nightly.107+):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>GreenwaldKhannaQuantileEstimator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>class</span> <span class=nc>Tuple</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=k>static</span> <span class=k>readonly</span> <span class=n>IComparer</span><span class=p>&lt;</span><span class=n>Tuple</span><span class=p>&gt;</span> <span class=n>Comparer</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>            <span class=n>Comparer</span><span class=p>&lt;</span><span class=n>Tuple</span><span class=p>&gt;.</span><span class=n>Create</span><span class=p>((</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>a</span><span class=p>.</span><span class=n>Value</span><span class=p>.</span><span class=n>CompareTo</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>Value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=kt>double</span> <span class=n>Value</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// Observation v[i]</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=kt>int</span> <span class=n>Gap</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// g[i] = rMin(v[i]) - rMin(v[i - 1])</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span> <span class=kt>int</span> <span class=n>Delta</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// delta[i] = rMax(v[i]) - rMin(v[i])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Tuple</span><span class=p>&gt;</span> <span class=n>tuples</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span> <span class=n>compressingInterval</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>double</span> <span class=n>epsilon</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>GreenwaldKhannaQuantileEstimator</span><span class=p>(</span><span class=kt>double</span> <span class=n>epsilon</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=n>epsilon</span> <span class=p>=</span> <span class=n>epsilon</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>compressingInterval</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Floor</span><span class=p>(</span><span class=m>1.0</span> <span class=p>/</span> <span class=p>(</span><span class=m>2.0</span> <span class=p>*</span> <span class=k>this</span><span class=p>.</span><span class=n>epsilon</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>void</span> <span class=n>Add</span><span class=p>(</span><span class=kt>double</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>t</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Tuple</span> <span class=p>{</span> <span class=n>Value</span> <span class=p>=</span> <span class=n>v</span><span class=p>,</span> <span class=n>Gap</span> <span class=p>=</span> <span class=m>1</span><span class=p>,</span> <span class=n>Delta</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Floor</span><span class=p>(</span><span class=m>2.0</span> <span class=p>*</span> <span class=n>epsilon</span> <span class=p>*</span> <span class=n>n</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=n>GetInsertIndex</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=p>==</span> <span class=m>0</span> <span class=p>||</span> <span class=n>i</span> <span class=p>==</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>t</span><span class=p>.</span><span class=n>Delta</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>tuples</span><span class=p>.</span><span class=n>Insert</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=p>%</span> <span class=n>compressingInterval</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>Compress</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>int</span> <span class=n>GetInsertIndex</span><span class=p>(</span><span class=n>Tuple</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>index</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>.</span><span class=n>BinarySearch</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>.</span><span class=n>Comparer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>index</span> <span class=p>&gt;=</span> <span class=m>0</span> <span class=p>?</span> <span class=n>index</span> <span class=p>:</span> <span class=p>~</span><span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>double</span> <span class=n>GetQuantile</span><span class=p>(</span><span class=kt>double</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tuples</span><span class=p>.</span><span class=n>Count</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>(</span><span class=s>&#34;Sequence contains no elements&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>rank</span> <span class=p>=</span> <span class=n>p</span> <span class=p>*</span> <span class=p>(</span><span class=n>n</span> <span class=p>-</span> <span class=m>1</span><span class=p>)</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>margin</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Ceiling</span><span class=p>(</span><span class=n>epsilon</span> <span class=p>*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>bestIndex</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>bestDist</span> <span class=p>=</span> <span class=kt>double</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rMin</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>t</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>rMin</span> <span class=p>+=</span> <span class=n>t</span><span class=p>.</span><span class=n>Gap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>rMax</span> <span class=p>=</span> <span class=n>rMin</span> <span class=p>+</span> <span class=n>t</span><span class=p>.</span><span class=n>Delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>rank</span> <span class=p>-</span> <span class=n>margin</span> <span class=p>&lt;=</span> <span class=n>rMin</span> <span class=p>&amp;&amp;</span> <span class=n>rMax</span> <span class=p>&lt;=</span> <span class=n>rank</span> <span class=p>+</span> <span class=n>margin</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>currentDist</span> <span class=p>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>Abs</span><span class=p>(</span><span class=n>rank</span> <span class=p>-</span> <span class=p>(</span><span class=n>rMin</span> <span class=p>+</span> <span class=n>rMax</span><span class=p>)</span> <span class=p>/</span> <span class=m>2.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>currentDist</span> <span class=p>&lt;</span> <span class=n>bestDist</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>bestDist</span> <span class=p>=</span> <span class=n>currentDist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>bestIndex</span> <span class=p>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>bestIndex</span> <span class=p>==</span> <span class=p>-</span><span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>(</span><span class=s>&#34;Failed to find the requested quantile&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tuples</span><span class=p>[</span><span class=n>bestIndex</span><span class=p>].</span><span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>void</span> <span class=n>Compress</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span> <span class=p>-</span> <span class=m>2</span><span class=p>;</span> <span class=n>i</span> <span class=p>&gt;=</span> <span class=m>1</span><span class=p>;</span> <span class=n>i</span><span class=p>--)</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=p>&lt;</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span> <span class=p>-</span> <span class=m>1</span> <span class=p>&amp;&amp;</span> <span class=n>DeleteIfNeeded</span><span class=p>(</span><span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>bool</span> <span class=n>DeleteIfNeeded</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Tuple</span> <span class=n>t1</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>t2</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>[</span><span class=n>i</span> <span class=p>+</span> <span class=m>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>threshold</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Floor</span><span class=p>(</span><span class=m>2.0</span> <span class=p>*</span> <span class=n>epsilon</span> <span class=p>*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>t1</span><span class=p>.</span><span class=n>Delta</span> <span class=p>&gt;=</span> <span class=n>t2</span><span class=p>.</span><span class=n>Delta</span> <span class=p>&amp;&amp;</span> <span class=n>t1</span><span class=p>.</span><span class=n>Gap</span> <span class=p>+</span> <span class=n>t2</span><span class=p>.</span><span class=n>Gap</span> <span class=p>+</span> <span class=n>t2</span><span class=p>.</span><span class=n>Delta</span> <span class=p>&lt;</span> <span class=n>threshold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>tuples</span><span class=p>.</span><span class=n>RemoveAt</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>t2</span><span class=p>.</span><span class=n>Gap</span> <span class=p>+=</span> <span class=n>t1</span><span class=p>.</span><span class=n>Gap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=implementation-notes>Implementation Notes</h3><h4 id=getquantilep-the-expected-rank-value><code>GetQuantile(p)</code>: the expected rank value</h4><p>The paper suggests (see §2.2.1) that if we want to estimate <span class="math inline">\(p^\textrm{quantile}\)</span>,
we should find an element with rank <span class="math inline">\(\lceil np \rceil\)</span>.
Since the paper uses 1-based indexing, we get a problem for <span class="math inline">\(p=0\)</span>.
Also, <span class="math inline">\(\lceil np \rceil\)</span> provides a non-uniform mapping from the real quantile position value to the integer rank.
I suggest using the same approach that we use in the Hyndman-Fan Type 7 quantile estimator and defining the rank <span class="math inline">\(r\)</span>
as a <em>real</em> value using the following equation: <span class="math inline">\(r = p(n-1) + 1\)</span>.
According to my experiments, it gives more accurate quantile estimations.</p><h4 id=getquantilep-the-margin-value><code>GetQuantile(p)</code>: the margin value</h4><p>The paper suggests (see §2.2.1) that we should use <span class="math inline">\(\epsilon n\)</span> as the search margin.
To be more specific,
we should find <span class="math inline">\(i\)</span> such that <span class="math inline">\(r-r_\min(v_i) \leq \epsilon n\)</span> and <span class="math inline">\(r_\max(v_i)-r \leq \epsilon n\)</span>.
It&rsquo;s not always possible for small values of <span class="math inline">\(\epsilon\)</span> and <span class="math inline">\(n\)</span> (when <span class="math inline">\(\epsilon * n\)</span>).
I suggest relaxing these conditions and using <span class="math inline">\(\lceil \epsilon n \rceil\)</span> as the margin in the above conditions.</p><h4 id=getquantilep-choosing-the-best-tuple><code>GetQuantile(p)</code>: choosing the best tuple</h4><p>In many cases, several tuples may satisfy the search conditions.
However, we should choose a single one to determine the result.
If we choose the first one or the last one, the corresponding quantile estimation may be inaccurate
(while it technically may satisfy the estimator precision requirements).
I suggesting choosing such a tuple <span class="math inline">\(t_i\)</span> so that it minimize the value of <span class="math inline">\(|r - (r_\min(v_i) + r_\max(v_i))/2|\)</span>.</p><h4 id=improving-compress-routine>Improving <code>Compress</code> routine</h4><p>The paper suggests (see §2.2.1, Figure 2) the following compress routine:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>COMPRESS()
</span></span><span class=line><span class=cl>  for i from s-2 to 0 do
</span></span><span class=line><span class=cl>    if ((BAND(Δ[i], 2ϵn) ≤ BAND(Δ[i+1], 2ϵn)) &amp;&amp;
</span></span><span class=line><span class=cl>        g[i]+g[i+1]+Δ[i+1] &lt; 2ϵn) then
</span></span><span class=line><span class=cl>          DELETE all descendants of t[i] and the tuple t[i] itself
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>  end
</span></span><span class=line><span class=cl>end
</span></span></code></pre></div><p>I suggest making the following adjustments:</p><ul><li>Replacing the lower bound of the loop by <span class="math inline">\(1\)</span>.
It allows keeping the actual value of the observed minimum
so that it provides more accurate estimations of lower quantiles.</li><li>The band representation from §2.1 may help to understand the logic behind the suggested data structure.
However, in my opinion, it&rsquo;s not required for the implementation.
The condition <code>(BAND(Δ[i], 2ϵn) ≤ BAND(Δ[i+1], 2ϵn)</code> could be easily replaced by <code>Δ[i] ≥ Δ[i+1]</code>.</li><li>The tree representation from §2.1 also looks like an over-complication in the context of implementation.
Instead of <code>DELETE all descendants of t[i] and the tuple t[i] itself</code> we could just say
<code>MERGE t[i] and t[i+1] while they are mergeable</code>.</li></ul><p>Thus, the above pseudo-code could be rewritten as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>COMPRESS()
</span></span><span class=line><span class=cl>  for i from s-2 to 1 do
</span></span><span class=line><span class=cl>    while (i ≤ s-2 &amp;&amp;
</span></span><span class=line><span class=cl>           Δ[i] ≥ Δ[i+1] &amp;&amp;
</span></span><span class=line><span class=cl>           g[i]+g[i+1]+Δ[i+1] &lt; 2ϵn) do
</span></span><span class=line><span class=cl>             MERGE(t[i], t[i+1])
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>  end
</span></span><span class=line><span class=cl>end
</span></span></code></pre></div><h3 id=references>References</h3><ul><li><b id=Greenwald2001>[Greenwald2001]</b><br>Greenwald, Michael, and Sanjeev Khanna. &ldquo;Space-efficient online computation of quantile summaries.&rdquo;
ACM SIGMOD Record 30, no. 2 (2001): 58-66.<br><a href=https://doi.org/10.1145/375663.375670>https://doi.org/10.1145/375663.375670</a></li></ul></div><br><br></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}));function toggleTheme(e){e?(document.documentElement.classList.add("dark"),themeToggleLightIcon.classList.remove("hidden"),themeToggleDarkIcon.classList.add("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")}),imagesLight.forEach(e=>{e.classList.add("hidden")})):(document.documentElement.classList.remove("dark"),themeToggleDarkIcon.classList.remove("hidden"),themeToggleLightIcon.classList.add("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}),imagesDark.forEach(e=>{e.classList.add("hidden")}))}themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),event.altKey?(localStorage.removeItem("color-theme"),toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches)):localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{if(localStorage.getItem("color-theme")===null){const t=e.matches?"dark":"light";toggleTheme(t==="dark")}})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2024 <span class=whitespace-nowrap>Andrey Akinshin</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"],ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></body></html>