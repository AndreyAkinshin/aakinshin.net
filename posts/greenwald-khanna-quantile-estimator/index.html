<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.123.7"><meta name=author content='Andrey Akinshin'><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content='Mathematics,Statistics'><title>Greenwald-Khanna quantile estimator | Andrey Akinshin</title>
<meta name=description content="The Greenwald-Khanna quantile estimator is a classic sequential quantile estimator which has the following features:
It allows estimating quantiles with respect to the given precision $\epsilon$. It requires $O(\frac{1}{\epsilon} log(\epsilon N))$ memory in..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.f8640bf9a1f7ba7802d4c626b7c44d7f16a850d1b3573e70d5e67cc11f2bb278.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-2 xs:px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/posts/>Posts</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/research/>Research</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/library/>Library</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/about/>About</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/search/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#magnifying-glass"/></svg></a></div></div><button id=theme-toggle type=button title="Alt+Click to match OS color theme" class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><div class=main-post><h1 class=blog-post-title id=post-title>Greenwald-Khanna quantile estimator</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai text-accent-l dark:text-front-d"><title>Date</title><use xlink:href="/img/fa/all.svg#calendar-days"/></svg>
<time datetime=2021-11-02>November 2, 2021</time><svg class="fai ml-3 text-accent-l dark:text-front-d"><title>Tags</title><use xlink:href="/img/fa/all.svg#tag"/></svg><div class="flex flex-wrap gap-y-1"><a class=label-link href=https://aakinshin.net/tags/mathematics/><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#math"/></svg>
Mathematics
</a><a class=label-link href=https://aakinshin.net/tags/statistics/><svg class="rating-icon"><use xlink:href="/img/fa/all.svg#statistics"/></svg>
Statistics</a></div></div><br><div class=main-content><p>The Greenwald-Khanna quantile estimator is a classic sequential quantile estimator
which has the following features:</p><ul><li>It allows estimating quantiles with respect to the given precision $\epsilon$.</li><li>It requires $O(\frac{1}{\epsilon} log(\epsilon N))$ memory in the worst case.</li><li>It doesn&rsquo;t require knowledge of the total number of elements in the sequence
and the positions of the requested quantiles.</li></ul><p>In this post,
I briefly explain the basic idea of the underlying data structure,
and share a copy-pastable C# implementation.
At the end of the post, I discuss some important implementation decisions
that are unclear from the original paper,
but heavily affect the estimator accuracy.</p><h3 id=the-main-idea-of-the-greenwald-khanna-quantile-estimator>The main idea of the Greenwald-Khanna quantile estimator</h3><p>If you want to get a deep understanding of the algorithm
I highly recommend reading the original paper <a href=/posts/greenwald-khanna-quantile-estimator/#Greenwald2001>[Greenwald2001]</a> first.
In this section, we just briefly recall the main idea to provide the context for further implementation.</p><p>The quantile estimator has a single parameter $\epsilon$ that defines its precision.
The suggested data structure supports two operations:</p><ol><li><code>Add(v)</code>: Add a new element $v$</li><li><code>GetQuantile(p)</code>: Get the estimation of the $p^\textrm{th}$ quantile</li></ol><p>If the number of currently observed elements is $n$, the max error of <code>GetQuantile(p)</code> is $\epsilon n$.
This means that <code>GetQuantile</code> returns an element that belongs to the interval
between elements with ranks $(p-\epsilon)n$ and $(p+\epsilon)n$ in the sorted list of observed elements.</p><p>The high-level internal representation assumes that we maintain a sorted subset of observed elements:
$v_0 \leq v_1 \leq \ldots \leq v_{s-1}$.
For each element $v_i$, we have values $r_{\min}(v_i)$ and $r_{\max}(v_i)$
that denote the minimum and the maximum estimations of the $v_i$ rank across all observed elements.
However, maintaining of the actual $r_{\min}(v_i)$ and $r_{\max}(v_i)$ values is computationally inefficient
because each <code>Add</code> operation would require too many modifications.
That&rsquo;s why actually we keep a list of tuples $t_i = (v_i, g_i, \Delta_i)$,
where $g_i$ and $\Delta_i$ should be interpreted as follows:</p>$$
g_i = r_{\min}(v_i) - r_{\min}(v_{i-1}), \quad
\Delta_i = r_{\max}(v_i) - r_{\min}(v_i).
$$<p>The equations could also be described using the following scheme:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>rmax(v[0]) ←------→ rmax(v[1]) ←------→ rmax(v[2]) ←--...
</span></span><span class=line><span class=cl>   ↑                   ↑                   ↑
</span></span><span class=line><span class=cl>   | delta[0]          | delta[1]          | delta[2]
</span></span><span class=line><span class=cl>   ↓         g[1]      ↓         g[2]      ↓         g[3]
</span></span><span class=line><span class=cl>rmin(v[0]) ←------→ rmin(v[1]) ←------→ rmin(v[2]) ←--...
</span></span></code></pre></div><p>Such a representation makes the <code>Add</code> operation simple and fast.
This operation just inserts a new tuple in a proper place.
Since $\{v_i\}$ is sorted,
we could find position for the new element using binary search (it requires $O(log(s))$) operations).
The value of the corresponding $g$ is always $1$.
Thus, we &ldquo;increment&rdquo; values of $r_{\min}(v)$ and $r_{\max}(v)$ without any actual modifications.
The value of the corresponding $\Delta$ is $\lfloor 2\epsilon n \rfloor$ for the central elements,
and $0$ for the border cases (when the new element is the new minimum or the new maximum).</p><p>The authors suggest the following invariant for this data structure (assuming we have processed n elements):</p>$$
g_i + \Delta_i \leq 2 \epsilon n
$$<p>Such an invariant allow us to get a simple implementation of <code>GetQuantile(p)</code>.
As an estimation of the $p^\textrm{th}$ quantile, we could use the element with rank $r = \lceil pn \rceil$.
In <a href=/posts/greenwald-khanna-quantile-estimator/#Greenwald2001>[Greenwald2001]</a>, the authors show that it&rsquo;s always possible to find such a tuple $i$ so that</p>$$
r - \epsilon n \leq r_\min(v_i), \quad r_\max(v_i) \leq r + \epsilon n.
$$<p>Since the true rank of $v_i$ across observed elements is inside $[r_\min(v_i); r_\max(v_i)]$,
the difference between the actual rank of $v_i$ and the requested rank $r$ is less than $\epsilon n$.
Thus, we could use $v_i$ as the estimation of the requested quantile
because it satisfies the precision requirements.</p><p>The last important aspect of the suggested approach is about maintaining a low number of tuples.
Once in a while (after each $\lfloor 1/(2\epsilon) \rfloor$ observed elements), we should perform
the <code>Compress</code> operation and merge some of the sequential tuple pairs.
If we want to merge tuples $t_i$ and $t_{i+1}$, the following conditions should be satisfied:</p><ul><li>$g_i + g_{i+1} + \Delta_{i+1} < 2 \epsilon n$ (so to maintain the main invariant)</li><li>$\Delta_{i+1} \geq \Delta_i$</li></ul><p>If we decide to merge $t_i$ and $t_{i+1}$, we replace them with a new tuple $t_* = (v_*, g_*, \Delta_*)$
with the following values:</p>$$
v_* = v_{i+1},\quad g_* = g_i + g_{i+1},\quad \Delta_* = \Delta_{i + 1}.
$$<p>To get additional details about the Greenwald-Khanna quantile estimator,
read the original paper <a href=/posts/greenwald-khanna-quantile-estimator/#Greenwald2001>[Greenwald2001]</a>.</p><h3 id=reference-copy-pastable-implementation>Reference copy-pastable implementation</h3><p>Based on the suggested description, I came up with the following implementation
(it&rsquo;s also available in <a href=https://github.com/AndreyAkinshin/perfolizer>perfolizer</a> 0.3.0-nightly.107+):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kd>public</span> <span class=k>class</span> <span class=nc>GreenwaldKhannaQuantileEstimator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=k>class</span> <span class=nc>Tuple</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kd>static</span> <span class=k>readonly</span> <span class=n>IComparer</span><span class=p>&lt;</span><span class=n>Tuple</span><span class=p>&gt;</span> <span class=n>Comparer</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>            <span class=n>Comparer</span><span class=p>&lt;</span><span class=n>Tuple</span><span class=p>&gt;.</span><span class=n>Create</span><span class=p>((</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=n>a</span><span class=p>.</span><span class=n>Value</span><span class=p>.</span><span class=n>CompareTo</span><span class=p>(</span><span class=n>b</span><span class=p>.</span><span class=n>Value</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>double</span> <span class=n>Value</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// Observation v[i]</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>int</span> <span class=n>Gap</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// g[i] = rMin(v[i]) - rMin(v[i - 1])</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>int</span> <span class=n>Delta</span> <span class=p>{</span> <span class=k>get</span><span class=p>;</span> <span class=k>set</span><span class=p>;</span> <span class=p>}</span> <span class=c1>// delta[i] = rMax(v[i]) - rMin(v[i])</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=k>readonly</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Tuple</span><span class=p>&gt;</span> <span class=n>tuples</span> <span class=p>=</span> <span class=k>new</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=k>readonly</span> <span class=kt>int</span> <span class=n>compressingInterval</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=k>readonly</span> <span class=kt>double</span> <span class=n>epsilon</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>GreenwaldKhannaQuantileEstimator</span><span class=p>(</span><span class=kt>double</span> <span class=n>epsilon</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=n>epsilon</span> <span class=p>=</span> <span class=n>epsilon</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>compressingInterval</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Floor</span><span class=p>(</span><span class=m>1.0</span> <span class=p>/</span> <span class=p>(</span><span class=m>2.0</span> <span class=p>*</span> <span class=k>this</span><span class=p>.</span><span class=n>epsilon</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=k>void</span> <span class=n>Add</span><span class=p>(</span><span class=kt>double</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>t</span> <span class=p>=</span> <span class=k>new</span> <span class=n>Tuple</span> <span class=p>{</span> <span class=n>Value</span> <span class=p>=</span> <span class=n>v</span><span class=p>,</span> <span class=n>Gap</span> <span class=p>=</span> <span class=m>1</span><span class=p>,</span> <span class=n>Delta</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Floor</span><span class=p>(</span><span class=m>2.0</span> <span class=p>*</span> <span class=n>epsilon</span> <span class=p>*</span> <span class=n>n</span><span class=p>)</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=n>GetInsertIndex</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=p>==</span> <span class=m>0</span> <span class=p>||</span> <span class=n>i</span> <span class=p>==</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>t</span><span class=p>.</span><span class=n>Delta</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>tuples</span><span class=p>.</span><span class=n>Insert</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=p>%</span> <span class=n>compressingInterval</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>Compress</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>int</span> <span class=n>GetInsertIndex</span><span class=p>(</span><span class=n>Tuple</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>index</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>.</span><span class=n>BinarySearch</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=n>Tuple</span><span class=p>.</span><span class=n>Comparer</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>index</span> <span class=p>&gt;=</span> <span class=m>0</span> <span class=p>?</span> <span class=n>index</span> <span class=p>:</span> <span class=p>~</span><span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>double</span> <span class=n>GetQuantile</span><span class=p>(</span><span class=kt>double</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>tuples</span><span class=p>.</span><span class=n>Count</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>(</span><span class=s>&#34;Sequence contains no elements&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>rank</span> <span class=p>=</span> <span class=n>p</span> <span class=p>*</span> <span class=p>(</span><span class=n>n</span> <span class=p>-</span> <span class=m>1</span><span class=p>)</span> <span class=p>+</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>margin</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Ceiling</span><span class=p>(</span><span class=n>epsilon</span> <span class=p>*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>bestIndex</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>bestDist</span> <span class=p>=</span> <span class=kt>double</span><span class=p>.</span><span class=n>MaxValue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>rMin</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>var</span> <span class=n>t</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>rMin</span> <span class=p>+=</span> <span class=n>t</span><span class=p>.</span><span class=n>Gap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>rMax</span> <span class=p>=</span> <span class=n>rMin</span> <span class=p>+</span> <span class=n>t</span><span class=p>.</span><span class=n>Delta</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>rank</span> <span class=p>-</span> <span class=n>margin</span> <span class=p>&lt;=</span> <span class=n>rMin</span> <span class=p>&amp;&amp;</span> <span class=n>rMax</span> <span class=p>&lt;=</span> <span class=n>rank</span> <span class=p>+</span> <span class=n>margin</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>double</span> <span class=n>currentDist</span> <span class=p>=</span> <span class=n>Math</span><span class=p>.</span><span class=n>Abs</span><span class=p>(</span><span class=n>rank</span> <span class=p>-</span> <span class=p>(</span><span class=n>rMin</span> <span class=p>+</span> <span class=n>rMax</span><span class=p>)</span> <span class=p>/</span> <span class=m>2.0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>currentDist</span> <span class=p>&lt;</span> <span class=n>bestDist</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>bestDist</span> <span class=p>=</span> <span class=n>currentDist</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>bestIndex</span> <span class=p>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>bestIndex</span> <span class=p>==</span> <span class=p>-</span><span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>(</span><span class=s>&#34;Failed to find the requested quantile&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>tuples</span><span class=p>[</span><span class=n>bestIndex</span><span class=p>].</span><span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=k>void</span> <span class=n>Compress</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span> <span class=p>-</span> <span class=m>2</span><span class=p>;</span> <span class=n>i</span> <span class=p>&gt;=</span> <span class=m>1</span><span class=p>;</span> <span class=n>i</span><span class=p>--)</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=p>&lt;</span> <span class=n>tuples</span><span class=p>.</span><span class=n>Count</span> <span class=p>-</span> <span class=m>1</span> <span class=p>&amp;&amp;</span> <span class=n>DeleteIfNeeded</span><span class=p>(</span><span class=n>i</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kt>bool</span> <span class=n>DeleteIfNeeded</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Tuple</span> <span class=n>t1</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>t2</span> <span class=p>=</span> <span class=n>tuples</span><span class=p>[</span><span class=n>i</span> <span class=p>+</span> <span class=m>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>threshold</span> <span class=p>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=n>Math</span><span class=p>.</span><span class=n>Floor</span><span class=p>(</span><span class=m>2.0</span> <span class=p>*</span> <span class=n>epsilon</span> <span class=p>*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>t1</span><span class=p>.</span><span class=n>Delta</span> <span class=p>&gt;=</span> <span class=n>t2</span><span class=p>.</span><span class=n>Delta</span> <span class=p>&amp;&amp;</span> <span class=n>t1</span><span class=p>.</span><span class=n>Gap</span> <span class=p>+</span> <span class=n>t2</span><span class=p>.</span><span class=n>Gap</span> <span class=p>+</span> <span class=n>t2</span><span class=p>.</span><span class=n>Delta</span> <span class=p>&lt;</span> <span class=n>threshold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>tuples</span><span class=p>.</span><span class=n>RemoveAt</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>t2</span><span class=p>.</span><span class=n>Gap</span> <span class=p>+=</span> <span class=n>t1</span><span class=p>.</span><span class=n>Gap</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=implementation-notes>Implementation Notes</h3><h4 id=getquantilep-the-expected-rank-value><code>GetQuantile(p)</code>: the expected rank value</h4><p>The paper suggests (see §2.2.1) that if we want to estimate $p^\textrm{quantile}$,
we should find an element with rank $\lceil np \rceil$.
Since the paper uses 1-based indexing, we get a problem for $p=0$.
Also, $\lceil np \rceil$ provides a non-uniform mapping from the real quantile position value to the integer rank.
I suggest using the same approach that we use in the Hyndman-Fan Type 7 quantile estimator and defining the rank $r$
as a <em>real</em> value using the following equation: $r = p(n-1) + 1$.
According to my experiments, it gives more accurate quantile estimations.</p><h4 id=getquantilep-the-margin-value><code>GetQuantile(p)</code>: the margin value</h4><p>The paper suggests (see §2.2.1) that we should use $\epsilon n$ as the search margin.
To be more specific,
we should find $i$ such that $r-r_\min(v_i) \leq \epsilon n$ and $r_\max(v_i)-r \leq \epsilon n$.
It&rsquo;s not always possible for small values of $\epsilon$ and $n$ (when $\epsilon * n$).
I suggest relaxing these conditions and using $\lceil \epsilon n \rceil$ as the margin in the above conditions.</p><h4 id=getquantilep-choosing-the-best-tuple><code>GetQuantile(p)</code>: choosing the best tuple</h4><p>In many cases, several tuples may satisfy the search conditions.
However, we should choose a single one to determine the result.
If we choose the first one or the last one, the corresponding quantile estimation may be inaccurate
(while it technically may satisfy the estimator precision requirements).
I suggesting choosing such a tuple $t_i$ so that it minimize the value of $|r - (r_\min(v_i) + r_\max(v_i))/2|$.</p><h4 id=improving-compress-routine>Improving <code>Compress</code> routine</h4><p>The paper suggests (see §2.2.1, Figure 2) the following compress routine:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>COMPRESS()
</span></span><span class=line><span class=cl>  for i from s-2 to 0 do
</span></span><span class=line><span class=cl>    if ((BAND(Δ[i], 2ϵn) ≤ BAND(Δ[i+1], 2ϵn)) &amp;&amp;
</span></span><span class=line><span class=cl>        g[i]+g[i+1]+Δ[i+1] &lt; 2ϵn) then
</span></span><span class=line><span class=cl>          DELETE all descendants of t[i] and the tuple t[i] itself
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>  end
</span></span><span class=line><span class=cl>end
</span></span></code></pre></div><p>I suggest making the following adjustments:</p><ul><li>Replacing the lower bound of the loop by $1$.
It allows keeping the actual value of the observed minimum
so that it provides more accurate estimations of lower quantiles.</li><li>The band representation from §2.1 may help to understand the logic behind the suggested data structure.
However, in my opinion, it&rsquo;s not required for the implementation.
The condition <code>(BAND(Δ[i], 2ϵn) ≤ BAND(Δ[i+1], 2ϵn)</code> could be easily replaced by <code>Δ[i] ≥ Δ[i+1]</code>.</li><li>The tree representation from §2.1 also looks like an over-complication in the context of implementation.
Instead of <code>DELETE all descendants of t[i] and the tuple t[i] itself</code> we could just say
<code>MERGE t[i] and t[i+1] while they are mergeable</code>.</li></ul><p>Thus, the above pseudo-code could be rewritten as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>COMPRESS()
</span></span><span class=line><span class=cl>  for i from s-2 to 1 do
</span></span><span class=line><span class=cl>    while (i ≤ s-2 &amp;&amp;
</span></span><span class=line><span class=cl>           Δ[i] ≥ Δ[i+1] &amp;&amp;
</span></span><span class=line><span class=cl>           g[i]+g[i+1]+Δ[i+1] &lt; 2ϵn) do
</span></span><span class=line><span class=cl>             MERGE(t[i], t[i+1])
</span></span><span class=line><span class=cl>    end
</span></span><span class=line><span class=cl>  end
</span></span><span class=line><span class=cl>end
</span></span></code></pre></div><h3 id=references>References</h3><ul><li><b id=Greenwald2001>[Greenwald2001]</b><br>Greenwald, Michael, and Sanjeev Khanna. &ldquo;Space-efficient online computation of quantile summaries.&rdquo;
ACM SIGMOD Record 30, no. 2 (2001): 58-66.<br><a href=https://doi.org/10.1145/375663.375670>https://doi.org/10.1145/375663.375670</a></li></ul></div></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}));function toggleTheme(e){e?(document.documentElement.classList.add("dark"),themeToggleLightIcon.classList.remove("hidden"),themeToggleDarkIcon.classList.add("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")}),imagesLight.forEach(e=>{e.classList.add("hidden")})):(document.documentElement.classList.remove("dark"),themeToggleDarkIcon.classList.remove("hidden"),themeToggleLightIcon.classList.add("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}),imagesDark.forEach(e=>{e.classList.add("hidden")}))}themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),event.altKey?(localStorage.removeItem("color-theme"),toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches)):localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{if(localStorage.getItem("color-theme")===null){const t=e.matches?"dark":"light";toggleTheme(t==="dark")}})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2024 <span class=whitespace-nowrap>Andrey Akinshin</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"],ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+=" has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></body></html>