<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Statistics,Quantiles,Harrell-Davis quantile estimator,R,perfolizer"><title>Weighted quantile estimators | Andrey Akinshin</title><meta name=description content="Update 2021-07-06: the approach was updated using the Kish&amp;rsquo;s effective sample size.
In this post, I will show how to calculate weighted quantile esti..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.882998740b9c4c24677576b997bde5a487246e2e3bd72128a0e922eaa59db029.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.50da8736f05b35aac9691de67fe993cbe01b7d88fcf0cb682c3a8f39933fe4a3.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.ae812fc71daf5160d927febda5a991cee6c361345e3f685d3736931ed7537986.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41419012-5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41419012-5');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-sm navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-posts href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-pdnb href=https://aakinshin.net/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class="blog-post table-sm"><h1 class=blog-post-title id=post-title>Weighted quantile estimators</h1><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2020-09-29>September 29, 2020</time>
&nbsp;&nbsp;
<i class="fas fa-tag"></i>&nbsp;
<a href=https://aakinshin.net/tags/statistics/ class="badge badge-info">Statistics</a>
<a href=https://aakinshin.net/tags/quantiles/ class="badge badge-info">Quantiles</a>
<a href=https://aakinshin.net/tags/harrell-davis-quantile-estimator/ class="badge badge-info">Harrell-Davis quantile estimator</a>
<a href=https://aakinshin.net/tags/r/ class="badge badge-info">R</a>
<a href=https://aakinshin.net/tags/perfolizer/ class="badge badge-info">perfolizer</a></span><br><br><p><strong>Update 2021-07-06:
the approach was updated using the <a href=https://aakinshin.net/posts/kish-ess-weighted-quantiles/>Kish&rsquo;s effective sample size</a>.</strong></p><p>In this post, I will show how to calculate weighted quantile estimates and how to use them in practice.</p><p>Let&rsquo;s start with a problem from real life.
Imagine that you measure the total duration of a unit test executed daily on a CI server.
Every day you get a single number that corresponds to the test duration from the latest revision for this day:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/moving1-light.svg target=_blank class=imgldlink alt=moving1><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/moving1-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/moving1-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=600 src=/posts/weighted-quantiles/img/moving1-light.svg></picture></a></div></div><br><p>You collect a history of such measurements for 100 days.
Now you want to describe the &ldquo;actual&rdquo; distribution of the performance measurements.</p><p>However, for the latest &ldquo;actual&rdquo; revision, you have only a single measurement, which is not enough to build a distribution.
Also, you can&rsquo;t build a distribution based on the last N measurements because they can contain change points that will spoil your results.
So, what you really want to do is to use all the measurements, but older values should have a lower impact on the final distribution form.</p><p>Such a problem can be solved using the weighted quantiles!
This powerful approach can be applied to any time series regardless of the domain area.
In this post, we learn how to calculate and apply weighted quantiles.</p><h3 id=literature-overview>Literature overview</h3><p>When I started looking for a weighted quantile implementation,
I was sure that it should be easy to google some well explained sources.
Unfortunately, I didn&rsquo;t manage to find any workable approach.
Here are some of my findings (you can scroll to the next section if you are not interested in non-working approaches):</p><ul><li><a href=https://en.wikipedia.org/wiki/Percentile#Weighted_percentile>The weighted percentile method</a> on Wikipedia<br>A very strange formulation with missing details.
It doesn&rsquo;t seem to be true because it&rsquo;s based on two subsequent elements from the given sample.
Here is a simple counterexample for any formula which is based on two subsequent elements.
Imagine a sample <span class="math inline">\( \{ x_1, x_2, x_3, x_4 \}\)</span> where <span class="math inline">\(x_1 \leq x_2 \leq x_3 \leq x_4\)</span> with weights <span class="math inline">\(\{ 1, 0, 1, 0 \}\)</span>.
I expect that the median value will be <span class="math inline">\( (x_1 + x_3) / 2\)</span>, but we can&rsquo;t get such a result using two subsequent elements.
If we have low weights around the element that corresponds to the target quantile, the formula should involve several elements from the original sample.</li><li><a href=https://stats.stackexchange.com/a/13223/261747>Answer for &ldquo;Defining quantiles over a weighted sample&rdquo;</a> on StackExchange.<br>The same problem here: a formula with two subsequent elements.</li><li><a href=https://blogs.sas.com/content/iml/2016/08/29/weighted-percentiles.html>Weighted percentiles</a> on SAS blogs.<br>It explains only the general concept of weighted quantiles, but it doesn&rsquo;t provide any details.
Although the main idea looks correct (it uses ECDF), it&rsquo;s hard to check and reuse it.</li></ul><p>Also, I found some implementations of weighted quantiles:</p><ul><li><a href=http://finzi.psych.upenn.edu/R/library/Hmisc/html/wtd.stats.html>Hmisc::wtd.quantile</a> (R)<br>Has a <a href=https://github.com/harrelfe/Hmisc/issues/97>critical bug</a>, doesn&rsquo;t work.
Designed only for the Harrell-Davis quantile estimator.</li><li><a href=https://www.rdocumentation.org/packages/reldist/versions/1.6-6/topics/wtd.quantile>reldist::wtd.quantile</a> (R)<br>Just <a href=https://github.com/cran/reldist/blob/5e5c9357b7ca27585a11bbcfb2e4a2ab6e37dd7b/R/wtd.quantile.R#L16>calls</a> <code>wtd.quantile</code> from <code>Hmisc</code></li><li><a href=https://github.com/FilippoBovo/robustats>FilippoBovo/robustats</a> (Python)<br>Produces very strange results.
<a href=https://github.com/FilippoBovo/robustats/blob/8d029001acaa7702fe5ecb33479664bb7cb0a3f7/robustats/robustats.py#L32>For example</a>, the weighted median value for <span class="math inline">\(\{ 1.0, 2.0 \}\)</span> with weights <span class="math inline">\(\{ 1.0, 1.0 \}\)</span> is <span class="math inline">\(1.0\)</span>.</li></ul><p>The weighted quantiles look like a very natural concept to me.
So, I believe it should be explained somewhere, but I just didn&rsquo;t manage to find it.
If you know such a reference, I will appreciate if you share it with me.</p><p>Meanwhile, I decided to derive all the formulas myself because it sounds like a fun exercise.
In this post, I will show how to transform a non-weighted quantile estimator to a weighted one
and present exact formulas for the Harrell-Davis and Type 7 weighted quantile estimators.</p><h3 id=notation>Notation</h3><p>We will use the following notation:</p><ul><li><span class="math inline">\(x\)</span>: original sample. Assuming that it&rsquo;s always contain sorted real numbers.</li><li><span class="math inline">\(n\)</span>: the number of elements in the sample.</li><li><span class="math inline">\(x_i\)</span>: <span class="math inline">\(i^\textrm{th}\)</span> element of the sample.</li><li><span class="math inline">\(w\)</span>: a vector of weights. It has the same length as <span class="math inline">\(x\)</span>. Assuming <span class="math inline">\(w_i \geq 0\)</span>, <span class="math inline">\(\sum_{i=1}^n w > 0\)</span>.</li><li><span class="math inline">\(s_i(w)\)</span>: partial sum of weights, <span class="math inline">\(s_i(w) = \sum_{j=1}^{i} w_j\)</span>. Assuming <span class="math inline">\(s_0(w) = 0\)</span>.</li><li><span class="math inline">\(q_p\)</span>: estimation of the <span class="math inline">\(p^\textrm{th}\)</span> quantile based on <span class="math inline">\(x\)</span>.</li></ul><h3 id=weighted-quantiles>Weighted quantiles</h3><p>Let&rsquo;s say we have a sample <span class="math inline">\(x = \{ x_1, x_2, \ldots, x_n \}\)</span> and we want to calculate the <span class="math inline">\(p^\textrm{th}\)</span> quantile <span class="math inline">\(q_p\)</span>.</p><div class=block-example><b><span class=block-example-title></span></b><br><em>Input:</em> <span class="math inline">\(x = \{ 1, 2, 3, 4, 5 \}\)</span> and <span class="math inline">\(p = 0.5\)</span>.<br><em>Result:</em> <span class="math inline">\(q_p = 3\)</span>.<br>Since <span class="math inline">\(p = 0.5\)</span>, we are looking for the median, it&rsquo;s the middle element of a sorted sample which equals <span class="math inline">\(3\)</span> in our case.</div><p>Let&rsquo;s also consider a vector of weights <span class="math inline">\(w = \{ w_1, w_2, \ldots, w_n \}\)</span>.
We assume that the weight of <span class="math inline">\(x_i\)</span> is <span class="math inline">\(w_i\)</span>.
We want to calculate the <span class="math inline">\(p^\textrm{th}\)</span> quantile <span class="math inline">\(q_p\)</span> with respect to these weights.
To give you an idea of this concept, let&rsquo;s look at another example.</p><div class=block-example><b><span class=block-example-title></span></b><br><em>Input:</em> <span class="math inline">\(x = \{ 1, 2, 3, 4, 5 \}\)</span>, <span class="math inline">\(w = \{ 1, 0, 0, 1, 1 \}\)</span>, <span class="math inline">\(p = 0.5\)</span>.<br><em>Result:</em> <span class="math inline">\(q_p = 4\)</span>.<br>Here <span class="math inline">\(w_2 = w_3 = 0\)</span>, which means that we can omit the second and the third element of the sample.
Since <span class="math inline">\(w_1 = w_4 = w_5 = 1\)</span>, we can imagine that our sample was transformed to <span class="math inline">\(\{ 1, 4, 5 \}\)</span>.
After that, it&rsquo;s easy to see that <span class="math inline">\(q_p = 4\)</span> because it&rsquo;s the middle element of the transformed sample.</div><p>It was an easy example because <span class="math inline">\(w\)</span> contained only zeros and ones.
What about more complicated cases when <span class="math inline">\(w\)</span> contains fractional numbers?
The exact formula for weighted quantiles depends on the used quantile estimator for the non-weighted case.
In this post, we consider two estimator kinds:</p><ul><li><strong>The Type 7 quantile estimator</strong><br>It&rsquo;s the most popular quantile estimator which is used by default in
R, Julia, NumPy, Excel (<code>PERCENTILE</code>, <code>PERCENTILE.INC</code>), Python (<code>inclusive</code> method).
We call it &ldquo;Type 7&rdquo; according to notation from <a href=#Hyndman1996>[Hyndman1996]</a>,
where Rob J. Hyndman and Yanan Fan described nine quantile algorithms which are used in statistical computer packages.</li><li><strong>The Harrell-Davis quantile estimator</strong><br>It&rsquo;s my favorite option in real life because
it&rsquo;s more efficient than classic quantile estimators based on linear interpolation,
and it provides more reliable estimations on small samples.
This quantile estimator is described in <a href=#Harrell1982>[Harrell1982]</a>.</li></ul><h3 id=weighted-harrell-davis-quantile-estimator>Weighted Harrell-Davis quantile estimator</h3><p>I start with the Harrell-Davis quantile estimator because it provides a more intuitive generalization for the weighted case.</p><p>Here is the formula for the Harrell-Davis quantile estimator:</p><p><span class="math display">\[q_p = \sum_{i=1}^{n} W_{n,i} \cdot x_i,
\]</span></p><p><span class="math display">\[W_{n,i} = I_{i/n} (p(n+1)), (1-p)(n+1)) - I_{(i-1)/n} (p(n+1), (1-p)(n+1))
\]</span></p><p>where <span class="math inline">\(I_t(a, b)\)</span> denotes the <a href=https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function>regularized incomplete beta function</a>.
It&rsquo;s not a simple formula, so let&rsquo;s visualize it for better understanding.
<span class="math inline">\(I_u (a, b)\)</span> depends on three variables: <span class="math inline">\(x\)</span>, <span class="math inline">\(a\)</span>, and <span class="math inline">\(b\)</span>.
The values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> and fixed for the given <span class="math inline">\(p\)</span>:</p><p><span class="math display">\[\left\{
\begin{array}{rccl}
a = & p     & \cdot & (n + 1),\\
b = & (1-p) & \cdot & (n + 1).
\end{array}
\right.
\]</span></p><p>Thus, we can rewrite the formula for <span class="math inline">\(W_{n,i}\)</span> as follows:</p><p><span class="math display">\[W_{n,i} = I_{i/n}(a, b) - I_{(i-1)/n}(a, b).
\]</span></p><div class=block-example><b><span class=block-example-title></span></b><br><em>Input:</em> <span class="math inline">\(n=9\)</span>, <span class="math inline">\(p=0.25\)</span> (we are looking for the first <a href=https://en.wikipedia.org/wiki/Quartile>quartile</a>).<br><em>Result:</em> <span class="math inline">\(a = p(n+1) = 0.25 \cdot 10 = 2.5, \quad b = (1-p)(n+1) = 0.75 \cdot 10 = 7.5\)</span>.</div><p>Using the predefined <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, we can define the following function:</p><p><span class="math display">\[g(t) = t^{a-1} (1-t)^{b-1}.
\]</span></p><div class=block-example><b><span class=block-example-title></span></b><br><p>For <span class="math inline">\(a = 2.5\)</span> and <span class="math inline">\(b = 7.5\)</span>, <span class="math inline">\(g(t)\)</span> looks as follows:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/hd1-light.svg target=_blank class=imgldlink alt=hd1><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/hd1-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/hd1-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/hd1-light.svg></picture></a></div></div><br></div><p>The value of the <a href=https://en.wikipedia.org/wiki/Beta_function>beta function</a> is the area under this curve:</p><p><span class="math display">\[B(a,b) = \int_0^1 t^{a-1}(1-t)^{b-1}\,dt.
\]</span></p><p>The value of the <a href=https://en.wikipedia.org/wiki/Beta_function#Incomplete_beta_function>incomplete beta function</a> for <span class="math inline">\(x\)</span> is the area under this curve between <span class="math inline">\(0\)</span> and <span class="math inline">\(x\)</span>:</p><p><span class="math display">\[B(u; a,b) = \int_0^u t^{a-1}(1-t)^{b-1}\,dt.
\]</span></p><p>The value of the <em>regularized incomplete beta function</em> for <span class="math inline">\(x\)</span> is the normalized version of the incomplete beta function, so its value always belongs to <span class="math inline">\([0; 1]\)</span>.
To get the regularized version, we should divide the incomplete beta function by <span class="math inline">\(B(a,b)\)</span> (it&rsquo;s a constant for given <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>).</p><p><span class="math display">\[I_u(a,b) = \frac{B(u;\,a,b)}{B(a,b)}.
\]</span></p><div class=block-example><b><span class=block-example-title></span></b><br><p><span class="math inline">\(I_{0.25}(a, b)\)</span> corresponds to the area of the highlighted area on the following plot:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/hd2-light.svg target=_blank class=imgldlink alt=hd2><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/hd2-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/hd2-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/hd2-light.svg></picture></a></div></div><br></div><p>Here are a few additional facts which are good to understand:</p><ul><li><span class="math inline">\(I_{0.0}(a, b) = 0.0\)</span>, it&rsquo;s the minimum value of this function.</li><li><span class="math inline">\(I_{1.0}(a, b) = 1.0\)</span>, it&rsquo;s the maximum value of this function and the area under the curve on the above plot.</li><li><span class="math inline">\(I_u(a,b)\)</span> is also the <a href=https://en.wikipedia.org/wiki/Cumulative_distribution_function>cumulative distribution function</a> (CDF) for the <a href=https://en.wikipedia.org/wiki/Beta_distribution>Beta distribution</a>.</li><li>Regularized version of <span class="math inline">\(g(t)\)</span> is the <a href=https://en.wikipedia.org/wiki/Probability_density_function>probability density function</a> (PDF) of the Beta distribution:
<span class="math inline">\(f(t) = g(t) / B(a, b) = t^{a-1} (1-t)^{b-1} / B(a, b)\)</span>.
On the above and below plots, we are working with PDF.</li></ul><p>Now we can visualize <span class="math inline">\(W_{n,i} = I_{i/n}(a, b) - I_{(i-1)/n}(a, b)\)</span>.
Each <span class="math inline">\(W_{n,i}\)</span> corresponds to a fragment of our plot.</p><div class=block-example><b><span class=block-example-title></span></b><br><p><em>Input:</em> <span class="math inline">\(n=9\)</span>, <span class="math inline">\(p=0.25\)</span>, <span class="math inline">\(a=2.5\)</span>, <span class="math inline">\(b=7.5\)</span>.<br>In this case, we get 9 fragments of <span class="math inline">\(I_u(a,b)\)</span> (last two segments are almost invisible):</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/hd3-light.svg target=_blank class=imgldlink alt=hd3><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/hd3-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/hd3-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/hd3-light.svg></picture></a></div></div><br><p><span class="math inline">\(W_{n,i}\)</span> equals the area of the <span class="math inline">\(i^\textrm{th}\)</span> fragment.</p></div><p>We work with the <em>regularized</em> version of the incomplete beta function, so the sum of these fragments equals <span class="math inline">\(1\)</span>:</p><p><span class="math display">\[\sum_{i=1}^n W_{n, i} = 1.
\]</span></p><p>Since <span class="math inline">\(q_p = \sum_{i=1}^{n} W_{n,i} \cdot x_i\)</span>, the <span class="math inline">\(W_{n, i}\)</span> coefficients define the &ldquo;contribution&rdquo; of <span class="math inline">\(x_i\)</span> to the quantile value.</p><p>Now it&rsquo;s time to convert our non-weighted quantile estimator to a weighted one.
First of all, we should introduce the concept of &ldquo;weighted sample size.&rdquo;
We are going to use the <a href=https://aakinshin.net/posts/kish-ess-weighted-quantiles/>Kish&rsquo;s effective sample size</a>:</p><p><span class="math display">\[n^* = \frac{\Big( \sum_{i=1}^n w_i \Big)^2}{\sum_{i=1}^n w_i^2 }.
\]</span></p><p>Thus, the weighted sample size of <span class="math inline">\(w = \{1, 1, 1, 0, 0 \}\)</span> and <span class="math inline">\(w = \{ 1, 1, 1 \}\)</span> is <span class="math inline">\(3\)</span> for both cases.
This value has an influence on the values of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.
Here are the updated equations for the weighted case:</p><p><span class="math display">\[\left\{
\begin{array}{rccl}
a^* = & p     & \cdot & (n^* + 1),\\
b^* = & (1-p) & \cdot & (n^* + 1).
\end{array}
\right.
\]</span></p><p>Next, I suggest changing how we choose the width of the <span class="math inline">\(I_u(a,b)\)</span> fragments.
Currently, the endpoints of the <span class="math inline">\(i^\textrm{th}\)</span> fragment are</p><p><span class="math display">\[\left\{
\begin{array}{rcc}
l_i & = & \dfrac{i - 1}{n},\\
r_i & = & \dfrac{i}{n}.
\end{array}
\right.
\]</span></p><p>All the fragments have the same width which equals <span class="math inline">\(1/n\)</span>.
Let&rsquo;s introduce new endpoints in such a way that the width of the fragment will be equal to <span class="math inline">\(w_i/s_n(w)\)</span>:</p><p><span class="math display">\[\left\{
\begin{array}{rcc}
l^*_i & = & \dfrac{s_{i-1}(w)}{s_n(w)},\\
r^*_i & = & \dfrac{s_i(w)}{s_n(w)}.
\end{array}
\right.
\]</span></p><p>It&rsquo;s a generalization of the non-weighted case because <span class="math inline">\(l_i = l^*_i, r_i = r^*_i\)</span> when all weights are equal (e.g., <span class="math inline">\(\forall i: w_i = 1\)</span>).
Now we can introduce a &ldquo;weighted version&rdquo; of <span class="math inline">\(W_{n, i}\)</span>:</p><p><span class="math display">\[W^*_{n, i} = I_{r^*_i}(a^*, b^*) - I_{l^*_i}(a^*, b^*).
\]</span></p><p>Here is the final formula for the weighted Harrell-Davis quantile estimator:</p><p><span class="math display">\[q^*_p = \sum_{i=1}^{n} W^*_{n,i} \cdot x_i.
\]</span></p><div class=block-example><b><span class=block-example-title></span></b><br><p><em>Input:</em> <span class="math inline">\(x = \{ 1, 2, 3, 4, 5 \}\)</span>, <span class="math inline">\(w = \{ 1, 0, 0, 1, 1 \}\)</span>, <span class="math inline">\(p = 0.5\)</span>.</p><p>Without weights, we had the following five equal-width fragments:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/hd4-light.svg target=_blank class=imgldlink alt=hd4><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/hd4-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/hd4-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/hd4-light.svg></picture></a></div></div><br><p>With weights, the second and the third fragments will be eliminated.
It means that now we have three equal fragments (for <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_4\)</span>, <span class="math inline">\(x_5\)</span>):</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/hd5-light.svg target=_blank class=imgldlink alt=hd5><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/hd5-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/hd5-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/hd5-light.svg></picture></a></div></div><br></div><div class=block-example><b><span class=block-example-title></span></b><br><p><em>Input:</em> <span class="math inline">\(x = \{ 1, 2, 3, 4, 5 \}\)</span>, <span class="math inline">\(w = \{ 0.4, 0.4, 0.05, 0.05, 0.1 \}\)</span>, <span class="math inline">\(p = 0.5\)</span>.<br>The values of <span class="math inline">\(x\)</span> and <span class="math inline">\(p\)</span> match the previous example, so we have the same plot for <span class="math inline">\(I_u(a, b)\)</span>.
However, the new value of <span class="math inline">\(w\)</span> defines another fragmentation:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/hd6-light.svg target=_blank class=imgldlink alt=hd6><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/hd6-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/hd6-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/hd6-light.svg></picture></a></div></div><br><p>As we can see, <span class="math inline">\(x_1\)</span> and <span class="math inline">\(x_2\)</span> have a major impact on the median value because they have high weights: <span class="math inline">\(w_1 = w_2 = 0.4\)</span>.
Meanwhile, <span class="math inline">\(x_3\)</span>, <span class="math inline">\(x_4\)</span>, and <span class="math inline">\(x_5\)</span> have a minor impact because they have low weights: <span class="math inline">\(w_3 = 0.05\)</span>, <span class="math inline">\(w_4 = 0.05\)</span>, <span class="math inline">\(w_5 = 0.1\)</span>.
The weighted median value <span class="math inline">\(q^*_{0.5}\)</span> is <span class="math inline">\(\approx 1.7756\)</span>.</p></div><h3 id=the-generalization>The generalization</h3><p>We can generalize this approach for any non-weighted quantile estimator.
Let&rsquo;s say we can express the non-weighted equations via a CDF function <span class="math inline">\(F\)</span> in the following way:</p><p><span class="math display">\[\begin{gather*}
q_p = \sum_{i=1}^{n} W_{n,i} \cdot x_i,\\
W_{n, i} = F(r_i) - F(l_i),\\
l_i = (i - 1) / n, \quad r_i = i / n.
\end{gather*}
\]</span></p><p>In this case, we can generalize it to the weighted case using an altered version of above equations:</p><p><span class="math display">\[\begin{gather*}
q^*_p = \sum_{i=1}^{n} W^*_{n,i} \cdot x_i,\\
W^*_{n, i} = F(r^*_i) - F(l^*_i),\\
l^*_i = s_{i-1}(w) / s_n(w), \quad r^*_i = s_i(w) / s_n(w).
\end{gather*}
\]</span></p><p>It can be easily transformed back to the non-weighted case if we put <span class="math inline">\(w_i = 1\)</span> for any <span class="math inline">\(i\)</span>.</p><p>In the case of the Harrell-Davis quantile estimator, we should put <span class="math inline">\(F(u) = I_u(a^*, b^*)\)</span>.</p><h3 id=weighted-type-7-quantile-estimator>Weighted Type 7 quantile estimator</h3><p>First of all, let&rsquo;s recall the <a href=https://en.wikipedia.org/wiki/Quantile#Estimating_quantiles_from_a_sample>formula</a> for the Type 7 quantile estimator in the non-weighted case.
In order to do that, we should calculate the real valued index <span class="math inline">\(h = p (n - 1) + 1\)</span>.
After that, the quantile value can be calculated using the following formula:</p><p><span class="math display">\[q_p = x_{\lfloor h \rfloor} + (h - \lfloor h \rfloor) (x_{\lfloor h \rfloor + 1} - x_{\lfloor h \rfloor}).
\]</span></p><p>To get the non-weighted case formula in the generic form, we should express it via a CDF function (let&rsquo;s call it <span class="math inline">\(F_7\)</span>).
It has the following form:</p><p><span class="math display">\[F_7(u) = \left\{
\begin{array}{lcrcllr}
0 & \textrm{for} &         &      & u & <    & (h-1)/n, \\
un-h+1 & \textrm{for} & (h-1)/n & \leq & u  & \leq & h/n, \\
1 & \textrm{for} & h/n     & <    & u. &      &
\end{array}
\right.
\]</span></p><p>The corresponding PDF (let&rsquo;s call it <span class="math inline">\(f_7\)</span>) looks simpler:</p><p><span class="math display">\[f_7(u) = F'_7(u) = \left\{
\begin{array}{lcrcllr}
0 & \textrm{for} &         &      & u & <    & (h-1)/n, \\
n      & \textrm{for} & (h-1)/n & \leq & u  & \leq & h/n, \\
0 & \textrm{for} & h/n     & <    & u. &      &
\end{array}
\right.
\]</span></p><div class=block-example><b><span class=block-example-title></span></b><br><p><em>Input:</em> <span class="math inline">\(n = 5\)</span>, <span class="math inline">\(p = 0.25\)</span>.<br>We have <span class="math inline">\(h = 2\)</span> which gives us the following plots:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/type7-1-light.svg target=_blank class=imgldlink alt=type7-1><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/type7-1-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/type7-1-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/type7-1-light.svg></picture></a></div></div><br></div><p>Let&rsquo;s verify that it works the correct way for the non-weighted case using <span class="math inline">\(W_{n,i} = F_7(i / n) - F_7((i - 1) / n)\)</span>:</p><ul><li>Assuming <span class="math inline">\(h\)</span> is an integer number.<br>For <span class="math inline">\(i < h\)</span>, we have <span class="math inline">\(W_{n,i} = 0 - 0 = 0\)</span>.<br>For <span class="math inline">\(i = h\)</span>, we have <span class="math inline">\(W_{n,i} = 1 - 0 = 1\)</span>.<br>For <span class="math inline">\(i > h\)</span>, we have <span class="math inline">\(W_{n,i} = 1 - 1 = 0\)</span>.<br>Thus, <span class="math inline">\(q_p = \sum_{i=1}^{n} W_{n,i} \cdot x_i = x_h = x_{\lfloor h \rfloor} + (h - \lfloor h \rfloor) (x_{\lfloor h \rfloor + 1} - x_{\lfloor h \rfloor})\)</span>.</li></ul><div class=block-example><b><span class=block-example-title></span></b><br><p><em>Input:</em> <span class="math inline">\(n = 5\)</span>, <span class="math inline">\(p = 0.25\)</span>.<br>We have <span class="math inline">\(h = 2\)</span>, which is an integer number.
Here are the corresponding PDF and CDF plots:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/type7-2-light.svg target=_blank class=imgldlink alt=type7-2><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/type7-2-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/type7-2-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/type7-2-light.svg></picture></a></div></div><br><p>It&rsquo;s easy to see that we have only one non-negative <span class="math inline">\(W_{n,i}\)</span>: <span class="math inline">\(W_{5,2} = 1\)</span>.
It means that <span class="math inline">\(q_{0.25} = x_2\)</span>, which satisfies our expectations (the first quartile of a sample with five elements is the second element).</p></div><ul><li>Assuming <span class="math inline">\(h\)</span> is a non-integer number.<br>For <span class="math inline">\(i < \lfloor h \rfloor\)</span>, we have <span class="math inline">\(W_{n,i} = 0 - 0 = 0\)</span>.<br>For <span class="math inline">\(i = \lfloor h \rfloor\)</span>, we have <span class="math inline">\(W_{n,i} = (\lfloor h \rfloor/n \cdot n - h + 1) - 0 = \lfloor h \rfloor - h + 1\)</span>.<br>For <span class="math inline">\(i = \lfloor h \rfloor + 1\)</span>, we have <span class="math inline">\(W_{n,i} = 1 - (\lfloor h \rfloor/n \cdot n - h + 1) = h - \lfloor h \rfloor \)</span>.<br>For <span class="math inline">\(i > \lfloor h \rfloor + 1\)</span>, we have <span class="math inline">\(W_{n,i} = 1 - 1 = 0\)</span>.<br>Thus, <span class="math inline">\(q_p = \sum_{i=1}^{n} W_{n,i} \cdot x_i = (\lfloor h \rfloor - h + 1) x_{\lfloor h \rfloor} + (h - \lfloor h \rfloor) x_{\lfloor h \rfloor + 1} = x_{\lfloor h \rfloor} + (h - \lfloor h \rfloor) (x_{\lfloor h \rfloor + 1} - x_{\lfloor h \rfloor})\)</span>.</li></ul><div class=block-example><b><span class=block-example-title></span></b><br><p><em>Input:</em> <span class="math inline">\(n = 5\)</span>, <span class="math inline">\(p = 0.25\)</span>.<br>We have <span class="math inline">\(h = 2.4\)</span> which is a non-integer number.
Thus, the first quartile estimation is a linear combination of <span class="math inline">\(x_2\)</span> and <span class="math inline">\(x_3\)</span>:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/type7-3-light.svg target=_blank class=imgldlink alt=type7-3><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/type7-3-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/type7-3-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/type7-3-light.svg></picture></a></div></div><br></div><p>As we can see, the suggested <span class="math inline">\(F_7\)</span> perfectly matches the non-weighted case.
Using equations from the previous section, we can get the weighted case.</p><div class=block-example><b><span class=block-example-title></span></b><br><em>Input:</em> <span class="math inline">\(n = 5\)</span>, <span class="math inline">\(x = \{ 1, 2, 3, 4, 5\}\)</span>, <span class="math inline">\(w = \{ 1, 0, 1, 1, 1 \}\)</span>, <span class="math inline">\(p = 0.25\)</span>.<br>Here we have:<br><span class="math inline">\(h = p(n - 1) + 1 = 2,\)</span><br><span class="math inline">\((h - 1) / n = 0.2, \quad h / n = 0.4,\)</span><br><span class="math inline">\(F_7(u) = \left\{ \begin{array}{lcrcllr} 0 & \textrm{for} &     &      & u  & < & 0.2, \\ 5u-1 & \textrm{for} & 0.2 & \leq & u  & \leq & 0.4, \\ 1    & \textrm{for} & 0.4 & <    & u, & & \end{array} \right.\)</span><br><span class="math inline">\(s_0(w) = 0, \; s_1(w) = 1, \; s_2(w) = 1, \; s_3(w) = 2, \; s_4(w) = 3, \; s_5(w) = 4,\)</span><br><span class="math inline">\(\begin{array}{ll} l^*_1 = s_0(w) / s_5(w) = 0.00, & r^*_1 = s_1(w) / s_5(w) = 0.25,\\ l^*_2 = s_1(w) / s_5(w) = 0.25, & r^*_2 = s_2(w) / s_5(w) = 0.25,\\ l^*_3 = s_2(w) / s_5(w) = 0.25, & r^*_3 = s_3(w) / s_5(w) = 0.50,\\ l^*_4 = s_3(w) / s_5(w) = 0.50, & r^*_4 = s_4(w) / s_5(w) = 0.75,\\ l^*_5 = s_4(w) / s_5(w) = 0.75, & r^*_5 = s_5(w) / s_5(w) = 1.00,\\ \end{array}\)</span><br><span class="math inline">\(W^*_{5,1} = F_7(r_1) - F_7(l_1) = F_7(0.25) - F_7(0.00) = 0.25 - 0.25 = 0.25,\)</span><br><span class="math inline">\(W^*_{5,2} = F_7(r_2) - F_7(l_2) = F_7(0.25) - F_7(0.25) = 0.25 - 0.25 = 0.00,\)</span><br><span class="math inline">\(W^*_{5,3} = F_7(r_3) - F_7(l_3) = F_7(0.50) - F_7(0.25) = 1.00 - 0.25 = 0.75,\)</span><br><span class="math inline">\(W^*_{5,4} = F_7(r_4) - F_7(l_4) = F_7(0.75) - F_7(0.50) = 1.00 - 1.00 = 0.00,\)</span><br><span class="math inline">\(W^*_{5,5} = F_7(r_5) - F_7(l_5) = F_7(1.00) - F_7(0.75) = 1.00 - 1.00 = 0.00,\)</span><br><span class="math inline">\(q^*_{0.25} = W^*_{5,1}x_1 + W^*_{5,2}x_2 + W^*_{5,3}x_3 + W^*_{5,4}x_4 + W^*_{5,5}x_5 = 0.25x_1 + 0.75x_3 = 0.25 + 2.25 = 2.5.\)</span></div><h3 id=weighted-type-4-9-quantile-estimators>Weighted Type 4-9 quantile estimators</h3><p>Although the Type 7 is one of the most popular quantile estimators nowadays,
the above approach can be applied to any of Type 4-9 estimators.
All of them are based on the same interpolation formula:</p><p><span class="math display">\[q_p = x_{\lfloor h \rfloor} + (h - \lfloor h \rfloor) (x_{\lfloor h \rfloor + 1} - x_{\lfloor h \rfloor}).
\]</span></p><p>The only difference between them is how we choose the <span class="math inline">\(h\)</span> value:</p><table><thead><tr><th align=left>Type</th><th align=left>h</th></tr></thead><tbody><tr><td align=left>4</td><td align=left><span class="math inline">\(np\)</span></td></tr><tr><td align=left>5</td><td align=left><span class="math inline">\(np+1/2\)</span></td></tr><tr><td align=left>6</td><td align=left><span class="math inline">\((n+1)p\)</span></td></tr><tr><td align=left>7</td><td align=left><span class="math inline">\((n-1)p+1\)</span></td></tr><tr><td align=left>8</td><td align=left><span class="math inline">\((n+1/3)p+1/3\)</span></td></tr><tr><td align=left>9</td><td align=left><span class="math inline">\((n+1/4)/p+3/8\)</span></td></tr></tbody></table><p>An important note: if the obtained <span class="math inline">\(h\)</span> value is less than <span class="math inline">\(1\)</span> or larger than <span class="math inline">\(n\)</span>,
it should be clamped to the <span class="math inline">\([1;n]\)</span> interval.
Once we get the <span class="math inline">\(h\)</span> value, we can use the same PDF/CDF functions that we used for the Type 7 quantile estimator:</p><p><span class="math display">\[F_k(u) = \left\{
\begin{array}{lcrcllr}
0 & \textrm{for} &         &      & u & <    & (h-1)/n, \\
un-h+1 & \textrm{for} & (h-1)/n & \leq & u  & \leq & h/n, \\
1 & \textrm{for} & h/n     & <    & u. &      &
\end{array}
\right.
\]</span></p><p><span class="math display">\[f_k(u) = F'_k(u) = \left\{
\begin{array}{lcrcllr}
0 & \textrm{for} &         &      & u & <    & (h-1)/n, \\
n      & \textrm{for} & (h-1)/n & \leq & u  & \leq & h/n, \\
0 & \textrm{for} & h/n     & <    & u. &      &
\end{array}
\right.
\]</span></p><h3 id=weighted-quantiles-in-action-exponential-smoothing>Weighted quantiles in action (exponential smoothing)</h3><p>Let&rsquo;s go back to the original problem with performance measurements and quantile evaluations.
We already know how to calculate the weighted quantiles.
All we need now is the weight values.
For problems like this, it&rsquo;s pretty convenient to use the <a href=https://en.wikipedia.org/wiki/Exponential_decay>exponential decay</a> law:</p><p><span class="math display">\[\omega(t) = 2^{-t/t_{1/2}}
\]</span></p><p>where <span class="math inline">\(t_{1/2}\)</span> is the <a href=https://en.wikipedia.org/wiki/Half-life>half-life</a>.
This value describes the period of time required for the current weight to reduce to half of its original value.
Thus, we have</p><p><span class="math display">\[\omega(0) = 1, \quad \omega(t_{1/2}) = 0.5, \quad \omega(2t_{1/2}) = 0.25, \quad \omega(3t_{1/2}) = 0.125, \ldots
\]</span></p><p>For our problem, we should use the exponential decay in a reverse way:</p><p><span class="math display">\[w_i = \omega(n - i).
\]</span></p><p>Thus, the last measurement has weight <span class="math inline">\(w_n = 1\)</span>,
the measurement from <span class="math inline">\(t_{1/2}\)</span> days ago has weight <span class="math inline">\(w_{n-t_{1/2}} = 0.5\)</span>,
the measurement from <span class="math inline">\(2t_{1/2}\)</span> days ago has weight <span class="math inline">\(w_{n-2t_{1/2}} = 0.25\)</span>,
and so on.</p><p>Originally, we had the following pictures with daily measurements:</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/moving1-light.svg target=_blank class=imgldlink alt=moving1><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/moving1-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/moving1-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/moving1-light.svg></picture></a></div></div><br><p>Let&rsquo;s say we want to get a daily estimation for the actual median value.
To do that, we have to apply the following procedure after each day:</p><ul><li>Assign weights <span class="math inline">\(w_i\)</span> to existing measurements <span class="math inline">\(x_i\)</span> according to the exponential decay law.</li><li>Sort the pairs <span class="math inline">\((x_i, w_i)\)</span> by the measurement values <span class="math inline">\(x_i\)</span> because our equations require a sorted sample.</li><li>Apply the Harrell-Davis quantile estimator (because it&rsquo;s an efficient estimator) to get the median estimation (<span class="math inline">\(q_{0.5}\)</span>).</li></ul><p>Here is an illustration of how it works in practice (for this example, <span class="math inline">\(t_{1/2} = 5\)</span>).</p><div class=row><div class=mx-auto><a href=/posts/weighted-quantiles/img/moving2-light.svg target=_blank class=imgldlink alt=moving2><picture>
<source theme=dark srcset=/posts/weighted-quantiles/img/moving2-dark.svg media="(prefers-color-scheme: dark)"><source theme=light srcset=/posts/weighted-quantiles/img/moving2-light.svg media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><img class="mx-auto d-block img-fluid" width=400 src=/posts/weighted-quantiles/img/moving2-light.svg></picture></a></div></div><br><p>Of course, we can apply this procedure not only to the median, but to any other quantile and get a daily estimation of the &ldquo;actual&rdquo; distribution.
It may be &ldquo;spoiled&rdquo; after change point, but it will be &ldquo;recovered&rdquo; after several days.
This technique is known as the <a href=https://aakinshin.net/posts/quantile-exponential-smoothing/>quantile exponential smoothing</a>.
The same idea can be also applied to different measures of dispersion,
so we can use the <a href=https://aakinshin.net/posts/dispersion-exponential-smoothing/>dispersion exponential smoothing</a>.</p><p>This approach can be improved with the help of change point detection (e.g., using <a href=https://aakinshin.net/posts/edpelt/>EdPelt</a> or <a href=https://github.com/AndreyAkinshin/perfolizer#changepoint-detection>RqqPelt</a>): we can just drop the values before the last change point.
However, the weighted approach improves our estimations in this case as well because some change points may not be correctly detected, or measurements may change slowly without explicit change points.</p><h3 id=reference-implementation>Reference implementation</h3><p>If you use R, here are functions that you can use in your scripts:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=c1># Weighted generic quantile estimator</span>
<span class=n>wquantile.generic</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>,</span> <span class=n>cdf.gen</span><span class=p>,</span> <span class=n>weights</span> <span class=o>=</span> <span class=kc>NA</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>n</span> <span class=o>&lt;-</span> <span class=nf>length</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=nf>if </span><span class=p>(</span><span class=nf>any</span><span class=p>(</span><span class=nf>is.na</span><span class=p>(</span><span class=n>weights</span><span class=p>)))</span>
    <span class=n>weights</span> <span class=o>&lt;-</span> <span class=nf>rep</span><span class=p>(</span><span class=m>1</span> <span class=o>/</span> <span class=n>n</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
  <span class=n>nw</span> <span class=o>&lt;-</span> <span class=nf>sum</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span><span class=n>^2</span> <span class=o>/</span> <span class=nf>sum</span><span class=p>(</span><span class=n>weights^2</span><span class=p>)</span> <span class=c1># Kish&#39;s effective sample size</span>

  <span class=n>indexes</span> <span class=o>&lt;-</span> <span class=nf>order</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=n>x</span> <span class=o>&lt;-</span> <span class=n>x[indexes]</span>
  <span class=n>weights</span> <span class=o>&lt;-</span> <span class=n>weights[indexes]</span>

  <span class=n>weights</span> <span class=o>&lt;-</span> <span class=n>weights</span> <span class=o>/</span> <span class=nf>sum</span><span class=p>(</span><span class=n>weights</span><span class=p>)</span>
  <span class=n>cdf.probs</span> <span class=o>&lt;-</span> <span class=nf>cumsum</span><span class=p>(</span><span class=nf>c</span><span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=n>weights</span><span class=p>))</span>
  
  <span class=nf>sapply</span><span class=p>(</span><span class=n>probs</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>cdf</span> <span class=o>&lt;-</span> <span class=nf>cdf.gen</span><span class=p>(</span><span class=n>nw</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span>
    <span class=n>q</span> <span class=o>&lt;-</span> <span class=nf>cdf</span><span class=p>(</span><span class=n>cdf.probs</span><span class=p>)</span>
    <span class=n>w</span> <span class=o>&lt;-</span> <span class=nf>tail</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=m>-1</span><span class=p>)</span> <span class=o>-</span> <span class=nf>head</span><span class=p>(</span><span class=n>q</span><span class=p>,</span> <span class=m>-1</span><span class=p>)</span>
    <span class=nf>sum</span><span class=p>(</span><span class=n>w</span> <span class=o>*</span> <span class=n>x</span><span class=p>)</span>
  <span class=p>})</span>
<span class=p>}</span>

<span class=c1># Weighted Harrell-Davis quantile estimator</span>
<span class=n>whdquantile</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>,</span> <span class=n>weights</span> <span class=o>=</span> <span class=kc>NA</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>cdf.gen</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=nf>return</span><span class=p>(</span><span class=nf>function</span><span class=p>(</span><span class=n>cdf.probs</span><span class=p>)</span> <span class=p>{</span>
    <span class=nf>pbeta</span><span class=p>(</span><span class=n>cdf.probs</span><span class=p>,</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=m>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>p</span><span class=p>,</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=m>1</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=m>1</span> <span class=o>-</span> <span class=n>p</span><span class=p>))</span>
  <span class=p>})</span>
  <span class=nf>wquantile.generic</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>,</span> <span class=n>cdf.gen</span><span class=p>,</span> <span class=n>weights</span><span class=p>)</span>
<span class=p>}</span>

<span class=c1># Weighted Type 7 quantile estimator</span>
<span class=n>wquantile</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>,</span> <span class=n>weights</span> <span class=o>=</span> <span class=kc>NA</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>cdf.gen</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=nf>return</span><span class=p>(</span><span class=nf>function</span><span class=p>(</span><span class=n>cdf.probs</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>h</span> <span class=o>&lt;-</span> <span class=n>p</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=m>1</span><span class=p>)</span> <span class=o>+</span> <span class=m>1</span>
    <span class=n>u</span> <span class=o>&lt;-</span> <span class=nf>pmax</span><span class=p>((</span><span class=n>h</span> <span class=o>-</span> <span class=m>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>n</span><span class=p>,</span> <span class=nf>pmin</span><span class=p>(</span><span class=n>h</span> <span class=o>/</span> <span class=n>n</span><span class=p>,</span> <span class=n>cdf.probs</span><span class=p>))</span>
    <span class=n>u</span> <span class=o>*</span> <span class=n>n</span> <span class=o>-</span> <span class=n>h</span> <span class=o>+</span> <span class=m>1</span>
  <span class=p>})</span>
  <span class=nf>wquantile.generic</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>,</span> <span class=n>cdf.gen</span><span class=p>,</span> <span class=n>weights</span><span class=p>)</span>
<span class=p>}</span>
</code></pre></div><p>If you use C#, you can take an implementation from
the latest nightly version (0.3.0-nightly.96+) of <a href=https://github.com/AndreyAkinshin/perfolizer>Perfolizer</a>
(you need <code>HarrellDavisQuantileEstimator</code> and <code>SimpleQuantileEstimator</code>).</p><h3 id=conclusion>Conclusion</h3><p>In this post, we derived equations for weighted quantile, including a generic CDF-based approach and specific formulas for the Harrell-Davis and Type 7 quantile estimators.
This technique has various applications, and we showed how to apply it to estimate quantiles for a time series using exponential decay.</p><p>The suggested equations present my own view on the concept of weighted quantiles since it&rsquo;s not a popular topic, and I didn&rsquo;t manage to find any good explanations.
If you know any papers/posts/implementations with the same or other approaches, I will appreciate if you share it with me.</p><h3 id=references>References</h3><ul><li><b id=Harrell1982>[Harrell1982]</b><br>Harrell, F.E. and Davis, C.E., 1982. A new distribution-free quantile estimator.
<em>Biometrika</em>, 69(3), pp.635-640.<br><a href=https://pdfs.semanticscholar.org/1a48/9bb74293753023c5bb6bff8e41e8fe68060f.pdf>https://pdfs.semanticscholar.org/1a48/9bb74293753023c5bb6bff8e41e8fe68060f.pdf</a></li><li><b id=Hyndman1996>[Hyndman1996]</b><br>Hyndman, R. J. and Fan, Y. 1996. Sample quantiles in statistical packages, <em>American Statistician</em> 50, 361–365.<br><a href=https://doi.org/10.2307/2684934>https://doi.org/10.2307/2684934</a></li></ul><br><br><div class=row><div class="mx-auto share-block"><div class=share-title>Share:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fweighted-quantiles%2f&title=Weighted%20quantile%20estimators" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=Weighted%20quantile%20estimators&url=https%3a%2f%2faakinshin.net%2fposts%2fweighted-quantiles%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x"></i></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fweighted-quantiles%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=share-button><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fposts%2fweighted-quantiles%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=share-button><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fposts%2fweighted-quantiles%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fweighted-quantiles%2f&title=Weighted%20quantile%20estimators" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013&mdash;2022 Andrey Akinshin
|
<a href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub></i></a><a href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter></i></a><a href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS></i></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.082780cb948cc57eabbc0d80172a7a5347d5572b599938b4c9876dfd7978b424.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true,},options:{skipHtmlTags:['script','noscript','style','textarea','pre'],ignoreHtmlClass:'tex2jax_ignore',processHtmlClass:'tex2jax_process'}};</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>