<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><title>RyuJIT CTP5 and loop unrolling | Andrey Akinshin</title><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://googlechromelabs.github.io/dark-mode-toggle/src/dark-mode-toggle.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.e78467baec0179d7ccd2ef995e0c94f25b4a63a3191a93c3547e22bdf590ef5d.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.a9ad336a30411929ac042537ef03ddbe3b2b28af5aa50655711f870419408467.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-lg navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/pages/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" data-toggle=dropdown href=# role=button aria-haspopup=true aria-expanded=false>EN</a><div class=dropdown-menu><a class=dropdown-item href=https://aakinshin.net/ru/posts/ryujit-ctp5-and-loop-unrolling/>RU</a></div></li><li class=nav-item></li><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a></li><li class=nav-item><a class=nav-link href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class=blog-post><h2 class=blog-post-title id=post-title>RyuJIT CTP5 and loop unrolling</h2><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2015-03-01>March 1, 2015</time>
&nbsp;&nbsp;
<a href=https://aakinshin.net/tags/dotnet/ class="badge badge-info">.NET</a>
<a href=https://aakinshin.net/tags/cs/ class="badge badge-info">C#</a>
<a href=https://aakinshin.net/tags/jit/ class="badge badge-info">JIT</a>
<a href=https://aakinshin.net/tags/ryujit/ class="badge badge-info">RyuJIT</a>
<a href=https://aakinshin.net/tags/loopunrolling/ class="badge badge-info">LoopUnrolling</a></span><br><br><p>RyuJIT will be available soon. It is a next generation JIT-compiler for .NET-applications. Microsoft likes to tell us about the benefits of SIMD using and JIT-compilation time reducing. But what about basic code optimization which is usually applying by a compiler? Today we talk about the loop unrolling (unwinding) optimization. In general, in this type of code optimization, the code</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>1024</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</code></pre></div><p>transforms to</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>1024</span><span class=p>;</span> <span class=n>i</span> <span class=p>+=</span> <span class=m>4</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=m>1</span><span class=p>);</span>
    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=m>2</span><span class=p>);</span>
    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=m>3</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div><p>Such approach can significantly increase performance of your code. So, what&rsquo;s about loop unrolling in .NET?</p><h3 id=common-theory>Common theory</h3><p>First of all, let&rsquo;s talk about how loop unrolling affects to our applications.</p><h4 id=advantages>Advantages</h4><ul><li>We are reducing the number of machine commands (iterator increments).</li><li>Reduced overheads of <a href=https://en.wikipedia.org/wiki/Branch_predictor>branch prediction</a>.</li><li>We increase the possibility of using <a href=https://en.wikipedia.org/wiki/Instruction-level_parallelism>instruction-level parallelism</a>.</li><li>We can apply additional code improvements in conjunction with other optimizations (e. g. , <a href=http://en.wikipedia.org/wiki/Inline_expansion>inlining</a>).</li></ul><h4 id=disadvantages>Disadvantages</h4><ul><li>The source code size increased.</li><li>Sometimes, due to the increasing size of the instruction amount, it is impossible to simultaneously apply loop unrolling and inlining.</li><li>Possible <a href=http://en.wikipedia.org/wiki/CPU_cache#Cache_miss>cache misses</a> in the commands cache.</li><li>Possible increased register usage in a single iteration (we may not have enough registers, other optimizations can not apply because of registers deficit).</li><li>If there is branching in the iteration, loop unrolling can adversely affect to other optimizations.</li></ul><h4 id=conclusion>Conclusion</h4><p>Loop unrolling is a very powerful tool for optimization, but only if we use it wisely. I don&rsquo;t recommended apply it yourself: it will reduce the readability of the source code and it can adversely affect to use other optimizations. It is best to leave this approach to the compiler. It is important that your compiler could do loop unrolling competently.</p><h3 id=experiments>Experiments</h3><h4 id=source-code>Source code</h4><p>We will work with a very simple loop which is very easy to unroll:</p><div class=highlight><pre class=chroma><code class=language-cs data-lang=cs><span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>1024</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
    <span class=n>sum</span> <span class=p>+=</span> <span class=n>i</span><span class=p>;</span>
<span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>sum</span><span class=p>);</span>
</code></pre></div><p>Note, the amount of iterations is known beforehand and it is equal to 2<sup>10</sup>. It is very important because it greatly simplifies usage of the considered optimization.</p><h4 id=jit-x86>JIT-x86</h4><p>Let&rsquo;s run the code with JIT-x86 and look to the assembler code:</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm>        <span class=nf>int</span> <span class=no>sum</span> <span class=err>=</span> <span class=mi>0</span><span class=c>;                    
</span><span class=c></span><span class=mi>00</span><span class=no>EE0052</span>  <span class=no>in</span>          <span class=no>al</span><span class=p>,</span><span class=no>dx</span>             
<span class=mi>00</span><span class=no>EE0053</span>  <span class=no>push</span>        <span class=no>esi</span>               
<span class=mi>00</span><span class=no>EE0054</span>  <span class=no>xor</span>         <span class=no>esi</span><span class=p>,</span><span class=no>esi</span>           
        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c>; i &lt; 1024; i++)  
</span><span class=c></span><span class=mi>00</span><span class=no>EE0056</span>  <span class=no>xor</span>         <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>           
            <span class=no>sum</span> <span class=err>+=</span> <span class=no>i</span><span class=c>;                   
</span><span class=c></span><span class=mi>00</span><span class=no>EE0058</span>  <span class=no>add</span>         <span class=no>esi</span><span class=p>,</span><span class=no>eax</span>           <span class=c>; sum += i
</span><span class=c></span>        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c>; i &lt; 1024; i++)  
</span><span class=c></span><span class=mi>00</span><span class=no>EE005A</span>  <span class=no>inc</span>         <span class=no>eax</span>               <span class=c>; i++
</span><span class=c></span><span class=mi>00</span><span class=no>EE005B</span>  <span class=no>cmp</span>         <span class=no>eax</span><span class=p>,</span><span class=mi>400</span><span class=no>h</span>          
<span class=mi>00</span><span class=no>EE0060</span>  <span class=no>jl</span>          <span class=mi>00</span><span class=no>EE0058</span>          
</code></pre></div><p>As you can see, JIT-x86 didn&rsquo;t apply loop unrolling. You should understood, the 32-bit version of JIT-compiler is quite primitive. JIT-x86 apply loop unrolling rarely, only if specific conditions are satisfied.</p><h4 id=jit-x64>JIT-x64</h4><p>Next, try the experiment with the 64-bit version of JIT-compiler:</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm>        <span class=nf>int</span> <span class=no>sum</span> <span class=err>=</span> <span class=mi>0</span><span class=c>;                               
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC8710090</span>  <span class=no>sub</span>         <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span>              
        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c>; i &lt; 1024; i++)             
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC8710094</span>  <span class=no>xor</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>ecx</span>              
<span class=mi>00007</span><span class=no>FFCC8710096</span>  <span class=no>mov</span>         <span class=no>edx</span><span class=p>,</span><span class=mi>1</span>                <span class=c>; edx = i + 1
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC871009B</span>  <span class=no>nop</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=p>]</span>  
<span class=mi>00007</span><span class=no>FFCC87100A0</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>rdx-1</span><span class=p>]</span>          <span class=c>; eax = i
</span><span class=c></span>            <span class=no>sum</span> <span class=err>+=</span> <span class=no>i</span><span class=c>;                              
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100A3</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>eax</span>              <span class=c>; sum += i
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100A5</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>edx</span>              <span class=c>; sum += i + 1
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100A7</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>rdx</span><span class=err>+</span><span class=mi>1</span><span class=p>]</span>          <span class=c>; eax = i + 2
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100AA</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>eax</span>              <span class=c>; sum += i + 2;
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100AC</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>rdx</span><span class=err>+</span><span class=mi>2</span><span class=p>]</span>          <span class=c>; eax = i + 3
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100AF</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>eax</span>              <span class=c>; sum += i + 3;
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100B1</span>  <span class=no>add</span>         <span class=no>edx</span><span class=p>,</span><span class=mi>4</span>                <span class=c>; i += 4
</span><span class=c></span>        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c>; i &lt; 1024; i++)             
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC87100B4</span>  <span class=no>cmp</span>         <span class=no>edx</span><span class=p>,</span><span class=mi>401</span><span class=no>h</span>             
<span class=mi>00007</span><span class=no>FFCC87100BA</span>  <span class=no>jl</span>          <span class=mi>00007</span><span class=no>FFCC87100A0</span>     
</code></pre></div><p>As you can see, loop unrolling have been applied, the loop body repeated 4 times. JIT-x64 is able to repeat the loop body 2, 3 or 4 times (it depends on the amount of iterations). Unfortunately, if there are no 2, 3, 4 in the set of iterations amount divisors, loop unrolling will not be applied.</p><h4 id=ryujit>RyuJIT</h4><p>What&rsquo;s about new RyuJIT? Let&rsquo;s look to the assembler code:</p><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm>        <span class=nf>int</span> <span class=no>sum</span> <span class=err>=</span> <span class=mi>0</span><span class=c>;                            
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC86E0091</span>  <span class=no>sub</span>         <span class=no>rsp</span><span class=p>,</span><span class=mi>20</span><span class=no>h</span>           
<span class=mi>00007</span><span class=no>FFCC86E0095</span>  <span class=no>xor</span>         <span class=no>esi</span><span class=p>,</span><span class=no>esi</span>           
        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c>; i &lt; 1024; i++)          
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC86E0097</span>  <span class=no>xor</span>         <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>           
            <span class=no>sum</span> <span class=err>+=</span> <span class=no>i</span><span class=c>;                           
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC86E0099</span>  <span class=no>add</span>         <span class=no>esi</span><span class=p>,</span><span class=no>eax</span>           <span class=c>; sum += i
</span><span class=c></span>        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c>; i &lt; 1024; i++)          
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC86E009B</span>  <span class=no>inc</span>         <span class=no>eax</span>               <span class=c>; i++
</span><span class=c></span><span class=mi>00007</span><span class=no>FFCC86E009D</span>  <span class=no>cmp</span>         <span class=no>eax</span><span class=p>,</span><span class=mi>400</span><span class=no>h</span>          
<span class=mi>00007</span><span class=no>FFCC86E00A2</span>  <span class=no>jl</span>          <span class=mi>00007</span><span class=no>FFCC86E0099</span>  
</code></pre></div><p>A sad situation: RyuJIT can&rsquo;t unroll even the simplest loop. The cause is the following: RyuJIT is based off of the same codebase as JIT-x86 (see: <a href=http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx>RyuJIT: The next-generation JIT compiler for .NET</a>).</p><h3 id=summary>Summary</h3><p>RyuJIT allows us to use SIMD-instructions and reduces the JIT compilation time. Unfortunately, the performance of the resulted code with the transition to the new JIT can reduce. Note, there is no the final RuyJIT, the experiment was conducted for CTP5. Let&rsquo;s hope that the RyuJIT release will include smart code optimizations.</p><h3 id=links>Links</h3><ul><li><a href=http://aakinshin.net/en/blog/dotnet/unrolling-of-small-loops-in-different-jit-versions/>Unrolling of small loops in different JIT versions</a></li><li><a href=http://en.wikipedia.org/wiki/Loop_unrolling>Wikipedia: Loop unrolling</a></li><li><a href=https://www.researchgate.net/publication/2449271_Generalized_Loop-Unrolling_a_Method_for_Program_Speed-Up>J. C. Huang, T. Leng, Generalized Loop-Unrolling: a Method for Program Speed-Up (1998)</a></li><li><a href=https://en.wikipedia.org/wiki/Branch_predictor>Wikipedia: Branch prediction</a></li><li><a href=https://en.wikipedia.org/wiki/Instruction-level_parallelism>Wikipedia: Instruction-level parallelism</a></li><li><a href=http://en.wikipedia.org/wiki/Inline_expansion>Wikipedia: Inline expansion</a></li><li><a href=http://en.wikipedia.org/wiki/CPU_cache#Cache_miss>Wikipedia: Cache miss</a></li><li><a href=http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful>StackOverflow: http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful</a></li><li><a href=http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx>Blogs.Msdn: RyuJIT: The next-generation JIT compiler for .NET</a></li></ul><br><br><div class=mx-auto>Share:<div class=faicon><a href="https://twitter.com/intent/tweet?text=RyuJIT%20CTP5%20and%20loop%20unrolling&url=https%3a%2f%2faakinshin.net%2fposts%2fryujit-ctp5-and-loop-unrolling%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x" title=Twitter></i></a></div><div class=faicon><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fryujit-ctp5-and-loop-unrolling%2f&title=RyuJIT%20CTP5%20and%20loop%20unrolling" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=faicon><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fryujit-ctp5-and-loop-unrolling%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=faicon><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fposts%2fryujit-ctp5-and-loop-unrolling%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=faicon><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fposts%2fryujit-ctp5-and-loop-unrolling%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=faicon><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fryujit-ctp5-and-loop-unrolling%2f&title=RyuJIT%20CTP5%20and%20loop%20unrolling" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2020 Andrey Akinshin | <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.ea4f51ac7f59c8e13f4df787df946eb1a447174ce2f1fc5349483de93a607ecb.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script></body></html>