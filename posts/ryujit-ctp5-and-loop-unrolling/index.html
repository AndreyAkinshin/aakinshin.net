<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.123.3"><meta name=author content='Andrey Akinshin'><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content='Programming,.NET,C#,JIT,RyuJIT,LoopUnrolling'><title>RyuJIT CTP5 and loop unrolling | Andrey Akinshin</title>
<meta name=description content="RyuJIT will be available soon. It is a next generation JIT-compiler for .NET-applications. Microsoft likes to tell us about the benefits of SIMD using and JIT-compilation time reducing. But what about basic code optimization which is usually applying by a c..."><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.25504b87a17cfaf1c000a5bcca42b1c4888fa4efc097d640d9139388b3e67e55.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-2 xs:px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/posts/>Posts</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/research/>Research</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/library/>Library</a></div><div class="flex nav-item h-12 items-center"><a class=text-white href=https://aakinshin.net/about/>About</a></div></div><button id=theme-toggle type=button title="Alt+Click to match OS color theme" class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><div class=main-post><h1 class=blog-post-title id=post-title>RyuJIT CTP5 and Loop Unrolling</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai text-accent-l dark:text-front-d"><title>Date</title><use xlink:href="/img/fa/all.svg#calendar-days"/></svg>
<time datetime=2015-03-01>March 1, 2015</time><svg class="fai ml-3 text-accent-l dark:text-front-d"><title>Tags</title><use xlink:href="/img/fa/all.svg#tag"/></svg><div class="flex flex-wrap gap-y-1"><a class=label-link href=https://aakinshin.net/tags/programming/>Programming</a>
<a class=label-link href=https://aakinshin.net/tags/dotnet/>.NET</a>
<a class=label-link href=https://aakinshin.net/tags/cs/>C#</a>
<a class=label-link href=https://aakinshin.net/tags/jit/>JIT</a>
<a class=label-link href=https://aakinshin.net/tags/ryujit/>RyuJIT</a>
<a class=label-link href=https://aakinshin.net/tags/loopunrolling/>LoopUnrolling</a></div></div><br><div class=main-content><p>RyuJIT will be available soon. It is a next generation JIT-compiler for .NET-applications. Microsoft likes to tell us about the benefits of SIMD using and JIT-compilation time reducing. But what about basic code optimization which is usually applying by a compiler? Today we talk about the loop unrolling (unwinding) optimization. In general, in this type of code optimization, the code</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>1024</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span></code></pre></div><p>transforms to</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>1024</span><span class=p>;</span> <span class=n>i</span> <span class=p>+=</span> <span class=m>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=m>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=m>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>i</span> <span class=p>+</span> <span class=m>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Such approach can significantly increase performance of your code. So, what&rsquo;s about loop unrolling in .NET?</p><h3 id=common-theory>Common theory</h3><p>First of all, let&rsquo;s talk about how loop unrolling affects to our applications.</p><h4 id=advantages>Advantages</h4><ul><li>We are reducing the number of machine commands (iterator increments).</li><li>Reduced overheads of <a href=https://en.wikipedia.org/wiki/Branch_predictor>branch prediction</a>.</li><li>We increase the possibility of using <a href=https://en.wikipedia.org/wiki/Instruction-level_parallelism>instruction-level parallelism</a>.</li><li>We can apply additional code improvements in conjunction with other optimizations (e. g. , <a href=http://en.wikipedia.org/wiki/Inline_expansion>inlining</a>).</li></ul><h4 id=disadvantages>Disadvantages</h4><ul><li>The source code size increased.</li><li>Sometimes, due to the increasing size of the instruction amount, it is impossible to simultaneously apply loop unrolling and inlining.</li><li>Possible <a href=http://en.wikipedia.org/wiki/CPU_cache#Cache_miss>cache misses</a> in the commands cache.</li><li>Possible increased register usage in a single iteration (we may not have enough registers, other optimizations can not apply because of registers deficit).</li><li>If there is branching in the iteration, loop unrolling can adversely affect to other optimizations.</li></ul><h4 id=conclusion>Conclusion</h4><p>Loop unrolling is a very powerful tool for optimization, but only if we use it wisely. I don&rsquo;t recommended apply it yourself: it will reduce the readability of the source code and it can adversely affect to use other optimizations. It is best to leave this approach to the compiler. It is important that your compiler could do loop unrolling competently.</p><h3 id=experiments>Experiments</h3><h4 id=source-code>Source code</h4><p>We will work with a very simple loop which is very easy to unroll:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=kt>int</span> <span class=n>sum</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=p>=</span> <span class=m>0</span><span class=p>;</span> <span class=n>i</span> <span class=p>&lt;</span> <span class=m>1024</span><span class=p>;</span> <span class=n>i</span><span class=p>++)</span>
</span></span><span class=line><span class=cl>    <span class=n>sum</span> <span class=p>+=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Console</span><span class=p>.</span><span class=n>WriteLine</span><span class=p>(</span><span class=n>sum</span><span class=p>);</span>
</span></span></code></pre></div><p>Note, the amount of iterations is known beforehand and it is equal to 2<sup>10</sup>. It is very important because it greatly simplifies usage of the considered optimization.</p><h4 id=jit-x86>JIT-x86</h4><p>Let&rsquo;s run the code with JIT-x86 and look to the assembler code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>        <span class=nf>int</span> <span class=no>sum</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>;                    
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>EE0052</span>  <span class=no>in</span>          <span class=no>al</span><span class=p>,</span><span class=no>dx</span>             
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>EE0053</span>  <span class=no>push</span>        <span class=no>esi</span>               
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>EE0054</span>  <span class=no>xor</span>         <span class=no>esi</span><span class=p>,</span><span class=no>esi</span>           
</span></span><span class=line><span class=cl>        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>; i &lt; 1024; i++)  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>EE0056</span>  <span class=no>xor</span>         <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>           
</span></span><span class=line><span class=cl>            <span class=no>sum</span> <span class=err>+=</span> <span class=no>i</span><span class=c1>;                   
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>EE0058</span>  <span class=no>add</span>         <span class=no>esi</span><span class=p>,</span><span class=no>eax</span>           <span class=c1>; sum += i
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>; i &lt; 1024; i++)  
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>EE005A</span>  <span class=no>inc</span>         <span class=no>eax</span>               <span class=c1>; i++
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00</span><span class=nf>EE005B</span>  <span class=no>cmp</span>         <span class=no>eax</span><span class=p>,</span><span class=mi>400</span><span class=no>h</span>          
</span></span><span class=line><span class=cl><span class=mi>00</span><span class=no>EE0060</span>  <span class=no>jl</span>          <span class=mi>00</span><span class=no>EE0058</span>          
</span></span></code></pre></div><p>As you can see, JIT-x86 didn&rsquo;t apply loop unrolling. You should understood, the 32-bit version of JIT-compiler is quite primitive. JIT-x86 apply loop unrolling rarely, only if specific conditions are satisfied.</p><h4 id=jit-x64>JIT-x64</h4><p>Next, try the experiment with the 64-bit version of JIT-compiler:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>        <span class=nf>int</span> <span class=no>sum</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>;                               
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC8710090</span>  <span class=no>sub</span>         <span class=no>rsp</span><span class=p>,</span><span class=mi>28</span><span class=no>h</span>              
</span></span><span class=line><span class=cl>        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>; i &lt; 1024; i++)             
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC8710094</span>  <span class=no>xor</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>ecx</span>              
</span></span><span class=line><span class=cl><span class=mi>00007</span><span class=no>FFCC8710096</span>  <span class=no>mov</span>         <span class=no>edx</span><span class=p>,</span><span class=mi>1</span>                <span class=c1>; edx = i + 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC871009B</span>  <span class=no>nop</span>         <span class=no>dword</span> <span class=no>ptr</span> <span class=p>[</span><span class=no>rax</span><span class=err>+</span><span class=no>rax</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=mi>00007</span><span class=no>FFCC87100A0</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>rdx-1</span><span class=p>]</span>          <span class=c1>; eax = i
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>sum</span> <span class=err>+=</span> <span class=no>i</span><span class=c1>;                              
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100A3</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>eax</span>              <span class=c1>; sum += i
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100A5</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>edx</span>              <span class=c1>; sum += i + 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100A7</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>rdx</span><span class=err>+</span><span class=mi>1</span><span class=p>]</span>          <span class=c1>; eax = i + 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100AA</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>eax</span>              <span class=c1>; sum += i + 2;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100AC</span>  <span class=no>lea</span>         <span class=no>eax</span><span class=p>,[</span><span class=no>rdx</span><span class=err>+</span><span class=mi>2</span><span class=p>]</span>          <span class=c1>; eax = i + 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100AF</span>  <span class=no>add</span>         <span class=no>ecx</span><span class=p>,</span><span class=no>eax</span>              <span class=c1>; sum += i + 3;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100B1</span>  <span class=no>add</span>         <span class=no>edx</span><span class=p>,</span><span class=mi>4</span>                <span class=c1>; i += 4
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>; i &lt; 1024; i++)             
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC87100B4</span>  <span class=no>cmp</span>         <span class=no>edx</span><span class=p>,</span><span class=mi>401</span><span class=no>h</span>             
</span></span><span class=line><span class=cl><span class=mi>00007</span><span class=no>FFCC87100BA</span>  <span class=no>jl</span>          <span class=mi>00007</span><span class=no>FFCC87100A0</span>     
</span></span></code></pre></div><p>As you can see, loop unrolling have been applied, the loop body repeated 4 times. JIT-x64 is able to repeat the loop body 2, 3 or 4 times (it depends on the amount of iterations). Unfortunately, if there are no 2, 3, 4 in the set of iterations amount divisors, loop unrolling will not be applied.</p><h4 id=ryujit>RyuJIT</h4><p>What&rsquo;s about new RyuJIT? Let&rsquo;s look to the assembler code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl>        <span class=nf>int</span> <span class=no>sum</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>;                            
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC86E0091</span>  <span class=no>sub</span>         <span class=no>rsp</span><span class=p>,</span><span class=mi>20</span><span class=no>h</span>           
</span></span><span class=line><span class=cl><span class=mi>00007</span><span class=no>FFCC86E0095</span>  <span class=no>xor</span>         <span class=no>esi</span><span class=p>,</span><span class=no>esi</span>           
</span></span><span class=line><span class=cl>        <span class=no>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>; i &lt; 1024; i++)          
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC86E0097</span>  <span class=no>xor</span>         <span class=no>eax</span><span class=p>,</span><span class=no>eax</span>           
</span></span><span class=line><span class=cl>            <span class=no>sum</span> <span class=err>+=</span> <span class=no>i</span><span class=c1>;                           
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC86E0099</span>  <span class=no>add</span>         <span class=no>esi</span><span class=p>,</span><span class=no>eax</span>           <span class=c1>; sum += i
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nf>for</span> <span class=p>(</span><span class=no>int</span> <span class=no>i</span> <span class=err>=</span> <span class=mi>0</span><span class=c1>; i &lt; 1024; i++)          
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC86E009B</span>  <span class=no>inc</span>         <span class=no>eax</span>               <span class=c1>; i++
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=err>00007</span><span class=nf>FFCC86E009D</span>  <span class=no>cmp</span>         <span class=no>eax</span><span class=p>,</span><span class=mi>400</span><span class=no>h</span>          
</span></span><span class=line><span class=cl><span class=mi>00007</span><span class=no>FFCC86E00A2</span>  <span class=no>jl</span>          <span class=mi>00007</span><span class=no>FFCC86E0099</span>  
</span></span></code></pre></div><p>A sad situation: RyuJIT can&rsquo;t unroll even the simplest loop. The cause is the following: RyuJIT is based off of the same codebase as JIT-x86 (see: <a href=http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx>RyuJIT: The next-generation JIT compiler for .NET</a>).</p><h3 id=summary>Summary</h3><p>RyuJIT allows us to use SIMD-instructions and reduces the JIT compilation time. Unfortunately, the performance of the resulted code with the transition to the new JIT can reduce. Note, there is no the final RuyJIT, the experiment was conducted for CTP5. Let&rsquo;s hope that the RyuJIT release will include smart code optimizations.</p><h3 id=links>Links</h3><ul><li><a href=http://aakinshin.net/en/blog/dotnet/unrolling-of-small-loops-in-different-jit-versions/>Unrolling of small loops in different JIT versions</a></li><li><a href=http://en.wikipedia.org/wiki/Loop_unrolling>Wikipedia: Loop unrolling</a></li><li><a href=https://www.researchgate.net/publication/2449271_Generalized_Loop-Unrolling_a_Method_for_Program_Speed-Up>J. C. Huang, T. Leng, Generalized Loop-Unrolling: a Method for Program Speed-Up (1998)</a></li><li><a href=https://en.wikipedia.org/wiki/Branch_predictor>Wikipedia: Branch prediction</a></li><li><a href=https://en.wikipedia.org/wiki/Instruction-level_parallelism>Wikipedia: Instruction-level parallelism</a></li><li><a href=http://en.wikipedia.org/wiki/Inline_expansion>Wikipedia: Inline expansion</a></li><li><a href=http://en.wikipedia.org/wiki/CPU_cache#Cache_miss>Wikipedia: Cache miss</a></li><li><a href=http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful>StackOverflow: http://stackoverflow.com/questions/2349211/when-if-ever-is-loop-unrolling-still-useful</a></li><li><a href=http://blogs.msdn.com/b/dotnet/archive/2013/09/30/ryujit-the-next-generation-jit-compiler.aspx>Blogs.Msdn: RyuJIT: The next-generation JIT compiler for .NET</a></li></ul></div></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}));function toggleTheme(e){e?(document.documentElement.classList.add("dark"),themeToggleLightIcon.classList.remove("hidden"),themeToggleDarkIcon.classList.add("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")}),imagesLight.forEach(e=>{e.classList.add("hidden")})):(document.documentElement.classList.remove("dark"),themeToggleDarkIcon.classList.remove("hidden"),themeToggleLightIcon.classList.add("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")}),imagesDark.forEach(e=>{e.classList.add("hidden")}))}themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),event.altKey?(localStorage.removeItem("color-theme"),toggleTheme(window.matchMedia("(prefers-color-scheme: dark)").matches)):localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))}),window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{if(localStorage.getItem("color-theme")===null){const t=e.matches?"dark":"light";toggleTheme(t==="dark")}})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center">© 2013—2024 <span class=whitespace-nowrap>Andrey Akinshin</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer></body></html>