<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.74.3"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Statistics,Quantile"><title>Sfakianakis-Verginis quantile estimator | Andrey Akinshin</title><meta name=description content="A brief description of the Sfakianakis-Verginis quantile estimator"><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><link href=/css/lumen-bootstrap.min.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/slate-bootstrap.min.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><link href=/css/syntax-light.css theme=light rel=stylesheet type=text/css media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)"><link href=/css/syntax-dark.css theme=dark rel=stylesheet type=text/css media="(prefers-color-scheme: dark)"><script src=https://aakinshin.net/js/theme-before.min.26d61b7027fe55e642f0001cef94cb75b567d721086492aab6b4e32d9ee7811d.js></script><script type=module src=https://aakinshin.net/js/dark-mode-toggle.min.882998740b9c4c24677576b997bde5a487246e2e3bd72128a0e922eaa59db029.mjs></script><link href=https://aakinshin.net/css/fontawesome-all.min.50da8736f05b35aac9691de67fe993cbe01b7d88fcf0cb682c3a8f39933fe4a3.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/about.min.2a76db7cc14055b3bafacc363f453917ab54a818a7db2a0a9b2409c0f6bf07c5.css rel=stylesheet type=text/css media=all><link href=https://aakinshin.net/css/blog.min.ae812fc71daf5160d927febda5a991cee6c361345e3f685d3736931ed7537986.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZVB6MXSX32"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-ZVB6MXSX32');</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-41419012-5"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41419012-5');</script><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(28700916,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/28700916 style=position:absolute;left:-9999px alt></div></noscript><script src=/js/jquery-3.3.1.slim.min.js></script></head><body><div class=bg-primary><div class="container bg-primary"><nav class="navbar navbar-expand-sm navbar-dark bg-primary"><ul class="navbar-nav mr-auto"><li class=nav-item><a class=nav-link id=nav-link-blog href=https://aakinshin.net/><i class="fas fa-home" title=Home style=color:#fff></i></a></li><li class=nav-item><a class=nav-link id=nav-link-posts href=https://aakinshin.net/posts/>Posts</a></li><li class=nav-item><a class=nav-link id=nav-link-about href=https://aakinshin.net/about/>About</a></li><li class=nav-item><a class=nav-link id=nav-link-pdnb href=https://aakinshin.net/prodotnetbenchmarking/>Pro .NET Benchmarking</a></li></ul><ul class="navbar-nav ml-auto"><li class=nav-item><dark-mode-toggle permanent=true></dark-mode-toggle></li></ul></nav></div></div><div class=container><main id=main><div class=blog-main><div class="blog-post table-sm"><h1 class=blog-post-title id=post-title>Sfakianakis-Verginis quantile estimator</h1><span class=blog-post-meta><div class=faicon><i class="far fa-calendar-alt"></i></div><time datetime=2021-03-09>March 9, 2021</time>
&nbsp;&nbsp;
<i class="fas fa-tag"></i>&nbsp;
<a href=https://aakinshin.net/tags/statistics/ class="badge badge-info">Statistics</a>
<a href=https://aakinshin.net/tags/quantile/ class="badge badge-info">Quantile</a></span><br><br><p>There are dozens of different ways to estimate quantiles.
One of these ways is to use the Sfakianakis-Verginis quantile estimator.
To be more specific, it&rsquo;s a family of three estimators.
If we want to estimate the <span class="math inline">\(p^\textrm{th}\)</span> quantile for sample <span class="math inline">\(X\)</span>,
we can use one of the following equations:</p><p><span class="math display">\[\begin{split}
\operatorname{SV1}_p =&
\frac{B_0}{2} \big( X_{(1)}+X_{(2)}-X_{(3)} \big) +
\sum_{i=1}^{n} \frac{B_i+B_{i-1}}{2} X_{(i)} +
\frac{B_n}{2} \big(- X_{(n-2)}+X_{(n-1)}-X_{(n)} \big),\\
\operatorname{SV2}_p =& \sum_{i=1}^{n} B_{i-1} X_{(i)} + B_n \cdot \big(2X_{(n)} - X_{(n-1)}\big),\\
\operatorname{SV3}_p =& \sum_{i=1}^n B_i X_{(i)} + B_0 \cdot \big(2X_{(1)}-X_{(2)}\big).
\end{split}
\]</span></p><p>where <span class="math inline">\(B_i = B(i; n, p)\)</span> is probability mass function os the binomial distribution <span class="math inline">\(B(n, p)\)</span>,
<span class="math inline">\(X_{(i)}\)</span> are order statistics of the sample <span class="math inline">\(X\)</span>.</p><p>In this post, I derive these equations following the paper
<a href=https://doi.org/10.1080/03610910701790491>&ldquo;A new family of nonparametric quantile estimators&rdquo;</a>
by Michael E. Sfakianakis and Dimitris G. Verginis.
Also, I add some additional explanations,
reconstruct missing steps,
simplify the final equations,
and provide reference implementations in C# and R.</p><h3 id=preparation>Preparation</h3><p>Consider sample <span class="math inline">\(X = \{ X_1, X_2, \ldots, X_n \}\)</span> (<span class="math inline">\(n \geq 3\)</span>).
Let <span class="math inline">\(X_{(1)}, X_{(2)}, \ldots, X_{(n)}\)</span> be the order statistics of this sample
(<span class="math inline">\(X_{(k)}\)</span> is the <span class="math inline">\(k^\textrm{th}\)</span> smallest element).
Now let&rsquo;s build the following intervals:</p><p><span class="math display">\[S_0 = \big(L, X_{(1)} \big),\;
S_1 = \big[X_{(1)}, X_{(2)} \big),
\ldots,
S_{n-1} = \big[X_{(n-1)},X_{n} \big),\;
S_{(n)} = \big[X_{(n)}, U \big)
\]</span></p><p>where <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> are lower and upper bounds for <span class="math inline">\(X\)</span> values (<span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span> could be equal to <span class="math inline">\(-\infty\)</span> and <span class="math inline">\(\infty\)</span>).</p><div class=row><div class=mx-auto><a href=/posts/sfakianakis-verginis-quantile-estimator/img/segments.png target=_blank alt=segments><img class="mx-auto d-block img-fluid" width=800 src=/posts/sfakianakis-verginis-quantile-estimator/img/segments.png></a></div></div><br><p>We want to estimate <span class="math inline">\(p^\textrm{th}\)</span> quantile <span class="math inline">\(Q_p\)</span>.
Obviously, <span class="math inline">\(Q_p\)</span> should belong to one of the <span class="math inline">\(S_i\)</span> intervals (because they cover all possible <span class="math inline">\(Q_p\)</span> values).
With the help of <span class="math inline">\(Q_p\)</span>, we can introduce variables <span class="math inline">\(\delta_i\)</span>:</p><p><span class="math display">\[\delta_i =
\begin{cases}
1 & \textrm{if}\; X_i \leq Q_p,\\
0 & \textrm{if}\; X_i > Q_p.
\end{cases}
\]</span></p><p>Since <span class="math inline">\(Q_p\)</span> is the <span class="math inline">\(p^\textrm{th}\)</span> quantile,
the probability of <span class="math inline">\((X_i \leq Q_p)\)</span> is <span class="math inline">\(p\)</span> and
the probability of <span class="math inline">\((X_i > Q_p)\)</span> is <span class="math inline">\(1-p\)</span>.
Thus, <span class="math inline">\(\delta_i\)</span> belongs to the <a href=https://en.wikipedia.org/wiki/Bernoulli_distribution>bernoulli distribution</a>:
<span class="math inline">\(\delta_i \sim \textrm{Bernoulli}(p)\)</span>.</p><p>Next, consider the sum of <span class="math inline">\(\delta_i\)</span> values:</p><p><span class="math display">\[N = \delta_1 + \delta_2 + \ldots + \delta_{n-1} + \delta_n.
\]</span></p><p>Since <span class="math inline">\(\delta_i\)</span> are independent variables from the Bernoulli distribution,
their sum belongs to the <a href=https://en.wikipedia.org/wiki/Binomial_distribution>binomial distribution</a>:
<span class="math inline">\(N \sim \textrm{Binomial(n, p)}\)</span>.
Now we can get the probability of <span class="math inline">\(Q_p \in S_i\)</span>:</p><p><span class="math display">\[P(Q_p \in S_i) = P(N = i) = B(i; n, p) = {n \choose k} p^k (1-p)^{(n-k)}.
\]</span></p><p>Let <span class="math inline">\(Q'_{p,i}\)</span> be a point estimator of <span class="math inline">\(Q_p\)</span> conditioned on the event <span class="math inline">\(Q_p \in S_i\)</span>.
With the help of <span class="math inline">\(Q'_{p,i}\)</span>, we could introduce the Sfakianakis-Verginis quantile estimator:</p><p><span class="math display">\[\operatorname{SV}_p = \operatorname{E}(Q'_p) = \sum_{i=0}^n P(Q_p \in S_i) \cdot Q'_{p,i}.
\]</span></p><p>There are three variations of the Sfakianakis-Verginis quantile estimator depending on the definition of <span class="math inline">\(Q'_{p,i}\)</span>.</p><h3 id=sv1>SV1</h3><p>The first approach assumes that the <span class="math inline">\(p^\textrm{th}\)</span> quantile is in the middle of the <span class="math inline">\(i^\textrm{th}\)</span> segment:</p><p><span class="math display">\[Q'_{p,i} = \frac{X_{(i)}+X_{(i+1)}}{2}\quad \textrm{for}\;\; i=1..n-1.
\]</span></p><p>If we don&rsquo;t know values of <span class="math inline">\(L\)</span> and <span class="math inline">\(U\)</span>, we need a way to define <span class="math inline">\(Q'_{p,i}\)</span> for <span class="math inline">\(i=0\)</span> and <span class="math inline">\(i=n\)</span>.
The author suggests using these assumptions:</p><p><span class="math display">\[Q'_{p,0}-Q'_{p,1} = Q'_{p,1} - Q'_{p,2}; \quad Q'_{p,n} - Q'_{p,n-1} = Q'_{p,n-1}-Q'_{p,n-2}.
\]</span></p><p>Thus, we have:</p><p><span class="math display">\[\begin{split}
Q'_{p,0} = & 2Q'_{p,1} - Q'_{p,2}
&= 2 \frac{X_{(1)}+X_{(2)}}{2} - \frac{X_{(2)}+X_{(3)}}{2}
&= \frac{2X_{(1)}+X_{(2)}-X_{(3)}}{2},\\
Q'_{p,n} = & 2Q'_{p,n-1} - Q'_{p,n-2}
&= 2 \frac{X_{(n-1)}+X_{(n)}}{2} - \frac{X_{(n-2)}+X_{(n-1)}}{2}
&= \frac{2X_{(n)}+X_{(n-1)}-X_{(n-2)}}{2}.
\end{split}
\]</span></p><p>Now we can start deriving <span class="math inline">\(\operatorname{SV1}_p\)</span>:</p><p><span class="math display">\[\begin{split}
\operatorname{SV1}_p
& = \operatorname{E}(Q'_{p,i}) = \sum_{i=0}^n P(Q_p \in S_i) \cdot Q'_{p,i} = \\
& = \sum_{i=0}^n B(i;n,p) Q'_{p,i} = \\
& = B(0;n,p) Q'_{p,0} + \sum_{i=1}^{n-1} B(i;n,p) Q'_{p,i} + B(n;n,p) Q'_{p,n} \\
\end{split}
\]</span></p><p>It gives us the following expression:</p><p><span class="math display">\[\begin{split}
\operatorname{SV1}_p =
B(0;n,p) \frac{2X_{(1)}+X_{(2)}-X_{(3)}}{2} +
B(1;n,p) \frac{X_{(1)}+X_{(2)}}{2} +
B(2;n,p) \frac{X_{(2)}+X_{(3)}}{2} + \ldots + \\+
B(n-2;n,p) \frac{X_{(n-2)}+X_{(n-1)}}{2} +
B(n-1;n,p) \frac{X_{(n-1)}+X_{(n)}}{2} +
B(n;n,p) \frac{2X_{(n)}+X_{(n-1)}-X_{(n-2)}}{2}.
\end{split}
\]</span></p><p>By regrouping the equation members, we get the final result from the paper:</p><p><span class="math display">\[\begin{split}
\operatorname{SV1}_p =
& \frac{2B(0;n,p)+B(1;n,p)}{2} X_{(1)} + \frac{B(0;n,p)}{2}X_{(2)} - \frac{B(0;n,p)}{2}X_{(3)}\\
& +\sum_{i=2}^{n-1} \frac{B(i;n,p)+B(i-1;n,p)}{2} X_{(i)} \\
& -\frac{B(n;n,p)}{2} X_{(n-2)} + \frac{B(n;n,p)}{2} X_{(n-1)} + \frac{2B(n;n,p)+B(n-1;n,p)}{2}X_{(n)}
\end{split}
\]</span></p><h3 id=sv2>SV2</h3><p>The second approach assumes that the <span class="math inline">\(p^\textrm{th}\)</span> quantile is in the right endpoint of the <span class="math inline">\(i^\textrm{th}\)</span> segment:</p><p><span class="math display">\[Q'_{p,i} = X_{(i+1)}\quad \textrm{for}\;\; i=0..n-1.
\]</span></p><p>To get the value of <span class="math inline">\(Q'_{p,n}\)</span>, we use an assumption from the <span class="math inline">\(\operatorname{SV1}_p\)</span> section:</p><p><span class="math display">\[Q'_{p,n} - Q'_{p,n-1} = Q'_{p,n-1}-Q'_{p,n-2}
\]</span></p><p>which can be transformed to</p><p><span class="math display">\[Q'_{p,n} = 2Q'_{p,n-1} - Q'_{p,n-2} = 2X_{(n)} - X_{(n-1)}.
\]</span></p><p>Using <span class="math inline">\(\operatorname{SV2}_p = \sum_{i=0}^n B(i;n,p) Q'_{p,i}\)</span>, we get:</p><p><span class="math display">\[\operatorname{SV2}_p = \sum_{i=0}^{n-1} B(i;n,p) X_{(i+1)} + (2X_{(n)} - X_{(n-1)}) B(n;n,p)
\]</span></p><h3 id=sv3>SV3</h3><p>The third approach assumes that the <span class="math inline">\(p^\textrm{th}\)</span> quantile is in the left endpoint of the <span class="math inline">\(i^\textrm{th}\)</span> segment:</p><p><span class="math display">\[Q'_{p,i} = X_{(i)}\quad \textrm{for}\;\; i=1..n.
\]</span></p><p>To get the value of <span class="math inline">\(Q'_{p,0}\)</span>, we use an assumption from the <span class="math inline">\(\operatorname{SV1}_p\)</span> section:</p><p><span class="math display">\[Q'_{p,0}-Q'_{p,1} = Q'_{p,1} - Q'_{p,2}
\]</span></p><p>which can be transformed to</p><p><span class="math display">\[Q'_{p,0} = 2Q'_{p,1} - Q'_{p,2} = 2X_{(1)}-X_{(2)}.
\]</span></p><p>Using <span class="math inline">\(\operatorname{SV3}_p = \sum_{i=0}^n B(i;n,p) Q'_{p,i}\)</span>, we get:</p><p><span class="math display">\[\operatorname{SV3}_p = \sum_{i=1}^n B(i;n,p) X_{(i)} + (2X_{(1)}-X_{(2)}) B(0;n,p)
\]</span></p><h3 id=simplification>Simplification</h3><p>In my opinion, the above equations (that match the original paper) are too bulky.
Let&rsquo;s simplify them!
We can notice that we work with the same Binomial distribution <span class="math inline">\(B(n, p)\)</span>.
What the point of writing the arguments <span class="math inline">\(n\)</span> and <span class="math inline">\(p\)</span> each time?
This just makes it difficult to read the equation!
(If you read the original paper, you may notice that the authors are also confused with this notation;
sometimes they write <span class="math inline">\(B(i;p,n)\)</span> or <span class="math inline">\(B(i;p)\)</span> instead of <span class="math inline">\(B(i;n,p)\)</span>.)
Let&rsquo;s denote <span class="math inline">\(B(i;p,n)\)</span> as <span class="math inline">\(B_i\)</span>:</p><p><span class="math display">\[B_i = B(i;p,n).
\]</span></p><p>Now we could rewrite the first equation in a shorter form:</p><p><span class="math display">\[\begin{split}
SV1_p = & \frac{2B_0+B_1}{2}X_{(1)} + \frac{B_0}{2} X_{(2)} - \frac{B_0}{2} X_{(3)}\\
& + \sum_{i=2}^{n-1} \frac{B_i+B_{i-1}}{2} X_{(i)}\\
& -\frac{B_n}{2} X_{(n-2)} + \frac{B_n}{2} X _{(n-1)} + \frac{2B_n + B_{n-1}}{2} X_{(n)}
\end{split}
\]</span></p><p>Currently, the sum part <span class="math inline">\(\sum_{i=2}^{n-1} \frac{B_i+B_{i-1}}{2} X_{(i)}\)</span> enumerates <span class="math inline">\(i\)</span> from <span class="math inline">\(2\)</span> to <span class="math inline">\(n-1\)</span>.
The part could &ldquo;absorb&rdquo; the <span class="math inline">\(\frac{B_i+B_{i-1}}{2} X_{(i)}\)</span> expression for <span class="math inline">\(i=1\)</span> and for <span class="math inline">\(i=n\)</span> from other members of the equation:</p><p><span class="math display">\[\operatorname{SV1}_p =
\frac{B_0}{2} \big( X_{(1)}+X_{(2)}-X_{(3)} \big) +
\sum_{i=1}^{n} \frac{B_i+B_{i-1}}{2} X_{(i)} +
\frac{B_n}{2} \big(- X_{(n-2)}+X_{(n-1)}-X_{(n)} \big)
\]</span></p><p>In the second equation, we could adjust indexes and enumerate <span class="math inline">\(i\)</span> in range <span class="math inline">\(1..n\)</span> instead of <span class="math inline">\(0..(n-1)\)</span>
(to make it consistent with the first and the third equations):</p><p><span class="math display">\[\operatorname{SV2}_p = \sum_{i=1}^{n} B_{i-1} X_{(i)} + B_n \cdot \big(2X_{(n)} - X_{(n-1)}\big)
\]</span></p><p>In the third equation, we should just replace <span class="math inline">\(B(i;p,n)\)</span> by <span class="math inline">\(B_i\)</span>:</p><p><span class="math display">\[\operatorname{SV3}_p = \sum_{i=1}^n B_i X_{(i)} + B_0 \cdot \big(2X_{(1)}-X_{(2)}\big)
\]</span></p><h3 id=reference-implementation>Reference implementation</h3><p>If you use R, here is the function that you can use in your scripts:</p><div class=highlight><pre class=chroma><code class=language-r data-lang=r><span class=n>sv1quantile</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>n</span> <span class=o>&lt;-</span> <span class=nf>length</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=nf>if </span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=m>2</span><span class=p>)</span>
    <span class=nf>return</span><span class=p>(</span><span class=nf>quantile</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>))</span>
  <span class=n>x</span> <span class=o>&lt;-</span> <span class=nf>sort</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=nf>sapply</span><span class=p>(</span><span class=n>probs</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>B</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=nf>dbinom</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span>
    <span class=nf>B</span><span class=p>(</span><span class=m>0</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>x[1]</span> <span class=o>+</span> <span class=n>x[2]</span> <span class=o>-</span> <span class=n>x[3]</span><span class=p>)</span> <span class=o>/</span> <span class=m>2</span> <span class=o>+</span>
      <span class=nf>sum</span><span class=p>(</span><span class=nf>sapply</span><span class=p>(</span><span class=m>1</span><span class=o>:</span><span class=n>n</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=p>(</span><span class=nf>B</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>+</span> <span class=nf>B</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=m>1</span><span class=p>))</span> <span class=o>*</span> <span class=n>x[i]</span> <span class=o>/</span> <span class=m>2</span><span class=p>))</span> <span class=o>+</span>
      <span class=nf>B</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=o>-</span><span class=n>x[n</span><span class=m>-2</span><span class=n>]</span> <span class=o>+</span> <span class=n>x[n</span><span class=m>-1</span><span class=n>]</span> <span class=o>+</span> <span class=n>x[n]</span><span class=p>)</span> <span class=o>/</span> <span class=m>2</span>
  <span class=p>})</span>
<span class=p>}</span>
<span class=n>sv2quantile</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>n</span> <span class=o>&lt;-</span> <span class=nf>length</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=nf>if </span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=m>2</span><span class=p>)</span>
    <span class=nf>return</span><span class=p>(</span><span class=nf>quantile</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>))</span>
  <span class=n>x</span> <span class=o>&lt;-</span> <span class=nf>sort</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=nf>sapply</span><span class=p>(</span><span class=n>probs</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>B</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=nf>dbinom</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span>
    <span class=nf>sum</span><span class=p>(</span><span class=nf>sapply</span><span class=p>(</span><span class=m>1</span><span class=o>:</span><span class=n>n</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=nf>B</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=m>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>x[i]</span><span class=p>))</span> <span class=o>+</span> <span class=nf>B</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=m>2</span> <span class=o>*</span> <span class=n>x[n]</span> <span class=o>-</span> <span class=n>x[n</span> <span class=o>-</span> <span class=m>1</span><span class=n>]</span><span class=p>)</span>
  <span class=p>})</span>
<span class=p>}</span>
<span class=n>sv3quantile</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>)</span> <span class=p>{</span>
  <span class=n>n</span> <span class=o>&lt;-</span> <span class=nf>length</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=nf>if </span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=m>2</span><span class=p>)</span>
    <span class=nf>return</span><span class=p>(</span><span class=nf>quantile</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>probs</span><span class=p>))</span>
  <span class=n>x</span> <span class=o>&lt;-</span> <span class=nf>sort</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
  <span class=nf>sapply</span><span class=p>(</span><span class=n>probs</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>B</span> <span class=o>&lt;-</span> <span class=nf>function</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=nf>dbinom</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span>
    <span class=nf>sum</span><span class=p>(</span><span class=nf>sapply</span><span class=p>(</span><span class=m>1</span><span class=o>:</span><span class=n>n</span><span class=p>,</span> <span class=nf>function</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=nf>B</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>*</span> <span class=n>x[i]</span><span class=p>))</span> <span class=o>+</span>
      <span class=nf>B</span><span class=p>(</span><span class=m>0</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=m>2</span> <span class=o>*</span> <span class=n>x[1]</span> <span class=o>-</span> <span class=n>x[2]</span><span class=p>)</span>
  <span class=p>})</span>
<span class=p>}</span>
</code></pre></div><p>If you use C#, you can take an implementation from
the latest nightly version (0.3.0-nightly.90+) of <a href=https://github.com/AndreyAkinshin/perfolizer>Perfolizer</a>
(you need <code>SfakianakisVerginis1QuantileEstimator</code>, <code>SfakianakisVerginis2QuantileEstimator</code>, <code>SfakianakisVerginis3QuantileEstimator</code>).</p><h3 id=conclusion>Conclusion</h3><p>The Sfakianakis-Verginis quantile estimator is an interesting way to estimate quantiles.
In this post, we briefly described the idea and looked at the estimator equations.
In future posts, we compare the efficiency of the suggested approach with other quantile estimators.</p><h3 id=references>References</h3><ul><li><b id=Sfakianakis2008>[Sfakianakis2008]</b><br>Sfakianakis, Michael E., and Dimitris G. Verginis. &ldquo;A new family of nonparametric quantile estimators.&rdquo; Communications in Statistics—Simulation and Computation® 37, no. 2 (2008): 337-345.<br><a href=https://doi.org/10.1080/03610910701790491>https://doi.org/10.1080/03610910701790491</a></li></ul><br><br><div class=row><div class="mx-auto share-block"><div class=share-title>Share:</div><div class=share-button><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fsfakianakis-verginis-quantile-estimator%2f&title=Sfakianakis-Verginis%20quantile%20estimator" target=_blank title="Share on Reddit"><i class="fab fa-reddit fa-2x"></i></a></div><div class=share-button><a href="https://twitter.com/intent/tweet?text=Sfakianakis-Verginis%20quantile%20estimator&url=https%3a%2f%2faakinshin.net%2fposts%2fsfakianakis-verginis-quantile-estimator%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><i class="fab fa-twitter fa-2x"></i></a></div><div class=share-button><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fsfakianakis-verginis-quantile-estimator%2f" target=_blank title="Share on HackerNews"><i class="fab fa-hacker-news fa-2x"></i></a></div><div class=share-button><a href="https://facebook.com/sharer.php?u=https%3a%2f%2faakinshin.net%2fposts%2fsfakianakis-verginis-quantile-estimator%2f" rel=nofollow target=_blank title="Share on Facebook"><i class="fab fa-facebook fa-2x"></i></a></div><div class=share-button><a href="http://vk.com/share.php?url=https%3a%2f%2faakinshin.net%2fposts%2fsfakianakis-verginis-quantile-estimator%2f" target=_blank title="Share on VKontakte"><i class="fab fa-vk fa-2x"></i></a></div><div class=share-button><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fsfakianakis-verginis-quantile-estimator%2f&title=Sfakianakis-Verginis%20quantile%20estimator" target=_blank title="Add to Pocket"><i class="fab fa-get-pocket fa-2x"></i></a></div></div></div></div><hr></div></div></main></div><footer class=blog-footer><div class=container><p>&copy; 2013–2021 Andrey Akinshin
|
<a href=https://github.com/AndreyAkinshin><i class="fab fa-github" title=GitHub style=color:#fff></i></a><a href=https://twitter.com/andrey_akinshin><i class="fab fa-twitter" title=Twitter style=color:#fff></i></a><a href=https://aakinshin.net/posts/index.xml><i class="fas fa-rss" title=RSS style=color:#fff></i></a>|
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></p></div></footer><script src=https://aakinshin.net/js/theme-after.min.082780cb948cc57eabbc0d80172a7a5347d5572b599938b4c9876dfd7978b424.js></script><script src=/js/popper.min.js></script><script src=/js/bootstrap.min.js></script><script src=/js/anchor.min.js></script><script src=https://aakinshin.net/js/custom.min.11932490dde776463ed165b345838c701accc0cfdedf2e0868f13415f41f0872.js></script><script>window.MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']],processEscapes:true,processEnvironments:true,},options:{skipHtmlTags:['script','noscript','style','textarea','pre'],ignoreHtmlClass:'tex2jax_ignore',processHtmlClass:'tex2jax_process'}};</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></body></html>