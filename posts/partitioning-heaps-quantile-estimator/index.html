<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.103.0-DEV"><meta name=author content="Andrey Akinshin"><link href=/img/favicon.ico rel=icon type=image/x-icon><meta name=keywords content="Mathematics,Statistics,Research,Quantile,Moving Quantile"><title>Fast implementation of the moving quantile based on the partitioning heaps | Andrey Akinshin</title><meta name=description content="The Hardle-Steiger method to estimate the moving median and its generalization for the moving quantiles"><meta name=twitter:site content="@andrey_akinshin"><meta name=twitter:creator content="@andrey_akinshin"><script>localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?document.documentElement.classList.add("dark"):document.documentElement.classList.remove("dark")</script><link href=https://aakinshin.net/css/main.min.4e2bd537e3ff3b195db9e8858bfb294a8059c352fdfb348daba0e516cda43b0b.css rel=stylesheet type=text/css media=all><link rel=alternate type=application/rss+xml href=https://aakinshin.net/posts/index.xml title="RSS Feed"></head><body><nav><div class="container flex flex-wrap items-center justify-between mx-auto max-w-6xl h-12 px-6"><div class="flex items-center justify-start justify-self-start"><div class="flex nav-item h-12 w-12 items-center justify-center"><a class=text-white href=https://aakinshin.net/><svg class="fai w-5 h-5 pr-0 mb-0.5"><use xlink:href="/img/fa/all.svg#house-chimney"/></svg></a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/posts/>Posts</a></div><div class="flex nav-item h-12 items-center"><a class="px-3 text-white" href=https://aakinshin.net/about/>About</a></div></div><button id=theme-toggle type=button class="nav-item p-3 content-center justify-self-end"><svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001.0 1010.586 10.586z"/></svg><svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentcolor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 011 1v1A1 1 0 119 4V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.12-10.607a1 1 0 010 1.414l-.706.707A1 1 0 1113.536 5.05l.707-.707a1 1 0 011.414.0zM17 11a1 1 0 100-2h-1a1 1 0 100 2h1zm-7 4a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zM5.05 6.464A1 1 0 106.465 5.05l-.708-.707A1 1 0 004.343 5.757l.707.707zm1.414 8.486-.707.707a1 1 0 01-1.414-1.414l.707-.707a1 1 0 011.414 1.414zM4 11a1 1 0 100-2H3a1 1 0 000 2h1z" fill-rule="evenodd" clip-rule="evenodd"/></svg></button></div></nav><div class="main container mx-auto max-w-6xl px-6"><div class=main-post><h1 class=blog-post-title id=post-title>Fast implementation of the moving quantile based on the partitioning heaps</h1><div class="flex flex-wrap justify-start items-center"><svg class="fai text-accent-l dark:text-front-d"><title>Date</title><use xlink:href="/img/fa/all.svg#calendar-days"/></svg><time datetime=2020-12-29>December 29, 2020</time><svg class="fai ml-3 text-accent-l dark:text-front-d"><title>Tags</title><use xlink:href="/img/fa/all.svg#tag"/></svg>
<a class=label-link href=https://aakinshin.net/tags/mathematics/>Mathematics</a>
<a class=label-link href=https://aakinshin.net/tags/statistics/>Statistics</a>
<a class=label-link href=https://aakinshin.net/tags/research/>Research</a>
<a class=label-link href=https://aakinshin.net/tags/quantile/>Quantile</a>
<a class=label-link href=https://aakinshin.net/tags/moving-quantile/>Moving Quantile</a></div><br><div class=main-content><p>Imagine you have a time series.
Let&rsquo;s say, after each new observation, you want to know an &ldquo;average&rdquo; value across the last <span class="math inline">\(L\)</span> observations.
Such a metric is known as <a href=https://en.wikipedia.org/wiki/Moving_average>a moving average</a>
(or rolling/running average).</p><p>The most popular moving average example is <a href=https://en.wikipedia.org/wiki/Moving_average#Simple_moving_average>the moving mean</a>.
It&rsquo;s easy to efficiently implement this metric.
However, it has a major drawback: it&rsquo;s not robust.
Outliers can easily spoil the moving mean and transform it into a meaningless and untrustable metric.</p><p>Fortunately, we have a good alternative: <a href=https://en.wikipedia.org/wiki/Moving_average#Moving_median>the moving median</a>.
Typically, it generates a stable and smooth series of values.
In the below figure, you can see the difference between the moving mean and the moving median on noisy data.</p><div class="flex my-7 justify-center"><a class="img-light hidden" href=/posts/partitioning-heaps-quantile-estimator/img/example-light.png target=_blank alt=example><img src=/posts/partitioning-heaps-quantile-estimator/img/example-light.png width=800></a>
<a class="img-dark hidden" href=/posts/partitioning-heaps-quantile-estimator/img/example-dark.png target=_blank alt=example><img src=/posts/partitioning-heaps-quantile-estimator/img/example-dark.png width=800></a></div><p>The moving median also has a drawback: it&rsquo;s not easy to efficiently implement it.
Today we going to discuss the Hardle-Steiger method to estimate the median
(memory: <span class="math inline">\(O(L)\)</span>, element processing complexity: <span class="math inline">\(O(log(L))\)</span>, median estimating complexity: <span class="math inline">\(O(1)\)</span>).
Also, we will learn how to calculate <em>the moving quantiles</em> based on this method.</p><p>In this post, you will find the following:</p><ul><li>An overview of the Hardle-Steiger method</li><li>A simple way to implement the Hardle-Steiger method</li><li>Moving quantiles inspired by the Hardle-Steiger method</li><li>How to process initial elements</li><li>Reference C# implementation</li></ul><h3 id=an-overview-of-the-hardle-steiger-method>An overview of the Hardle-Steiger method</h3><p>This method is described in <a href=#Hardle1995>[Hardle1995]</a>.
The core idea is based on a data structure that contains two joined <a href=https://en.wikipedia.org/wiki/Heap_(data_structure)>heaps</a>:</p><div class=row><div class=mx-auto><a href=/posts/partitioning-heaps-quantile-estimator/img/double-heap.svg target=_blank alt=double-heap><img class="mx-auto d-block img-fluid" width=400 src=/posts/partitioning-heaps-quantile-estimator/img/double-heap.svg></a></div></div><br><p>In this figure, you see an example for <span class="math inline">\(L=21\)</span>.
It contains:</p><ul><li><span class="math inline">\(H_1 .. H_{10}\)</span>: min heap</li><li><span class="math inline">\(H_{-1} .. H_{-10}\)</span>: max heap</li><li><span class="math inline">\(H_0\)</span>: a node that joins two heaps</li></ul><p>The <span class="math inline">\(H\)</span> array contain the last <span class="math inline">\(L\)</span> elements of the time series and satisfy the following conditions:</p><ul><li><span class="math inline">\(\max(H_{-2i},\; H_{-2i-1}) \leq H_{-i} \leq H_0\)</span></li><li><span class="math inline">\(\min(H_{2i},\; H_{2i+1}) \geq H_{i} \geq H_0\)</span></li></ul><p>Thus, <span class="math inline">\(H_0\)</span> is
less than all elements in the upper heap (positive indexes) and
greater than all elements in the lower heap (negative indexes).
Since we have an equal number of elements in both heaps,
<span class="math inline">\(H_0\)</span> represents the median value.</p><p>That&rsquo;s all!
If we want to know the current value of the moving median, we should just take the value of <span class="math inline">\(H_0\)</span>.
The suggested algorithm has the following characteristics:</p><ul><li>Amount of memory: <span class="math inline">\(O(L)\)</span></li><li>Element processing complexity: <span class="math inline">\(O(log(L))\)</span></li><li>Median estimating complexity: <span class="math inline">\(O(1)\)</span></li></ul><p>Now we should learn how to invalidate this data structure for new observations.</p><h3 id=a-simple-way-to-implement-the-hardle-steiger-method>A simple way to implement the Hardle-Steiger method</h3><p>The most famous implementation of the Hardle-Steiger method is the <a href=http://svn.r-project.org/R/trunk/src/library/stats/src/Trunmed.c>Turlach implementation</a> in C.
It&rsquo;s used in the R&rsquo;s function <a href=https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/runmed>runmed</a>.
This implementation doesn&rsquo;t look simple, so it&rsquo;s not easy to replicate it using another language
(you can find a few StackOverflow discussion about this implementation
<a href=https://stackoverflow.com/q/1309263/184842>here</a> and <a href=https://stackoverflow.com/q/5527437/184842>here</a>).
So, I looked at the above picture and came up with my own way to implement this algorithm
(you can find a reference C# implementation at the end of this post).
It differs from the Turlach implementation and from the suggested approach in the original paper,
but it still uses the same idea.</p><p>We are going to keep three array with numbers:</p><ul><li><code>double[] h</code>: the elements of the partitioning heaps</li><li><code>int[] heapToElementIndex</code>: returns the original element index for the given heap element</li><li><code>int[] elementToHeapIndex</code>: returns the heap index for the given element index</li></ul><p>The swap routine is trivial:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=k>private</span> <span class=k>void</span> <span class=n>Swap</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapIndex2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>elementIndex1</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>elementIndex2</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>value1</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>value2</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>value2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>value1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To simplify the calculations, we take all the element indexes by modulo <span class="math inline">\(L\)</span>.
Since we have exactly <span class="math inline">\(L\)</span> subsequent indexes at each moment,
there are no index collisions.</p><p>When we get a new element <code>x[i]</code>, we should replace the <code>h[i % L]</code> value by <code>x[i]</code>.
Next, we should do a series of swaps to repair the heap conditions.
In the classic heap implementation, we usually have two <code>Sift</code> methods: <code>SiftUp</code> and <code>SiftDown</code>.
To reduce the number of cases, we are going to implement a generic <code>Sift</code> routine according to the following scheme:</p><ul><li>Consider the current heap node and lower neighbor nodes.
If we have any lower neighbor nodes that are larger than the current node,
we swap the current node with the node that has the maximum value (across considered nodes).</li><li>Otherwise, we consider the current heap node and the upper neighbor nodes.
Repeat the previous step with an opposite sign.</li><li>If we swapped the current node with a lower or upper neighbor node,
we repeat two previous steps with the new node location.
Otherwise, we stop.</li></ul><p>This logic still have a lot of cases that should be handled,
but it&rsquo;s not so hard to implement it.
See the reference implementation at the end of this post for details.</p><h3 id=moving-quantiles-inspired-by-the-hardle-steiger-method>Moving quantiles inspired by the Hardle-Steiger method</h3><p>The original algorithm was designed only for the moving median.
Let&rsquo;s generalize it to calculate any moving quantile.</p><p>We can express the Hardle-Steiger method in terms of order statistics.
For the given odd <span class="math inline">\(L\)</span>, we can define <span class="math inline">\(k = (L-1)/2\)</span>.
The median element across the last <span class="math inline">\(L\)</span> numbers is the <span class="math inline">\((k+1)^\textrm{th}\)</span> smallest element (assuming one-base indexing).
<span class="math inline">\(H_0\)</span> is the request number because it&rsquo;s larger than all of the elements in the lower heap (which contains exactly <span class="math inline">\(k\)</span> elements) and smaller than all of the elements in the upper heap (which also contains <span class="math inline">\(k\)</span> elements).</p><p>Now let&rsquo;s change the heap sizes!
For any <span class="math inline">\(k \in [0; L-1]\)</span>, we can consider the lower heap of size <span class="math inline">\(k\)</span> and the upper heap of size <span class="math inline">\(L-k-1\)</span>.
In this case, <span class="math inline">\(H_0\)</span> will represent the <span class="math inline">\((k+1)^\textrm{th}\)</span> smallest element.
The <span class="math inline">\(p^\textrm{th}\)</span> quantile (<span class="math inline">\(p \in [0; 1]\)</span>) can be estimated as the <span class="math inline">\(\lfloor p(L-1) \rfloor^\textrm{th}\)</span> smallest element!
Note that now the window size can be an arbitrary positive number
(unlike the original approach which supports only odd <span class="math inline">\(L\)</span> values).</p><p>It looks simple, so I was surprised that I didn&rsquo;t manage to find this idea anywhere.
If you find any references where this approach is explained, please let me know.</p><h3 id=how-to-process-initial-elements>How to process initial elements</h3><p>Let&rsquo;s say that the windows size <span class="math inline">\(L=21\)</span>, we estimate the median <span class="math inline">\(k=10\)</span>,
but we are at the beginning of our time series, and we have only 13 elements.
What should we return?
There two possible strategies here:</p><ul><li><strong>Order Statistics</strong><br>Since the <span class="math inline">\(k^\textrm{th}\)</span> smallest element was requested, we should return it.
In the above example, it would be the <span class="math inline">\(10^\textrm{th}\)</span> smallest element from the 13 observed numbers.</li><li><strong>Quantile Approximation</strong><br>Since the median was requested, we should return it.
In the above example, it would be <span class="math inline">\(7^\textrm{th}\)</span> smallest element from the 13 observed numbers.</li></ul><p>Also, there are other strategies (e.g., repeating the first element).
However, in my opinion, other approaches don&rsquo;t satisfy the
<a href=https://en.wikipedia.org/wiki/Principle_of_least_astonishment>principle of least astonishment</a>,
so we are not going to discuss them.</p><p>The two presented strategy define the way of the heap initialization (how we process <span class="math inline">\(x[i]\)</span> for <span class="math inline">\(i < L\)</span>).
We start with two empty heaps.
Once we got the first element, we always put it into <span class="math inline">\(H_0\)</span>.
Next, we should add subsequent elements to the lower or upper heap depending on the chosen strategy:</p><ul><li><strong>Order Statistics</strong><br>We add elements to the lower heap until it&rsquo;s full.
After that, we add elements to the upper heap.</li><li><strong>Quantile Approximation</strong><br>We choose the lower or upper heap trying to keep the ratio
<span class="math inline">\(\textrm{LowerHeapSize} / (\textrm{LowerHeapSize} + \textrm{UpperHeapSize})\)</span>
close to the target quantile.</li></ul><h3 id=reference-c-implementation>Reference C# implementation</h3><p>Below you can find a full C# implementation of the moving quantile according to the above approach.
You can also use it with
the latest nightly version (0.3.0-nightly.86+) of <a href=https://github.com/AndreyAkinshin/perfolizer>Perfolizer</a>
(you need <code>PartitioningHeapsMovingQuantileEstimator</code>).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cs data-lang=cs><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// A moving selector based on a partitioning heaps.</span>
</span></span><span class=line><span class=cl><span class=cs>/// Memory: O(windowSize).</span>
</span></span><span class=line><span class=cl><span class=cs>/// Add complexity: O(log(windowSize)).</span>
</span></span><span class=line><span class=cl><span class=cs>/// GetValue complexity: O(1).</span>
</span></span><span class=line><span class=cl><span class=cs>/// </span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;remarks&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Based on the following paper:</span>
</span></span><span class=line><span class=cl><span class=cs>/// Hardle, W., and William Steiger. &#34;Algorithm AS 296: Optimal median smoothing.&#34; Journal of the Royal Statistical Society.</span>
</span></span><span class=line><span class=cl><span class=cs>/// Series C (Applied Statistics) 44, no. 2 (1995): 258-264.</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/remarks&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>class</span> <span class=nc>PartitioningHeapsMovingQuantileEstimator</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span> <span class=n>windowSize</span><span class=p>,</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>double</span><span class=p>[]</span> <span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>heapToElementIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span><span class=p>[]</span> <span class=n>elementToHeapIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=kt>int</span> <span class=n>rootHeapIndex</span><span class=p>,</span> <span class=n>lowerHeapMaxSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>readonly</span> <span class=n>MovingQuantileEstimatorInitStrategy</span> <span class=n>initStrategy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=kt>int</span> <span class=n>upperHeapSize</span><span class=p>,</span> <span class=n>lowerHeapSize</span><span class=p>,</span> <span class=n>totalElementCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=n>PartitioningHeapsMovingQuantileEstimator</span><span class=p>(</span><span class=kt>int</span> <span class=n>windowSize</span><span class=p>,</span> <span class=kt>int</span> <span class=n>k</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=n>MovingQuantileEstimatorInitStrategy</span> <span class=n>initStrategy</span> <span class=p>=</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>QuantileApproximation</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=n>windowSize</span> <span class=p>=</span> <span class=n>windowSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=n>k</span> <span class=p>=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>h</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>double</span><span class=p>[</span><span class=n>windowSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>heapToElementIndex</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>windowSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>elementToHeapIndex</span> <span class=p>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>windowSize</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>lowerHeapMaxSize</span> <span class=p>=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=p>.</span><span class=n>initStrategy</span> <span class=p>=</span> <span class=n>initStrategy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>rootHeapIndex</span> <span class=p>=</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>void</span> <span class=n>Swap</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapIndex2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>elementIndex1</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>elementIndex2</span> <span class=p>=</span> <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>value1</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span> <span class=n>value2</span> <span class=p>=</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>h</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>value2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>h</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>value1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex1</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex2</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=k>void</span> <span class=n>Sift</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapCurrentIndex</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapChildIndex1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>heapChildIndex2</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>isUpperHeap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>hasChild1</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>-</span> <span class=n>lowerHeapSize</span> <span class=p>&lt;=</span> <span class=n>heapChildIndex1</span> <span class=p>&amp;&amp;</span> <span class=n>heapChildIndex1</span> <span class=p>&lt;=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=n>upperHeapSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=kt>bool</span> <span class=n>hasChild2</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>-</span> <span class=n>lowerHeapSize</span> <span class=p>&lt;=</span> <span class=n>heapChildIndex2</span> <span class=p>&amp;&amp;</span> <span class=n>heapChildIndex2</span> <span class=p>&lt;=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=n>upperHeapSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(!</span><span class=n>hasChild1</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>hasChild2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>heapCurrentIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>hasChild1</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>hasChild2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpperHeap</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=n>isUpperHeap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>Swap</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapChildIndex1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>heapChildIndex1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>heapCurrentIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>hasChild1</span> <span class=p>&amp;&amp;</span> <span class=n>hasChild2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>((</span><span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>])</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpperHeap</span> <span class=p>||</span>
</span></span><span class=line><span class=cl>                    <span class=p>(</span><span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>])</span> <span class=p>&amp;&amp;</span> <span class=n>isUpperHeap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>heapChildIndex0</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>                        <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpperHeap</span> <span class=p>||</span>
</span></span><span class=line><span class=cl>                        <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex1</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapChildIndex2</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=n>isUpperHeap</span>
</span></span><span class=line><span class=cl>                            <span class=p>?</span> <span class=n>heapChildIndex1</span>
</span></span><span class=line><span class=cl>                            <span class=p>:</span> <span class=n>heapChildIndex2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=n>Swap</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapChildIndex0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>return</span> <span class=n>heapChildIndex0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=n>heapCurrentIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>InvalidOperationException</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=k>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>!=</span> <span class=n>rootHeapIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>bool</span> <span class=n>isUpHeap</span> <span class=p>=</span> <span class=n>heapIndex</span> <span class=p>&gt;</span> <span class=n>rootHeapIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>heapParentIndex</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>)</span> <span class=p>/</span> <span class=m>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>h</span><span class=p>[</span><span class=n>heapParentIndex</span><span class=p>]</span> <span class=p>&lt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=p>!</span><span class=n>isUpHeap</span> <span class=p>||</span> <span class=n>h</span><span class=p>[</span><span class=n>heapParentIndex</span><span class=p>]</span> <span class=p>&gt;</span> <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>&amp;&amp;</span> <span class=n>isUpHeap</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>Swap</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapParentIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>heapParentIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>heapChildIndex1</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>)</span> <span class=p>*</span> <span class=m>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>heapChildIndex2</span> <span class=p>=</span> <span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>)</span> <span class=p>*</span> <span class=m>2</span> <span class=p>+</span> <span class=n>Math</span><span class=p>.</span><span class=n>Sign</span><span class=p>(</span><span class=n>heapIndex</span> <span class=p>-</span> <span class=n>rootHeapIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>newHeapIndex</span> <span class=p>=</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapChildIndex1</span><span class=p>,</span> <span class=n>heapChildIndex2</span><span class=p>,</span> <span class=n>isUpHeap</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>newHeapIndex</span> <span class=p>!=</span> <span class=n>heapIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>newHeapIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=c1>// heapIndex == rootHeapIndex</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>lowerHeapSize</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>newHeapIndex</span> <span class=p>=</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapIndex</span> <span class=p>-</span> <span class=m>1</span><span class=p>,</span> <span class=p>-</span><span class=m>1</span><span class=p>,</span> <span class=k>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>newHeapIndex</span> <span class=p>!=</span> <span class=n>heapIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>newHeapIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>upperHeapSize</span> <span class=p>&gt;</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>newHeapIndex</span> <span class=p>=</span> <span class=n>SwapWithChildren</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>,</span> <span class=n>heapIndex</span> <span class=p>+</span> <span class=m>1</span><span class=p>,</span> <span class=p>-</span><span class=m>1</span><span class=p>,</span> <span class=k>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span> <span class=p>(</span><span class=n>newHeapIndex</span> <span class=p>!=</span> <span class=n>heapIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>newHeapIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=k>void</span> <span class=n>Add</span><span class=p>(</span><span class=kt>double</span> <span class=k>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>elementIndex</span> <span class=p>=</span> <span class=n>totalElementCount</span> <span class=p>%</span> <span class=n>windowSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>Insert</span><span class=p>(</span><span class=kt>int</span> <span class=n>heapIndex</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>h</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>=</span> <span class=k>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>heapToElementIndex</span><span class=p>[</span><span class=n>heapIndex</span><span class=p>]</span> <span class=p>=</span> <span class=n>elementIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex</span><span class=p>]</span> <span class=p>=</span> <span class=n>heapIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>heapIndex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>totalElementCount</span><span class=p>++</span> <span class=p>&lt;</span> <span class=n>windowSize</span><span class=p>)</span> <span class=c1>// Heap is not full</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>totalElementCount</span> <span class=p>==</span> <span class=m>1</span><span class=p>)</span> <span class=c1>// First element</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Insert</span><span class=p>(</span><span class=n>rootHeapIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=kt>bool</span> <span class=n>quantileApproximationCondition</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>                    <span class=n>initStrategy</span> <span class=p>==</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>QuantileApproximation</span> <span class=p>&amp;&amp;</span>
</span></span><span class=line><span class=cl>                    <span class=n>lowerHeapSize</span> <span class=p>&lt;</span> <span class=n>k</span> <span class=p>*</span> <span class=n>totalElementCount</span> <span class=p>/</span> <span class=n>windowSize</span> <span class=p>||</span>
</span></span><span class=line><span class=cl>                    <span class=n>initStrategy</span> <span class=p>==</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>OrderStatistics</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>lowerHeapSize</span> <span class=p>&lt;</span> <span class=n>lowerHeapMaxSize</span> <span class=p>&amp;&amp;</span> <span class=n>quantileApproximationCondition</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>lowerHeapSize</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>rootHeapIndex</span> <span class=p>-</span> <span class=n>lowerHeapSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>Sift</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>upperHeapSize</span><span class=p>++;</span>
</span></span><span class=line><span class=cl>                    <span class=kt>int</span> <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>Insert</span><span class=p>(</span><span class=n>rootHeapIndex</span> <span class=p>+</span> <span class=n>upperHeapSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                    <span class=n>Sift</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Replace old element</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>heapIndex</span> <span class=p>=</span> <span class=n>elementToHeapIndex</span><span class=p>[</span><span class=n>elementIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>Insert</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>Sift</span><span class=p>(</span><span class=n>heapIndex</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>public</span> <span class=kt>double</span> <span class=n>GetQuantile</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>totalElementCount</span> <span class=p>==</span> <span class=m>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfRangeException</span><span class=p>(</span><span class=s>&#34;There are no any values&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>initStrategy</span> <span class=p>==</span> <span class=n>MovingQuantileEstimatorInitStrategy</span><span class=p>.</span><span class=n>OrderStatistics</span> <span class=p>&amp;&amp;</span> <span class=n>k</span> <span class=p>&gt;=</span> <span class=n>totalElementCount</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=k>new</span> <span class=n>IndexOutOfRangeException</span><span class=p>(</span><span class=s>$&#34;Not enough values (n = {totalElementCount}, k = {k})&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>h</span><span class=p>[</span><span class=n>rootHeapIndex</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl><span class=cs>/// Defines how a moving quantile estimator calculates the target quantile value</span>
</span></span><span class=line><span class=cl><span class=cs>/// when the total number of elements is less than the window size</span>
</span></span><span class=line><span class=cl><span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl><span class=k>public</span> <span class=k>enum</span> <span class=n>MovingQuantileEstimatorInitStrategy</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Approximate the target quantile.</span>
</span></span><span class=line><span class=cl>    <span class=c1>///</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;example&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// windowSize = 5, k = 2 (the median)</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// If the total number of elements equals 3, the median (k = 1) will be returned </span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/example&gt; </span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>QuantileApproximation</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// Return the requested order statistics</span>
</span></span><span class=line><span class=cl>    <span class=c1>///</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;example&gt;</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// windowSize = 5, k = 2</span>
</span></span><span class=line><span class=cl>    <span class=cs>/// If the total number of elements equals 3, the largest element (k = 2) will be returned </span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/example&gt; </span>
</span></span><span class=line><span class=cl>    <span class=cs>/// &lt;/summary&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>OrderStatistics</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=conclusion>Conclusion</h3><p>In this post, we discussed the Hardle-Steiger method to estimate the moving median.
Also, we built a generalization of this method to estimate any moving quantile.
This approach is useful in monitoring
when you want to get the average value of your time series using only recent elements.
It&rsquo;s optimal in terms of performance and memory footprint for medium-size windows.
In future blog posts, I will show other approaches that estimate the moving quantile
(that are optimal for small-size and big-size windows).</p><h3 id=references>References</h3><ul><li><b id=Hardle1995>[Hardle1995]</b><br>Hardle, W., and William Steiger. &ldquo;Algorithm AS 296: Optimal median smoothing.&rdquo; Journal of the Royal Statistical Society. Series C (Applied Statistics) 44, no. 2 (1995): 258-264.<br><a href=https://doi.org/10.2307/2986349>https://doi.org/10.2307/2986349</a></li><li><a href=https://stackoverflow.com/q/1309263/184842>StackOverflow: Rolling median algorithm in C</a></li><li><a href=https://stackoverflow.com/q/5527437/184842>StackOverflow: Rolling median in C - Turlach implementation</a></li></ul></div><br><br><div class="flex flex-wrap justify-center items-center mb-5"><span>Share:</span><div class="text-4xl pl-3"><a href="https://www.reddit.com/submit?url=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator%2f&title=Fast%20implementation%20of%20the%20moving%20quantile%20based%20on%20the%20partitioning%20heaps" target=_blank title="Share on Reddit"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#reddit"/></svg></a></div><div class="text-4xl pl-3"><a href="https://twitter.com/intent/tweet?text=Fast%20implementation%20of%20the%20moving%20quantile%20based%20on%20the%20partitioning%20heaps&url=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator%2f&via=andrey_akinshin&related=andrey_akinshin" rel=nofollow target=_blank title="Share on Twitter"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></div><div class="text-4xl pl-3"><a href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator%2f" target=_blank title="Share on HackerNews"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#hacker-news"/></svg></a></div><div class="text-4xl pl-3"><a href="https://getpocket.com/save?url=https%3a%2f%2faakinshin.net%2fposts%2fpartitioning-heaps-quantile-estimator%2f&title=Fast%20implementation%20of%20the%20moving%20quantile%20based%20on%20the%20partitioning%20heaps" target=_blank title="Add to Pocket"><svg class="fai fai-link"><use xlink:href="/img/fa/all.svg#get-pocket"/></svg></a></div></div></div></div><script>var themeToggleDarkIcon=document.getElementById("theme-toggle-dark-icon"),themeToggleBtn,themeToggleLightIcon=document.getElementById("theme-toggle-light-icon");const imagesDark=document.querySelectorAll(".img-dark"),imagesLight=document.querySelectorAll(".img-light");localStorage.getItem("color-theme")==="dark"||!("color-theme"in localStorage)&&window.matchMedia("(prefers-color-scheme: dark)").matches?(themeToggleLightIcon.classList.remove("hidden"),imagesDark.forEach(e=>{e.classList.remove("hidden")})):(themeToggleDarkIcon.classList.remove("hidden"),imagesLight.forEach(e=>{e.classList.remove("hidden")})),themeToggleBtn=document.getElementById("theme-toggle"),themeToggleBtn.addEventListener("click",function(){themeToggleDarkIcon.classList.toggle("hidden"),themeToggleLightIcon.classList.toggle("hidden"),imagesLight.forEach(e=>{e.classList.toggle("hidden")}),imagesDark.forEach(e=>{e.classList.toggle("hidden")}),localStorage.getItem("color-theme")?localStorage.getItem("color-theme")==="light"?(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark")):(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):document.documentElement.classList.contains("dark")?(document.documentElement.classList.remove("dark"),localStorage.setItem("color-theme","light")):(document.documentElement.classList.add("dark"),localStorage.setItem("color-theme","dark"))})</script><footer class="z-20 p-4 md:p-6 mt-3 w-full border-t border-gray-200 shadow flex items-center justify-center dark:border-gray-600 bg-white dark:bg-zinc-800"><span class="dark:text-gray-400 text-center"> 20132022 <span class=whitespace-nowrap>Andrey Akinshin</span></span><ul class="flex flex-wrap items-center px-4 mb-1"><li><a href=https://github.com/AndreyAkinshin><svg class="fai fai-link w-5 h-5"><title>GitHub</title><use xlink:href="/img/fa/all.svg#github"/></svg></a></li><li><a href=https://twitter.com/andrey_akinshin><svg class="fai fai-link w-5 h-5"><title>Twitter</title><use xlink:href="/img/fa/all.svg#twitter"/></svg></a></li><li><a href=https://aakinshin.net/posts/index.xml><svg class="fai fai-link w-5 h-5"><title>RSS</title><use xlink:href="/img/fa/all.svg#rss"/></svg></a></li></ul><div class=main-content><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></div></footer><script src=https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.3.1/anchor.min.js integrity="sha512-zPB79j2C+3sFS9zcA3vg/z6bVKzJVEyu9pY5w89akQRys76zpAT2t6S3wZKla3QQ14O5l/Yt0RUQ/DHXx82Y5g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script>anchors.options={placement:"left",icon:""},anchors.add("h1"),anchors.add("h2"),anchors.add("h3")</script><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"],ignoreHtmlClass:"tex2jax_ignore",processHtmlClass:"tex2jax_process"}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></body></html>