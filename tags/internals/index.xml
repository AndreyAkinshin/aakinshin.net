<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Internals on Andrey Akinshin</title><link>https://aakinshin.net/tags/internals/</link><description>Recent content in Internals on Andrey Akinshin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 09 Sep 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/tags/internals/index.xml" rel="self" type="application/rss+xml"/><item><title>Stopwatch under the hood</title><link>https://aakinshin.net/posts/stopwatch/</link><pubDate>Fri, 09 Sep 2016 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/stopwatch/</guid><description>&lt;p>&lt;strong>Update:&lt;/strong>
You can find an updated and significantly improved version of this post in my book &lt;a href="https://aakinshin.net/prodotnetbenchmarking/">&amp;ldquo;Pro .NET Benchmarking&amp;rdquo;&lt;/a>.&lt;/p>
&lt;p>In &lt;a href="https://aakinshin.net/en/blog/dotnet/datetime/">the previous post&lt;/a>, we discussed &lt;code>DateTime&lt;/code>.
This structure can be used in situations when you don&amp;rsquo;t need a good level of precision.
If you want to do high-precision time measurements, you need a better tool because &lt;code>DateTime&lt;/code> has a small resolution and a big latency.
Also, time is tricky, you can create wonderful bugs if you don&amp;rsquo;t understand how it works (see &lt;a href="http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time">Falsehoods programmers believe about time&lt;/a> and &lt;a href="http://infiniteundo.com/post/25509354022/more-falsehoods-programmers-believe-about-time">More falsehoods programmers believe about time&lt;/a>).&lt;/p>
&lt;p>In this post, we will briefly talk about the &lt;a href="https://msdn.microsoft.com/library/system.diagnostics.stopwatch.aspx">Stopwatch&lt;/a> class:&lt;/p>
&lt;ul>
&lt;li>Which kind of hardware timers could be a base for &lt;code>Stopwatch&lt;/code>&lt;/li>
&lt;li>High precision timestamp API on Windows and Linux&lt;/li>
&lt;li>Latency and Resolution of &lt;code>Stopwatch&lt;/code> in different environments&lt;/li>
&lt;li>Common pitfalls: which kind of problems could we get trying to measure small time intervals&lt;/li>
&lt;/ul>
&lt;p>If you are not a .NET developer, you can also find a lot of useful information in this post: mainly we will discuss low-level details of high-resolution timestamping (probably your favorite language also uses the same API).
As usual, you can also find useful links for further reading.&lt;/p></description></item><item><title>DateTime under the hood</title><link>https://aakinshin.net/posts/datetime/</link><pubDate>Fri, 19 Aug 2016 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/datetime/</guid><description>&lt;p>&lt;strong>Update:&lt;/strong>
You can find an updated and significantly improved version of this post in my book &lt;a href="https://aakinshin.net/prodotnetbenchmarking/">&amp;ldquo;Pro .NET Benchmarking&amp;rdquo;&lt;/a>.&lt;/p>
&lt;p>&lt;a href="https://msdn.microsoft.com/library/system.datetime.aspx">DateTime&lt;/a> is a widely used .NET type. A lot of developers use it all the time, but not all of them really know how it works. In this post, I discuss &lt;a href="https://msdn.microsoft.com/library/system.datetime.utcnow.aspx">DateTime.UtcNow&lt;/a>: how it&amp;rsquo;s implemented, what the latency and the resolution of &lt;code>DateTime&lt;/code> on Windows and Linux, how the resolution can be changed, and how it can affect your application. This post is an overview, so you probably will not see super detailed explanations of some topics, but you will find a lot of useful links for further reading.&lt;/p></description></item><item><title>Blittable types</title><link>https://aakinshin.net/posts/blittable/</link><pubDate>Thu, 26 Nov 2015 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/blittable/</guid><description>&lt;p>Challenge of the day: what will the following code display?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="na">[StructLayout(LayoutKind.Explicit)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">UInt128&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na"> [FieldOffset(0)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">ulong&lt;/span> &lt;span class="n">Value1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na"> [FieldOffset(8)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">ulong&lt;/span> &lt;span class="n">Value2&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">[StructLayout(LayoutKind.Sequential)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="nc">MyStruct&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="n">UInt128&lt;/span> &lt;span class="n">UInt128&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">char&lt;/span> &lt;span class="n">Char&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">unsafe&lt;/span> &lt;span class="k">void&lt;/span> &lt;span class="n">Main&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">myStruct&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">MyStruct&lt;/span>&lt;span class="p">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">baseAddress&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&amp;amp;&lt;/span>&lt;span class="n">myStruct&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">var&lt;/span> &lt;span class="n">uInt128Adress&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&amp;amp;&lt;/span>&lt;span class="n">myStruct&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">UInt128&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uInt128Adress&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="n">baseAddress&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Console&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WriteLine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Marshal&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">OffsetOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">typeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">MyStruct&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s">&amp;#34;UInt128&amp;#34;&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>A hint: two zeros or two another same values are wrong answers in the general case. The following table shows the console output on different runtimes:&lt;/p>
&lt;table>
&lt;tr>&lt;th>&lt;/th>&lt;th>MS.NET-x86&lt;/th>&lt;th>MS.NET-x64&lt;/th>&lt;th>Mono&lt;/th>&lt;/tr>
&lt;tr>&lt;td>uInt128Adress - baseAddress &lt;/td>&lt;td>4&lt;/td>&lt;td>8&lt;/td>&lt;td>0&lt;/td>&lt;/tr>
&lt;tr>&lt;td>Marshal.OffsetOf(typeof(MyStruct), "UInt128")&lt;/td>&lt;td>0&lt;/td>&lt;td>0&lt;/td>&lt;td>0&lt;/td>&lt;/tr>
&lt;/table>
&lt;p>If you want to know why it happens, you probably should learn some useful information about blittable types.&lt;/p></description></item></channel></rss>