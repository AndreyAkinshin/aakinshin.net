<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Benchmarking on Andrey Akinshin</title><link>https://aakinshin.net/tags/benchmarking/</link><description>Recent content in Benchmarking on Andrey Akinshin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 10 Apr 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/tags/benchmarking/index.xml" rel="self" type="application/rss+xml"/><item><title>Cross-runtime .NET disassembly with BenchmarkDotNet</title><link>https://aakinshin.net/posts/dotnet-crossruntime-disasm/</link><pubDate>Tue, 10 Apr 2018 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/dotnet-crossruntime-disasm/</guid><description>&lt;p>&lt;a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet&lt;/a> is a cool tool for benchmarking.
It has a lot of useful features that help you with performance investigations.
However, you can use these features even if you are not actually going to benchmark something.
One of these features is &lt;code>DisassemblyDiagnoser&lt;/code>.
It shows you a disassembly listing of your code for all required runtimes.
In this post, I will show you how to get disassembly listing for .NET Framework, .NET Core, and Mono with one click!
You can do it with a very small code snippet like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="na">[DryCoreJob, DryMonoJob, DryClrJob(Platform.X86)]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">[DisassemblyDiagnoser]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">IntroDisasm&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na"> [Benchmark]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">double&lt;/span> &lt;span class="n">Sum&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">res&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="m">64&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">++)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">res&lt;/span> &lt;span class="p">+=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">res&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>BenchmarkDotNet v0.10.14</title><link>https://aakinshin.net/posts/bdn-v0_10_14/</link><pubDate>Mon, 09 Apr 2018 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/bdn-v0_10_14/</guid><description>&lt;p>BenchmarkDotNet v0.10.14 has been released! This release includes:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Per-method parameterization&lt;/strong> (&lt;a href="http://benchmarkdotnet.org/Advanced/Arguments.htm">Read more&lt;/a>)&lt;/li>
&lt;li>&lt;strong>Console histograms and multimodal disribution detection&lt;/strong> (&lt;a href="https://aakinshin.net/posts/dotnet-crossruntime-disasm/">Read more&lt;/a>)&lt;/li>
&lt;li>&lt;strong>Many improvements for Mono disassembly support on Windows&lt;/strong> (A blog post is coming soon)&lt;/li>
&lt;li>&lt;strong>Many bugfixes&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>In the &lt;a href="https://github.com/dotnet/BenchmarkDotNet/issues?q=milestone:v0.10.14">v0.10.14&lt;/a> scope,
8 issues were resolved and 11 pull requests where merged.
This release includes 47 commits by 8 contributors.&lt;/p></description></item><item><title>BenchmarkDotNet v0.10.13</title><link>https://aakinshin.net/posts/bdn-v0_10_13/</link><pubDate>Fri, 02 Mar 2018 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/bdn-v0_10_13/</guid><description>&lt;p>BenchmarkDotNet v0.10.13 has been released! This release includes:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Mono Support for DisassemblyDiagnoser:&lt;/strong>
Now you can easily get an assembly listing not only on .NET Framework/.NET Core, but also on Mono.
It works on Linux, macOS, and Windows (Windows requires installed cygwin with &lt;code>obj&lt;/code> and &lt;code>as&lt;/code>).
(See &lt;a href="https://github.com/dotnet/BenchmarkDotNet/issues/541">#541&lt;/a>)&lt;/li>
&lt;li>&lt;strong>Support ANY CoreFX and CoreCLR builds:&lt;/strong>
BenchmarkDotNet allows the users to run their benchmarks against ANY CoreCLR and CoreFX builds.
You can compare your local build vs MyGet feed or Debug vs Release or one version vs another.
(See &lt;a href="https://github.com/dotnet/BenchmarkDotNet/issues/651">#651&lt;/a>)&lt;/li>
&lt;li>&lt;strong>C# 7.2 support&lt;/strong>
(See &lt;a href="https://github.com/dotnet/BenchmarkDotNet/issues/643">#643&lt;/a>)&lt;/li>
&lt;li>&lt;strong>.NET 4.7.1 support&lt;/strong>
(See &lt;a href="https://github.com/dotnet/BenchmarkDotNet/commit/28aa946a9a277b6c2b1166af0397134b02bedf2d">28aa94&lt;/a>)&lt;/li>
&lt;li>&lt;strong>Support Visual Basic project files (.vbroj) targeting .NET Core&lt;/strong>
(See &lt;a href="https://github.com/dotnet/BenchmarkDotNet/issues/626">#626&lt;/a>)&lt;/li>
&lt;li>&lt;strong>DisassemblyDiagnoser now supports generic types&lt;/strong>
(See &lt;a href="https://github.com/dotnet/BenchmarkDotNet/issues/640">#640&lt;/a>)&lt;/li>
&lt;li>&lt;strong>Now it&amp;rsquo;s possible to benchmark both Mono and .NET Core from the same app&lt;/strong>
(See &lt;a href="https://github.com/dotnet/BenchmarkDotNet/issues/653">#653&lt;/a>)&lt;/li>
&lt;li>&lt;strong>Many bug fixes&lt;/strong>
(See details below)&lt;/li>
&lt;/ul></description></item><item><title>BenchmarkDotNet v0.10.12</title><link>https://aakinshin.net/posts/bdn-v0_10_12/</link><pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/bdn-v0_10_12/</guid><description>&lt;p>BenchmarkDotNet v0.10.12 has been released! This release includes:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Improved DisassemblyDiagnoser:&lt;/strong>
BenchmarkDotNet contains an embedded disassembler so that it can print assembly code for all benchmarks;
it&amp;rsquo;s not easy, but the disassembler evolves in every release.&lt;/li>
&lt;li>&lt;strong>Improved MemoryDiagnoser:&lt;/strong>
it has a better precision level, and it takes less time to evaluate memory allocations in a benchmark.&lt;/li>
&lt;li>&lt;strong>New TailCallDiagnoser:&lt;/strong>
now you get notifications when JIT applies the tail call optimizations to your methods.&lt;/li>
&lt;li>&lt;strong>Better environment info:&lt;/strong>
when your share performance results, it&amp;rsquo;s very important to share information about your environment.
The library generates the environment summary for you by default.
Now it contains information about the amount of physical CPU, physical cores, and logic cores.
If you run a benchmark on a virtual machine, you will get the name of the hypervisor
(e.g., Hyper-V, VMware, or VirtualBox).&lt;/li>
&lt;li>&lt;strong>Better summary table:&lt;/strong>
one of the greatest features of BenchmarkDotNet is the summary table.
It shows all important information about results in a compact and understandable form.
Now it has better customization options: you can display relative performance of different environments
(e.g., compare .NET Framework and .NET Core) and group benchmarks by categories.&lt;/li>
&lt;li>&lt;strong>New GC settings:&lt;/strong> now we support &lt;code>NoAffinitize&lt;/code>, &lt;code>HeapAffinitizeMask&lt;/code>, &lt;code>HeapCount&lt;/code>.&lt;/li>
&lt;li>Other minor improvements and bug fixes&lt;/li>
&lt;/ul></description></item><item><title>BenchmarkDotNet v0.10.10</title><link>https://aakinshin.net/posts/bdn-v0_10_10/</link><pubDate>Fri, 03 Nov 2017 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/bdn-v0_10_10/</guid><description>&lt;p>BenchmarkDotNet v0.10.10 has been released!
This release includes many new features like Disassembly Diagnoser, ParamsSources, .NET Core x86 support, Environment variables, and more!&lt;/p></description></item><item><title>BenchmarkDotNet v0.10.7</title><link>https://aakinshin.net/posts/bdn-v0_10_7/</link><pubDate>Mon, 05 Jun 2017 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/bdn-v0_10_7/</guid><description>&lt;p>BenchmarkDotNet v0.10.7 has been released.
In this post, I will briefly cover the following features:&lt;/p>
&lt;ul>
&lt;li>LINQPad support&lt;/li>
&lt;li>Filters and categories&lt;/li>
&lt;li>Updated Setup/Cleanup attributes&lt;/li>
&lt;li>Better Value Types support&lt;/li>
&lt;li>Building Sources on Linux&lt;/li>
&lt;/ul></description></item><item><title>Performance exercise: Division</title><link>https://aakinshin.net/posts/perfex-div/</link><pubDate>Mon, 26 Dec 2016 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/perfex-div/</guid><description>&lt;p>In the previous post, we &lt;a href="https://aakinshin.net/en/blog/dotnet/perfex-min/">discussed&lt;/a> the performance space of the minimum function
which was implemented via a simple ternary operator and with the help of bit magic.
Now we continue to talk about performance and bit hacks.
In particular, we will divide a positive number by three:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">uint&lt;/span> &lt;span class="n">Div3Simple&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">uint&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="p">/&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">uint&lt;/span> &lt;span class="n">Div3BitHacks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">uint&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">uint&lt;/span>&lt;span class="p">)((&lt;/span>&lt;span class="n">n&lt;/span> &lt;span class="p">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">ulong&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="m">0xAAAAAAAB&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&amp;gt;&lt;/span> &lt;span class="m">33&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As usual, it&amp;rsquo;s hard to say which method is faster in advanced because the performance depends on the environment.
Here are some interesting results:&lt;/p>
&lt;table class="table table-sm">
 &lt;tr> &lt;th>&lt;/th> &lt;th>Simple&lt;/th> &lt;th>BitHacks&lt;/th> &lt;/tr>
 &lt;tr> &lt;th>LegacyJIT-x86&lt;/th> &lt;td class="norm">≈8.3ns&lt;/td> &lt;td class="fast">≈2.6ns&lt;/td> &lt;/tr>
 &lt;tr> &lt;th>LegacyJIT-x64&lt;/th> &lt;td class="fast">≈2.6ns&lt;/td> &lt;td class="fast">≈1.7ns&lt;/td> &lt;/tr>
 &lt;tr> &lt;th>RyuJIT-x64 &lt;/th> &lt;td class="norm">≈6.9ns&lt;/td> &lt;td class="fast">≈1.5ns&lt;/td> &lt;/tr>
 &lt;tr> &lt;th>Mono4.6.2-x86&lt;/th> &lt;td class="norm">≈8.5ns&lt;/td> &lt;td class="slow">≈14.4ns&lt;/td> &lt;/tr>
 &lt;tr> &lt;th>Mono4.6.2-x64&lt;/th> &lt;td class="norm">≈8.3ns&lt;/td> &lt;td class="fast">≈2.8ns&lt;/td> &lt;/tr>
&lt;/table></description></item><item><title>Performance exercise: Minimum</title><link>https://aakinshin.net/posts/perfex-min/</link><pubDate>Tue, 20 Dec 2016 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/perfex-min/</guid><description>&lt;p>Performance is tricky. Especially, if you are working with very fast operations. In today benchmarking exercise, we will try to measure performance of two simple methods which calculate minimum of two numbers. Sounds easy? Ok, let&amp;rsquo;s do it, here are our guinea pigs for today:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-cs" data-lang="cs">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">MinTernary&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="p">?&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">MinBitHacks&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="p">&amp;amp;&lt;/span> &lt;span class="p">((&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&amp;gt;&lt;/span> &lt;span class="m">31&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="p">&amp;amp;&lt;/span> &lt;span class="p">(~(&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="p">-&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">&amp;gt;&amp;gt;&lt;/span> &lt;span class="m">31&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And here are some results:&lt;/p>
&lt;table class="table table-sm">
 &lt;style type="text/css" scoped>
 td.slow { color: #ff4444; } 
 td.fast { color: #00C851; }
 &lt;/style>
 &lt;tr> &lt;th>&lt;/th> &lt;th colspan="2">Random&lt;/th> &lt;th colspan="2">Const&lt;/th> &lt;/tr>
 &lt;tr> &lt;th>&lt;/th> &lt;th>Ternary&lt;/th> &lt;th>BitHacks&lt;/th> &lt;th>Ternary&lt;/th> &lt;th>BitHacks&lt;/th> &lt;/tr>
 &lt;tr> &lt;th>LegacyJIT-x86&lt;/th>
 &lt;td class="slow">≈643µs&lt;/td>
 &lt;td class="fast">≈227µs&lt;/td>
 &lt;td class="fast">≈160µs&lt;/td>
 &lt;td class="slow">≈226µs&lt;/td>
 &lt;/tr>
 &lt;tr> &lt;th>LegacyJIT-x64&lt;/th>
 &lt;td class="slow">≈450µs&lt;/td>
 &lt;td class="fast">≈123µs&lt;/td>
 &lt;td class="fast">≈68µs&lt;/td>
 &lt;td class="slow">≈123µs&lt;/td>
 &lt;/tr>
 &lt;tr> &lt;th>RyuJIT-x64&lt;/th>
 &lt;td class="slow">≈594µs&lt;/td>
 &lt;td class="fast">≈241µs&lt;/td>
 &lt;td class="fast">≈180µs&lt;/td>
 &lt;td class="slow">≈241µs&lt;/td>
 &lt;/tr>
 &lt;tr> &lt;th>Mono-x64&lt;/th>
 &lt;td class="fast">≈203µs&lt;/td>
 &lt;td class="slow">≈283µs&lt;/td>
 &lt;td class="fast">≈204µs&lt;/td>
 &lt;td class="slow">≈282µs&lt;/td>
 &lt;/tr>
&lt;/table>
&lt;p>What&amp;rsquo;s going on here? Let&amp;rsquo;s discuss it in detail.&lt;/p></description></item><item><title>Paired benchmarking. How to measure performance</title><link>https://aakinshin.net/library/web/c2b0493e679e12cf8a55a6c266dd82ed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://aakinshin.net/library/web/c2b0493e679e12cf8a55a6c266dd82ed/</guid><description/></item></channel></rss>