<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Performance on Andrey Akinshin</title><link>https://aakinshin.net/tags/performance/</link><description>Recent content in Performance on Andrey Akinshin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 14 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/tags/performance/index.xml" rel="self" type="application/rss+xml"/><item><title>.NET Core performance revolution in Rider 2020.1</title><link>https://aakinshin.net/posts/netcore-performance-revolution-in-rider-2020-1/</link><pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/netcore-performance-revolution-in-rider-2020-1/</guid><description>&lt;p>&lt;em>This blog post was &lt;a href="https://blog.jetbrains.com/dotnet/2020/04/14/net-core-performance-revolution-rider-2020-1/">originally posted&lt;/a> on &lt;a href="https://blog.jetbrains.com/dotnet/">JetBrains .NET blog&lt;/a>.&lt;/em>&lt;/p>
&lt;p>Many &lt;a href="https://www.jetbrains.com/rider/">Rider&lt;/a> users may know that &lt;a href="https://www.codemag.com/Article/1811091/Building-a-.NET-IDE-with-JetBrains-Rider">the IDE has two main processes&lt;/a>: frontend (Java-application based on the IntelliJ platform) and backend (.NET-application based on ReSharper). Since the first release of Rider, we’ve used Mono as the backend runtime on Linux and macOS. A few years ago, we decided to migrate to .NET Core. After resolving hundreds of technical challenges, &lt;strong>we are finally ready to present the .NET Core edition of Rider!&lt;/strong>&lt;/p>
&lt;p>In this blog post, we want to share the results of some benchmarks that compare the Mono-powered and the .NET Core-powered editions of Rider. You may find this interesting if you are also thinking about migrating to .NET Core, or if you just want a high-level overview of the improvements to Rider in terms of performance and footprint, following the migration. (Spoiler: they’re huge!)&lt;/p></description></item><item><title>Introducing perfolizer</title><link>https://aakinshin.net/posts/introducing-perfolizer/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/introducing-perfolizer/</guid><description>&lt;p>Over the last 7 years, I&amp;rsquo;ve been maintaining &lt;a href="https://github.com/dotnet/BenchmarkDotNet">BenchmarkDotNet&lt;/a>;
it&amp;rsquo;s a library that helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments.
Today, BenchmarkDotNet became the most popular .NET library for benchmarking which was adopted by &lt;a href="https://github.com/dotnet/BenchmarkDotNet#who-use-benchmarkdotnet">3500+&lt;/a> projects including .NET Core.&lt;/p>
&lt;p>While it has tons of features for benchmarking that allows getting reliable and accurate measurements,
it has a limited set of features for performance analysis.
And it&amp;rsquo;s a problem for many developers.
Lately, I started to get a lot of emails when people ask me
&amp;ldquo;OK, I benchmarked my application and got tons of numbers. What should I do next?&amp;rdquo;
It&amp;rsquo;s an excellent question that requires special tools.
So, I decided to start another project that focuses specifically on performance analysis.&lt;/p>
&lt;p>Meet &lt;a href="https://github.com/AndreyAkinshin/perfolizer">perfolizer&lt;/a> — a toolkit for performance analysis!
The source code is available on &lt;a href="https://github.com/AndreyAkinshin/perfolizer">GitHub&lt;/a> under the MIT license.&lt;/p>





&lt;div class="row">
&lt;div class="mx-auto">
 &lt;a href="https://aakinshin.net/posts/introducing-perfolizer/img/perfolizer.svg" target="_blank" alt="perfolizer">
 &lt;img
 class="mx-auto d-block img-fluid"
 width='800'
 src="https://aakinshin.net/posts/introducing-perfolizer/img/perfolizer.svg" />
 &lt;/a>
&lt;/div>
&lt;/div>
&lt;br /></description></item><item><title>Reflecting on performance testing</title><link>https://aakinshin.net/posts/reflecting-on-performance-testing/</link><pubDate>Tue, 01 Aug 2017 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/reflecting-on-performance-testing/</guid><description>&lt;p>Performance is an important feature for many projects.
Unfortunately, it&amp;rsquo;s an all too common situation when a developer accidentally spoils the performance adding some new code.
After a series of such incidents, people often start to think about performance regression testing.&lt;/p>
&lt;p>As developers, we write unit tests all the time.
These tests check that our business logic work as designed and that new features don&amp;rsquo;t break existing code.
It looks like a good idea to write some perf tests as well, which will verify that we don&amp;rsquo;t have any performance regressions.&lt;/p>
&lt;p>Turns out this is harder than it sounds.
A lot of developers don&amp;rsquo;t write perf tests at all.
Some teams write perf tests, but almost all of them use their own infrastructure for analysis
(which is not a bad thing in general because it&amp;rsquo;s usually designed for specific projects and requirements).
There are a lot of books about test-driven development (TDD),
but there are no books about performance-driven development (PDD).
There are well-known libraries for unit-testing (like xUnit/NUnit/MSTest for .NET),
but there are almost no libraries for performance regression testing.
Yeah, of course, there are &lt;em>some&lt;/em> libraries which you can use.
But there are troubles with &lt;em>well-known all recognized&lt;/em> libraries, approaches, and tools.
Ask your colleagues about it: some of them will give you different answers, the rest of them will start Googling it.&lt;/p>
&lt;p>There is no common understanding of what performance testing should look like.
This situation exists because it&amp;rsquo;s really hard to develop a solution which solves &lt;em>all problems&lt;/em> for &lt;em>all kind of projects&lt;/em>.
However, it doesn&amp;rsquo;t mean that we shouldn&amp;rsquo;t try.
And we should try, we should share our experience and discuss best practices.&lt;/p></description></item><item><title>NuGet2 and a DirectorySeparatorChar bug</title><link>https://aakinshin.net/posts/nuget2-and-directoryseparatorchar/</link><pubDate>Mon, 06 Feb 2017 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/nuget2-and-directoryseparatorchar/</guid><description>&lt;p>In &lt;a href="https://www.jetbrains.com/rider/">Rider&lt;/a>, we care a lot about performance.
I like to improve the application responsiveness and do interesting optimizations all the time.
Rider is already well-optimized, and it&amp;rsquo;s often hard to make significant performance improvements, so usually I do micro-optimizations which do not have a very big impact on the whole application.
However, sometimes it&amp;rsquo;s possible to improve the speed of a feature 100 times with just a few lines of code.&lt;/p>
&lt;p>Rider is based on &lt;a href="https://www.jetbrains.com/resharper/">ReSharper&lt;/a>, so we have a lot of cool features out of the box.
One of these features is &lt;a href="https://www.jetbrains.com/help/resharper/2016.3/Code_Analysis__Solution-Wide_Analysis.html">Solution-Wide Analysis&lt;/a>
which lets you constantly keep track of issues in your solution.
Sometimes, solution-wide analysis takes a lot of time to run because there are many files which should be analyzed.
Of course, it works super fast on small and projects.&lt;/p>
&lt;p>Let&amp;rsquo;s talk about a performance bug (&lt;a href="https://youtrack.jetbrains.com/issue/RIDER-3742">#RIDER-3742&lt;/a>) that we recently had.&lt;/p>
&lt;ul>
&lt;li>&lt;em>Repro:&lt;/em> Open Rider, create a new &amp;ldquo;ASP .NET MVC Application&amp;rdquo;, enable solution wide-analysis.&lt;/li>
&lt;li>&lt;em>Expected:&lt;/em> The analysis should take 1 second.&lt;/li>
&lt;li>&lt;em>Actual:&lt;/em> The analysis takes 1 second on Windows and &lt;strong>2 minutes&lt;/strong> on Linux and MacOS.&lt;/li>
&lt;/ul></description></item><item><title>Every 7.8μs your computer’s memory has a hiccup</title><link>https://aakinshin.net/library/web/1ffb46c0399bd1f530dd3d3de588e910/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://aakinshin.net/library/web/1ffb46c0399bd1f530dd3d3de588e910/</guid><description/></item><item><title>Paired benchmarking. How to measure performance</title><link>https://aakinshin.net/library/web/c2b0493e679e12cf8a55a6c266dd82ed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://aakinshin.net/library/web/c2b0493e679e12cf8a55a6c266dd82ed/</guid><description/></item><item><title>Performance Roulette: The Luck of Code Alignment</title><link>https://aakinshin.net/library/web/a6ec2bdadfab5521a785ca0328ecbe62/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://aakinshin.net/library/web/a6ec2bdadfab5521a785ca0328ecbe62/</guid><description/></item><item><title>Your CPU May Have Slowed Down on Wednesday</title><link>https://aakinshin.net/library/web/0811d8cb4b19c9fc8381c6232ddebefc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://aakinshin.net/library/web/0811d8cb4b19c9fc8381c6232ddebefc/</guid><description/></item></channel></rss>