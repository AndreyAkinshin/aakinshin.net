<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>OpenCV on Andrey Akinshin</title><link>https://aakinshin.net/tags/opencv/</link><description>Recent content in OpenCV on Andrey Akinshin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 08 Aug 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/tags/opencv/index.xml" rel="self" type="application/rss+xml"/><item><title>Unexpected area to collect garbage in .NET</title><link>https://aakinshin.net/posts/gc-native/</link><pubDate>Thu, 08 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/gc-native/</guid><description>&lt;p>The .NET framework provides an intelligent garbage collector that saves us a trouble of manual memory management. And in 95% of cases you can forget about memory and related issues. But the remaining 5% have some specific aspects connected to unmanaged resources, too big objects, etc. And it’s better to know how the garbage is collected. Otherwise, you can get surprises.&lt;/p>
&lt;p>Do you think GC is able to collect an object till its last method is complete? It appears it is. But it is necessary to run an application in release mode without debugging. In this case JIT compiler will perform optimizations that will make this situation possible. Of course, JIT compiler does it when the remaining method body doesn’t contain references to the object or its fields. It should seem a very harmless optimization. But it can lead to the problems if you work with the unmanaged resources: object compilation can be executed before the operation over the unmanaged resource is finished. And most likely it will result in the application crash.&lt;/p></description></item></channel></rss>