<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GC on Andrey Akinshin</title><link>https://aakinshin.net/tags/gc/</link><description>Recent content in GC on Andrey Akinshin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 20 Feb 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://aakinshin.net/tags/gc/index.xml" rel="self" type="application/rss+xml"/><item><title>Analyzing distribution of Mono GC collections</title><link>https://aakinshin.net/posts/mono-gc-collects/</link><pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/mono-gc-collects/</guid><description>&lt;p>Sometimes I want to understand the GC performance impact on an application quickly.
I know that there are many powerful diagnostic tools and approaches,
but I&amp;rsquo;m a fan of the &amp;ldquo;right tool for the job&amp;rdquo; idea.
In simple cases, I prefer simple noninvasive approaches which provide a quick way
to get an overview of the current situation
(if everything is terrible, I always can switch to an advanced approach).
Today I want to share with you my favorite way to quickly get statistics
of GC pauses in Mono and generate nice plots like this:&lt;/p>





&lt;div class="row">
&lt;div class="mx-auto">
 &lt;a href="https://aakinshin.net/posts/mono-gc-collects/img/plot-64.png" target="_blank" alt="plot-64">
 &lt;img
 class="mx-auto d-block img-fluid"
 width='800'
 src="https://aakinshin.net/posts/mono-gc-collects/img/plot-64.png" />
 &lt;/a>
&lt;/div>
&lt;/div>
&lt;br /></description></item><item><title>Unexpected area to collect garbage in .NET</title><link>https://aakinshin.net/posts/gc-native/</link><pubDate>Thu, 08 Aug 2013 00:00:00 +0000</pubDate><guid>https://aakinshin.net/posts/gc-native/</guid><description>&lt;p>The .NET framework provides an intelligent garbage collector that saves us a trouble of manual memory management. And in 95% of cases you can forget about memory and related issues. But the remaining 5% have some specific aspects connected to unmanaged resources, too big objects, etc. And it’s better to know how the garbage is collected. Otherwise, you can get surprises.&lt;/p>
&lt;p>Do you think GC is able to collect an object till its last method is complete? It appears it is. But it is necessary to run an application in release mode without debugging. In this case JIT compiler will perform optimizations that will make this situation possible. Of course, JIT compiler does it when the remaining method body doesn’t contain references to the object or its fields. It should seem a very harmless optimization. But it can lead to the problems if you work with the unmanaged resources: object compilation can be executed before the operation over the unmanaged resource is finished. And most likely it will result in the application crash.&lt;/p></description></item></channel></rss>